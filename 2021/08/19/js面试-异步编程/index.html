<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="https://avatars.githubusercontent.com/u/26106551?s=400&u=0d85a0dcaadac1d093bffef18f2b759321132d14&v=4">
  <link rel="icon" type="image/png" sizes="32x32" href="https://avatars.githubusercontent.com/u/26106551?s=400&u=0d85a0dcaadac1d093bffef18f2b759321132d14&v=4">
  <link rel="icon" type="image/png" sizes="16x16" href="https://avatars.githubusercontent.com/u/26106551?s=400&u=0d85a0dcaadac1d093bffef18f2b759321132d14&v=4">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" integrity="sha256-Vzbj7sDDS/woiFS3uNKo8eIuni59rjyNGtXfstRzStA=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"eyecatwang.github.io","root":"/","images":"/images","scheme":"Pisces","darkmode":false,"version":"8.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":true,"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"valine","storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>
<meta name="description" content="异步编程的实现方式？JavaScript中的异步机制可以分为以下几种：  回调函数 的方式，使用回调函数的方式有一个缺点是，多个回调函数嵌套的时候会造成回调函数地狱，上下两层的回调函数间的代码耦合度太高，不利于代码的可维护。 Promise 的方式，使用 Promise 的方式可以将嵌套的回调函数作为链式调用。但是使用这种方法，有时会造成多个 then 的链式调用，可能会造成代码的语义不够明确。">
<meta property="og:type" content="article">
<meta property="og:title" content="javascript面试-异步编程">
<meta property="og:url" content="https://eyecatwang.github.io/2021/08/19/js%E9%9D%A2%E8%AF%95-%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/">
<meta property="og:site_name" content="eyecatwang">
<meta property="og:description" content="异步编程的实现方式？JavaScript中的异步机制可以分为以下几种：  回调函数 的方式，使用回调函数的方式有一个缺点是，多个回调函数嵌套的时候会造成回调函数地狱，上下两层的回调函数间的代码耦合度太高，不利于代码的可维护。 Promise 的方式，使用 Promise 的方式可以将嵌套的回调函数作为链式调用。但是使用这种方法，有时会造成多个 then 的链式调用，可能会造成代码的语义不够明确。">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2021-08-19T07:14:33.000Z">
<meta property="article:modified_time" content="2021-12-06T01:02:42.330Z">
<meta property="article:author" content="eyecatwang">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://eyecatwang.github.io/2021/08/19/js%E9%9D%A2%E8%AF%95-%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://eyecatwang.github.io/2021/08/19/js%E9%9D%A2%E8%AF%95-%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/","path":"2021/08/19/js面试-异步编程/","title":"javascript面试-异步编程"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>javascript面试-异步编程 | eyecatwang</title>
  




  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">eyecatwang</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">王晓叶的博客</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li>
        <li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li>
        <li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
        <li class="menu-item menu-item-schedule"><a href="/schedule/" rel="section"><i class="fa fa-calendar fa-fw"></i>日程表</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%EF%BC%9F"><span class="nav-number">1.</span> <span class="nav-text">异步编程的实现方式？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#setTimeout%E3%80%81Promise%E3%80%81Async-Await-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">2.</span> <span class="nav-text">setTimeout、Promise、Async&#x2F;Await 的区别</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AF%B9Promise%E7%9A%84%E7%90%86%E8%A7%A3"><span class="nav-number">3.</span> <span class="nav-text">对Promise的理解</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Promise%E7%9A%84%E5%AE%9E%E4%BE%8B%E6%9C%89%E4%B8%89%E4%B8%AA%E7%8A%B6%E6%80%81"><span class="nav-number">3.1.</span> <span class="nav-text">Promise的实例有三个状态:</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Promise%E7%9A%84%E5%AE%9E%E4%BE%8B%E6%9C%89%E4%B8%A4%E4%B8%AA%E8%BF%87%E7%A8%8B%EF%BC%9A"><span class="nav-number">3.2.</span> <span class="nav-text">Promise的实例有两个过程：</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Promise%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95"><span class="nav-number">4.</span> <span class="nav-text">Promise的基本用法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%9B%E5%BB%BAPromise%E5%AF%B9%E8%B1%A1"><span class="nav-number">4.1.</span> <span class="nav-text">创建Promise对象</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Promise%E6%96%B9%E6%B3%95"><span class="nav-number">4.2.</span> <span class="nav-text">Promise方法</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Promise%E8%A7%A3%E5%86%B3%E4%BA%86%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98"><span class="nav-number">5.</span> <span class="nav-text">Promise解决了什么问题</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Promise-all%E5%92%8CPromise-race%E7%9A%84%E5%8C%BA%E5%88%AB%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">6.</span> <span class="nav-text">Promise.all和Promise.race的区别的使用场景</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AF%B9async-await-%E7%9A%84%E7%90%86%E8%A7%A3"><span class="nav-number">7.</span> <span class="nav-text">对async&#x2F;await 的理解</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#await-%E5%88%B0%E5%BA%95%E5%9C%A8%E7%AD%89%E5%95%A5%EF%BC%9F"><span class="nav-number">8.</span> <span class="nav-text">await 到底在等啥？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#async-await%E7%9A%84%E4%BC%98%E5%8A%BF"><span class="nav-number">9.</span> <span class="nav-text">async&#x2F;await的优势</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#async-await%E5%AF%B9%E6%AF%94Promise%E7%9A%84%E4%BC%98%E5%8A%BF"><span class="nav-number">10.</span> <span class="nav-text">async&#x2F;await对比Promise的优势</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#async-await-%E5%A6%82%E4%BD%95%E6%8D%95%E8%8E%B7%E5%BC%82%E5%B8%B8"><span class="nav-number">11.</span> <span class="nav-text">async&#x2F;await 如何捕获异常</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%B9%B6%E8%A1%8C%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">12.</span> <span class="nav-text">并发与并行的区别？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%EF%BC%9F%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%E6%9C%89%E4%BB%80%E4%B9%88%E7%BC%BA%E7%82%B9%EF%BC%9F%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E5%9B%9E%E8%B0%83%E5%9C%B0%E7%8B%B1%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="nav-number">13.</span> <span class="nav-text">什么是回调函数？回调函数有什么缺点？如何解决回调地狱问题？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#setTimeout%E3%80%81setInterval%E3%80%81requestAnimationFrame-%E5%90%84%E6%9C%89%E4%BB%80%E4%B9%88%E7%89%B9%E7%82%B9%EF%BC%9F"><span class="nav-number">14.</span> <span class="nav-text">setTimeout、setInterval、requestAnimationFrame 各有什么特点？</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="eyecatwang"
      src="https://avatars.githubusercontent.com/u/26106551">
  <p class="site-author-name" itemprop="name">eyecatwang</p>
  <div class="site-description" itemprop="description">eyecatwang的学习日记</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">43</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/EyecatWang" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;EyecatWang" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://eyecatwang.github.io/2021/08/19/js%E9%9D%A2%E8%AF%95-%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars.githubusercontent.com/u/26106551">
      <meta itemprop="name" content="eyecatwang">
      <meta itemprop="description" content="eyecatwang的学习日记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="eyecatwang">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          javascript面试-异步编程
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-08-19 15:14:33" itemprop="dateCreated datePublished" datetime="2021-08-19T15:14:33+08:00">2021-08-19</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-12-06 09:02:42" itemprop="dateModified" datetime="2021-12-06T09:02:42+08:00">2021-12-06</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E9%9D%A2%E8%AF%95/" itemprop="url" rel="index"><span itemprop="name">面试</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E9%9D%A2%E8%AF%95/js/" itemprop="url" rel="index"><span itemprop="name">js</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h1 id="异步编程的实现方式？"><a href="#异步编程的实现方式？" class="headerlink" title="异步编程的实现方式？"></a>异步编程的实现方式？</h1><p>JavaScript中的异步机制可以分为以下几种：</p>
<ul>
<li>回调函数 的方式，使用回调函数的方式有一个缺点是，多个回调函数嵌套的时候会造成回调函数地狱，上下两层的回调函数间的代码耦合度太高，不利于代码的可维护。</li>
<li>Promise 的方式，使用 Promise 的方式可以将嵌套的回调函数作为链式调用。但是使用这种方法，有时会造成多个 then 的链式调用，可能会造成代码的语义不够明确。</li>
<li>generator 的方式，它可以在函数的执行过程中，将函数的执行权转移出去，在函数外部还可以将执行权转移回来。当遇到异步函数执行的时候，将函数执行权转移出去，当异步函数执行完毕时再将执行权给转移回来。因此在 generator 内部对于异步操作的方式，可以以同步的顺序来书写。使用这种方式需要考虑的问题是何时将函数的控制权转移回来，因此需要有一个自动执行 generator 的机制，比如说 co 模块等方式来实现 generator 的自动执行。</li>
<li>async 函数 的方式，async 函数是 generator 和 promise 实现的一个自动执行的语法糖，它内部自带执行器，当函数内部执行到一个 await 语句的时候，如果语句返回一个 promise 对象，那么函数将会等待 promise 对象的状态变为 resolve 后再继续向下执行。因此可以将异步逻辑，转化为同步的顺序来书写，并且这个函数可以自动执行。</li>
</ul>
<h1 id="setTimeout、Promise、Async-Await-的区别"><a href="#setTimeout、Promise、Async-Await-的区别" class="headerlink" title="setTimeout、Promise、Async/Await 的区别"></a>setTimeout、Promise、Async/Await 的区别</h1><p>（1）setTimeout</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">console.log(&#x27;script start&#x27;)	//1. 打印 script start</span><br><span class="line">setTimeout(function()&#123;</span><br><span class="line">    console.log(&#x27;settimeout&#x27;)	// 4. 打印 settimeout</span><br><span class="line">&#125;)	// 2. 调用 setTimeout 函数，并定义其完成后执行的回调函数</span><br><span class="line">console.log(&#x27;script end&#x27;)	//3. 打印 script start</span><br><span class="line">// 输出顺序：script start-&gt;script end-&gt;settimeout</span><br></pre></td></tr></table></figure>
<p>（2）Promise<br>Promise本身是同步的立即执行函数， 当在executor中执行resolve或者reject的时候, 此时是异步操作， 会先执行then/catch等，当主栈完成后，才会去调用resolve/reject中存放的方法执行，打印p的时候，是打印的返回结果，一个Promise实例。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">console.log(&#x27;script start&#x27;)</span><br><span class="line">let promise1 = new Promise(function (resolve) &#123;</span><br><span class="line">    console.log(&#x27;promise1&#x27;)</span><br><span class="line">    resolve()</span><br><span class="line">    console.log(&#x27;promise1 end&#x27;)</span><br><span class="line">&#125;).then(function () &#123;</span><br><span class="line">    console.log(&#x27;promise2&#x27;)</span><br><span class="line">&#125;)</span><br><span class="line">setTimeout(function()&#123;</span><br><span class="line">    console.log(&#x27;settimeout&#x27;)</span><br><span class="line">&#125;)</span><br><span class="line">console.log(&#x27;script end&#x27;)</span><br><span class="line">// 输出顺序: script start-&gt;promise1-&gt;promise1 end-&gt;script end-&gt;promise2-&gt;settimeout</span><br></pre></td></tr></table></figure>
<p>当JS主线程执行到Promise对象时：</p>
<ul>
<li>promise1.then() 的回调就是一个 task</li>
<li>promise1 是 resolved或rejected: 那这个 task 就会放入当前事件循环回合的 microtask queue</li>
<li>promise1 是 pending: 这个 task 就会放入 事件循环的未来的某个(可能下一个)回合的 microtask queue 中</li>
<li>setTimeout 的回调也是个 task ，它会被放入 macrotask queue 即使是 0ms 的情况</li>
</ul>
<p>（3）async/await</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">async function async1()&#123;</span><br><span class="line">   console.log(&#x27;async1 start&#x27;);</span><br><span class="line">    await async2();</span><br><span class="line">    console.log(&#x27;async1 end&#x27;)</span><br><span class="line">&#125;</span><br><span class="line">async function async2()&#123;</span><br><span class="line">    console.log(&#x27;async2&#x27;)</span><br><span class="line">&#125;</span><br><span class="line">console.log(&#x27;script start&#x27;);</span><br><span class="line">async1();</span><br><span class="line">console.log(&#x27;script end&#x27;)</span><br><span class="line">// 输出顺序：script start-&gt;async1 start-&gt;async2-&gt;script end-&gt;async1 end</span><br></pre></td></tr></table></figure>
<p>async 函数返回一个 Promise 对象，当函数执行的时候，一旦遇到 await 就会先返回，等到触发的异步操作完成，再执行函数体内后面的语句。可以理解为，是让出了线程，跳出了 async 函数体。<br>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">async function func1() &#123;</span><br><span class="line">    return 1</span><br><span class="line">&#125;</span><br><span class="line">console.log(func1())</span><br></pre></td></tr></table></figure>

<p>func1的运行结果其实就是一个Promise对象。因此也可以使用then来处理后续逻辑。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func1().then(res =&gt; &#123;</span><br><span class="line">    console.log(res);  // 30</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>await的含义为等待，也就是 async 函数需要等待await后的函数执行完成并且有了返回结果（Promise对象）之后，才能继续执行下面的代码。await通过返回一个Promise对象来实现同步的效果。</p>
<h1 id="对Promise的理解"><a href="#对Promise的理解" class="headerlink" title="对Promise的理解"></a>对Promise的理解</h1><p>Promise是异步编程的一种解决方案，它是一个对象，可以获取异步操作的消息，他的出现大大改善了异步编程的困境，避免了地狱回调，它比传统的解决方案回调函数和事件更合理和更强大。<br>所谓Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。</p>
<h2 id="Promise的实例有三个状态"><a href="#Promise的实例有三个状态" class="headerlink" title="Promise的实例有三个状态:"></a>Promise的实例有三个状态:</h2><ul>
<li>Pending（进行中）</li>
<li>Resolved（已完成）</li>
<li>Rejected（已拒绝）</li>
</ul>
<p>当把一件事情交给promise时，它的状态就是Pending，任务完成了状态就变成了Resolved、没有完成失败了就变成了Rejected。</p>
<h2 id="Promise的实例有两个过程："><a href="#Promise的实例有两个过程：" class="headerlink" title="Promise的实例有两个过程："></a>Promise的实例有两个过程：</h2><ul>
<li>pending -&gt; fulfilled : Resolved（已完成）</li>
<li>pending -&gt; rejected：Rejected（已拒绝）</li>
</ul>
<p>注意：一旦从进行状态变成为其他状态就永远不能更改状态了。<br>Promise的特点：</p>
<ul>
<li>对象的状态不受外界影响。promise对象代表一个异步操作，有三种状态，pending（进行中）、fulfilled（已成功）、rejected（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态，这也是promise这个名字的由来——“承诺”；</li>
<li>一旦状态改变就不会再变，任何时候都可以得到这个结果。promise对象的状态改变，只有两种可能：从pending变为fulfilled，从pending变为rejected。这时就称为resolved（已定型）。如果改变已经发生了，你再对promise对象添加回调函数，也会立即得到这个结果。这与事件（event）完全不同，事件的特点是：如果你错过了它，再去监听是得不到结果的。</li>
</ul>
<p>Promise的缺点：</p>
<ul>
<li>无法取消Promise，一旦新建它就会立即执行，无法中途取消。</li>
<li>如果不设置回调函数，Promise内部抛出的错误，不会反应到外部。</li>
<li>当处于pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。</li>
</ul>
<p>总结：<br>Promise 对象是异步编程的一种解决方案，最早由社区提出。Promise 是一个构造函数，接收一个函数作为参数，返回一个 Promise 实例。一个 Promise 实例有三种状态，分别是pending、resolved 和 rejected，分别代表了进行中、已成功和已失败。实例的状态只能由 pending 转变 resolved 或者rejected 状态，并且状态一经改变，就凝固了，无法再被改变了。<br>状态的改变是通过 resolve() 和 reject() 函数来实现的，可以在异步操作结束后调用这两个函数改变 Promise 实例的状态，它的原型上定义了一个 then 方法，使用这个 then 方法可以为两个状态的改变注册回调函数。这个回调函数属于微任务，会在本轮事件循环的末尾执行。<br>注意： 在构造 Promise 的时候，构造函数内部的代码是立即执行的</p>
<h1 id="Promise的基本用法"><a href="#Promise的基本用法" class="headerlink" title="Promise的基本用法"></a>Promise的基本用法</h1><h2 id="创建Promise对象"><a href="#创建Promise对象" class="headerlink" title="创建Promise对象"></a>创建Promise对象</h2><p>Promise对象代表一个异步操作，有三种状态：pending（进行中）、fulfilled（已成功）和rejected（已失败）。<br>Promise构造函数接受一个函数作为参数，该函数的两个参数分别是resolve和reject。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const promise = new Promise(function(resolve, reject) &#123;</span><br><span class="line">  // ... some code</span><br><span class="line">  if (/* 异步操作成功 */)&#123;</span><br><span class="line">    resolve(value);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    reject(error);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>一般情况下都会使用new Promise()来创建promise对象，但是也可以使用promise.resolve和promise.reject这两个方法：</p>
<ol>
<li>Promise.resolve</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Promise.resolve(value)的返回值也是一个promise对象，可以对返回值进行.then调用，代码如下：</span><br><span class="line">Promise.resolve(11).then(function(value)&#123;</span><br><span class="line">  console.log(value); // 打印出11</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>resolve(11)代码中，会让promise对象进入确定(resolve状态)，并将参数11传递给后面的then所指定的onFulfilled 函数；<br>创建promise对象可以使用new Promise的形式创建对象，也可以使用Promise.resolve(value)的形式创建promise对象；</p>
<ol start="2">
<li>Promise.reject</li>
</ol>
<p>Promise.reject 也是new Promise的快捷形式，也创建一个promise对象。代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Promise.reject(new Error(“我错了，请原谅俺！！”));</span><br></pre></td></tr></table></figure>
<p>就是下面的代码new Promise的简单形式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">new Promise(function(resolve,reject)&#123;</span><br><span class="line">   reject(new Error(&quot;我错了！&quot;));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>下面是使用resolve方法和reject方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function testPromise(ready) &#123;</span><br><span class="line">  return new Promise(function(resolve,reject)&#123;</span><br><span class="line">    if(ready) &#123;</span><br><span class="line">      resolve(&quot;hello world&quot;);</span><br><span class="line">    &#125;else &#123;</span><br><span class="line">      reject(&quot;No thanks&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line">// 方法调用</span><br><span class="line">testPromise(true).then(function(msg)&#123;</span><br><span class="line">  console.log(msg);</span><br><span class="line">&#125;,function(error)&#123;</span><br><span class="line">  console.log(error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>上面的代码的含义是给testPromise方法传递一个参数，返回一个promise对象，如果为true的话，那么调用promise对象中的resolve()方法，并且把其中的参数传递给后面的then第一个函数内，因此打印出 “hello world”, 如果为false的话，会调用promise对象中的reject()方法，则会进入then的第二个函数内，会打印No thanks；</p>
<h2 id="Promise方法"><a href="#Promise方法" class="headerlink" title="Promise方法"></a>Promise方法</h2><p>Promise有五个常用的方法：then()、catch()、all()、race()、finally。下面就来看一下这些方法。</p>
<ol>
<li>then()</li>
</ol>
<p>当Promise执行的内容符合成功条件时，调用resolve函数，失败就调用reject函数。Promise创建完了，那该如何调用呢？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">promise.then(function(value) &#123;</span><br><span class="line">  // success</span><br><span class="line">&#125;, function(error) &#123;</span><br><span class="line">  // failure</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>then方法可以接受两个回调函数作为参数。第一个回调函数是Promise对象的状态变为resolved时调用，第二个回调函数是Promise对象的状态变为rejected时调用。其中第二个参数可以省略。<br>then方法返回的是一个新的Promise实例（不是原来那个Promise实例）。因此可以采用链式写法，即then方法后面再调用另一个then方法。<br>当要写有顺序的异步事件时，需要串行时，可以这样写：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">let promise = new Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">    ajax(&#x27;first&#x27;).success(function(res)&#123;</span><br><span class="line">        resolve(res);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line">promise.then(res=&gt;&#123;</span><br><span class="line">    return new Promise((resovle,reject)=&gt;&#123;</span><br><span class="line">        ajax(&#x27;second&#x27;).success(function(res)&#123;</span><br><span class="line">            resolve(res)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;).then(res=&gt;&#123;</span><br><span class="line">    return new Promise((resovle,reject)=&gt;&#123;</span><br><span class="line">        ajax(&#x27;second&#x27;).success(function(res)&#123;</span><br><span class="line">            resolve(res)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;).then(res=&gt;&#123;</span><br><span class="line">    </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>那当要写的事件没有顺序或者关系时，还如何写呢？可以使用all 方法来解决。<br>2. catch()<br>Promise对象除了有then方法，还有一个catch方法，该方法相当于then方法的第二个参数，指向reject的回调函数。不过catch方法还有一个作用，就是在执行resolve回调函数时，如果出现错误，抛出异常，不会停止运行，而是进入catch方法中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">p.then((data) =&gt; &#123;</span><br><span class="line">     console.log(&#x27;resolved&#x27;,data);</span><br><span class="line">&#125;,(err) =&gt; &#123;</span><br><span class="line">     console.log(&#x27;rejected&#x27;,err);</span><br><span class="line">     &#125;</span><br><span class="line">); </span><br><span class="line">p.then((data) =&gt; &#123;</span><br><span class="line">    console.log(&#x27;resolved&#x27;,data);</span><br><span class="line">&#125;).catch((err) =&gt; &#123;</span><br><span class="line">    console.log(&#x27;rejected&#x27;,err);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>all()<br>all方法可以完成并行任务， 它接收一个数组，数组的每一项都是一个promise对象。当数组中所有的promise的状态都达到resolved的时候，all方法的状态就会变成resolved，如果有一个状态变成了rejected，那么all方法的状态就会变成rejected。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">let promise1 = new Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">	setTimeout(()=&gt;&#123;</span><br><span class="line">       resolve(1);</span><br><span class="line">	&#125;,2000)</span><br><span class="line">&#125;);</span><br><span class="line">let promise2 = new Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">	setTimeout(()=&gt;&#123;</span><br><span class="line">       resolve(2);</span><br><span class="line">	&#125;,1000)</span><br><span class="line">&#125;);</span><br><span class="line">let promise3 = new Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">	setTimeout(()=&gt;&#123;</span><br><span class="line">       resolve(3);</span><br><span class="line">	&#125;,3000)</span><br><span class="line">&#125;);</span><br><span class="line">Promise.all([promise1,promise2,promise3]).then(res=&gt;&#123;</span><br><span class="line">    console.log(res);</span><br><span class="line">    //结果为：[1,2,3] </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
调用all方法时的结果成功的时候是回调函数的参数也是一个数组，这个数组按顺序保存着每一个promise对象resolve执行时的值。<br>（4）race()<br>race方法和all一样，接受的参数是一个每项都是promise的数组，但是与all不同的是，当最先执行完的事件执行完之后，就直接返回该promise对象的值。如果第一个promise对象状态变成resolved，那自身的状态变成了resolved；反之第一个promise变成rejected，那自身状态就会变成rejected。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">let promise1 = new Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">	setTimeout(()=&gt;&#123;</span><br><span class="line">       reject(1);</span><br><span class="line">	&#125;,2000)</span><br><span class="line">&#125;);</span><br><span class="line">let promise2 = new Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">	setTimeout(()=&gt;&#123;</span><br><span class="line">       resolve(2);</span><br><span class="line">	&#125;,1000)</span><br><span class="line">&#125;);</span><br><span class="line">let promise3 = new Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">	setTimeout(()=&gt;&#123;</span><br><span class="line">       resolve(3);</span><br><span class="line">	&#125;,3000)</span><br><span class="line">&#125;);</span><br><span class="line">Promise.race([promise1,promise2,promise3]).then(res=&gt;&#123;</span><br><span class="line">	console.log(res);</span><br><span class="line">	//结果：2</span><br><span class="line">&#125;,rej=&gt;&#123;</span><br><span class="line">    console.log(rej)&#125;;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
那么race方法有什么实际作用呢？当要做一件事，超过多长时间就不做了，可以用这个方法来解决：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Promise.race([promise1,timeOutPromise(5000)]).then(res=&gt;&#123;&#125;)</span><br></pre></td></tr></table></figure></li>
<li>finally()<br>finally方法用于指定不管 Promise 对象最后状态如何，都会执行的操作。该方法是 ES2018 引入标准的。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">promise</span><br><span class="line">.then(result =&gt; &#123;···&#125;)</span><br><span class="line">.catch(error =&gt; &#123;···&#125;)</span><br><span class="line">.finally(() =&gt; &#123;···&#125;);</span><br></pre></td></tr></table></figure>
上面代码中，不管promise最后的状态，在执行完then或catch指定的回调函数以后，都会执行finally方法指定的回调函数。<br>下面是一个例子，服务器使用 Promise 处理请求，然后使用finally方法关掉服务器。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">server.listen(port)</span><br><span class="line">  .then(function () &#123;</span><br><span class="line">    // ...</span><br><span class="line">  &#125;)</span><br><span class="line">  .finally(server.stop);</span><br></pre></td></tr></table></figure>
finally方法的回调函数不接受任何参数，这意味着没有办法知道，前面的 Promise 状态到底是fulfilled还是rejected。这表明，finally方法里面的操作，应该是与状态无关的，不依赖于 Promise 的执行结果。finally本质上是then方法的特例：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">promise</span><br><span class="line">.finally(() =&gt; &#123;</span><br><span class="line">  // 语句</span><br><span class="line">&#125;);</span><br><span class="line">// 等同于</span><br><span class="line">promise</span><br><span class="line">.then(</span><br><span class="line">  result =&gt; &#123;</span><br><span class="line">    // 语句</span><br><span class="line">    return result;</span><br><span class="line">  &#125;,</span><br><span class="line">  error =&gt; &#123;</span><br><span class="line">    // 语句</span><br><span class="line">    throw error;</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
上面代码中，如果不使用finally方法，同样的语句需要为成功和失败两种情况各写一次。有了finally方法，则只需要写一次。<h1 id="Promise解决了什么问题"><a href="#Promise解决了什么问题" class="headerlink" title="Promise解决了什么问题"></a>Promise解决了什么问题</h1>在工作中经常会碰到这样一个需求，比如我使用ajax发一个A请求后，成功后拿到数据，需要把数据传给B请求；那么需要如下编写代码：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let fs = require(&#x27;fs&#x27;)</span><br><span class="line">fs.readFile(&#x27;./a.txt&#x27;,&#x27;utf8&#x27;,function(err,data)&#123;</span><br><span class="line">  fs.readFile(data,&#x27;utf8&#x27;,function(err,data)&#123;</span><br><span class="line">    fs.readFile(data,&#x27;utf8&#x27;,function(err,data)&#123;</span><br><span class="line">      console.log(data)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
上面的代码有如下缺点：</li>
</ol>
<ul>
<li>后一个请求需要依赖于前一个请求成功后，将数据往下传递，会导致多个ajax请求嵌套的情况，代码不够直观。</li>
<li>如果前后两个请求不需要传递参数的情况下，那么后一个请求也需要前一个请求成功后再执行下一步操作，这种情况下，那么也需要如上编写代码，导致代码不够直观。</li>
</ul>
<p>Promise出现之后，代码变成这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">let fs = require(&#x27;fs&#x27;)</span><br><span class="line">function read(url)&#123;</span><br><span class="line">  return new Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">    fs.readFile(url,&#x27;utf8&#x27;,function(error,data)&#123;</span><br><span class="line">      error &amp;&amp; reject(error)</span><br><span class="line">      resolve(data)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line">read(&#x27;./a.txt&#x27;).then(data=&gt;&#123;</span><br><span class="line">  return read(data) </span><br><span class="line">&#125;).then(data=&gt;&#123;</span><br><span class="line">  return read(data)  </span><br><span class="line">&#125;).then(data=&gt;&#123;</span><br><span class="line">  console.log(data)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>这样代码看起了就简洁了很多，解决了地狱回调的问题。</p>
<h1 id="Promise-all和Promise-race的区别的使用场景"><a href="#Promise-all和Promise-race的区别的使用场景" class="headerlink" title="Promise.all和Promise.race的区别的使用场景"></a>Promise.all和Promise.race的区别的使用场景</h1><p>（1）Promise.all<br>Promise.all可以将多个Promise实例包装成一个新的Promise实例。同时，成功和失败的返回值是不同的，成功的时候返回的是一个结果数组，而失败的时候则返回最先被reject失败状态的值。<br>Promise.all中传入的是数组，返回的也是是数组，并且会将进行映射，传入的promise对象返回的值是按照顺序在数组中排列的，但是注意的是他们执行的顺序并不是按照顺序的，除非可迭代对象为空。<br>需要注意，Promise.all获得的成功结果的数组里面的数据顺序和Promise.all接收到的数组顺序是一致的，这样当遇到发送多个请求并根据请求顺序获取和使用数据的场景，就可以使用Promise.all来解决。<br>（2）Promise.race<br>顾名思义，Promse.race就是赛跑的意思，意思就是说，Promise.race([p1, p2, p3])里面哪个结果获得的快，就返回那个结果，不管结果本身是成功状态还是失败状态。当要做一件事，超过多长时间就不做了，可以用这个方法来解决：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Promise.race([promise1,timeOutPromise(5000)]).then(res=&gt;&#123;&#125;)</span><br></pre></td></tr></table></figure>
<h1 id="对async-await-的理解"><a href="#对async-await-的理解" class="headerlink" title="对async/await 的理解"></a>对async/await 的理解</h1><p>async/await其实是Generator 的语法糖，它能实现的效果都能用then链来实现，它是为优化then链而开发出来的。从字面上来看，async是“异步”的简写，await则为等待，所以很好理解async 用于申明一个 function 是异步的，而 await 用于等待一个异步方法执行完成。当然语法上强制规定await只能出现在asnyc函数中，先来看看async函数返回了什么：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">async function testAsy()&#123;</span><br><span class="line">   return &#x27;hello world&#x27;;</span><br><span class="line">&#125;</span><br><span class="line">let result = testAsy(); </span><br><span class="line">console.log(result)</span><br></pre></td></tr></table></figure>

<p>所以，async 函数返回的是一个 Promise 对象。async 函数（包含函数语句、函数表达式、Lambda表达式）会返回一个 Promise 对象，如果在函数中 return 一个直接量，async 会把这个直接量通过 Promise.resolve() 封装成 Promise 对象。<br>async 函数返回的是一个 Promise 对象，所以在最外层不能用 await 获取其返回值的情况下，当然应该用原来的方式：then() 链来处理这个 Promise 对象，就像这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">async function testAsy()&#123;</span><br><span class="line">   return &#x27;hello world&#x27;</span><br><span class="line">&#125;</span><br><span class="line">let result = testAsy() </span><br><span class="line">console.log(result)</span><br><span class="line">result.then(v=&gt;&#123;</span><br><span class="line">    console.log(v)   // hello world</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>那如果 async 函数没有返回值，又该如何？很容易想到，它会返回 Promise.resolve(undefined)。<br>联想一下 Promise 的特点——无等待，所以在没有 await 的情况下执行 async 函数，它会立即执行，返回一个 Promise 对象，并且，绝不会阻塞后面的语句。这和普通返回 Promise 对象的函数并无二致。<br>注意：Promise.resolve(x) 可以看作是 new Promise(resolve =&gt; resolve(x)) 的简写，可以用于快速封装字面量对象或其他对象，将其封装成 Promise 实例。</p>
<h1 id="await-到底在等啥？"><a href="#await-到底在等啥？" class="headerlink" title="await 到底在等啥？"></a>await 到底在等啥？</h1><p>await 在等待什么呢？ 一般来说，都认为 await 是在等待一个 async 函数完成。不过按语法说明，await 等待的是一个表达式，这个表达式的计算结果是 Promise 对象或者其它值（换句话说，就是没有特殊限定）。<br>因为 async 函数返回一个 Promise 对象，所以 await 可以用于等待一个 async 函数的返回值——这也可以说是 await 在等 async 函数，但要清楚，它等的实际是一个返回值。注意到 await 不仅仅用于等 Promise 对象，它可以等任意表达式的结果，所以，await 后面实际是可以接普通函数调用或者直接量的。所以下面这个示例完全可以正确运行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function getSomething() &#123;</span><br><span class="line">    return &quot;something&quot;;</span><br><span class="line">&#125;</span><br><span class="line">async function testAsync() &#123;</span><br><span class="line">    return Promise.resolve(&quot;hello async&quot;);</span><br><span class="line">&#125;</span><br><span class="line">async function test() &#123;</span><br><span class="line">    const v1 = await getSomething();</span><br><span class="line">    const v2 = await testAsync();</span><br><span class="line">    console.log(v1, v2);</span><br><span class="line">&#125;</span><br><span class="line">test();</span><br></pre></td></tr></table></figure>
<p>await 表达式的运算结果取决于它等的是什么。</p>
<ul>
<li>如果它等到的不是一个 Promise 对象，那 await 表达式的运算结果就是它等到的东西。</li>
<li>如果它等到的是一个 Promise 对象，await 就忙起来了，它会阻塞后面的代码，等着 Promise 对象 resolve，然后得到 resolve 的值，作为 await 表达式的运算结果。</li>
</ul>
<p>来看一个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function testAsy(x)&#123;</span><br><span class="line">   return new Promise(resolve=&gt;&#123;setTimeout(() =&gt; &#123;</span><br><span class="line">       resolve(x);</span><br><span class="line">     &#125;, 3000)</span><br><span class="line">    &#125;</span><br><span class="line">   )</span><br><span class="line">&#125;</span><br><span class="line">async function testAwt()&#123;    </span><br><span class="line">  let result =  await testAsy(&#x27;hello world&#x27;);</span><br><span class="line">  console.log(result);    // 3秒钟之后出现hello world</span><br><span class="line">  console.log(&#x27;cuger&#x27;)   // 3秒钟之后出现cug</span><br><span class="line">&#125;</span><br><span class="line">testAwt();</span><br><span class="line">console.log(&#x27;cug&#x27;)  //立即输出cug</span><br></pre></td></tr></table></figure>
<p>这就是 await 必须用在 async 函数中的原因。async 函数调用不会造成阻塞，它内部所有的阻塞都被封装在一个 Promise 对象中异步执行。await暂停当前async的执行，所以’cug’’最先输出，hello world’和‘cuger’是3秒钟后同时出现的。</p>
<h1 id="async-await的优势"><a href="#async-await的优势" class="headerlink" title="async/await的优势"></a>async/await的优势</h1><p>单一的 Promise 链并不能发现 async/await 的优势，但是，如果需要处理由多个 Promise 组成的 then 链的时候，优势就能体现出来了（很有意思，Promise 通过 then 链来解决多层回调的问题，现在又用 async/await 来进一步优化它）。<br>假设一个业务，分多个步骤完成，每个步骤都是异步的，而且依赖于上一个步骤的结果。仍然用 setTimeout 来模拟异步操作：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 传入参数 n，表示这个函数执行的时间（毫秒）</span><br><span class="line"> * 执行的结果是 n + 200，这个值将用于下一步骤</span><br><span class="line"> */</span><br><span class="line">function takeLongTime(n) &#123;</span><br><span class="line">    return new Promise(resolve =&gt; &#123;</span><br><span class="line">        setTimeout(() =&gt; resolve(n + 200), n);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">function step1(n) &#123;</span><br><span class="line">    console.log(`step1 with $&#123;n&#125;`);</span><br><span class="line">    return takeLongTime(n);</span><br><span class="line">&#125;</span><br><span class="line">function step2(n) &#123;</span><br><span class="line">    console.log(`step2 with $&#123;n&#125;`);</span><br><span class="line">    return takeLongTime(n);</span><br><span class="line">&#125;</span><br><span class="line">function step3(n) &#123;</span><br><span class="line">    console.log(`step3 with $&#123;n&#125;`);</span><br><span class="line">    return takeLongTime(n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在用 Promise 方式来实现这三个步骤的处理：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function doIt() &#123;</span><br><span class="line">    console.time(&quot;doIt&quot;);</span><br><span class="line">    const time1 = 300;</span><br><span class="line">    step1(time1)</span><br><span class="line">        .then(time2 =&gt; step2(time2))</span><br><span class="line">        .then(time3 =&gt; step3(time3))</span><br><span class="line">        .then(result =&gt; &#123;</span><br><span class="line">            console.log(`result is $&#123;result&#125;`);</span><br><span class="line">            console.timeEnd(&quot;doIt&quot;);</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;</span><br><span class="line">doIt();</span><br><span class="line">// c:\var\test&gt;node --harmony_async_await .</span><br><span class="line">// step1 with 300</span><br><span class="line">// step2 with 500</span><br><span class="line">// step3 with 700</span><br><span class="line">// result is 900</span><br><span class="line">// doIt: 1507.251ms</span><br></pre></td></tr></table></figure>
<p>输出结果 result 是 step3() 的参数 700 + 200 = 900。doIt() 顺序执行了三个步骤，一共用了 300 + 500 + 700 = 1500 毫秒，和 console.time()/console.timeEnd() 计算的结果一致。<br>如果用 async/await 来实现呢，会是这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">async function doIt() &#123;</span><br><span class="line">    console.time(&quot;doIt&quot;);</span><br><span class="line">    const time1 = 300;</span><br><span class="line">    const time2 = await step1(time1);</span><br><span class="line">    const time3 = await step2(time2);</span><br><span class="line">    const result = await step3(time3);</span><br><span class="line">    console.log(`result is $&#123;result&#125;`);</span><br><span class="line">    console.timeEnd(&quot;doIt&quot;);</span><br><span class="line">&#125;</span><br><span class="line">doIt();</span><br></pre></td></tr></table></figure>
<p>结果和之前的 Promise 实现是一样的，但是这个代码看起来是不是清晰得多，几乎跟同步代码一样</p>
<h1 id="async-await对比Promise的优势"><a href="#async-await对比Promise的优势" class="headerlink" title="async/await对比Promise的优势"></a>async/await对比Promise的优势</h1><ul>
<li>代码读起来更加同步，Promise虽然摆脱了回调地狱，但是then的链式调⽤也会带来额外的阅读负担</li>
<li>Promise传递中间值⾮常麻烦，⽽async/await⼏乎是同步的写法，⾮常优雅</li>
<li>错误处理友好，async/await可以⽤成熟的try/catch，Promise的错误捕获⾮常冗余</li>
<li>调试友好，Promise的调试很差，由于没有代码块，你不能在⼀个返回表达式的箭头函数中设置断点，如果你在⼀个.then代码块中使⽤调试器的步进(step-over)功能，调试器并不会进⼊后续的.then代码块，因为调试器只能跟踪同步代码的每⼀步。</li>
</ul>
<h1 id="async-await-如何捕获异常"><a href="#async-await-如何捕获异常" class="headerlink" title="async/await 如何捕获异常"></a>async/await 如何捕获异常</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">async function fn()&#123;</span><br><span class="line">    try&#123;</span><br><span class="line">        let a = await Promise.reject(&#x27;error&#x27;)</span><br><span class="line">    &#125;catch(error)&#123;</span><br><span class="line">        console.log(error)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="并发与并行的区别？"><a href="#并发与并行的区别？" class="headerlink" title="并发与并行的区别？"></a>并发与并行的区别？</h1><ul>
<li>并发是宏观概念，我分别有任务 A 和任务 B，在一段时间内通过任务间的切换完成了这两个任务，这种情况就可以称之为并发。</li>
<li>并行是微观概念，假设 CPU 中存在两个核心，那么我就可以同时完成任务 A、B。同时完成多个任务的情况就可以称之为并行。</li>
</ul>
<h1 id="什么是回调函数？回调函数有什么缺点？如何解决回调地狱问题？"><a href="#什么是回调函数？回调函数有什么缺点？如何解决回调地狱问题？" class="headerlink" title="什么是回调函数？回调函数有什么缺点？如何解决回调地狱问题？"></a>什么是回调函数？回调函数有什么缺点？如何解决回调地狱问题？</h1><p>以下代码就是一个回调函数的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ajax(url, () =&gt; &#123;</span><br><span class="line">    // 处理逻辑</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>回调函数有一个致命的弱点，就是容易写出回调地狱（Callback hell）。假设多个请求存在依赖性，可能会有如下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ajax(url, () =&gt; &#123;</span><br><span class="line">    // 处理逻辑</span><br><span class="line">    ajax(url1, () =&gt; &#123;</span><br><span class="line">        // 处理逻辑</span><br><span class="line">        ajax(url2, () =&gt; &#123;</span><br><span class="line">            // 处理逻辑</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>以上代码看起来不利于阅读和维护，当然，也可以把函数分开来写：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function firstAjax() &#123;</span><br><span class="line">  ajax(url1, () =&gt; &#123;</span><br><span class="line">    // 处理逻辑</span><br><span class="line">    secondAjax()</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line">function secondAjax() &#123;</span><br><span class="line">  ajax(url2, () =&gt; &#123;</span><br><span class="line">    // 处理逻辑</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line">ajax(url, () =&gt; &#123;</span><br><span class="line">  // 处理逻辑</span><br><span class="line">  firstAjax()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>以上的代码虽然看上去利于阅读了，但是还是没有解决根本问题。回调地狱的根本问题就是：</p>
<ol>
<li>嵌套函数存在耦合性，一旦有所改动，就会牵一发而动全身</li>
<li>嵌套函数一多，就很难处理错误</li>
</ol>
<p>当然，回调函数还存在着别的几个缺点，比如不能使用 try catch 捕获错误，不能直接 return。</p>
<h1 id="setTimeout、setInterval、requestAnimationFrame-各有什么特点？"><a href="#setTimeout、setInterval、requestAnimationFrame-各有什么特点？" class="headerlink" title="setTimeout、setInterval、requestAnimationFrame 各有什么特点？"></a>setTimeout、setInterval、requestAnimationFrame 各有什么特点？</h1><p>异步编程当然少不了定时器了，常见的定时器函数有 setTimeout、setInterval、requestAnimationFrame。最常用的是setTimeout，很多人认为 setTimeout 是延时多久，那就应该是多久后执行。<br>其实这个观点是错误的，因为 JS 是单线程执行的，如果前面的代码影响了性能，就会导致 setTimeout 不会按期执行。当然了，可以通过代码去修正 setTimeout，从而使定时器相对准确：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">let period = 60 * 1000 * 60 * 2</span><br><span class="line">let startTime = new Date().getTime()</span><br><span class="line">let count = 0</span><br><span class="line">let end = new Date().getTime() + period</span><br><span class="line">let interval = 1000</span><br><span class="line">let currentInterval = interval</span><br><span class="line">function loop() &#123;</span><br><span class="line">  count++</span><br><span class="line">  // 代码执行所消耗的时间</span><br><span class="line">  let offset = new Date().getTime() - (startTime + count * interval);</span><br><span class="line">  let diff = end - new Date().getTime()</span><br><span class="line">  let h = Math.floor(diff / (60 * 1000 * 60))</span><br><span class="line">  let hdiff = diff % (60 * 1000 * 60)</span><br><span class="line">  let m = Math.floor(hdiff / (60 * 1000))</span><br><span class="line">  let mdiff = hdiff % (60 * 1000)</span><br><span class="line">  let s = mdiff / (1000)</span><br><span class="line">  let sCeil = Math.ceil(s)</span><br><span class="line">  let sFloor = Math.floor(s)</span><br><span class="line">  // 得到下一次循环所消耗的时间</span><br><span class="line">  currentInterval = interval - offset </span><br><span class="line">  console.log(&#x27;时：&#x27;+h, &#x27;分：&#x27;+m, &#x27;毫秒：&#x27;+s, &#x27;秒向上取整：&#x27;+sCeil, &#x27;代码执行时间：&#x27;+offset, &#x27;下次循环间隔&#x27;+currentInterval) </span><br><span class="line">  setTimeout(loop, currentInterval)</span><br><span class="line">&#125;</span><br><span class="line">setTimeout(loop, currentInterval)</span><br></pre></td></tr></table></figure>
<p>接下来看 setInterval，其实这个函数作用和 setTimeout 基本一致，只是该函数是每隔一段时间执行一次回调函数。<br>通常来说不建议使用 setInterval。第一，它和 setTimeout 一样，不能保证在预期的时间执行任务。第二，它存在执行累积的问题，请看以下伪代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function demo() &#123;</span><br><span class="line">  setInterval(function()&#123;</span><br><span class="line">    console.log(2)</span><br><span class="line">  &#125;,1000)</span><br><span class="line">  sleep(2000)</span><br><span class="line">&#125;</span><br><span class="line">demo()</span><br></pre></td></tr></table></figure>
<p>以上代码在浏览器环境中，如果定时器执行过程中出现了耗时操作，多个回调函数会在耗时操作结束以后同时执行，这样可能就会带来性能上的问题。<br>如果有循环定时器的需求，其实完全可以通过 requestAnimationFrame 来实现：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">function setInterval(callback, interval) &#123;</span><br><span class="line">  let timer</span><br><span class="line">  const now = Date.now</span><br><span class="line">  let startTime = now()</span><br><span class="line">  let endTime = startTime</span><br><span class="line">  const loop = () =&gt; &#123;</span><br><span class="line">    timer = window.requestAnimationFrame(loop)</span><br><span class="line">    endTime = now()</span><br><span class="line">    if (endTime - startTime &gt;= interval) &#123;</span><br><span class="line">      startTime = endTime = now()</span><br><span class="line">      callback(timer)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  timer = window.requestAnimationFrame(loop)</span><br><span class="line">  return timer</span><br><span class="line">&#125;</span><br><span class="line">let a = 0</span><br><span class="line">setInterval(timer =&gt; &#123;</span><br><span class="line">  console.log(1)</span><br><span class="line">  a++</span><br><span class="line">  if (a === 3) cancelAnimationFrame(timer)</span><br><span class="line">&#125;, 1000)</span><br></pre></td></tr></table></figure>
    </div>

    
    
    

    <footer class="post-footer">
          

<div class="post-copyright">
<ul>
  <li class="post-copyright-author">
      <strong>本文作者： </strong>eyecatwang
  </li>
  <li class="post-copyright-link">
      <strong>本文链接：</strong>
      <a href="https://eyecatwang.github.io/2021/08/19/js%E9%9D%A2%E8%AF%95-%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/" title="javascript面试-异步编程">https://eyecatwang.github.io/2021/08/19/js面试-异步编程/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2021/08/19/js%E9%9D%A2%E8%AF%95-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/" rel="prev" title="javascript面试-数据类型">
                  <i class="fa fa-chevron-left"></i> javascript面试-数据类型
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2021/08/19/%E6%95%B0%E7%BB%84%E6%93%8D%E4%BD%9C/" rel="next" title="数组操作">
                  数组操作 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">eyecatwang</span>
</div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" integrity="sha256-yt2kYMy0w8AbtF89WXb2P1rfjcP/HTHLT7097U8Y5b8=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  
<script src="https://cdn.jsdelivr.net/npm/hexo-generator-searchdb@1.4.0/dist/search.js" integrity="sha256-vXZMYLEqsROAXkEw93GGIvaB2ab+QW6w3+1ahD9nXXA=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>



  <script src="/js/third-party/fancybox.js"></script>


  





</body>
</html>
