<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>call、 bind、apply区别</title>
    <url>/2021/08/19/call%E3%80%81apply%E5%92%8Cbind%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h1 id="call、-bind、apply区别"><a href="#call、-bind、apply区别" class="headerlink" title="call、 bind、apply区别"></a>call、 bind、apply区别</h1><p>我们都知道call apply bind都可以改变函数调用的this指向。那么它们三者有什么区别，什么时候该用哪个呢？</p>
<p>我们先来看MDN语法说明</p>
<h2 id="语法说明"><a href="#语法说明" class="headerlink" title="语法说明"></a>语法说明</h2><h3 id="1-call语法"><a href="#1-call语法" class="headerlink" title="1. call语法"></a>1. call语法</h3><ul>
<li>fun.call(thisArg, arg1, arg2, …)</li>
<li>thisArg: 在fun函数运行时指定的this值。需要注意的是，指定的this值并不一定是该函数执行时真正的this值，如果这个函数处于非严格模式下，则指定为null和undefined的this值会自动指向全局对象(浏览器中就是window对象)，同时值为原始值(数字，字符串，布尔值)的this会指向该原始值的自动包装对象。</li>
<li>arg1, arg2, … 指定的参数列表</li>
</ul>
<h3 id="2-apply语法"><a href="#2-apply语法" class="headerlink" title="2. apply语法"></a>2. apply语法</h3><ul>
<li>fun.apply(thisArg, [argsArray])</li>
<li>thisArg 在 fun 函数运行时指定的 this 值。需要注意的是，指定的 this 值并不一定是该函数执行时真正的 this 值，如果这个函数处于非严格模式下，则指定为 null 或 undefined 时会自动指向全局对象（浏览器中就是window对象），同时值为原始值（数字，字符串，布尔值）的 this 会指向该原始值的自动包装对象。</li>
<li>argsArray 一个数组或者类数组对象，其中的数组元素将作为单独的参数传给 fun 函数。如果该参数的值为null 或 undefined，则表示不需要传入任何参数。从ECMAScript 5 开始可以使用类数组对象。</li>
</ul>
<h3 id="3-bind语法"><a href="#3-bind语法" class="headerlink" title="3. bind语法"></a>3. bind语法</h3><ul>
<li>fun.bind(thisArg[, arg1[, arg2[, …]]])</li>
<li>thisArg 当绑定函数被调用时，该参数会作为原函数运行时的 this 指向。当使用new 操作符调用绑定函数时，该参数无效。</li>
<li>arg1, arg2, … 当绑定函数被调用时，这些参数将置于实参之前传递给被绑定的方法。</li>
</ul>
<h2 id="例子说明"><a href="#例子说明" class="headerlink" title="例子说明"></a>例子说明</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 有只猫叫小黑，小黑会吃鱼</span></span><br><span class="line"><span class="keyword">const</span> cat = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;小黑&#x27;</span>,</span><br><span class="line">    <span class="function"><span class="title">eatFish</span>(<span class="params">...args</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;this指向=&gt;&#x27;</span>, <span class="built_in">this</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;...args&#x27;</span>, args);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.name + <span class="string">&#x27;吃鱼&#x27;</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 有只狗叫大毛，大毛会吃骨头</span></span><br><span class="line"><span class="keyword">const</span> dog = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;大毛&#x27;</span>,</span><br><span class="line">    <span class="function"><span class="title">eatBone</span>(<span class="params">...args</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;this指向=&gt;&#x27;</span>, <span class="built_in">this</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;...args&#x27;</span>, args);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.name + <span class="string">&#x27;吃骨头&#x27;</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;=================== call =========================&#x27;</span>);</span><br><span class="line"><span class="comment">// 有一天大毛想吃鱼了，可是它不知道怎么吃。怎么办？小黑说我吃的时候喂你吃</span></span><br><span class="line">cat.eatFish.call(dog, <span class="string">&#x27;汪汪汪&#x27;</span>, <span class="string">&#x27;call&#x27;</span>)</span><br><span class="line"><span class="comment">// 大毛为了表示感谢，决定下次吃骨头的时候也喂小黑吃</span></span><br><span class="line">dog.eatBone.call(cat, <span class="string">&#x27;喵喵喵&#x27;</span>, <span class="string">&#x27;call&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;=================== apply =========================&#x27;</span>);</span><br><span class="line">cat.eatFish.apply(dog, [<span class="string">&#x27;汪汪汪&#x27;</span>, <span class="string">&#x27;apply&#x27;</span>])</span><br><span class="line">dog.eatBone.apply(cat, [<span class="string">&#x27;喵喵喵&#x27;</span>, <span class="string">&#x27;apply&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;=================== bind =========================&#x27;</span>);</span><br><span class="line"><span class="comment">// 有一天他们觉得每次吃的时候再喂太麻烦了。干脆直接教对方怎么吃</span></span><br><span class="line"><span class="keyword">const</span> test1 = cat.eatFish.bind(dog, <span class="string">&#x27;汪汪汪&#x27;</span>, <span class="string">&#x27;bind&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> test2 = dog.eatBone.bind(cat, <span class="string">&#x27;喵喵喵&#x27;</span>, <span class="string">&#x27;bind&#x27;</span>)</span><br><span class="line">test1()</span><br><span class="line">test2()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><p>call跟apply的用法几乎一样，唯一的不同就是传递的参数不同，call只能一个参数一个参数的传入。</p>
</li>
<li><p>apply则只支持传入一个数组，哪怕是一个参数也要是数组形式。最终调用函数时候这个数组会拆成一个个参数分别传入。</p>
</li>
<li><p>至于bind方法，他是直接改变这个函数的this指向并且返回一个新的函数，之后再次调用这个函数的时候this都是指向bind绑定的第一个参数。bind传餐方式跟call方法一致。</p>
</li>
</ul>
<p>由于apply函数传参的特殊性，我们又衍生出了一个黑魔法。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 如果一个数组我们已知里面全都是数字，想要知道最大的那个数，由于Array没有max方法，Math对象上有</span></span><br><span class="line"><span class="comment">// 我们可以根据apply传递参数的特性将这个数组当成参数传入</span></span><br><span class="line"><span class="comment">// 最终Math.max函数调用的时候会将apply的数组里面的参数一个一个传入，恰好符合Math.max的参数传递方式</span></span><br><span class="line"><span class="comment">// 这样变相的实现了数组的max方法。min方法也同理</span></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line"><span class="keyword">const</span> max = <span class="built_in">Math</span>.max.apply(<span class="literal">null</span>, arr)</span><br><span class="line"><span class="built_in">console</span>.log(max)    <span class="comment">// 6</span></span><br></pre></td></tr></table></figure>

<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>箭头函数没有this，会忽律第一个参数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> cat = &#123;</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&quot;小黑&quot;</span>,</span><br><span class="line">        <span class="attr">eatFish</span>: <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;this 指向=》&quot;</span>, <span class="built_in">this</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;...args=&gt;&quot;</span>, args);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.name + <span class="string">&quot;吃鱼&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> dog = &#123;</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&quot;大毛&quot;</span>,</span><br><span class="line">        <span class="function"><span class="title">eatBone</span>(<span class="params">...args</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&quot;this 指向=》&quot;</span>, <span class="built_in">this</span>);</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&quot;...args=&gt;&quot;</span>, args);</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="built_in">this</span>.name + <span class="string">&quot;吃骨头&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cat.eatFish.call(dog, <span class="string">&quot;1&quot;</span>, <span class="string">&quot;2&quot;</span>)</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>call 和 apply 的主要作用，是改变对象的执行上下文，并且是立即执行的。它们在参数上的写法略有区别。</p>
<p>bind 也能改变对象的执行上下文，它与 call 和 apply 不同的是，返回值是一个函数，并且需要稍后再调用一下，才会执行。</p>
]]></content>
      <categories>
        <category>js基础</category>
      </categories>
  </entry>
  <entry>
    <title>js实现call, apply, bind方法</title>
    <url>/2021/08/19/js%E5%AE%9E%E7%8E%B0call,%20apply,%20bind%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>#实现call方法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;叫爸爸&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> son = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;叫儿子&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="built_in">this</span>.name) </span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Function</span>.prototype.call_ = <span class="function"><span class="keyword">function</span> (<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//判断是否为null或者undefined,同时考虑传递参数不是对象情况</span></span><br><span class="line">    obj = obj ? <span class="built_in">Object</span>(obj) : <span class="built_in">window</span>;</span><br><span class="line">    <span class="keyword">var</span> args = [];</span><br><span class="line">    <span class="comment">// 注意i从1开始</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>, len = <span class="built_in">arguments</span>.length; i &lt; len; i++) &#123;</span><br><span class="line">        args.push(<span class="built_in">arguments</span>[i])</span><br><span class="line">    &#125;;</span><br><span class="line">    obj.fn = <span class="built_in">this</span>; <span class="comment">// 此时this就是函数fn</span></span><br><span class="line">    obj.fn(...args)</span><br><span class="line">    <span class="keyword">delete</span> obj.fn; <span class="comment">//删除fn</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>#实现apply方法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;叫爸爸&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> son = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;叫儿子&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="built_in">this</span>.name) </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Function</span>.prototype.apply_ = <span class="function"><span class="keyword">function</span> (<span class="params">obj, arr</span>) </span>&#123;</span><br><span class="line">    obj = obj ? <span class="built_in">Object</span>(obj): <span class="built_in">window</span></span><br><span class="line">    obj.fn = <span class="built_in">this</span></span><br><span class="line">    <span class="keyword">if</span> (!arr) &#123;</span><br><span class="line">        obj.fn();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> args = [];</span><br><span class="line">        <span class="comment">// 注意i从1开始</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>, len = <span class="built_in">arguments</span>.length; i &lt; len; i++) &#123;</span><br><span class="line">            args.push(<span class="built_in">arguments</span>[i])</span><br><span class="line">        &#125;;</span><br><span class="line">        obj.fn(...args)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span> obj.fn</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>#实现bind方法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;叫爸爸&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> son = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;叫儿子&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="built_in">this</span>.name) </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Function</span>.prototype.bind_ = <span class="function"><span class="keyword">function</span> (<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//判断是否为null或者undefined,同时考虑传递参数不是对象情况</span></span><br><span class="line">    obj = obj ? <span class="built_in">Object</span>(obj) : <span class="built_in">window</span>;</span><br><span class="line">    <span class="keyword">var</span> args = [];</span><br><span class="line">    <span class="comment">// 注意i从1开始</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>, len = <span class="built_in">arguments</span>.length; i &lt; len; i++) &#123;</span><br><span class="line">        args.push(<span class="built_in">arguments</span>[i])</span><br><span class="line">    &#125;;</span><br><span class="line">    obj.fn = <span class="built_in">this</span>; <span class="comment">// 此时this就是函数fn</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        obj.fn(...args)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>js基础</category>
      </categories>
  </entry>
  <entry>
    <title>js精度问题</title>
    <url>/2021/10/20/js%E7%B2%BE%E5%BA%A6%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>js中的数字按照IEEE 754的标准，使用64位双精度浮点型来表示。</p>
<p>其中符号位S，指数位E，尾数位M分别占了1，11，52位，并在ES5规范中指出了指数位E的取值范围是[-1074, 971].</p>
<h2 id="精度问题汇总"><a href="#精度问题汇总" class="headerlink" title="精度问题汇总"></a>精度问题汇总</h2><p>想用有限的位来表示无穷的数字，显然是不可能的，因此会出现一些列精度问题</p>
<p>· 浮点数精度问题，比如，0.1+0.2 !== 0.3<br>· 大数精度问题，比如9999 9999 9999 9999 == 1000 0000 0000 0000 1<br>· toFixed 四舍五入结果不准确，比如1.335.toFixed(2) == 1.33</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="number">1.335</span>).toPrecision(<span class="number">20</span>); <span class="comment">// &quot;1.3349999999999999645&quot;</span></span><br></pre></td></tr></table></figure>

<p>而关于大数精度问题，我们可以先看下面这个代码片段：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 能精确表示的整数范围上限,S为1个0，E为11个0，S为52个1</span></span><br><span class="line"><span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">53</span>) - <span class="number">1</span> === <span class="built_in">Number</span>.MAX_SAFE_INTEGER    <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 能精确表示的整数范围下限,S为1个1，E为11个0，S为52个1</span></span><br><span class="line">-(<span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">53</span>) - <span class="number">1</span>) === <span class="built_in">Number</span>.MIN_SAFE_INTEGER    <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 能表示的最大数字，S为1个0，E为971，S为52个1</span></span><br><span class="line">(<span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">53</span>) - <span class="number">1</span>) * <span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">971</span>) === <span class="built_in">Number</span>.MAX_VALUE    <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 能表示的最接近于0的正数，S为1个0，E为-1074，S为0</span></span><br><span class="line"><span class="built_in">Math</span>.pow(<span class="number">2</span>, -<span class="number">1074</span>) === <span class="built_in">Number</span>.MIN_VALUE <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>通过以上可以明白，[MIN_SAFE_INTEGER, MAX_SAFE_INTEGER] 的整数都可以精确表示，但是超出这个范围的整数就不一定能精确表示。这样就会产生所谓的大数精度丢失问题。</p>
<h2 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h2><p>首先考虑的是如何解决浮点数运算的精度问题，有 3 种思路：</p>
<p>· 考虑到每次浮点数运算的偏差非常小(其实不然)，可以对结果进行指定精度的四舍五入，比如可以parseFloat(result.toFixed(12));<br>· 将浮点数转为整数运算，再对结果做除法。比如0.1 + 0.2，可以转化为(1*2)/3。<br>· 把浮点数转化为字符串，模拟实际运算的过程。</p>
<p>先来看第一种方案，在大多数情况下，它可以得到正确结果，但是对一些极端情况，toFixed 到 12 是不够的，比如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">210000</span> * <span class="number">10000</span>  * <span class="number">1000</span> * <span class="number">8.2</span>    <span class="comment">// 17219999999999.998</span></span><br><span class="line"><span class="built_in">parseFloat</span>(<span class="number">17219999999999.998</span>.toFixed(<span class="number">12</span>));    <span class="comment">// 17219999999999.998，而正确结果为 17220000000000</span></span><br></pre></td></tr></table></figure>
<p>上面的情况，如果想让结果正确，需要 toFixed(2)，这显然是不可接受的。</p>
<p>再看第二种方案，比如 number-precision 这个库就是使用的这种方案，但是这也是有问题的，比如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这两个浮点数，转化为整数之后，相乘的结果已经超过了 MAX_SAFE_INTEGER</span></span><br><span class="line"><span class="number">123456.789</span> * <span class="number">123456.789</span>     <span class="comment">// 转化为 (123456789 * 123456789)/1000000，结果是 15241578750.19052</span></span><br></pre></td></tr></table></figure>

<p>所以，最终考虑使用第三种方案，目前已经有了很多较为成熟的库，比如 bignumber.js，decimal.js，以及big.js等。我们可以根据自己的需求来选择对应的工具。并且，这些库不仅解决了浮点数的运算精度问题，还支持了大数运算，并且修复了原生toFixed结果不准确的问题。</p>
]]></content>
      <categories>
        <category>js基础</category>
      </categories>
  </entry>
  <entry>
    <title>javascript面试-git</title>
    <url>/2021/08/19/js%E9%9D%A2%E8%AF%95-git/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>面试</category>
        <category>js</category>
      </categories>
  </entry>
  <entry>
    <title>javascript面试-http</title>
    <url>/2021/08/19/js%E9%9D%A2%E8%AF%95-http/</url>
    <content><![CDATA[<h1 id="说一下http和https"><a href="#说一下http和https" class="headerlink" title="说一下http和https"></a>说一下http和https</h1><h2 id="http和https的基本概念"><a href="#http和https的基本概念" class="headerlink" title="http和https的基本概念"></a>http和https的基本概念</h2><p>http: 超文本传输协议，是互联网上应用最为广泛的一种网络协议，是一个客户端和服务器端请求和应答的标准（TCP），用于从WWW服务器传输超文本到本地浏览器的传输协议，它可以使浏览器更加高效，使网络传输减少。</p>
<p>https: 是以安全为目标的HTTP通道，简单讲是HTTP的安全版，即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。</p>
<p>https协议的主要作用是：建立一个信息安全通道，来确保数组的传输，确保网站的真实性。</p>
<h2 id="http和https的区别？"><a href="#http和https的区别？" class="headerlink" title="http和https的区别？"></a>http和https的区别？</h2><p>http传输的数据都是未加密的，也就是明文的，网景公司设置了SSL协议来对http协议传输的数据进行加密处理，简单来说https协议是由http和ssl协议构建的可进行加密传输和身份认证的网络协议，比http协议的安全性更高。<br>主要的区别如下：</p>
<p>Https协议需要ca证书，费用较高。</p>
<p>http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。</p>
<p>使用不同的链接方式，端口也不同，一般而言，http协议的端口为80，https的端口为443</p>
<p>http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。</p>
<h2 id="https协议的工作原理"><a href="#https协议的工作原理" class="headerlink" title="https协议的工作原理"></a>https协议的工作原理</h2><p>客户端在使用HTTPS方式与Web服务器通信时有以下几个步骤，如图所示。</p>
<p>客户使用https url访问服务器，则要求web 服务器建立ssl链接。</p>
<p>web服务器接收到客户端的请求之后，会将网站的证书（证书中包含了公钥），返回或者说传输给客户端。</p>
<p>客户端和web服务器端开始协商SSL链接的安全等级，也就是加密等级。</p>
<p>客户端浏览器通过双方协商一致的安全等级，建立会话密钥，然后通过网站的公钥来加密会话密钥，并传送给网站。</p>
<p>web服务器通过自己的私钥解密出会话密钥。</p>
<p>web服务器通过会话密钥加密与客户端之间的通信。</p>
<h2 id="https协议的优点"><a href="#https协议的优点" class="headerlink" title="https协议的优点"></a>https协议的优点</h2><p>使用HTTPS协议可认证用户和服务器，确保数据发送到正确的客户机和服务器；</p>
<p>HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全，可防止数据在传输过程中不被窃取、改变，确保数据的完整性。</p>
<p>HTTPS是现行架构下最安全的解决方案，虽然不是绝对安全，但它大幅增加了中间人攻击的成本。</p>
<p>谷歌曾在2014年8月份调整搜索引擎算法，并称“比起同等HTTP网站，采用HTTPS加密的网站在搜索结果中的排名将会更高”。</p>
<h2 id="https协议的缺点"><a href="#https协议的缺点" class="headerlink" title="https协议的缺点"></a>https协议的缺点</h2><p>https握手阶段比较费时，会使页面加载时间延长50%，增加10%~20%的耗电。</p>
<p>https缓存不如http高效，会增加数据开销。</p>
<p>SSL证书也需要钱，功能越强大的证书费用越高。</p>
<p>SSL证书需要绑定IP，不能再同一个ip上绑定多个域名，ipv4资源支持不了这种消耗。</p>
]]></content>
      <categories>
        <category>面试</category>
        <category>js</category>
      </categories>
  </entry>
  <entry>
    <title>javascript面试-nginx</title>
    <url>/2021/08/19/js%E9%9D%A2%E8%AF%95-nginx/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>面试</category>
        <category>js</category>
      </categories>
  </entry>
  <entry>
    <title>javascript面试-node</title>
    <url>/2021/08/19/js%E9%9D%A2%E8%AF%95-node/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>面试</category>
        <category>js</category>
      </categories>
  </entry>
  <entry>
    <title>javascript面试-this问题</title>
    <url>/2021/08/19/js%E9%9D%A2%E8%AF%95-this&amp;call&amp;apply&amp;bind/</url>
    <content><![CDATA[<h1 id="对this对象的理解"><a href="#对this对象的理解" class="headerlink" title="对this对象的理解"></a>对this对象的理解</h1><p>this 是执行上下文中的一个属性，它指向最后一次调用这个方法的对象。在实际开发中，this 的指向可以通过四种调用模式来判断。</p>
<ul>
<li>第一种是函数调用模式，当一个函数不是一个对象的属性时，直接作为函数来调用时，this 指向全局对象。</li>
<li>第二种是方法调用模式，如果一个函数作为一个对象的方法来调用时，this 指向这个对象。</li>
<li>第三种是构造器调用模式，如果一个函数用 new 调用时，函数执行前会新创建一个对象，this 指向这个新创建的对象。</li>
<li>第四种是 apply 、 call 和 bind 调用模式，这三个方法都可以显示的指定调用函数的 this 指向。其中 apply 方法接收两个参数：一个是 this 绑定的对象，一个是参数数组。call 方法接收的参数，第一个是 this 绑定的对象，后面的其余参数是传入函数执行的参数。也就是说，在使用 call() 方法时，传递给函数的参数必须逐个列举出来。bind 方法通过传入一个对象，返回一个 this 绑定了传入对象的新函数。这个函数的 this 指向除了使用 new 时会被改变，其他情况下都不会改变。</li>
</ul>
<p>这四种方式，使用构造器调用模式的优先级最高，然后是 apply、call 和 bind 调用模式，然后是方法调用模式，然后是函数调用模式。</p>
<h1 id="call-和-apply-的区别？"><a href="#call-和-apply-的区别？" class="headerlink" title="call() 和 apply() 的区别？"></a>call() 和 apply() 的区别？</h1><p>它们的作用一模一样，区别仅在于传入参数的形式的不同。</p>
<ul>
<li>apply 接受两个参数，第一个参数指定了函数体内 this 对象的指向，第二个参数为一个带下标的集合，这个集合可以为数组，也可以为类数组，apply 方法把这个集合中的元素作为参数传递给被调用的函数。</li>
<li>call 传入的参数数量不固定，跟 apply 相同的是，第一个参数也是代表函数体内的 this 指向，从第二个参数开始往后，每个参数被依次传入函数。</li>
</ul>
<h1 id="实现call、apply-及-bind-函数"><a href="#实现call、apply-及-bind-函数" class="headerlink" title="实现call、apply 及 bind 函数"></a>实现call、apply 及 bind 函数</h1><h2 id="call-函数的实现步骤："><a href="#call-函数的实现步骤：" class="headerlink" title="call 函数的实现步骤："></a>call 函数的实现步骤：</h2><ul>
<li>判断调用对象是否为函数，即使是定义在函数的原型上的，但是可能出现使用 call 等方式调用的情况。</li>
<li>判断传入上下文对象是否存在，如果不存在，则设置为 window 。</li>
<li>处理传入的参数，截取第一个参数后的所有参数。</li>
<li>将函数作为上下文对象的一个属性。</li>
<li>使用上下文对象来调用这个方法，并保存返回结果。</li>
<li>删除刚才新增的属性。</li>
<li>返回结果。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Function.prototype.myCall = function(context) &#123;</span><br><span class="line">  // 判断调用对象</span><br><span class="line">  if (typeof this !== &quot;function&quot;) &#123;</span><br><span class="line">    console.error(&quot;type error&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  // 获取参数</span><br><span class="line">  let args = [...arguments].slice(1),</span><br><span class="line">    result = null;</span><br><span class="line">  // 判断 context 是否传入，如果未传入则设置为 window</span><br><span class="line">  context = context || window;</span><br><span class="line">  // 将调用函数设为对象的方法</span><br><span class="line">  context.fn = this;</span><br><span class="line">  // 调用函数</span><br><span class="line">  result = context.fn(...args);</span><br><span class="line">  // 将属性删除</span><br><span class="line">  delete context.fn;</span><br><span class="line">  return result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="apply-函数的实现步骤："><a href="#apply-函数的实现步骤：" class="headerlink" title="apply 函数的实现步骤："></a>apply 函数的实现步骤：</h2><ul>
<li>判断调用对象是否为函数，即使是定义在函数的原型上的，但是可能出现使用 call 等方式调用的情况。</li>
<li>判断传入上下文对象是否存在，如果不存在，则设置为 window 。</li>
<li>将函数作为上下文对象的一个属性。</li>
<li>判断参数值是否传入</li>
<li>使用上下文对象来调用这个方法，并保存返回结果。</li>
<li>删除刚才新增的属性</li>
<li>返回结果</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Function.prototype.myApply = function(context) &#123;</span><br><span class="line">  // 判断调用对象是否为函数</span><br><span class="line">  if (typeof this !== &quot;function&quot;) &#123;</span><br><span class="line">    throw new TypeError(&quot;Error&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  let result = null;</span><br><span class="line">  // 判断 context 是否存在，如果未传入则为 window</span><br><span class="line">  context = context || window;</span><br><span class="line">  // 将函数设为对象的方法</span><br><span class="line">  context.fn = this;</span><br><span class="line">  // 调用方法</span><br><span class="line">  if (arguments[1]) &#123;</span><br><span class="line">    result = context.fn(...arguments[1]);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    result = context.fn();</span><br><span class="line">  &#125;</span><br><span class="line">  // 将属性删除</span><br><span class="line">  delete context.fn;</span><br><span class="line">  return result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>（3）bind 函数的实现步骤：</p>
<ul>
<li>判断调用对象是否为函数，即使是定义在函数的原型上的，但是可能出现使用 call 等方式调用的情况。</li>
<li>保存当前函数的引用，获取其余传入参数值。</li>
<li>创建一个函数返回</li>
<li>函数内部使用 apply 来绑定函数调用，需要判断函数作为构造函数的情况，这个时候需要传入当前函数的 this 给 apply 调用，其余情况都传入指定的上下文对象。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Function.prototype.myBind = function(context) &#123;</span><br><span class="line">  // 判断调用对象是否为函数</span><br><span class="line">  if (typeof this !== &quot;function&quot;) &#123;</span><br><span class="line">    throw new TypeError(&quot;Error&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  // 获取参数</span><br><span class="line">  var args = [...arguments].slice(1),</span><br><span class="line">    fn = this;</span><br><span class="line">  return function Fn() &#123;</span><br><span class="line">    // 根据调用方式，传入不同绑定值</span><br><span class="line">    return fn.apply(</span><br><span class="line">      this instanceof Fn ? this : context,</span><br><span class="line">      args.concat(...arguments)</span><br><span class="line">    );</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>面试</category>
        <category>js</category>
      </categories>
  </entry>
  <entry>
    <title>javascript面试-typescript</title>
    <url>/2021/08/19/js%E9%9D%A2%E8%AF%95-typescript/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>面试</category>
        <category>js</category>
      </categories>
  </entry>
  <entry>
    <title>javascript面试-vue</title>
    <url>/2021/08/19/js%E9%9D%A2%E8%AF%95-vue/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>面试</category>
        <category>js</category>
      </categories>
  </entry>
  <entry>
    <title>javascript面试-webpack</title>
    <url>/2021/08/19/js%E9%9D%A2%E8%AF%95-webpack/</url>
    <content><![CDATA[<h1 id="webpack-是用来做什么的，原理是什么"><a href="#webpack-是用来做什么的，原理是什么" class="headerlink" title="webpack 是用来做什么的，原理是什么"></a>webpack 是用来做什么的，原理是什么</h1><p>webpack就是通过一个index.js这样的入口文件，根据此入口文件查找各层的js模块的依赖最终打包成一个文件，webpack做了依赖收集<br>原理：<br>（1）初始化参数：解析webpack配置参数，合并shell传入和webpack.config.js文件配置的参数，形成最后的配置结果。</p>
<p>（2）开始编译：上一步得到的参数初始化compiler对象，注册所有配置的插件，插件监听webpack构建生命周期的事件节点，做出相应的反应，执行对象的 run 方法开始执行编译。</p>
<p>（3）确定入口：从配置的entry入口，开始解析文件构建AST语法树，找出依赖，递归下去。</p>
<p>（4）编译模块：递归中根据文件类型和loader配置，调用所有配置的loader对文件进行转换，再找出该模块依赖的模块，再递归本步骤直到所有入口依赖的文件都经过了本步骤的处理。</p>
<p>（5）完成模块编译并输出：递归完事后，得到每个文件结果，包含每个模块以及他们之间的依赖关系，根据entry配置生成代码块chunk。</p>
<p>（6）输出完成：输出所有的chunk到文件系统。</p>
<h1 id="webpack-中的-loader-的作用是什么"><a href="#webpack-中的-loader-的作用是什么" class="headerlink" title="webpack 中的 loader 的作用是什么"></a>webpack 中的 loader 的作用是什么</h1><p>webpack是基于 node 的，只能处理 JS和 JSON文件，loader 的作用是用来处理其他类型的文件（less\vue….等） 可以将 less 转成 css 文件，将 jsx处理成 JS文件，将其他版本的 ES 处理成浏览器能识别的 ES 版本</p>
<h1 id="有没有自己写过一个-webpack-的-loader"><a href="#有没有自己写过一个-webpack-的-loader" class="headerlink" title="有没有自己写过一个 webpack 的 loader"></a>有没有自己写过一个 webpack 的 loader</h1><h1 id="webpack-中-plugin-的作用是什么，有没有自己写过"><a href="#webpack-中-plugin-的作用是什么，有没有自己写过" class="headerlink" title="webpack 中 plugin 的作用是什么，有没有自己写过"></a>webpack 中 plugin 的作用是什么，有没有自己写过</h1><p>plugin系统提供给开发者监听webpack生命周期并在特定事件触发时执行指定操作的能力。</p>
<h1 id="使用-webpack-时如何优化项目体积"><a href="#使用-webpack-时如何优化项目体积" class="headerlink" title="使用 webpack 时如何优化项目体积"></a>使用 webpack 时如何优化项目体积</h1><p>按需加载，代码压缩，代码分割，CDN 优化，gzip 加速<br>多入口情况下，使用 CommonsChunkPlugin 来提取公共代码 通过 externals 配置来提取常用库 使用 Happypack 实现多线程加速编译 使用 Tree-shaking 剔除多余代码</p>
<h1 id="webpack-中什么是-HMR，原理是什么"><a href="#webpack-中什么是-HMR，原理是什么" class="headerlink" title="webpack 中什么是 HMR，原理是什么"></a>webpack 中什么是 HMR，原理是什么</h1><p>HMR，Hot Module Replacement，热模块替换，见名思意，即无需刷新再内存环境中即可替换掉过旧模块。与 Live Reload 相对应。<br>在 webpack 的运行时中 <strong>webpack__modules</strong> 用以维护所有的模块。而热模块替换的原理，即通过 chunk 的方式加载最新的 modules，找到 <strong>webpack__modules</strong> 中对应的模块逐一替换，并删除其上下缓存。<br>流程</p>
<ol>
<li>webpack-dev-server 将打包输出 bundle 使用内存型文件系统控制，而非真实的文件系统。此时使用的是 memfs (opens new window)模拟 node.js fs API</li>
<li>每当文件发生变更时，webpac 将会重新编译，webpack-dev-server 将会监控到此时文件变更事件，并找到其对应的 module。此时使用的是 chokidar (opens new window)监控文件变更</li>
<li>webpack-dev-server 将会把变更模块通知到浏览器端，此时使用 websocket 与浏览器进行交流。此时使用的是 ws(opens new window)</li>
<li>浏览器根据 websocket 接收到 hash，并通过 hash 以 JSONP 的方式请求更新模块的 chunk</li>
<li>浏览器加载 chunk，并使用新的模块对旧模块进行热替换，并删除其缓存</li>
</ol>
<h1 id="使用-webpack-打包时，如何更好地利用-long-term-cache"><a href="#使用-webpack-打包时，如何更好地利用-long-term-cache" class="headerlink" title="使用 webpack 打包时，如何更好地利用 long term cache"></a>使用 webpack 打包时，如何更好地利用 long term cache</h1><p>使用 webpack 等打包器进行打包时，每个资源都可生成一个带有 hash 的路径。如</p>
<ul>
<li>build/main.071b73.js</li>
<li>build/main.94474e.css</li>
<li>build/logo.18bac8.png<br>此处对添加 hash 的资源设置永久缓存，可大幅度提高该网站的缓存能力，从而大幅度提高网站的二次加载性能。</li>
</ul>
<p>通过在服务器端/网关端对资源设置以下 Response Header，进行强缓存一年时间，称为永久缓存，即 Long Term Cache。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Cache-Control: public,max-age=31536000,immutable</span><br></pre></td></tr></table></figure>
<p>而当源文件内容发生变更时，资源的 hash 发生变化，生成新的可永久缓存的资源地址。</p>
<p>因此在实践中，可对打包处理后带有 hash 资源的所有文件设置永久缓存。</p>
<p>如果前端通过 docker/k8s/helm 进行部署，可由团队人员自行在构建 nginx 镜像时进行添加响应头字段。此处可作为前端性能优化的 kpi/okr。</p>
<p>可在浏览器控制台 Network 中查看响应头来验证所属项目是否已成功添加永久缓存。</p>
<h1 id="随着-http2-的发展，webpack-有没有更好的打包方案"><a href="#随着-http2-的发展，webpack-有没有更好的打包方案" class="headerlink" title="随着 http2 的发展，webpack 有没有更好的打包方案"></a>随着 http2 的发展，webpack 有没有更好的打包方案</h1><h1 id="Tree-Shaking-的原理是什么"><a href="#Tree-Shaking-的原理是什么" class="headerlink" title="Tree Shaking 的原理是什么"></a>Tree Shaking 的原理是什么</h1><p>Tree shaking 是一种通过清除多余代码方式来优化项目打包体积的技术，专业术语叫 Dead code elimination</p>
<p>为什么需要tree shaking<br>主要还是为了减少页面的加载时间，将无用的代码删除，减少js包的大小，从而减少用户等待的时间，使用户不因为漫长的等待而离开。<br>es6模块的特点：</p>
<ul>
<li>只能作为模块顶层的语句出现</li>
<li>import的模块名只能是字符串常量，不能动态引入</li>
<li>import binding是immutable,引入的模块不能再做修改</li>
</ul>
<p>原理:<br>用一句话解释就是，找到你整个代码里真正使用的代码，打包进去，那么没用的代码自然就剔除了。</p>
<ul>
<li>ES6 Module引入进行静态分析，故而编译的时候正确判断到底加载了那些模块</li>
<li>静态分析程序流，判断那些模块和变量未被使用或者引用，进而删除对应代码</li>
</ul>
<h1 id="vue-loader-的实现原理是什么"><a href="#vue-loader-的实现原理是什么" class="headerlink" title="vue-loader 的实现原理是什么"></a>vue-loader 的实现原理是什么</h1><p>vue-loader 会把 sfc 中的内容拆分为 template，script，style 三个“虚拟模块”，然后分别匹配 webpack 配置中对应的 rules，比如 script 模块会匹配所有跟处理 JavaScript 或 TypeScript 相关的 loader。</p>
<p>template 中的内容会通过 vue compiler 转换为 render 函数后合并到 script “虚拟模块”中。</p>
<p>scoped style 会经过 vue-loader/style-post-loader 的处理，成为只匹配特定元素的私有样式。</p>
<h1 id="对于已经-import-但未实际使用的模块使用-webpack-还会对它打包吗？"><a href="#对于已经-import-但未实际使用的模块使用-webpack-还会对它打包吗？" class="headerlink" title="对于已经 import 但未实际使用的模块使用 webpack 还会对它打包吗？"></a>对于已经 import 但未实际使用的模块使用 webpack 还会对它打包吗？</h1><p>tree shaking 通过扫描所有 ES6 的 export，找出被 import 的内容并添加到最终代码中。tree shaking 的使用时 源码必须遵循 ES6 的模块规范 (import &amp; export)，如果是 CommonJS 规范 (require) 则无法使用。 也就是说，需要给 babel 里面配置一下”es6 不要解析”：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// .babelrc</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    &quot;presets&quot;: [</span><br><span class="line">        [&quot;es2015&quot;, &#123;&quot;modules&quot;: false&#125;]</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>tree shaking 在 webpack2.0 里面需要进行手动设置，webpack3 和 webpack4 里面为默认设置。</p>
<h2 id="对于方法的处理"><a href="#对于方法的处理" class="headerlink" title="对于方法的处理"></a>对于方法的处理</h2><p>通过 tree shaking 设置后，webpack 里面会将没有使用的方法标记为： unused harmony export xxx，但代码仍然保留。（webpack 编译后的源码里面仍然包含没有使用的方法） 随后使用UglifyJSPlugin进行第二步，将已经标记的没有使用的方法进行删除。</p>
<h2 id="对于类的处理"><a href="#对于类的处理" class="headerlink" title="对于类的处理"></a>对于类的处理</h2><p>与标记方法不同，webpack 打包时会将整个类进行标记，也就是说，即使类里面的方法没有被使用也会进行打包编译。 这表明 webpack tree shaking 只处理顶层内容，例如类和对象内部都不会再被分别处理。 综上所述，可以得出 “对于已经 import 但未实际使用的模块使用 webpack 还会对它打包” 。 当然，想要精简代码是可以实现的，</p>
<h1 id="Code-Splitting-代码分割-的原理是什么"><a href="#Code-Splitting-代码分割-的原理是什么" class="headerlink" title="Code Splitting (代码分割) 的原理是什么"></a>Code Splitting (代码分割) 的原理是什么</h1><p>Code Splitting是webpack的一个重要特性，他允许你将代码打包生成多个bundle。对多页应用来说，它是必须的，因为必须要配置多个入口生成多个bundle；对于单页应用来说，如果只打包成一个bundle可能体积很大，导致无法利用浏览器并行下载的能力，且白屏时间长，也会导致下载很多可能用不到的代码，每次上线用户都得下载全部代码，Code Splitting能够将代码分割，实现按需加载或并行加载多个bundle，可利用并发下载能力，减少首次访问白屏时间，可以只上线必要的文件。</p>
<h1 id="三种Code-Splitting方式"><a href="#三种Code-Splitting方式" class="headerlink" title="三种Code Splitting方式"></a>三种Code Splitting方式</h1><h1 id="使用-webpack-如何分包"><a href="#使用-webpack-如何分包" class="headerlink" title="使用 webpack 如何分包"></a>使用 webpack 如何分包</h1><h1 id="如何压缩前端项目中-JS-的体积"><a href="#如何压缩前端项目中-JS-的体积" class="headerlink" title="如何压缩前端项目中 JS 的体积"></a>如何压缩前端项目中 JS 的体积</h1><ul>
<li>terser (opens new window)或者 uglify (opens new window)，及流行的使用 Rust 编写的 swc 压缩混淆化 JS。</li>
<li>gzip 或者 brotli 压缩，在网关处(nginx)开启</li>
<li>使用 webpack-bundle-analyzer 分析打包体积，替换占用较大体积的库，如 moment -&gt; dayjs</li>
<li>使用支持 Tree-Shaking 的库，对无引用的库或函数进行删除，如 lodash -&gt; lodash/es</li>
<li>对无法 Tree Shaking 的库，进行按需引入模块，如使用 import Button from ‘antd/lib/Button’，此处可手写 babel-plugin 自动完成，但不推荐</li>
<li>使用 babel (css 为 postcss) 时采用 browserlist，越先进的浏览器所需要的 polyfill 越少，体积更小</li>
<li>code spliting，路由懒加载，只加载当前路由的包，按需加载其余的 chunk，首页 JS 体积变小 (PS: 次条不减小总体积，但减小首页体积)</li>
<li>使用 webpack 的 splitChunksPlugin，把运行时、被引用多次的库进行分包，在分包时要注意避免某一个库被多次引用多次打包。此时分为多个 chunk，虽不能把总体积变小，但可提高加载性能 (PS: 此条不减小总体积，但可提升加载性能)</li>
</ul>
<h1 id="webpack-的-runtime-做了什么事情"><a href="#webpack-的-runtime-做了什么事情" class="headerlink" title="webpack 的 runtime 做了什么事情"></a>webpack 的 runtime 做了什么事情</h1><p>webpack 的 runtime，也就是 webpack 最后生成的代码，做了以下三件事:</p>
<ol>
<li><strong>webpack_modules</strong>: 维护一个所有模块的数组。将入口模块解析为 AST，根据 AST 深度优先搜索所有的模块，并构建出这个模块数组。每个模块都由一个包裹函数 (module, module.exports, <strong>webpack_require</strong>) 对模块进行包裹构成。</li>
<li><strong>webpack_require</strong>(moduleId): 手动实现加载一个模块。对已加载过的模块进行缓存，对胃加载过的模块，执行 id 定位到 <strong>webpack_modules</strong> 中的包裹函数，执行并返回 module.exports，并缓存</li>
<li><strong>webpack_require</strong>(0): 运行第一个模块，即运行入口模块<br>另外，当涉及到多个 chunk 的打包方式中，比如 code spliting，webpack 中会有 jsonp 加载 chunk 的运行时代码。</li>
</ol>
<h1 id="webpack-中的-code-spliting-是如何动态加载-chunk-的？"><a href="#webpack-中的-code-spliting-是如何动态加载-chunk-的？" class="headerlink" title="webpack 中的 code spliting 是如何动态加载 chunk 的？"></a>webpack 中的 code spliting 是如何动态加载 chunk 的？</h1><h1 id="打包器-webpack-rollup-如何将打包后的-js-资源注入-html-中"><a href="#打包器-webpack-rollup-如何将打包后的-js-资源注入-html-中" class="headerlink" title="打包器(webpack/rollup) 如何将打包后的 js 资源注入 html 中"></a>打包器(webpack/rollup) 如何将打包后的 js 资源注入 html 中</h1><h1 id="打包器-webpack-rollup-如何加载-json、image-等非-Javascript-资源"><a href="#打包器-webpack-rollup-如何加载-json、image-等非-Javascript-资源" class="headerlink" title="打包器(webpack/rollup) 如何加载 json、image 等非 Javascript 资源"></a>打包器(webpack/rollup) 如何加载 json、image 等非 Javascript 资源</h1><h1 id="打包器-webpack-rollup-如何加载-style-样式资源"><a href="#打包器-webpack-rollup-如何加载-style-样式资源" class="headerlink" title="打包器(webpack/rollup) 如何加载 style 样式资源"></a>打包器(webpack/rollup) 如何加载 style 样式资源</h1><h1 id="如何提升-webpack-构建资源的速度"><a href="#如何提升-webpack-构建资源的速度" class="headerlink" title="如何提升 webpack 构建资源的速度"></a>如何提升 webpack 构建资源的速度</h1><h1 id="如何分析前端打包体积"><a href="#如何分析前端打包体积" class="headerlink" title="如何分析前端打包体积"></a>如何分析前端打包体积</h1>]]></content>
      <categories>
        <category>面试</category>
        <category>js</category>
      </categories>
  </entry>
  <entry>
    <title>javascript面试-前端工程化</title>
    <url>/2021/08/19/js%E9%9D%A2%E8%AF%95-%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>面试</category>
        <category>js</category>
      </categories>
  </entry>
  <entry>
    <title>javascript面试-原型和原型链</title>
    <url>/2021/08/19/js%E9%9D%A2%E8%AF%95-%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE/</url>
    <content><![CDATA[<h1 id="对原型、原型链的理解"><a href="#对原型、原型链的理解" class="headerlink" title="对原型、原型链的理解"></a>对原型、原型链的理解</h1><p>在JavaScript中是使用构造函数来新建一个对象的，每一个构造函数的内部都有一个 prototype 属性，它的属性值是一个对象，这个对象包含了可以由该构造函数的所有实例共享的属性和方法。当使用构造函数新建一个对象后，在这个对象的内部将包含一个指针，这个指针指向构造函数的 prototype 属性对应的值，在 ES5 中这个指针被称为对象的原型。一般来说不应该能够获取到这个值的，但是现在浏览器中都实现了 proto 属性来访问这个属性，但是最好不要使用这个属性，因为它不是规范中规定的。ES5 中新增了一个 Object.getPrototypeOf() 方法，可以通过这个方法来获取对象的原型。<br>当访问一个对象的属性时，如果这个对象内部不存在这个属性，那么它就会去它的原型对象里找这个属性，这个原型对象又会有自己的原型，于是就这样一直找下去，也就是原型链的概念。原型链的尽头一般来说都是 Object.prototype 所以这就是新建的对象为什么能够使用 toString() 等方法的原因。<br>特点： JavaScript 对象是通过引用来传递的，创建的每个新对象实体中并没有一份属于自己的原型副本。当修改原型时，与之相关的对象也会继承这一改变。</p>
<h1 id="原型修改、重写"><a href="#原型修改、重写" class="headerlink" title="原型修改、重写"></a>原型修改、重写</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function Person(name) &#123;</span><br><span class="line">    this.name = name</span><br><span class="line">&#125;</span><br><span class="line">// 修改原型</span><br><span class="line">Person.prototype.getName = function() &#123;&#125;</span><br><span class="line">var p = new Person(&#x27;hello&#x27;)</span><br><span class="line">console.log(p.__proto__ === Person.prototype) // true</span><br><span class="line">console.log(p.__proto__ === p.constructor.prototype) // true</span><br><span class="line">// 重写原型</span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">    getName: function() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">var p = new Person(&#x27;hello&#x27;)</span><br><span class="line">console.log(p.__proto__ === Person.prototype)        // true</span><br><span class="line">console.log(p.__proto__ === p.constructor.prototype) // false</span><br></pre></td></tr></table></figure>
<p>可以看到修改原型的时候p的构造函数不是指向Person了，因为直接给Person的原型对象直接用对象赋值时，它的构造函数指向的了根构造函数Object，所以这时候p.constructor === Object ，而不是p.constructor === Person。要想成立，就要用constructor指回来：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Person.prototype = &#123;</span><br><span class="line">    getName: function() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">var p = new Person(&#x27;hello&#x27;)</span><br><span class="line">p.constructor = Person</span><br><span class="line">console.log(p.__proto__ === Person.prototype)        // true</span><br><span class="line">console.log(p.__proto__ === p.constructor.prototype) // true</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="原型链指向"><a href="#原型链指向" class="headerlink" title="原型链指向"></a>原型链指向</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">p.__proto__  // Person.prototype</span><br><span class="line">Person.prototype.__proto__  // Object.prototype</span><br><span class="line">p.__proto__.__proto__ //Object.prototype</span><br><span class="line">p.__proto__.constructor.prototype.__proto__ // Object.prototype</span><br><span class="line">Person.prototype.constructor.prototype.__proto__ // Object.prototype</span><br><span class="line">p1.__proto__.constructor // Person</span><br><span class="line">Person.prototype.constructor  // Person</span><br></pre></td></tr></table></figure>
<h1 id="原型链的终点是什么？如何打印出原型链的终点？"><a href="#原型链的终点是什么？如何打印出原型链的终点？" class="headerlink" title="原型链的终点是什么？如何打印出原型链的终点？"></a>原型链的终点是什么？如何打印出原型链的终点？</h1><p>由于Object是构造函数，原型链终点是Object.prototype.__proto__，而Object.prototype.<strong>proto</strong>=== null // true，所以，原型链的终点是null。原型链上的所有原型都是对象，所有的对象最终都是由Object构造的，而Object.prototype的下一级是Object.prototype.__proto__。</p>
<h1 id="如何获得对象非原型链上的属性？"><a href="#如何获得对象非原型链上的属性？" class="headerlink" title="如何获得对象非原型链上的属性？"></a>如何获得对象非原型链上的属性？</h1><p>使用后hasOwnProperty()方法来判断属性是否属于原型链的属性：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function iterate(obj)&#123;</span><br><span class="line">   var res=[];</span><br><span class="line">   for(var key in obj)&#123;</span><br><span class="line">        if(obj.hasOwnProperty(key))</span><br><span class="line">           res.push(key+&#x27;: &#x27;+obj[key]);</span><br><span class="line">   &#125;</span><br><span class="line">   return res;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>面试</category>
        <category>js</category>
      </categories>
  </entry>
  <entry>
    <title>javascript面试-垃圾回收和内存泄漏</title>
    <url>/2021/08/19/js%E9%9D%A2%E8%AF%95-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%92%8C%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/</url>
    <content><![CDATA[<h1 id="浏览器的垃圾回收机制"><a href="#浏览器的垃圾回收机制" class="headerlink" title="浏览器的垃圾回收机制"></a>浏览器的垃圾回收机制</h1><h2 id="垃圾回收的概念"><a href="#垃圾回收的概念" class="headerlink" title="垃圾回收的概念"></a>垃圾回收的概念</h2><p>垃圾回收：JavaScript代码运行时，需要分配内存空间来储存变量和值。当变量不在参与运行时，就需要系统收回被占用的内存空间，这就是垃圾回收。<br>回收机制：</p>
<ul>
<li>Javascript 具有自动垃圾回收机制，会定期对那些不再使用的变量、对象所占用的内存进行释放，原理就是找到不再使用的变量，然后释放掉其占用的内存。</li>
<li>JavaScript中存在两种变量：局部变量和全局变量。全局变量的生命周期会持续要页面卸载；而局部变量声明在函数中，它的生命周期从函数执行开始，直到函数执行结束，在这个过程中，局部变量会在堆或栈中存储它们的值，当函数执行结束后，这些局部变量不再被使用，它们所占有的空间就会被释放。</li>
<li>不过，当局部变量被外部函数使用时，其中一种情况就是闭包，在函数执行结束后，函数外部的变量依然指向函数内部的局部变量，此时局部变量依然在被使用，所以不会回收。</li>
</ul>
<h2 id="垃圾回收的方式"><a href="#垃圾回收的方式" class="headerlink" title="垃圾回收的方式"></a>垃圾回收的方式</h2><p>浏览器通常使用的垃圾回收方法有两种：标记清除，引用计数。</p>
<ol>
<li><p>标记清除</p>
<ul>
<li>标记清除是浏览器常见的垃圾回收方式，当变量进入执行环境时，就标记这个变量“进入环境”，被标记为“进入环境”的变量是不能被回收的，因为他们正在被使用。当变量离开环境时，就会被标记为“离开环境”，被标记为“离开环境”的变量会被内存释放。</li>
<li>垃圾收集器在运行的时候会给存储在内存中的所有变量都加上标记。然后，它会去掉环境中的变量以及被环境中的变量引用的标记。而在此之后再被加上标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。最后。垃圾收集器完成内存清除工作，销毁那些带标记的值，并回收他们所占用的内存空间。</li>
</ul>
</li>
<li><p>引用计数</p>
<ul>
<li>另外一种垃圾回收机制就是引用计数，这个用的相对较少。引用计数就是跟踪记录每个值被引用的次数。当声明了一个变量并将一个引用类型赋值给该变量时，则这个值的引用次数就是1。相反，如果包含对这个值引用的变量又取得了另外一个值，则这个值的引用次数就减1。当这个引用次数变为0时，说明这个变量已经没有价值，因此，在在机回收期下次再运行时，这个变量所占有的内存空间就会被释放出来。</li>
<li>这种方法会引起循环引用的问题：例如： obj1和obj2通过属性进行相互引用，两个对象的引用次数都是2。当使用循环计数时，由于函数执行完后，两个对象都离开作用域，函数执行结束，obj1和obj2还将会继续存在，因此它们的引用次数永远不会是0，就会引起循环引用。</li>
</ul>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function fun() &#123;</span><br><span class="line">    let obj1 = &#123;&#125;;</span><br><span class="line">    let obj2 = &#123;&#125;;</span><br><span class="line">    obj1.a = obj2; // obj1 引用 obj2</span><br><span class="line">    obj2.a = obj1; // obj2 引用 obj1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种情况下，就要手动释放变量占用的内存：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">obj1.a =  null</span><br><span class="line"> obj2.a =  null</span><br></pre></td></tr></table></figure>
<h2 id="减少垃圾回收"><a href="#减少垃圾回收" class="headerlink" title="减少垃圾回收"></a>减少垃圾回收</h2><p>虽然浏览器可以进行垃圾自动回收，但是当代码比较复杂时，垃圾回收所带来的代价比较大，所以应该尽量减少垃圾回收。</p>
<ul>
<li>对数组进行优化： 在清空一个数组时，最简单的方法就是给其赋值为[ ]，但是与此同时会创建一个新的空对象，可以将数组的长度设置为0，以此来达到清空数组的目的。</li>
<li>对object进行优化： 对象尽量复用，对于不再使用的对象，就将其设置为null，尽快被回收。</li>
<li>对函数进行优化： 在循环中的函数表达式，如果可以复用，尽量放在函数的外面。</li>
</ul>
<h1 id="哪些情况会导致内存泄漏"><a href="#哪些情况会导致内存泄漏" class="headerlink" title="哪些情况会导致内存泄漏"></a>哪些情况会导致内存泄漏</h1><p>以下四种情况会造成内存的泄漏：</p>
<ul>
<li>意外的全局变量： 由于使用未声明的变量，而意外的创建了一个全局变量，而使这个变量一直留在内存中无法被回收。</li>
<li>被遗忘的计时器或回调函数： 设置了 setInterval 定时器，而忘记取消它，如果循环函数有对外部变量的引用的话，那么这个变量会被一直留在内存中，而无法被回收。</li>
<li>脱离 DOM 的引用： 获取一个 DOM 元素的引用，而后面这个元素被删除，由于一直保留了对这个元素的引用，所以它也无法被回收。</li>
<li>闭包： 不合理的使用闭包，从而导致某些变量一直被留在内存当中。</li>
</ul>
]]></content>
      <categories>
        <category>面试</category>
        <category>js</category>
      </categories>
  </entry>
  <entry>
    <title>javascript面试-常用算法</title>
    <url>/2021/08/19/js%E9%9D%A2%E8%AF%95-%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="前序遍历判断回文链表"><a href="#前序遍历判断回文链表" class="headerlink" title="前序遍历判断回文链表"></a>前序遍历判断回文链表</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * function ListNode(val, next) &#123;</span><br><span class="line"> *     this.val = (val===undefined ? 0 : val)</span><br><span class="line"> *     this.next = (next===undefined ? null : next)</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">/**</span><br><span class="line"> * @param &#123;ListNode&#125; head</span><br><span class="line"> * @return &#123;boolean&#125;</span><br><span class="line"> */</span><br><span class="line">var isPalindrome = function(head) &#123;</span><br><span class="line">   let left = head</span><br><span class="line">   function f(right) &#123;</span><br><span class="line">       if (right === null) return true</span><br><span class="line">        let res = f(right.next)</span><br><span class="line">        res = res &amp;&amp; left.val === right.val</span><br><span class="line">        left = left.next</span><br><span class="line">        return res</span><br><span class="line">   &#125;</span><br><span class="line">   return f(head)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * function ListNode(val, next) &#123;</span><br><span class="line"> *     this.val = (val===undefined ? 0 : val)</span><br><span class="line"> *     this.next = (next===undefined ? null : next)</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">/**</span><br><span class="line"> * @param &#123;ListNode&#125; head</span><br><span class="line"> * @return &#123;ListNode&#125;</span><br><span class="line"> */</span><br><span class="line">var reverseList = function(head) &#123;</span><br><span class="line">    // [4, 5]</span><br><span class="line">    if (head === null || head.next === null) return head</span><br><span class="line">    const last = reverseList(head.next)</span><br><span class="line">    // head.next为5，5的next为4</span><br><span class="line">    head.next.next = head</span><br><span class="line">    head.next = null</span><br><span class="line">    return last</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="合并K个升序链表"><a href="#合并K个升序链表" class="headerlink" title="合并K个升序链表"></a>合并K个升序链表</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * function ListNode(val, next) &#123;</span><br><span class="line"> *     this.val = (val===undefined ? 0 : val)</span><br><span class="line"> *     this.next = (next===undefined ? null : next)</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">/**</span><br><span class="line"> * @param &#123;ListNode[]&#125; lists</span><br><span class="line"> * @return &#123;ListNode&#125;</span><br><span class="line"> */</span><br><span class="line">var mergeKLists = function(lists) &#123;</span><br><span class="line">    function mergeList (l1, l2) &#123;</span><br><span class="line">        if (l1 === null) return l2</span><br><span class="line">        if (l2 === null) return l1</span><br><span class="line">        if (l1.val &lt; l2.val) &#123;</span><br><span class="line">            l1.next = mergeList(l1.next, l2)</span><br><span class="line">            return l1</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            l2.next =  mergeList(l1, l2.next)</span><br><span class="line">            return l2</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 两两循环数组</span><br><span class="line">    function loop (list) &#123;</span><br><span class="line">        if (list.length === 0) return null</span><br><span class="line">        if (list.length === 1) return list[0]</span><br><span class="line">        const len = list.length;</span><br><span class="line">        const temp = []</span><br><span class="line">        const loopTeamp = len &gt;&gt; 1; // 位移</span><br><span class="line">        for (let i = 0; i &lt; loopTeamp; i ++) &#123;</span><br><span class="line">            temp.push(mergeList(list[2 * i], list[2* i + 1]))</span><br><span class="line">        &#125;</span><br><span class="line">        if (len % 2 === 1) &#123;</span><br><span class="line">            temp.push(list[len - 1])</span><br><span class="line">        &#125;</span><br><span class="line">        return loop(temp)</span><br><span class="line">    &#125;</span><br><span class="line">    return loop(lists)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="环形链表"><a href="#环形链表" class="headerlink" title="环形链表"></a>环形链表</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * function ListNode(val) &#123;</span><br><span class="line"> *     this.val = val;</span><br><span class="line"> *     this.next = null;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @param &#123;ListNode&#125; head</span><br><span class="line"> * @return &#123;ListNode&#125;</span><br><span class="line"> */</span><br><span class="line">var detectCycle = function(head) &#123;</span><br><span class="line">    let s = new Set()</span><br><span class="line">    while(head) &#123;</span><br><span class="line">        if (s.has(head)) return head</span><br><span class="line">        s.add(head)</span><br><span class="line">        head = head.next</span><br><span class="line">    &#125;</span><br><span class="line">    return null</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>快慢指针</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * function ListNode(val) &#123;</span><br><span class="line"> *     this.val = val;</span><br><span class="line"> *     this.next = null;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @param &#123;ListNode&#125; head</span><br><span class="line"> * @return &#123;ListNode&#125;</span><br><span class="line"> */</span><br><span class="line">var detectCycle = function(head) &#123;</span><br><span class="line">    if (head == null) return head</span><br><span class="line">    let fast = head, slow = head</span><br><span class="line">    while(fast &amp;&amp; fast.next) &#123;</span><br><span class="line">        slow = slow.next</span><br><span class="line">        fast = fast.next.next</span><br><span class="line">        if (fast == slow) &#123;</span><br><span class="line">            let cur = head</span><br><span class="line">            while (cur != fast) &#123;</span><br><span class="line">                cur = cur.next</span><br><span class="line">                fast = fast.next</span><br><span class="line">            &#125;</span><br><span class="line">            return fast</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return null</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="排序链表"><a href="#排序链表" class="headerlink" title="排序链表"></a>排序链表</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * function ListNode(val, next) &#123;</span><br><span class="line"> *     this.val = (val===undefined ? 0 : val)</span><br><span class="line"> *     this.next = (next===undefined ? null : next)</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line"> const merge = (head1, head2) =&gt; &#123;</span><br><span class="line">     const node = new ListNode(0)</span><br><span class="line">     let temp = node, temp1 = head1, temp2 = head2</span><br><span class="line">     while(temp1 !== null &amp;&amp; temp2 !== null) &#123;</span><br><span class="line">         if (temp1.val &lt;= temp2.val) &#123;</span><br><span class="line">             temp.next = temp1</span><br><span class="line">             temp1 = temp1.next</span><br><span class="line">         &#125; else &#123;</span><br><span class="line">             temp.next = temp2</span><br><span class="line">             temp2 = temp2.next</span><br><span class="line">         &#125;</span><br><span class="line">         temp = temp.next</span><br><span class="line">     &#125;</span><br><span class="line">     if (temp1 !== null) &#123;</span><br><span class="line">         temp.next = temp1</span><br><span class="line">     &#125; else if (temp2!== null) &#123;</span><br><span class="line">         temp.next = temp2</span><br><span class="line">     &#125;</span><br><span class="line">     return node.next</span><br><span class="line"> &#125;</span><br><span class="line">const toSortList = (head, tail) =&gt; &#123;</span><br><span class="line">     if (head === null) &#123;</span><br><span class="line">         return head // 为空判断</span><br><span class="line">     &#125;</span><br><span class="line">     if (head.next === tail) &#123; // 临界值</span><br><span class="line">        head.next = null</span><br><span class="line">        return head</span><br><span class="line">     &#125;</span><br><span class="line">     let slow = head, fast = head</span><br><span class="line">     while(fast !== tail) &#123;</span><br><span class="line">         slow = slow.next</span><br><span class="line">         fast = fast.next</span><br><span class="line">         if (fast!== tail) &#123;</span><br><span class="line">             fast = fast.next</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     let mid = slow</span><br><span class="line">     return merge(toSortList(head, mid), toSortList(mid, tail))</span><br><span class="line"> &#125;</span><br><span class="line">var sortList = function(head) &#123;</span><br><span class="line">    return toSortList(head, null)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="相交链表"><a href="#相交链表" class="headerlink" title="相交链表"></a>相交链表</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * function ListNode(val) &#123;</span><br><span class="line"> *     this.val = val;</span><br><span class="line"> *     this.next = null;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @param &#123;ListNode&#125; headA</span><br><span class="line"> * @param &#123;ListNode&#125; headB</span><br><span class="line"> * @return &#123;ListNode&#125;</span><br><span class="line"> */</span><br><span class="line">var getIntersectionNode = function(headA, headB) &#123;</span><br><span class="line">    if (headA === null || headB === null) return null</span><br><span class="line">    let nodeA = headA</span><br><span class="line">    let nodeB = headB</span><br><span class="line">    while(nodeA !== nodeB) &#123;</span><br><span class="line">        if (nodeA === null) &#123;</span><br><span class="line">            nodeA = headB</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            nodeA = nodeA.next</span><br><span class="line">        &#125;</span><br><span class="line">        if (nodeB === null) &#123;</span><br><span class="line">            nodeB = headA</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            nodeB = nodeB.next</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return nodeA</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="最长回文子串"><a href="#最长回文子串" class="headerlink" title="最长回文子串"></a>最长回文子串</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @param &#123;string&#125; s</span><br><span class="line"> * @return &#123;string&#125;</span><br><span class="line"> */</span><br><span class="line">var longestPalindrome = function(s) &#123;</span><br><span class="line">    let res = &#x27;&#x27;;</span><br><span class="line">    for (let i = 0; i &lt; s.length; i++) &#123;</span><br><span class="line">        // 寻找长度为奇数的回文子串(以当前元素向两边扩散)</span><br><span class="line">        const s1 = palindrome(s, i, i);</span><br><span class="line">        // 寻找长度为偶数的回文子串(以s[i],s[i + 1])向两边扩散</span><br><span class="line">        const s2 = palindrome(s, i, i + 1);</span><br><span class="line">        res = res.length &gt; s1.length ? res : s1;</span><br><span class="line">        res = res.length &gt; s2.length ? res : s2;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;;</span><br><span class="line">function palindrome(s, l, r) &#123;</span><br><span class="line">    // 左右指针，从s[l]和s[r]向两边扩散，找到最长回文串</span><br><span class="line">    while (l &gt;= 0 &amp;&amp; r &lt; s.length &amp;&amp; s[l] == s[r]) &#123;</span><br><span class="line">        l--; r++;</span><br><span class="line">    &#125;</span><br><span class="line">    return s.substr(l + 1, r - l - 1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="最长公共前缀"><a href="#最长公共前缀" class="headerlink" title="最长公共前缀"></a>最长公共前缀</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @param &#123;string[]&#125; strs</span><br><span class="line"> * @return &#123;string&#125;</span><br><span class="line"> */</span><br><span class="line">var longestCommonPrefix = function(strs) &#123;</span><br><span class="line">    if (strs.length === 0 || strs === null) return &#x27;&#x27;</span><br><span class="line">    return lcpCommonPrefix(strs)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function lcpCommonPrefix(arr) &#123;</span><br><span class="line">    let len = arr.length</span><br><span class="line">    if (len === 1) &#123;</span><br><span class="line">        return arr[0]</span><br><span class="line">    &#125;</span><br><span class="line">    let mid = Math.floor(len / 2)</span><br><span class="line">    let left = arr.slice(0, mid)</span><br><span class="line">    let right = arr.slice(mid, len)</span><br><span class="line">    return check(lcpCommonPrefix(left), lcpCommonPrefix(right))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function check(str1, str2)&#123;</span><br><span class="line">    let j = 0;</span><br><span class="line">    for (; j &lt; str1.length, j &lt; str2.length; j ++) &#123;</span><br><span class="line">        if (str1.charAt(j) !== str2.charAt(j)) &#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return str1.substr(0, j)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="无重复字符的最长子串"><a href="#无重复字符的最长子串" class="headerlink" title="无重复字符的最长子串"></a>无重复字符的最长子串</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @param &#123;string&#125; s</span><br><span class="line"> * @return &#123;number&#125;</span><br><span class="line"> */</span><br><span class="line">var lengthOfLongestSubstring = function(s) &#123;</span><br><span class="line">    let str = new Set();</span><br><span class="line">    let len = s.length;</span><br><span class="line">    let ans = 0;</span><br><span class="line">    let rk = -1;</span><br><span class="line">    for (let i = 0; i &lt; len; i ++) &#123;</span><br><span class="line">        if (i !==0 ) &#123;</span><br><span class="line">            str.delete(s.charAt(i - 1))</span><br><span class="line">        &#125;</span><br><span class="line">        while(rk + 1 &lt; len &amp;&amp; !str.has(s.charAt(rk + 1))) &#123;</span><br><span class="line">            str.add(s.charAt(rk + 1))</span><br><span class="line">            ++rk</span><br><span class="line">        &#125;</span><br><span class="line">        ans = Math.max(ans, rk + 1 - i)</span><br><span class="line">    &#125;</span><br><span class="line">    return ans</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="最小覆盖子串"><a href="#最小覆盖子串" class="headerlink" title="最小覆盖子串"></a>最小覆盖子串</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @param &#123;string&#125; s</span><br><span class="line"> * @param &#123;string&#125; t</span><br><span class="line"> * @return &#123;string&#125;</span><br><span class="line"> */</span><br><span class="line">var minWindow = function(s, t) &#123;</span><br><span class="line">  // 需要的</span><br><span class="line">  let need = &#123;&#125;;</span><br><span class="line">  // 窗口中的字符</span><br><span class="line">  let window = &#123;&#125;;</span><br><span class="line">  for (let a of t) &#123;</span><br><span class="line">    // 统计需要的字符</span><br><span class="line">    need[a] = (need[a] || 0) + 1;</span><br><span class="line">  &#125;</span><br><span class="line">  // 左右指针</span><br><span class="line">  let left = 0,</span><br><span class="line">    right = 0;</span><br><span class="line">  let valid = 0;</span><br><span class="line">  // 最小覆盖子串的起始索引及长度</span><br><span class="line">  let start = 0,</span><br><span class="line">    len = Number.MAX_VALUE;</span><br><span class="line">  while (right &lt; s.length) &#123;</span><br><span class="line">    // 即将移入窗口的字符</span><br><span class="line">    let c = s[right];</span><br><span class="line">    // 右移窗口</span><br><span class="line">    right++;</span><br><span class="line">    if (need[c]) &#123;</span><br><span class="line">      // 当前字符在需要的字符中，则更新当前窗口统计</span><br><span class="line">      window[c] = (window[c] || 0) + 1;</span><br><span class="line">      if (window[c] == need[c]) &#123;</span><br><span class="line">        // 当前窗口和需要的字符匹配时，验证数量增加1</span><br><span class="line">        valid++;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 当验证数量与需要的字符个数一致时，就应该收缩窗口了</span><br><span class="line">    while (valid == Object.keys(need).length) &#123;</span><br><span class="line">      // 更新最小覆盖子串</span><br><span class="line">      if (right - left &lt; len) &#123;</span><br><span class="line">        start = left;</span><br><span class="line">        len = right - left;</span><br><span class="line">      &#125;</span><br><span class="line">      //即将移出窗口的字符</span><br><span class="line">      let d = s[left];</span><br><span class="line">      // 左移窗口</span><br><span class="line">      left++;</span><br><span class="line">      if (need[d]) &#123;</span><br><span class="line">        if (window[d] == need[d]) &#123;</span><br><span class="line">          valid--;</span><br><span class="line">        &#125;</span><br><span class="line">        window[d]--;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return len == Number.MAX_VALUE ? &quot;&quot; : s.substr(start, len);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="验证回文串"><a href="#验证回文串" class="headerlink" title="验证回文串"></a>验证回文串</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @param &#123;string&#125; s</span><br><span class="line"> * @return &#123;boolean&#125;</span><br><span class="line"> */</span><br><span class="line">var isPalindrome = function(s) &#123;</span><br><span class="line">    var str = s.toLowerCase()</span><br><span class="line">    let left = 0;</span><br><span class="line">    let right = str.length - 1</span><br><span class="line">    while (left &lt; right) &#123;</span><br><span class="line">        if (!isValid(str[left])) &#123;</span><br><span class="line">            left ++</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        if (!isValid(str[right])) &#123;</span><br><span class="line">            right --</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        if (str[left] !== str[right]) &#123;</span><br><span class="line">            return false</span><br><span class="line">        &#125;</span><br><span class="line">        left ++</span><br><span class="line">        right --</span><br><span class="line">    &#125;</span><br><span class="line">    return true</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function isValid (str) &#123;</span><br><span class="line">    return (str &gt;= &#x27;a&#x27; &amp;&amp; str &lt;= &#x27;z&#x27;) || (str &gt;=&#x27;0&#x27; &amp;&amp; str &lt;= &#x27;9&#x27;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>面试</category>
        <category>js</category>
      </categories>
  </entry>
  <entry>
    <title>javascript面试-微前端</title>
    <url>/2021/08/19/js%E9%9D%A2%E8%AF%95-%E5%BE%AE%E5%89%8D%E7%AB%AF/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>面试</category>
        <category>js</category>
      </categories>
  </entry>
  <entry>
    <title>javascript面试-性能优化</title>
    <url>/2021/08/19/js%E9%9D%A2%E8%AF%95-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>面试</category>
        <category>js</category>
      </categories>
  </entry>
  <entry>
    <title>javascript面试-执行上下文、作用域链和闭包</title>
    <url>/2021/08/19/js%E9%9D%A2%E8%AF%95-%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E5%92%8C%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%E5%92%8C%E9%97%AD%E5%8C%85/</url>
    <content><![CDATA[<h1 id="对闭包的理解"><a href="#对闭包的理解" class="headerlink" title="对闭包的理解"></a>对闭包的理解</h1><p>闭包是指有权访问另一个函数作用域中变量的函数，创建闭包的最常见的方式就是在一个函数内创建另一个函数，创建的函数可以访问到当前函数的局部变量。<br>闭包有两个常用的用途；</p>
<ul>
<li>闭包的第一个用途是使我们在函数外部能够访问到函数内部的变量。通过使用闭包，可以通过在外部调用闭包函数，从而在外部访问到函数内部的变量，可以使用这种方法来创建私有变量。</li>
<li>闭包的另一个用途是使已经运行结束的函数上下文中的变量对象继续留在内存中，因为闭包函数保留了这个变量对象的引用，所以这个变量对象不会被回收。</li>
</ul>
<p>比如，函数 A 内部有一个函数 B，函数 B 可以访问到函数 A 中的变量，那么函数 B 就是闭包。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function A() &#123;</span><br><span class="line">  let a = 1</span><br><span class="line">  window.B = function () &#123;</span><br><span class="line">      console.log(a)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">A()</span><br><span class="line">B() // 1</span><br></pre></td></tr></table></figure>
<p>在 JS 中，闭包存在的意义就是让我们可以间接访问函数内部的变量。经典面试题：循环中使用闭包解决 var 定义函数的问题<br>for (var i = 1; i &lt;= 5; i++) {<br>  setTimeout(function timer() {<br>    console.log(i)<br>  }, i * 1000)<br>}<br>复制代码<br>首先因为 setTimeout 是个异步函数，所以会先把循环全部执行完毕，这时候 i 就是 6 了，所以会输出一堆 6。解决办法有三种：</p>
<p>第一种是使用闭包的方式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for (var i = 1; i &lt;= 5; i++) &#123;  ;(function(j) &#123;    setTimeout(function timer() &#123;      console.log(j)    &#125;, j * 1000)  &#125;)(i)&#125;</span><br></pre></td></tr></table></figure>
<p>在上述代码中，首先使用了立即执行函数将 i 传入函数内部，这个时候值就被固定在了参数 j 上面不会改变，当下次执行 timer 这个闭包的时候，就可以使用外部函数的变量 j，从而达到目的。</p>
<p>第二种就是使用 setTimeout 的第三个参数，这个参数会被当成 timer 函数的参数传入。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for (var i = 1; i &lt;= 5; i++) &#123;</span><br><span class="line">  setTimeout(</span><br><span class="line">    function timer(j) &#123;</span><br><span class="line">      console.log(j)</span><br><span class="line">    &#125;,</span><br><span class="line">    i * 1000,</span><br><span class="line">    i</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第三种就是使用 let 定义 i 了来解决问题了，这个也是最为推荐的方式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for (let i = 1; i &lt;= 5; i++) &#123;</span><br><span class="line">  setTimeout(function timer() &#123;</span><br><span class="line">    console.log(i)</span><br><span class="line">  &#125;, i * 1000)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="对作用域、作用域链的理解"><a href="#对作用域、作用域链的理解" class="headerlink" title="对作用域、作用域链的理解"></a>对作用域、作用域链的理解</h1><h2 id="全局作用域和函数作用域"><a href="#全局作用域和函数作用域" class="headerlink" title="全局作用域和函数作用域"></a>全局作用域和函数作用域</h2><ol>
<li><p>全局作用域</p>
<ul>
<li>最外层函数和最外层函数外面定义的变量拥有全局作用域</li>
<li>所有未定义直接赋值的变量自动声明为全局作用域</li>
<li>所有window对象的属性拥有全局作用域</li>
<li>全局作用域有很大的弊端，过多的全局作用域变量会污染全局命名空间，容易引起命名冲突。</li>
</ul>
</li>
<li><p>函数作用域</p>
<ul>
<li>函数作用域声明在函数内部的变零，一般只有固定的代码片段可以访问到</li>
<li>作用域是分层的，内层作用域可以访问外层作用域，反之不行</li>
</ul>
</li>
</ol>
<h2 id="块级作用域"><a href="#块级作用域" class="headerlink" title="块级作用域"></a>块级作用域</h2><ul>
<li>使用ES6中新增的let和const指令可以声明块级作用域，块级作用域可以在函数中创建也可以在一个代码块中的创建（由{ }包裹的代码片段）<br>let和const声明的变量不会有变量提升，也不可以重复声明</li>
<li>在循环中比较适合绑定块级作用域，这样就可以把声明的计数器变量限制在循环内部。</li>
</ul>
<p>作用域链：<br>在当前作用域中查找所需变量，但是该作用域没有这个变量，那这个变量就是自由变量。如果在自己作用域找不到该变量就去父级作用域查找，依次向上级作用域查找，直到访问到window对象就被终止，这一层层的关系就是作用域链。<br>作用域链的作用是保证对执行环境有权访问的所有变量和函数的有序访问，通过作用域链，可以访问到外层环境的变量和函数。<br>作用域链的本质上是一个指向变量对象的指针列表。变量对象是一个包含了执行环境中所有变量和函数的对象。作用域链的前端始终都是当前执行上下文的变量对象。全局执行上下文的变量对象（也就是全局对象）始终是作用域链的最后一个对象。<br>当查找一个变量时，如果当前执行环境中没有找到，可以沿着作用域链向后查找。</p>
<h1 id="对执行上下文的理解"><a href="#对执行上下文的理解" class="headerlink" title="对执行上下文的理解"></a>对执行上下文的理解</h1><h2 id="执行上下文类型"><a href="#执行上下文类型" class="headerlink" title="执行上下文类型"></a>执行上下文类型</h2><ol>
<li>全局执行上下文<br>任何不在函数内部的都是全局执行上下文，它首先会创建一个全局的window对象，并且设置this的值等于这个全局对象，一个程序中只有一个全局执行上下文。</li>
<li>函数执行上下文<br>当一个函数被调用时，就会为该函数创建一个新的执行上下文，函数的上下文可以有任意多个。</li>
<li>eval函数执行上下文<br>执行在eval函数中的代码会有属于他自己的执行上下文，不过eval函数不常使用，不做介绍。<h2 id="执行上下文栈"><a href="#执行上下文栈" class="headerlink" title="执行上下文栈"></a>执行上下文栈</h2></li>
</ol>
<ul>
<li>JavaScript引擎使用执行上下文栈来管理执行上下文</li>
<li>当JavaScript执行代码时，首先遇到全局代码，会创建一个全局执行上下文并且压入执行栈中，每当遇到一个函数调用，就会为该函数创建一个新的执行上下文并压入栈顶，引擎会执行位于执行上下文栈顶的函数，当函数执行完成之后，执行上下文从栈中弹出，继续执行下一个上下文。当所有的代码都执行完毕之后，从栈中弹出全局执行上下文。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let a = &#x27;Hello World!&#x27;;</span><br><span class="line">function first() &#123;</span><br><span class="line">  console.log(&#x27;Inside first function&#x27;);</span><br><span class="line">  second();</span><br><span class="line">  console.log(&#x27;Again inside first function&#x27;);</span><br><span class="line">&#125;</span><br><span class="line">function second() &#123;</span><br><span class="line">  console.log(&#x27;Inside second function&#x27;);</span><br><span class="line">&#125;</span><br><span class="line">first();</span><br><span class="line">//执行顺序</span><br><span class="line">//先执行second(),在执行first()</span><br></pre></td></tr></table></figure>
<h1 id="创建执行上下文"><a href="#创建执行上下文" class="headerlink" title="创建执行上下文"></a>创建执行上下文</h1><p>创建执行上下文有两个阶段：创建阶段和执行阶段</p>
<h2 id="创建阶段"><a href="#创建阶段" class="headerlink" title="创建阶段"></a>创建阶段</h2><p>（1）this绑定</p>
<ul>
<li>在全局执行上下文中，this指向全局对象（window对象）</li>
<li>在函数执行上下文中，this指向取决于函数如何调用。如果它被一个引用对象调用，那么 this 会被设置成那个对象，否则 this 的值被设置为全局对象或者 undefined</li>
</ul>
<p>（2）创建词法环境组件</p>
<ul>
<li>词法环境是一种有标识符——变量映射的数据结构，标识符是指变量/函数名，变量是对实际对象或原始数据的引用。</li>
<li>词法环境的内部有两个组件：加粗样式：环境记录器:用来储存变量个函数声明的实际位置外部环境的引用：可以访问父级作用域</li>
</ul>
<p>（3）创建变量环境组件</p>
<p>变量环境也是一个词法环境，其环境记录器持有变量声明语句在执行上下文中创建的绑定关系。</p>
<h2 id="执行阶段"><a href="#执行阶段" class="headerlink" title="执行阶段"></a>执行阶段</h2><p>此阶段会完成对变量的分配，最后执行完代码。<br>简单来说执行上下文就是指：<br>在执行一点JS代码之前，需要先解析代码。解析的时候会先创建一个全局执行上下文环境，先把代码中即将执行的变量、函数声明都拿出来，变量先赋值为undefined，函数先声明好可使用。这一步执行完了，才开始正式的执行程序。<br>在一个函数执行之前，也会创建一个函数执行上下文环境，跟全局执行上下文类似，不过函数执行上下文会多出this、arguments和函数的参数。</p>
<ul>
<li>全局上下文：变量定义，函数声明</li>
<li>函数上下文：变量定义，函数声明，this，arguments</li>
</ul>
]]></content>
      <categories>
        <category>面试</category>
        <category>js</category>
      </categories>
  </entry>
  <entry>
    <title>javascript面试-数据结构</title>
    <url>/2021/08/19/js%E9%9D%A2%E8%AF%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>面试</category>
        <category>js</category>
      </categories>
  </entry>
  <entry>
    <title>javascript面试-正则</title>
    <url>/2021/08/19/js%E9%9D%A2%E8%AF%95-%E6%AD%A3%E5%88%99/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>面试</category>
        <category>js</category>
      </categories>
  </entry>
  <entry>
    <title>javascript面试-浏览器DOM操作</title>
    <url>/2021/08/19/js%E9%9D%A2%E8%AF%95-%E6%B5%8F%E8%A7%88%E5%99%A8DOM/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>面试</category>
        <category>js</category>
      </categories>
  </entry>
  <entry>
    <title>javascript面试-计算机网络</title>
    <url>/2021/08/19/js%E9%9D%A2%E8%AF%95-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
    <content><![CDATA[<h1 id="OSI七层理想模型"><a href="#OSI七层理想模型" class="headerlink" title="OSI七层理想模型"></a>OSI七层理想模型</h1><h2 id="网络分层的含义"><a href="#网络分层的含义" class="headerlink" title="网络分层的含义"></a>网络分层的含义</h2><ul>
<li>应用层，用户最终使用的接口，微信、qq</li>
<li>表示层，对数据进行描述，压缩等</li>
<li>会话层，建立会话和管理会话</li>
<li>传输层，把数据传递给对方，怎么传，丢了要不要重新传递</li>
<li>网络层，网络层主要是寻址</li>
<li>数据链路层，只关心是两个设备链接起来，连接数据</li>
<li>物理层，只关心如何传输数据 0&amp;1，传输的是比特流</li>
</ul>
<p>实际模型</p>
<ul>
<li>应用层        应用层数据-&gt;报文<ul>
<li>应用层    </li>
<li>表示层</li>
<li>会话层</li>
</ul>
</li>
<li>传输层        传输层头部| 应用层数据 -&gt;数据段：增加端口</li>
<li>网络层        网络层头部|传输层头部|应用层数据 数据包 增加IP</li>
<li>网络接口层     桢头|网络层头部|传输层头部|应用层数据|桢尾 数据桢：增加mac地址<ul>
<li>数据链路层</li>
<li>物理层</li>
</ul>
</li>
</ul>
<h2 id="七层协议真正做了什么事情"><a href="#七层协议真正做了什么事情" class="headerlink" title="七层协议真正做了什么事情"></a>七层协议真正做了什么事情</h2><ul>
<li>报文（应用层 + 数据）</li>
<li>数据段 （应用层 + 数据+ 端口号）</li>
<li>数据包 （网络层+数据+端口+ IP地址）</li>
<li>数据桢（链路层+ 数据+ 端口+ ip+ mac地址）</li>
</ul>
<h2 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h2><p>通信是通过ip地址查找对应的mac来进行通信的，IP地址是可变的（类似与我们的快递地址是可变的）</p>
<h3 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h3><p>IPV4 ip地址的第四个版本 255.255.255.255 最大地址位<br>IPV6 ip地址的第六个版本 八个16进制 aaaa-aaaa-aaaa-aaaa-aaaa-aaaa-aaaa-aaaa</p>
<h3 id="mac地址"><a href="#mac地址" class="headerlink" title="mac地址"></a>mac地址</h3><p>原则上是唯一的（也是可以变的，不考虑篡改下是不可变的）每个网卡都会有一个mac地址</p>
<h2 id="网络层有哪些设备？"><a href="#网络层有哪些设备？" class="headerlink" title="网络层有哪些设备？"></a>网络层有哪些设备？</h2><p>物理层只关心发数据（局域网通信）</p>
<ul>
<li>光纤 同轴电缆 网线 中继器</li>
</ul>
<h2 id="链路层"><a href="#链路层" class="headerlink" title="链路层"></a>链路层</h2><p>局域网</p>
<ul>
<li>交换机</li>
</ul>
<h2 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h2><ul>
<li>路由器</li>
</ul>
<h2 id="网络中的协议"><a href="#网络中的协议" class="headerlink" title="网络中的协议"></a>网络中的协议</h2><p>协议就是约定和规范 （在7层模型中只有三层以上的才能称之为协议）</p>
<p>应用层（HTTP DNS）DHCP协议<br>传输层协议 TCP UDP<br>网络层 IP协议 ARP协议 下层为上层提供服务</p>
<h3 id="ARP协议（核心价值在于将IP地址转换成mac地址）"><a href="#ARP协议（核心价值在于将IP地址转换成mac地址）" class="headerlink" title="ARP协议（核心价值在于将IP地址转换成mac地址）"></a>ARP协议（核心价值在于将IP地址转换成mac地址）</h3><p>广播 根据ip地址，广播信息，然后应答，应答之后知道mac地址了 </p>
<h3 id="DHCP协议"><a href="#DHCP协议" class="headerlink" title="DHCP协议"></a>DHCP协议</h3><p>通过DHCP自动获取网络配置信息，我们无序自己手动配置IP，基于UDP</p>
<h3 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h3><p>因为ip地址很难记，用域名替代IP，IP替代mac地址<br>DNS服务器进行域名和与之对应的IP地址转换的服务器<br>DNS 如何进行解析的？<br>是基于UDP协议进行解析，没有三次握手</p>
<ol>
<li>如果域名被解析了，根据缓存输出对应ip，缓存地址两种情况，（路由器，本地host文件）</li>
<li>没有缓存，<a href="http://www.baidu.com.cn/">www.baidu.com.cn</a><br>cn :域名服务器 =》 根服务器里面查找。cn 找到之后=》域名服务器<br>com:域名服务器 =》 根服务器里面查找。cn 找到之后=》域名服务器<br>baidu :域名服务器 =》 根服务器里面查找。cn 找到之后=》域名服务器<br>www :域名服务器 =》 根服务器里面查找。cn 找到之后=》域名服务器</li>
</ol>
<p>DNS为什么块？<br>DNS服务器会对IP及域名进行缓存，采用UDP协议</p>
<h2 id="TCP和UDP-（传输层）"><a href="#TCP和UDP-（传输层）" class="headerlink" title="TCP和UDP （传输层）"></a>TCP和UDP （传输层）</h2><p>两个协议都在传输层，我们经常说TCP是面向连接，而UDP是面向无连接的</p>
<ul>
<li>UDP发出请求后，不考虑对方是否能接收到，内容是否完整，顺序是否正确，收到数据后不会进行通知</li>
<li>首部结构简单，在数据传输时能实现最小的开销</li>
</ul>
<h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><p>TCP传输控制协议，可靠，面向连接的协议，传输效率第（在不可靠的IP层上建立可靠的传输层）。TCP提供双工服务，即数据可在同一时间进行双向传播。</p>
<h3 id="TCP数据格式"><a href="#TCP数据格式" class="headerlink" title="TCP数据格式"></a>TCP数据格式</h3><p>0 ———— 15 16———-31<br>—–源端口号— | | 目标端口号—|<br>—————32位序列号——-|<br>—————r-32位确认号—–|<br>4位|保留|U|A|P|R|S|F|———-|<br>首部|6位|R|C|S|S|Y|I|16位窗口大小<br>长度|   |G|K|H|T|N|N|———-|<br>—–16位校验号—-|-16位紧急指针|</p>
<ol>
<li>TCP为什么需要三次握手？<br>因为需要双共通信<ul>
<li>客户端和服务端主动握手 SYN</li>
<li>服务端应答后台客户端 SYN ACK</li>
<li>客户端应答            ACK</li>
</ul>
</li>
<li>TCP四次挥手<ul>
<li>客户端发送断开消息 [FIN, ACK]</li>
<li>服务端应答        [ ACK ]</li>
<li>服务端说完剩下的话  [FIN ACK]</li>
<li>客户端 回应          [ ACK ]</li>
</ul>
</li>
</ol>
<h3 id><a href="#" class="headerlink" title></a></h3><p>a ============= &gt; b<br>seq = 0<br>a&lt;================b<br>seq = 0 ack = 1<br>a=================&gt;b<br>seq = 1 ack = 1</p>
<h3 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h3><ul>
<li>客户端有自己的缓存区，服务端也有自己的缓存区，会根据网络状况调整发送数据的多少</li>
<li>客户端给服务端发送的数据是乱序的，但是当服务端收到某个包后，之前的数据还没有收到，此时我们需要等待前面序号的包到了之后才能继续滑动（队头阻塞）</li>
<li>服务端会和客户端说明发送数据的个数</li>
<li>如果某个数据包丢失，那需要重新发送（超时重传 TRO）</li>
<li>当接收方的缓存区收满了，每隔一定时间，发送方会发送一个探测包，来询问能否调整窗口的大小，上层协议消耗掉接收方的数据，接收方也会主动通知发送方调整窗口，继续发送数据</li>
<li>流量控制，控制发送方发送的数据大小</li>
</ul>
<h3 id="粘包"><a href="#粘包" class="headerlink" title="粘包"></a>粘包</h3><p>nagle算法（node默认算法），同一时间段内只有一个包处于发送状态</p>
<p>cork算法可以合并多个包</p>
<h3 id="tcp问题-队头阻塞，慢开始，端链接，"><a href="#tcp问题-队头阻塞，慢开始，端链接，" class="headerlink" title="tcp问题-队头阻塞，慢开始，端链接，"></a>tcp问题-队头阻塞，慢开始，端链接，</h3><ul>
<li>滑动窗口控制传输速度</li>
<li>粘包 nagle算法，cork算法</li>
<li>拥塞处理，快重传 -快恢复算法</li>
<li>TCP顺序问题，后面的包到达需要等待前面的包返回之后才可以继续传输 （队头阻塞问题）</li>
<li>满启动的过程 非常消耗性能</li>
<li>time-wait 客户端连接服务器最后不会立即断开，在高并发 短连接的情况下，会出现端口全被占用</li>
</ul>
<h1 id="http-1-1（纯文本协议-安全问题-明文-安全）"><a href="#http-1-1（纯文本协议-安全问题-明文-安全）" class="headerlink" title="http 1.1（纯文本协议 安全问题 明文-安全）"></a>http 1.1（纯文本协议 安全问题 明文-安全）</h1><ul>
<li><p>基于TCP传输层，半双工通信，请求应答模式，默认无状态（默认TCP不能在没有应答后复用TCP通道继续发送消息）</p>
</li>
<li><p>tcp的规范，就是固定的组成结构</p>
<ul>
<li>  请求行 响应行 主要目的是描述我要做什么，服务端告诉客户端OK</li>
<li>  请求头 响应头 描述我们传输的数据内容，自定义我们的header</li>
<li>  请求体 响应体 两者的数据</li>
</ul>
</li>
<li><p>请求头</p>
</li>
</ul>
<ul>
<li>  accept                  content-type</li>
<li>  accept-encoding         content-encoding</li>
<li>  accept-language</li>
<li>  range                   content-range</li>
</ul>
<h2 id="请求头和响应头"><a href="#请求头和响应头" class="headerlink" title="请求头和响应头"></a>请求头和响应头</h2><ul>
<li>核心在于内容协商</li>
<li>http实现长连接，会默认在请求的时候，增加connection:keep-alive, connection: close 用于TCP通道传递数据（必须在一次请求应答后才能复用）<ul>
<li>  多个请求怎么办？</li>
</ul>
</li>
</ul>
<h2 id="管线化方式传递数据"><a href="#管线化方式传递数据" class="headerlink" title="管线化方式传递数据"></a>管线化方式传递数据</h2><ul>
<li>我们针对每个域名分配6个TCP通道（域名分片，域名不易过多，过多会导致DNS解析大量域名）问题，在于请求并发的请求，应答依旧是按顺序的（管道的特点就是先发送的先回来）（队头阻塞 http1.1中的队头阻塞）</li>
</ul>
<h2 id="可以使用cookie使用用户身份"><a href="#可以使用cookie使用用户身份" class="headerlink" title="可以使用cookie使用用户身份"></a>可以使用cookie使用用户身份</h2><p>在客户端增加cookie字段，服务端set-cookie每次请求都会自动携带cookie</p>
<h2 id="http缓存"><a href="#http缓存" class="headerlink" title="http缓存"></a>http缓存</h2><ul>
<li>强制缓存 协商缓存</li>
<li>强制缓存，客户端访问之后，接下来重复访问后直接从缓存中读取 cache-control</li>
<li>协商缓存的含义就是，当强制缓存失效后会再次向服务器发起请求，服务器要对比客户端的缓存文件和服务端是否一致，如果一致则返回302, 如果文件更新来，那么就采用返回新文件的方式last-modify /if modify-since 问题在于最后修改时间变化了，但是内容没变，同一时间无法返回多次修改</li>
<li>摘要算法 md4（不同的内容摘要的结果，肯定不同，两个相同的内容摘要肯定相同，无法通过最终的结果反推原内容）etag/if-none-match</li>
<li>no-cache(不缓存，但是缓存中有，每次询问) no-store（真正的不缓存，压根没有缓存），会简单的使用弱指纹，可以用last-modify</li>
</ul>
<h1 id="当-ping-一个-IP-地址时发生了什么"><a href="#当-ping-一个-IP-地址时发生了什么" class="headerlink" title="当 ping 一个 IP 地址时发生了什么"></a>当 ping 一个 IP 地址时发生了什么</h1><p>Step 1: ICMP 创建一个请求数据包(数据域中只包含字母)</p>
<p>Step 2: ICMP将该有效负荷交给IP协议，增加的IP头包含：源IP(Host A的IP)，目标IP(Host C的IP)，协议字段(0x01, ICMP的协议号)，这些信息在接收方主机用来判断将数据交给哪个协议处理</p>
<p>Step 3: IP协议判断目的IP是处于LAN还是某个远程网络，具体的判断方法是将目标IP和子网掩码一起找出目标网络，看是否等于本地网络；</p>
<p>Step 4: 由于IP协议判定这是一个远程的跨网络请求，要将这一分组路由到远程网络，就必须将它发给默认路由</p>
<p>Step 5: 主机 Host A(192.168.1.2)要将分组数据发送到默认网关(192.168.1.1), 就必须要知道Router A接口F0/0的MAC地址</p>
<p>Step 6: 检查主机ARP缓存，查看默认网关IP地址是否已经被解析为一个硬件地址</p>
<p>若已被解析：此分组可被传送到数据链路层以组建帧(可使用arp -a查看)</p>
<p>若未被解析：Host A使用ARP广播(MAC广播地址为：FF-FF-FF-FF-FF-FF), Router A接受到广播后，通过F0/0口返回该口的硬件地址</p>
<p>Step 7: 一旦分组和硬件地址交给链路层，局域网驱动程序负责选择合适的局域网类型(本例为以太网)的介质访问方式，创建数据帧</p>
<p>Step 8: 一旦帧创建完成，该帧被提交到物理层；物理层将 1bit/次的方式将数据发送到物理介质中</p>
<p>Step 10: 将分组数据从帧中取出，并将其他部分丢弃；然后，分组被递交给以太网类型字段中列出的协议（本例为IP协议）</p>
<p>Step 11：IP接受该分组，并检查其目的IP</p>
<p>由于分组的目的IP与本路由(Router A)的配置IP不匹配，此路由将在其路由表中查找目的IP的位置</p>
<p>Step 12: 如果路由表中没有网络 192.168.20.0 的路由表项，则立即丢弃该分组；并向源主机Host A发送目标网络不可达的ICMP报文</p>
<p>Step 13: 如果在路由表中查找到了相关的路由表项，则分组将被交换到指定的输出接口</p>
<p>Step 14: 路由器Router A将此分组交换到F0/1的缓冲区内</p>
<p>Step 15: F0/1需要获得目的方设备的MAC地址(本例为Router B的F0/0 MAC地址)</p>
<p>查看F0/1的ARP缓存，若存在，则分组和MAC地址将被提交到数据链路层，用于数据帧的组建；</p>
<p>若不存在，采用路由选择协议(RIP/EIGRP/OSPF)；</p>
<p>Step 16: 帧创建完成后，将其交给物理层，并由物理层逐比特发送到物理介质中</p>
<p>Step 17: Router B执行与Router A相同的操作 (即step9 - step16)</p>
<p>Step 18: Host C 接收到该帧，并立即运行CRC运算，若与FCS匹配，则检测帧中的目标MAC，如果同样相同，检查以太网类型值，判断网络层协议 – 本例为IP</p>
<p>Step 19: 在网络层，IP接受到该分组，并对其头部进行CRC；若相同，则检查目标IP是否与本机相同；若相同，检查分组的协议字段，了解上层的交付对象 – 本例为ICMP</p>
<p>Step 20: 负荷提交给ICMP；ICMP知道此为回应请求信号，ICMP将应答此请求</p>
<p>应答方式：首先丢弃接受到的字段，产生一个新的有效负荷作为回应字段</p>
<p>Step 21: 此时一个新的有效负荷产生，目标为Host A</p>
<p>Step 22: 将其提交给IP层，IP判断目的地址为本地LAN还是远程主机(本例为远程主机)，此分组首先发到默认网关</p>
<p>Step 23: 重复请求包所经历的步骤，直到将应答包发送到Host A的ICMP协议为止</p>
]]></content>
      <categories>
        <category>面试</category>
        <category>js</category>
      </categories>
  </entry>
  <entry>
    <title>this指向</title>
    <url>/2021/07/06/this%E6%8C%87%E5%90%91/</url>
    <content><![CDATA[<p>面向对象语言中 this 表示当前对象的一个引用。</p>
<p>但在 JavaScript 中 this 不是固定不变的，它会随着执行环境的改变而改变。</p>
<ul>
<li>在方法中，this 表示该方法所属的对象。</li>
</ul>
<ul>
<li>如果单独使用，this 表示全局对象。</li>
</ul>
<ul>
<li>在函数中，this 表示全局对象。</li>
</ul>
<ul>
<li>在函数中，在严格模式下，this 是未定义的(undefined)。</li>
</ul>
<ul>
<li>在事件中，this 表示接收事件的元素。</li>
</ul>
<ul>
<li>类似 call() 和 apply() 方法可以将 this 引用到任何对象。</li>
</ul>
<h2 id="方法中的this"><a href="#方法中的this" class="headerlink" title="方法中的this"></a>方法中的this</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  <span class="attr">firstName</span>: <span class="string">&quot;John&quot;</span>,</span><br><span class="line">  <span class="attr">lastName</span> : <span class="string">&quot;Doe&quot;</span>,</span><br><span class="line">  <span class="attr">fullName</span> : <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.firstName + <span class="string">&quot; &quot;</span> + <span class="built_in">this</span>.lastName;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">person.fullName() <span class="comment">// John Doe</span></span><br></pre></td></tr></table></figure>
<p>在对象方法中， this 指向调用它所在方法的对象。</p>
<p>在上面一个实例中，this 表示 person 对象。</p>
<p>fullName 方法所属的对象就是 person。</p>
<h2 id="单独使用-this"><a href="#单独使用-this" class="headerlink" title="单独使用 this"></a>单独使用 this</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person = <span class="built_in">this</span> <span class="comment">// [object Window]</span></span><br></pre></td></tr></table></figure>
<p>单独使用 this，则它指向全局(Global)对象。</p>
<p>在浏览器中，window 就是该全局对象为 [object Window]:</p>
<p>ps: 严格模式下，如果单独使用，this 也是指向全局(Global)对象。</p>
<h2 id="函数中使用-this（默认）"><a href="#函数中使用-this（默认）" class="headerlink" title="函数中使用 this（默认）"></a>函数中使用 this（默认）</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myFunction</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>; <span class="comment">// [object Window]</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在函数中，函数的所属者默认绑定到 this 上。</p>
<p>在浏览器中，window 就是该全局对象为 [object Window]:</p>
<p>ps: 严格模式下，函数是没有绑定到this下，this是undefined</p>
<h2 id="事件中的-this"><a href="#事件中的-this" class="headerlink" title="事件中的 this"></a>事件中的 this</h2><p>在 HTML 事件句柄中，this 指向了接收事件的 HTML 元素：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;button onclick=<span class="string">&quot;this =&gt; buttonHtml对象&quot;</span>&gt;</span><br><span class="line">点我</span><br><span class="line">&lt;/button&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="对象方法中绑定"><a href="#对象方法中绑定" class="headerlink" title="对象方法中绑定"></a>对象方法中绑定</h2><p>下面实例中，this 是 person 对象，person 对象是函数的所有者：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  <span class="attr">firstName</span>  : <span class="string">&quot;John&quot;</span>,</span><br><span class="line">  <span class="attr">lastName</span>   : <span class="string">&quot;Doe&quot;</span>,</span><br><span class="line">  <span class="attr">id</span>         : <span class="number">5566</span>,</span><br><span class="line">  <span class="attr">myFunction</span> : <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">person.myFunction() <span class="comment">// [object Object]</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="显式函数绑定"><a href="#显式函数绑定" class="headerlink" title="显式函数绑定"></a>显式函数绑定</h2><p>在 JavaScript 中函数也是对象，对象则有方法，apply 和 call 就是函数对象的方法。</p>
<p>这两个方法异常强大，他们允许切换函数执行的上下文环境（context），即 this 绑定的对象。<br>在下面实例中，当我们使用 person2 作为参数来调用 person1.fullName 方法时, this 将指向 person2, 即便它是 person1 的方法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person1 = &#123;</span><br><span class="line">  <span class="attr">fullName</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.firstName + <span class="string">&quot; &quot;</span> + <span class="built_in">this</span>.lastName;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person2 = &#123;</span><br><span class="line">  <span class="attr">firstName</span>:<span class="string">&quot;John&quot;</span>,</span><br><span class="line">  <span class="attr">lastName</span>: <span class="string">&quot;Doe&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line">person1.fullName.call(person2);  <span class="comment">// 返回 &quot;John Doe&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="隐式绑定"><a href="#隐式绑定" class="headerlink" title="隐式绑定"></a>隐式绑定</h2><p>什么是隐式绑定呢，如果函数调用时，前面存在调用它的对象，那么this就会隐式绑定到这个对象上。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;听风是风&#x27;</span>,</span><br><span class="line">    <span class="attr">func</span>: fn</span><br><span class="line">&#125;;</span><br><span class="line">obj.func() <span class="comment">//听风是风</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如果函数调用前存在多个对象，this指向距离调用自己最近的对象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;行星飞行&#x27;</span>,</span><br><span class="line">    <span class="attr">func</span>: fn,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> obj1 = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;听风是风&#x27;</span>,</span><br><span class="line">    <span class="attr">o</span>: obj</span><br><span class="line">&#125;;</span><br><span class="line">obj1.o.func() <span class="comment">//行星飞行</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>那如果我们将obj对象的name属性注释掉，现在输出什么呢？</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    <span class="attr">func</span>: fn,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> obj1 = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;听风是风&#x27;</span>,</span><br><span class="line">    <span class="attr">o</span>: obj</span><br><span class="line">&#125;;</span><br><span class="line">obj1.o.func() <span class="comment">// undefined</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>大家千万不要将作用域链和原型链弄混淆了，obj对象虽然obj1的属性，但它两原型链并不相同，并不是父子关系，由于obj未提供name属性，所以是undefined。</p>
<p>既然说到原型链，那我们再来点花哨的，我们再改写例子，看看下面输出多少：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fn</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">Fn.prototype.name = <span class="string">&#x27;时间跳跃&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = <span class="keyword">new</span> Fn();</span><br><span class="line">obj.func = fn;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj1 = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;听风是风&#x27;</span>,</span><br><span class="line">    <span class="attr">o</span>: obj</span><br><span class="line">&#125;;</span><br><span class="line">obj1.o.func() <span class="comment">//时间跳跃</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里输出时间跳跃，虽然obj对象并没有name属性，但顺着原型链，找到了产生自己的构造函数Fn，由于Fn原型链存在name属性，所以输出时间跳跃了。</p>
<h2 id="隐式丢失"><a href="#隐式丢失" class="headerlink" title="隐式丢失"></a>隐式丢失</h2><p>在特定情况下会存在隐式绑定丢失的问题，最常见的就是作为参数传递以及变量赋值，先看参数传递：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;行星飞行&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;听风是风&#x27;</span>,</span><br><span class="line">    <span class="attr">fn</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params">param</span>) </span>&#123;</span><br><span class="line">    param();</span><br><span class="line">&#125;;</span><br><span class="line">fn1(obj.fn);<span class="comment">//行星飞行</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这个例子中我们将 obj.fn 也就是一个函数传递进 fn1 中执行，这里只是单纯传递了一个函数而已，this并没有跟函数绑在一起，所以this丢失这里指向了window。</p>
<p>第二个引起丢失的问题是变量赋值，其实本质上与传参相同，看这个例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;行星飞行&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;听风是风&#x27;</span>,</span><br><span class="line">    <span class="attr">fn</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> fn1 = obj.fn;</span><br><span class="line">fn1(); <span class="comment">//行星飞行</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>注意，隐式绑定丢失并不是都会指向全局对象，比如下面的例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;行星飞行&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;听风是风&#x27;</span>,</span><br><span class="line">    <span class="attr">fn</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> obj1 = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;时间跳跃&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">obj1.fn = obj.fn;</span><br><span class="line">obj1.fn(); <span class="comment">//时间跳跃</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>虽然丢失了 obj 的隐式绑定，但是在赋值的过程中，又建立了新的隐式绑定，这里this就指向了对象 obj1。</p>
<h2 id="new绑定"><a href="#new绑定" class="headerlink" title="new绑定"></a>new绑定</h2><p>准确来说，js中的构造函数只是使用new 调用的普通函数，它并不是一个类，最终返回的对象也不是一个实例，只是为了便于理解习惯这么说罢了。</p>
<p>那么new一个函数究竟发生了什么呢，大致分为三步：</p>
<ul>
<li>以构造器的prototype属性为原型，创建新对象；</li>
<li>将this(可以理解为上句创建的新对象)和调用参数传给构造器，执行；</li>
<li>如果构造器没有手动返回对象，则返回第一步创建的对象</li>
</ul>
<p>这个过程我们称之为构造调用，我们来看个例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = <span class="string">&#x27;听风是风&#x27;</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> echo = <span class="keyword">new</span> Fn();</span><br><span class="line">echo.name<span class="comment">//听风是风</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在上方代码中，构造调用创建了一个新对象echo，而在函数体内，this将指向新对象echo上（可以抽象理解为新对象就是this）。</p>
<h2 id="this绑定优先级"><a href="#this绑定优先级" class="headerlink" title="this绑定优先级"></a>this绑定优先级</h2><p>显式绑定 &gt; 隐式绑定 &gt; 默认绑定</p>
<p>new绑定 &gt; 隐式绑定 &gt; 默认绑定</p>
<p>为什么显式绑定不和new绑定比较呢？因为不存在这种绑定同时生效的情景，如果同时写这两种代码会直接抛错，所以大家只用记住上面的规律即可。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = <span class="string">&#x27;听风是风&#x27;</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    <span class="attr">name</span>:<span class="string">&#x27;行星飞行&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> echo = <span class="keyword">new</span> Fn().call(obj);<span class="comment">//报错 call is not a function</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>那么我们结合几个例子来验证下上面的规律，首先是显式大于隐式：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//显式&gt;隐式</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    <span class="attr">name</span>:<span class="string">&#x27;行星飞行&#x27;</span>,</span><br><span class="line">    <span class="attr">fn</span>:<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">obj1 = &#123;</span><br><span class="line">    <span class="attr">name</span>:<span class="string">&#x27;时间跳跃&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line">obj.fn.call(obj1);<span class="comment">// 时间跳跃</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>其次是new绑定大于隐式：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//new&gt;隐式</span></span><br><span class="line">obj = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;时间跳跃&#x27;</span>,</span><br><span class="line">    <span class="attr">fn</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name = <span class="string">&#x27;听风是风&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> echo = <span class="keyword">new</span> obj.fn();</span><br><span class="line">echo.name;<span class="comment">//听风是风</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="箭头函数的this"><a href="#箭头函数的this" class="headerlink" title="箭头函数的this"></a>箭头函数的this</h2><p>ES6的箭头函数是另类的存在，为什么要单独说呢，这是因为箭头函数中的this不适用上面介绍的四种绑定规则。</p>
<p>准确来说，箭头函数中没有this，箭头函数的this指向取决于外层作用域中的this，外层作用域或函数的this指向谁，箭头函数中的this便指向谁。有点吃软饭的嫌疑，一点都不硬朗，我们来看个例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> obj1 = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;听风是风&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> obj2 = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;时间跳跃&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> bar = fn.call(obj1); <span class="comment">// fn this指向obj1</span></span><br><span class="line">bar.call(obj2); <span class="comment">//听风是风</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>为啥我们第一次绑定this并返回箭头函数后，再次改变this指向没生效呢？</p>
<p>前面说了，箭头函数的this取决于外层作用域的this，fn函数执行时this指向了obj1，所以箭头函数的this也指向obj1。除此之外，箭头函数this还有一个特性，那就是一旦箭头函数的this绑定成功，也无法被再次修改，有点硬绑定的意思。</p>
<p>当然，箭头函数的this也不是真的无法修改，我们知道箭头函数的this就像作用域继承一样从上层作用域找，因此我们可以修改外层函数this指向达到间接修改箭头函数this的目的。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> obj1 = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;听风是风&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> obj2 = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;时间跳跃&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line">fn.call(obj1)(); <span class="comment">// fn this指向obj1,箭头函数this也指向obj1</span></span><br><span class="line">fn.call(obj2)(); <span class="comment">//fn this 指向obj2,箭头函数this也指向obj2</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>js基础</category>
      </categories>
  </entry>
  <entry>
    <title>作用域</title>
    <url>/2018/07/06/%E4%BD%9C%E7%94%A8%E5%9F%9F/</url>
    <content><![CDATA[<h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><h3 id="什么是作用域？"><a href="#什么是作用域？" class="headerlink" title="什么是作用域？"></a>什么是作用域？</h3><p>作用域为可访问变量，对象，函数的集合。</p>
<p>作用域就是变量与函数的可访问范围，即作用域控制着变量与函数的可见性和生命周期。</p>
<p>在js中，变量的作用域分为全局作用域和局部作用域两种。<br>一个变量是全局作用域还是局部作用域，主要看变量声明的位置。</p>
<h4 id="全局作用域："><a href="#全局作用域：" class="headerlink" title="全局作用域："></a>全局作用域：</h4><ol>
<li>最外层函数和在最外层函数外面定义的变量</li>
<li>没有通过关键字”var”声明的变量</li>
<li>浏览器中，window对象的属性</li>
</ol>
<h4 id="局部作用域"><a href="#局部作用域" class="headerlink" title="局部作用域"></a>局部作用域</h4><ol>
<li>在函数内部就是局部作用域，这个代码的名字只在函数的内部起作用</li>
<li>调用函数时创建函数作用域，函数执行完毕之后，函数作用域销毁；</li>
<li>每调用一次函数就会创建一个新的函数作用域，它们之间是相互独立的。</li>
</ol>
<h3 id="块级作用域"><a href="#块级作用域" class="headerlink" title="块级作用域"></a>块级作用域</h3><p>在ES6中新增加了一个作用域就是会计作用域，通过let和const声明。那块级作用域什么情况下被创建内？答案如下</p>
<p>在一个函数内部</p>
<p>在一个代码块内部（{}包裹的代码块）</p>
<p>let声明的愈发与var的语法一致，基本上可以用let代替var,但会讲变量的作用域限制在当前代码块中。</p>
<p>块级作用域的特点：</p>
<p>声明变量不会提升到代码块顶部</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Scope</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(scope) <span class="comment">// Uncaught ReferenceError: value is not defined</span></span><br><span class="line"><span class="keyword">let</span> scope = <span class="string">&quot;块级&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(scope) <span class="comment">// 块级</span></span><br><span class="line">&#125;</span><br><span class="line">Scope()</span><br></pre></td></tr></table></figure>

<p>禁止重复声明</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Scope</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">let</span> scope = <span class="string">&#x27;a&#x27;</span></span><br><span class="line"> <span class="comment">//let scope = &#x27;b&#x27; // Uncaught SyntaxError: Identifier &#x27;scope&#x27; has already been declared</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>小技巧：在循环中可以用let const声明变量</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i&lt; <span class="number">100</span>; i++)&#123;&#125;</span><br><span class="line"><span class="built_in">console</span>.log(i) <span class="comment">// Uncaught ReferenceError: i is not defined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i&lt; <span class="number">100</span>; i++)&#123;&#125;</span><br><span class="line"><span class="built_in">console</span>.log(i) <span class="comment">// 100</span></span><br></pre></td></tr></table></figure>


<h3 id="作用域的目的"><a href="#作用域的目的" class="headerlink" title="作用域的目的"></a>作用域的目的</h3><p>是为了提高程序的可靠性，更重要的是减少命名冲突</p>
<h3 id="变量的作用域"><a href="#变量的作用域" class="headerlink" title="变量的作用域"></a>变量的作用域</h3><p>在js中，根据作用域的不同，变量可以分为两种：<strong>全局变量</strong>和<strong>局部变量</strong></p>
<h4 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h4><ul>
<li>在全局作用域下声明的变量叫做全局变量</li>
<li>全局变量在全局任何位置都可以使用，全局作用域中无法访问到局部作用域中的变量<h4 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h4></li>
<li>在局部作用域下声明的变量叫做局部变量</li>
<li>局部变量只能在函数内部使用，在局部作用域中可以访问到全局变量</li>
</ul>
<h2 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h2><p>在js代码运行中，所有用到的变量都需要去当前上下文环境中查找，当找不到的时候，就会继续查找上层的环境变量。<br>这样一级一级向上查找的过程，就组合成了一个作用域链。</p>
<p>所以说，<strong>作用域链</strong>与一个<strong>执行上下文</strong>相关，是内部上下文所有变量对象（包含父变量对象）的列表，用于变量查询。</p>
]]></content>
      <categories>
        <category>js基础</category>
      </categories>
  </entry>
  <entry>
    <title>冒泡排序</title>
    <url>/2021/08/25/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h2 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h2><ol>
<li><p>比较相邻的元素。如果第一个比第二个大，就交换他们两个。</p>
</li>
<li><p>对每一对相邻元素做同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。</p>
</li>
<li><p>针对所有的元素重复以上的步骤，除了最后一个。</p>
</li>
<li><p>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比比较</p>
</li>
</ol>
<h2 id="动图演示"><a href="#动图演示" class="headerlink" title="动图演示"></a>动图演示</h2><p><img src="/.io//1.jpeg" alt="原理图"></p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">40</span>, <span class="number">60</span>, <span class="number">60</span>, <span class="number">0</span>, <span class="number">30</span>]</span><br><span class="line"><span class="comment">// 编写方法，实现冒泡</span></span><br><span class="line"><span class="comment">//外层循环，控制趟数，每一次找到一个最大值</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">    <span class="comment">// 内层循环,控制比较的次数，并且判断两个数的大小</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; arr.length - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">        <span class="comment">// 白话解释：如果前面的数大，放到后面(当然是从小到大的冒泡排序)</span></span><br><span class="line">        <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">var</span> temp = arr[j];</span><br><span class="line">            arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">            arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(arr);</span><br></pre></td></tr></table></figure>

<h2 id="性能分析："><a href="#性能分析：" class="headerlink" title="性能分析："></a>性能分析：</h2><p>时间复杂度: O(N^2)<br>空间复杂度: O(1)<br>稳定性：稳定</p>
]]></content>
      <categories>
        <category>js基础</category>
      </categories>
  </entry>
  <entry>
    <title>创建对象方式</title>
    <url>/2018/07/06/%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<p>在 JavaScript 中创建对象的可行方法有哪些？</p>
<h2 id="1、对象的构造函数"><a href="#1、对象的构造函数" class="headerlink" title="1、对象的构造函数"></a>1、对象的构造函数</h2><p>创建空对象的最简单方法是使用object构造函数，目前不推荐这种方法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = <span class="keyword">new</span> object() <span class="comment">// 对象构造函数</span></span><br></pre></td></tr></table></figure>
<h2 id="2、对象的创建方法："><a href="#2、对象的创建方法：" class="headerlink" title="2、对象的创建方法："></a>2、对象的创建方法：</h2><p>Object的create方法通过将原型对象作为参数传递来创建一个新对象</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = <span class="built_in">Object</span>.create(<span class="literal">null</span>)</span><br></pre></td></tr></table></figure>
<h2 id="3、对象字面量语法"><a href="#3、对象字面量语法" class="headerlink" title="3、对象字面量语法"></a>3、对象字面量语法</h2><p>当传递null作为参数时，对象字面量语法等效于create方法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4、函数构造器"><a href="#4、函数构造器" class="headerlink" title="4、函数构造器"></a>4、函数构造器</h2><p>创建任何函数并应用new运算符来创建对象实例</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> obj = &#123;&#125;</span><br><span class="line">    obj.name = name</span><br><span class="line">    <span class="keyword">return</span> obj</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> obj1 = <span class="keyword">new</span> Person(<span class="string">&quot;哈哈&quot;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="5、带有原型的函数构造函数"><a href="#5、带有原型的函数构造函数" class="headerlink" title="5、带有原型的函数构造函数"></a>5、带有原型的函数构造函数</h2><p>这类似于函数构造函数，但它使用原型作为其属性和方法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">Person.prototype.name = <span class="string">&quot;哈哈&quot;</span></span><br><span class="line"><span class="keyword">var</span> obj = New Person()</span><br></pre></td></tr></table></figure>

<h2 id="6、es6类语法"><a href="#6、es6类语法" class="headerlink" title="6、es6类语法"></a>6、es6类语法</h2><p>es6引入类特性来创建对象</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="title">construtor</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> object = <span class="keyword">new</span> Person(<span class="string">&quot;哈哈&quot;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="7、单例模式"><a href="#7、单例模式" class="headerlink" title="7、单例模式"></a>7、单例模式</h2><p>Singleton是一个只能实例化一次的对象。对其构造函数的重复调用返回相同的实例，这样可以确保它们不会意外创建多个实例</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = <span class="keyword">new</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = <span class="string">&quot;哈哈&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>js基础</category>
      </categories>
  </entry>
  <entry>
    <title>原型及原型链</title>
    <url>/2018/07/06/%E5%8E%9F%E5%9E%8B%E5%8F%8A%E5%8E%9F%E5%9E%8B%E9%93%BE/</url>
    <content><![CDATA[<h2 id="prototype"><a href="#prototype" class="headerlink" title="prototype"></a>prototype</h2><p>每一个js对象(null除外)在创建的时候就会与之关联另一个对象【Prototype】，这个对象就是我们所说的原型。每个对象都会从原型“继承”属性。</p>
<p>举个例子</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line"><span class="attr">name</span>: <span class="string">&quot;zhangsan&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> newObj = <span class="built_in">Object</span>.create(obj)</span><br><span class="line"></span><br><span class="line">newObj.name <span class="comment">// zhangsan</span></span><br></pre></td></tr></table></figure>


<p>上述例子中，newObj对象的【Prototype】属性引用了obj对象，也就是说newObj对象的【Prototype】指向了obj对象，并继承了obj的属性。</p>
<p>几乎所有的对象在创建时【Prototype】属性都会被赋予非空的值，由【Prototype】串联起来的对象的关系链条我们就称为【Prototype】链也就是原型链，一般情况下【Prototype】链的最顶层是Object.prototype</p>
<p>每个函数都有一个 prototype 属性。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.name = <span class="string">&quot;zhangsan&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person()</span><br><span class="line"></span><br><span class="line">person.name <span class="comment">// zhangsan</span></span><br></pre></td></tr></table></figure>

<p><img src="/.io//1.png"></p>
<h2 id="proto"><a href="#proto" class="headerlink" title="proto"></a>proto</h2><p>每一个js对象（除null）都具有一个属性叫proto，这个属性会指向改对象的原型。</p>
<p>对象可以通过__proto__访问内部的【Prototype】属性，即我们可以通过__proto__访问对象的原型。</p>
<p>ps: __proto__是一种非标准的方法，实际开发中我们应该使用Object.getPrototypeOf()来获取对象的原型</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person();</span><br><span class="line"></span><br><span class="line">person.__proto__ === Person.prototype <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p><img src="/.io//2.png"></p>
<h2 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a>constructor</h2><p>每个原型都有一个constructor属性指向关联的构造函数，实例原型指向构造函数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">person.__proto__ == Person.prototype <span class="comment">// true</span></span><br><span class="line">Person === Person.prototype.constructor <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.getPrototypeOf(person) === Person.prototype <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>补充说明：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person();</span><br><span class="line">person.constructor === Person<span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>当获取 person.constructor 时，其实 person 中并没有 constructor 属性,当不能读取到constructor 属性时，会从 person 的原型也就是 Person.prototype 中读取，正好原型中有该属性，所以：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">person.constructor === Person.prototype.constructor</span><br></pre></td></tr></table></figure>
<p><img src="/.io//3.png"></p>
<h2 id="实例与原型"><a href="#实例与原型" class="headerlink" title="实例与原型"></a>实例与原型</h2><p>当读取实例的属性时，如果找不到，就会查找与对象关联的原型中的属性，如果还查不到，就去找原型的原型，一直找到最顶层为止。<br><img src="/.io//4.png"></p>
<h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h2><p>简单的回顾一下构造函数、原型和实例的关系：每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，而实例都包含一个指向原型对象的内部指针。那么假如我们让原型对象等于另一个类型的实例，结果会怎样？显然，此时的原型对象将包含一个指向另一个原型的指针，相应地，另一个原型中也包含着一个指向另一个构造函数的指针。假如另一个原型又是另一个类型的实例，那么上述关系依然成立。如此层层递进，就构成了实例与原型的链条。这就是所谓的原型链的基本概念。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.prototype.__proto__ === <span class="literal">null</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p><img src="/.io//5.png"></p>
]]></content>
      <categories>
        <category>js基础</category>
      </categories>
  </entry>
  <entry>
    <title>希尔排序</title>
    <url>/2021/08/25/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<p>希尔排序是希尔（Donald Shell）于1959年提出的一种排序算法。希尔排序也是一种插入排序，它是简单插入排序经过改进之后的一个更高效的版本，也称为缩小增量排序，同时该算法是冲破O(n2）的第一批算法之一。本文会以图解的方式详细介绍希尔排序的基本思想及其代码实现。</p>
<h2 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h2><p>希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止。</p>
<p>简单插入排序很循规蹈矩，不管数组分布是怎么样的，依然一步一步的对元素进行比较，移动，插入，比如[5,4,3,2,1,0]这种倒序序列，数组末端的0要回到首位置很是费劲，比较和移动元素均需n-1次。而希尔排序在数组中采用跳跃式分组的策略，通过某个增量将数组元素划分为若干组，然后分组进行插入排序，随后逐步缩小增量，继续按组进行插入排序操作，直至增量为1。希尔排序通过这种策略使得整个数组在初始阶段达到从宏观上看基本有序，小的基本在前，大的基本在后。然后缩小增量，到增量为1时，其实多数情况下只需微调即可，不会涉及过多的数据移动。</p>
<p>我们来看下希尔排序的基本步骤，在此我们选择增量gap=length/2，缩小增量继续以gap = gap/2的方式，这种增量选择我们可以用一个序列来表示，{n/2,(n/2)/2…1}，称为增量序列。希尔排序的增量序列的选择与证明是个数学难题，我们选择的这个增量序列是比较常用的，也是希尔建议的增量，称为希尔增量，但其实这个增量序列不是最优的。此处我们做示例使用希尔增量。</p>
<h2 id="动图演示"><a href="#动图演示" class="headerlink" title="动图演示"></a>动图演示</h2><p><img src="/.io//1.png" alt="原理图"></p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">40</span>, <span class="number">60</span>, <span class="number">60</span>, <span class="number">0</span>, <span class="number">30</span>]</span><br><span class="line"><span class="keyword">let</span> interval = <span class="built_in">parseInt</span>(arr.length / <span class="number">2</span>);</span><br><span class="line"><span class="keyword">while</span> (interval &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i ++) &#123;</span><br><span class="line">        <span class="keyword">let</span> n = i;</span><br><span class="line">        <span class="keyword">while</span> (arr[n] &lt; arr[n - interval] &amp;&amp; n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">let</span> temp = arr[n]</span><br><span class="line">            arr[n] = arr[n- interval]</span><br><span class="line">            arr[n - interval] = temp</span><br><span class="line">            n --</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    interval = <span class="built_in">parseInt</span>(interval / <span class="number">2</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(arr)</span><br></pre></td></tr></table></figure>

<h2 id="性能分析："><a href="#性能分析：" class="headerlink" title="性能分析："></a>性能分析：</h2><p>希尔排序中对于增量序列的选择十分重要，直接影响到希尔排序的性能。我们上面选择的增量序列{n/2,(n/2)/2…1}(希尔增量)，其最坏时间复杂度依然为O(n2)，一些经过优化的增量序列如Hibbard经过复杂证明可使得最坏时间复杂度为O(n3/2)</p>
]]></content>
      <categories>
        <category>js基础</category>
      </categories>
  </entry>
  <entry>
    <title>执行上下文</title>
    <url>/2021/07/06/%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87/</url>
    <content><![CDATA[<h2 id="理解执行上下文"><a href="#理解执行上下文" class="headerlink" title="理解执行上下文"></a>理解执行上下文</h2><blockquote>
<p>执行上下文：函数执行前进行的准备工作，也就是执行上下文环境，是当前代码执行的一个环境与作用域。</p>
</blockquote>
<p>运行js代码时，当代码执行进入一个环境时，就会为该环境创建一个执行上下文，它<br>会在你运行代码前做一些准备工作，如确定作用域，创建局部变量对象等。</p>
<h2 id="js中执行环境"><a href="#js中执行环境" class="headerlink" title="js中执行环境"></a>js中执行环境</h2><ul>
<li>全局环境</li>
<li>函数环境</li>
<li>eval函数环境（不推荐使用）</li>
</ul>
<h2 id="执行上下文的类型"><a href="#执行上下文的类型" class="headerlink" title="执行上下文的类型"></a>执行上下文的类型</h2><ul>
<li>全局执行上下文</li>
<li>函数执行上下文</li>
<li>eval函数执行上下文</li>
</ul>
<p>js运行时先进入全局环境，对应会生成全局上下文。程序代码中基本都会存在函数，调用<br>函数，就会进入函数执行环境，对应的就是生成函数执行上下文。</p>
<h2 id="js管理多个执行上下文"><a href="#js管理多个执行上下文" class="headerlink" title="js管理多个执行上下文"></a>js管理多个执行上下文</h2><p>函数变成中，代码中会声明多个函数，对应的执行上下文也会存在多个。在js中，通过栈的存取方式来管理执行上下文，我们可以称<br>其为执行栈，或者函数调用栈。</p>
<p><img src="/.io//1.png" alt="栈数据结构"></p>
<h2 id="执行栈（函数调用栈）"><a href="#执行栈（函数调用栈）" class="headerlink" title="执行栈（函数调用栈）"></a>执行栈（函数调用栈）</h2><p>程序进入一个执行环境时，它的执行上下文就会被创建，并被堆入执行栈中（入栈）；程序执行完成时，她的执行上下文就会被销毁，并从栈顶被推出（出栈），控制权交由下一个执行上下文。</p>
<p>因为JS执行中，最先进入全局环境，所以处于”栈底的永远时全局环境的执行上下文”。而处于”栈顶的是当前执行函数的执行上下文”，当函数调用完成后，它就会从栈顶被推出（理想情况下，闭包会阻止该操作）。</p>
<p><strong>全局环境只有一个，对应的全局执行上下文也只有一个，只有当页面被关闭之后它才会从执行栈中被推出，否则一直存在于栈底。</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params"></span>) </span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">bar</span> (<span class="params"></span>) </span>&#123;        </span><br><span class="line">      <span class="keyword">return</span> <span class="string">&#x27;I am bar&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bar();</span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br></pre></td></tr></table></figure>
<p><img src="/.io//2.png" alt="出栈入栈图解"></p>
<h2 id="执行上下文的声明周期"><a href="#执行上下文的声明周期" class="headerlink" title="执行上下文的声明周期"></a>执行上下文的声明周期</h2><p>执行上下文的声明周期有两个阶段：</p>
<ol>
<li><p>创建阶段（进入执行上下文）</p>
<p> 函数被调用时，进入函数环境，为期创建一个执行上下文，此时进入创建阶段。</p>
</li>
<li><p>执行阶段（代码执行）</p>
<p> 执行函数中代码时，此时执行上下文进入执行阶段。</p>
</li>
</ol>
<h2 id="创建阶段的操作"><a href="#创建阶段的操作" class="headerlink" title="创建阶段的操作"></a>创建阶段的操作</h2><p>1.创建变量对象</p>
<ul>
<li>函数环境会初始化创建Arguments对象（并赋值）</li>
<li>函数声明（并赋值）</li>
<li>变量声明，函数表达式声明（未赋值）</li>
</ul>
<ol start="2">
<li>确定this指向（this由调用者确定）</li>
<li>确定作用域（词法环境决定，哪里声明定义，就在哪里确定）</li>
</ol>
<h2 id="执行阶段的操作"><a href="#执行阶段的操作" class="headerlink" title="执行阶段的操作"></a>执行阶段的操作</h2><ol>
<li>变量对象赋值</li>
</ol>
<ul>
<li>变量赋值</li>
<li>函数表达式赋值</li>
</ul>
<ol start="2">
<li>调用函数</li>
<li>顺序执行其他代码</li>
</ol>
<h2 id="变量对象和活动对象的区别："><a href="#变量对象和活动对象的区别：" class="headerlink" title="变量对象和活动对象的区别："></a>变量对象和活动对象的区别：</h2><p>当进入到一个执行上下文后，这个变量对象才会被激活，所以叫活动对象(AO)，这时候活动对象上的各种属性才能被访问。</p>
<p><strong>“创建阶段对函数声明做赋值，变量及函数表达式仅做声明，真正的赋值操作要等到执行上下文代码执行阶段。”</strong></p>
<p>例1：变量提升</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a);         <span class="comment">// 输出undefined</span></span><br><span class="line">    <span class="keyword">var</span> a = <span class="string">&#x27;I am here&#x27;</span>;    <span class="comment">// 赋值</span></span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br><span class="line"><span class="comment">// 实际执行过程</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a;                <span class="comment">// 变量声明，var初始化undefined</span></span><br><span class="line">    <span class="built_in">console</span>.log(a); </span><br><span class="line">    a = <span class="string">&#x27;I am here&#x27;</span>;     <span class="comment">// 变量重新赋值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例2：函数声明优先级</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(bar);</span><br><span class="line">    <span class="keyword">var</span> bar = <span class="number">20</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> bar = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">30</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">foo();  <span class="comment">// 输出bar()整个函数声明</span></span><br></pre></td></tr></table></figure>

<h2 id="函数声明，变量声明，函数表达式的优先级"><a href="#函数声明，变量声明，函数表达式的优先级" class="headerlink" title="函数声明，变量声明，函数表达式的优先级"></a>函数声明，变量声明，函数表达式的优先级</h2><ol>
<li>函数声明，如果有同名属性，会替换掉</li>
<li>变量，函数表达式</li>
<li>函数声明优先 &gt; 变量，函数表达式</li>
</ol>
<h2 id="执行上下文的数量限制（堆栈溢出）"><a href="#执行上下文的数量限制（堆栈溢出）" class="headerlink" title="执行上下文的数量限制（堆栈溢出）"></a>执行上下文的数量限制（堆栈溢出）</h2><p>执行上下文可存在多个，虽然没有明确的数量限制，但如果超出栈分配的空间，会造成堆栈溢出。常见于递归调用，没有终止条件造成死循环的场景。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 递归调用自身</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    foo();</span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br><span class="line"><span class="comment">// 报错： Uncaught RangeError: Maximum call stack size exceeded</span></span><br></pre></td></tr></table></figure>

<h2 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h2><p>当程序调用一个函数时，会发生什么？</p>
<p>以下几个步骤：</p>
<ol>
<li>js创建一个新的执行上下文，我们叫做函数执行上下文。</li>
<li>这个函数执行上下文将有它自己的一组变量，这些变量将时这个执行上下文的本地变量。</li>
<li>新的执行上下文被推到执行堆栈中。可以将执行堆栈看作是一种保存程序在其执行中的位置的容器。</li>
</ol>
<p>当函数遇到一个return或者一个结束括号 “}” 。</p>
<p>当函数结束时，会执行一下操作：</p>
<ol>
<li>这个本地执行上下文从执行堆栈中弹出。</li>
<li>函数将返回值返回调用上下文。调用上下文时调用这个本地的执行上下文，它可以时全局执行上下文，也可以是灵位一个本地执行上下文。这取决与调用执行上下文来处理此时的返回值，返回的值可以是一个对象、一个数组、一个函数、一个布尔值等等，如果函数没有return语句，则返回undefined.</li>
<li></li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li>JavaScript是单线程</li>
<li>栈顶的执行上下文处于执行中，其它需要排队</li>
<li>全局上下文只有一个处于栈底，页面关闭时出栈</li>
<li>函数执行上下文可存在多个，但应避免递归时堆栈溢出</li>
<li>函数调用时就会创建新的上下文，即使调用自身，也会创建不同的执行上下文</li>
</ol>
]]></content>
      <categories>
        <category>js基础</category>
      </categories>
  </entry>
  <entry>
    <title>插入排序</title>
    <url>/2021/08/25/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h2 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h2><p>1.从数组的第二个数据开始往前比较，即一开始用第二个数和他前面的一个比较，如果 符合条件（比前面的大或者小，自定义），则让他们交换位置。</p>
<p>2.然后再用第三个数和第二个比较，符合则交换，但是此处还得继续往前比较，比如有 5个数8，15，20，45, 17,17比45小，需要交换，但是17也比20小，也要交换，当不需 要和15交换以后，说明也不需要和15前面的数据比较了，肯定不需要交换，因为前 面的数据都是有序的。</p>
<p>3.重复步骤二，一直到数据全都排完。</p>
<h2 id="动图演示"><a href="#动图演示" class="headerlink" title="动图演示"></a>动图演示</h2><p><img src="/.io//1.gif" alt="原理图"></p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">40</span>, <span class="number">60</span>, <span class="number">60</span>, <span class="number">0</span>, <span class="number">30</span>]</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> n = i;</span><br><span class="line">    <span class="keyword">while</span> (arr[n] &gt; arr[n+<span class="number">1</span>] &amp;&amp; n &gt;=<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> temp = arr[n];</span><br><span class="line">        arr[n] = arr[n + <span class="number">1</span>];</span><br><span class="line">        arr[n + <span class="number">1</span>] = temp;</span><br><span class="line">        n--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(arr);</span><br></pre></td></tr></table></figure>

<h2 id="性能分析："><a href="#性能分析：" class="headerlink" title="性能分析："></a>性能分析：</h2><p>1.属于稳定的排序，适合于数据量小，部分数据有序的情况排序。</p>
<p>2.如果目标是把n个元素的序列升序排列，那么采用插入排序存在最好情况和最坏情况。最好情况就是，序列已经是升序排列了，在这种情况下，需要进行的比较操作需（n-1）次即可。最坏情况就是，序列是降序排列，那么此时需要进行的比较共有n(n-1)/2次。插入排序的赋值操作是比较操作的次数加上 (n-1）次。平均来说插入排序算法的时间复杂度为O(n^2）。因而，插入排序不适合对于数据量比较大的排序应用。但是，如果需要排序的数据量很小，例如，量级小于千，那么插入排序还是一个不错的选择</p>
<p>3.插入排序的平均时间复杂度也是 O(n^2)，空间复杂度为常数阶 O(1)</p>
]]></content>
      <categories>
        <category>js基础</category>
      </categories>
  </entry>
  <entry>
    <title>数据类型</title>
    <url>/2021/08/19/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<h1 id="js中基本数据类型"><a href="#js中基本数据类型" class="headerlink" title="js中基本数据类型"></a>js中基本数据类型</h1><h2 id="原始数据类型"><a href="#原始数据类型" class="headerlink" title="原始数据类型"></a>原始数据类型</h2><ul>
<li>number</li>
<li>string</li>
<li>boolean</li>
<li>null</li>
<li>undefined</li>
<li>symbol(es6)</li>
<li>bigint(es10)</li>
</ul>
<h2 id="引用数据类型"><a href="#引用数据类型" class="headerlink" title="引用数据类型"></a>引用数据类型</h2><ul>
<li>object (包括function/array/object)</li>
</ul>
]]></content>
      <categories>
        <category>js基础</category>
      </categories>
  </entry>
  <entry>
    <title>数组操作</title>
    <url>/2021/08/19/%E6%95%B0%E7%BB%84%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h1 id="最常见的几种数组操作方法归纳总结"><a href="#最常见的几种数组操作方法归纳总结" class="headerlink" title="最常见的几种数组操作方法归纳总结"></a>最常见的几种数组操作方法归纳总结</h1><table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>concat()</td>
<td>连接两个或多个数组，并返回已连接数组的副本</td>
</tr>
<tr>
<td>copyWithin()</td>
<td>将数组中的数组元素复制到指定位置或从指定位置复制</td>
</tr>
<tr>
<td>entries()</td>
<td>返回键/值对数组迭代对象</td>
</tr>
<tr>
<td>every()</td>
<td>检查数组中的每个元素是否通过测试</td>
</tr>
<tr>
<td>fill()</td>
<td>用静态值填充数组中的元素</td>
</tr>
<tr>
<td>filter()</td>
<td>使用数组中通过测试的每个元素创建新数组</td>
</tr>
<tr>
<td>find()</td>
<td>返回数组中第一个通过测试的元素的值</td>
</tr>
<tr>
<td>findIndex()</td>
<td>返回数组中通过测试的第一个元素的索引。</td>
</tr>
<tr>
<td>forEach()</td>
<td>为每个数组元素调用函数。</td>
</tr>
<tr>
<td>from()</td>
<td>从对象创建数组</td>
</tr>
<tr>
<td>includes()</td>
<td>检查数组是否包含指定的元素。</td>
</tr>
<tr>
<td>indexOf()</td>
<td>在数组中搜索元素并返回其位置。</td>
</tr>
<tr>
<td>isArray()</td>
<td>检查对象是否为数组。</td>
</tr>
<tr>
<td>join()</td>
<td>将数组的所有元素连接成一个字符串。</td>
</tr>
<tr>
<td>keys()</td>
<td>返回 Array Iteration 对象，包含原始数组的键.</td>
</tr>
<tr>
<td>lastIndexOf()</td>
<td>在数组中搜索元素，从末尾开始，并返回其位置。</td>
</tr>
<tr>
<td>map()</td>
<td>使用为每个数组元素调用函数的结果创建新数组。</td>
</tr>
<tr>
<td>pop()</td>
<td>删除数组的最后一个元素，并返回该元素。</td>
</tr>
<tr>
<td>push()</td>
<td>将新元素添加到数组的末尾，并返回新的长度。</td>
</tr>
<tr>
<td>reduce()</td>
<td>将数组的值减为单个值（从左到右）。</td>
</tr>
<tr>
<td>reduceRight()</td>
<td>将数组的值减为单个值（从右到左）。</td>
</tr>
<tr>
<td>reverse()</td>
<td>反转数组中元素的顺序。</td>
</tr>
<tr>
<td>shift()</td>
<td>删除数组的第一个元素，并返回该元素。</td>
</tr>
<tr>
<td>slice()</td>
<td>选择数组的一部分，并返回新数组。</td>
</tr>
<tr>
<td>some()</td>
<td>检查数组中的任何元素是否通过测试。</td>
</tr>
<tr>
<td>sort()</td>
<td>对数组的元素进行排序。</td>
</tr>
<tr>
<td>splice()</td>
<td>从数组中添加/删除元素。</td>
</tr>
<tr>
<td>toString()</td>
<td>将数组转换为字符串，并返回结果。</td>
</tr>
<tr>
<td>unshift()</td>
<td>将新元素添加到数组的开头，并返回新的长度。</td>
</tr>
<tr>
<td>valueOf()</td>
<td>返回数组的原始值。</td>
</tr>
<tr>
<td>at()</td>
<td>2021.1新提案，解决方括号的限制，可以输入负数。</td>
</tr>
</tbody></table>
<h2 id="1-shift-方法：把数组的第一个元素删除，并返回第一个元素的值"><a href="#1-shift-方法：把数组的第一个元素删除，并返回第一个元素的值" class="headerlink" title="1.shift() 方法：把数组的第一个元素删除，并返回第一个元素的值"></a>1.shift() 方法：把数组的第一个元素删除，并返回第一个元素的值</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">arr.shift() <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<h2 id="2-concat-方法：用于连接两个或多个数组-并返回一个新数组，新数组是将参数添加到原数组中构成的"><a href="#2-concat-方法：用于连接两个或多个数组-并返回一个新数组，新数组是将参数添加到原数组中构成的" class="headerlink" title="2.concat() 方法：用于连接两个或多个数组,并返回一个新数组，新数组是将参数添加到原数组中构成的"></a>2.concat() 方法：用于连接两个或多个数组,并返回一个新数组，新数组是将参数添加到原数组中构成的</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">const</span> arr1 = arr.concat(<span class="number">2</span>, <span class="number">4</span>); <span class="comment">// 1, 3, 2, 4</span></span><br><span class="line"><span class="keyword">const</span> arr2 = [<span class="number">5</span>, <span class="number">6</span>];</span><br><span class="line"><span class="keyword">const</span> arr3 = [<span class="number">7</span>, <span class="number">8</span>];</span><br><span class="line"><span class="keyword">const</span> arr4 = arr2.concat(arr3); <span class="comment">// 5, 6, 7, 8</span></span><br></pre></td></tr></table></figure>

<h2 id="3-join-方法：用于把数组中的所有元素放入一个字符串。元素是通过指定的分隔符进行分隔的。"><a href="#3-join-方法：用于把数组中的所有元素放入一个字符串。元素是通过指定的分隔符进行分隔的。" class="headerlink" title="3. join() 方法：用于把数组中的所有元素放入一个字符串。元素是通过指定的分隔符进行分隔的。"></a>3. join() 方法：用于把数组中的所有元素放入一个字符串。元素是通过指定的分隔符进行分隔的。</h2><p>返回一个字符串。该字符串是通过把 arrayObject 的每个元素转换为字符串，然后把这些字符串连接起来，在两个元素之间插入separator 字符串而生成的。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>];</span><br><span class="line"><span class="keyword">const</span> str = arr.join(<span class="string">&#x27;-&#x27;</span>); <span class="comment">// 1-3-4-5-6</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="4-pop-方法：用于删除并返回数组的最后一个-删除元素-元素-如果数组为空则返回undefined-把数组长度减-1"><a href="#4-pop-方法：用于删除并返回数组的最后一个-删除元素-元素-如果数组为空则返回undefined-把数组长度减-1" class="headerlink" title="4. pop() 方法：用于删除并返回数组的最后一个(删除元素)元素,如果数组为空则返回undefined ,把数组长度减 1"></a>4. pop() 方法：用于删除并返回数组的最后一个(删除元素)元素,如果数组为空则返回undefined ,把数组长度减 1</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line"><span class="keyword">const</span> str = arr.pop(); <span class="comment">// 6</span></span><br><span class="line"><span class="built_in">console</span>.log(arr) <span class="comment">// 1,2,3,4,5</span></span><br></pre></td></tr></table></figure>

<h2 id="5-push-方法：可向数组的末尾添加一个或多个元素，并返回新的长度，（用来改变数组长度）。"><a href="#5-push-方法：可向数组的末尾添加一个或多个元素，并返回新的长度，（用来改变数组长度）。" class="headerlink" title="5.push() 方法：可向数组的末尾添加一个或多个元素，并返回新的长度，（用来改变数组长度）。"></a>5.push() 方法：可向数组的末尾添加一个或多个元素，并返回新的长度，（用来改变数组长度）。</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line"><span class="keyword">const</span> len = arr.push(<span class="number">5</span>)<span class="comment">// 5</span></span><br><span class="line"><span class="built_in">console</span>.log(arr) <span class="comment">// [1,2,3,4,5]</span></span><br></pre></td></tr></table></figure>
<h2 id="6-reverse-：方法用于颠倒数组中元素的顺序。"><a href="#6-reverse-：方法用于颠倒数组中元素的顺序。" class="headerlink" title="6.reverse() ：方法用于颠倒数组中元素的顺序。"></a>6.reverse() ：方法用于颠倒数组中元素的顺序。</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line"><span class="keyword">const</span> len = arr.reverse(); <span class="comment">// [6,5,4,3,2,1]</span></span><br><span class="line"><span class="built_in">console</span>.log(arr) <span class="comment">// [6,5,4,3,2,1]</span></span><br></pre></td></tr></table></figure>
<h2 id="7-slice-方法：可从已有的数组中返回选定的元素。slice-开始截取位置，结束截取位置"><a href="#7-slice-方法：可从已有的数组中返回选定的元素。slice-开始截取位置，结束截取位置" class="headerlink" title="7.slice() 方法：可从已有的数组中返回选定的元素。slice(开始截取位置，结束截取位置)"></a>7.slice() 方法：可从已有的数组中返回选定的元素。slice(开始截取位置，结束截取位置)</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line"><span class="keyword">const</span> a = arr.slice(<span class="number">1</span>,<span class="number">2</span>); <span class="comment">// [2]</span></span><br><span class="line"><span class="built_in">console</span>.log(arr)<span class="comment">// [1,2,3,4,5,6]</span></span><br></pre></td></tr></table></figure>
<h2 id="8-splice-：方法向-从数组中添加-删除项目，然后返回被删除的项目。"><a href="#8-splice-：方法向-从数组中添加-删除项目，然后返回被删除的项目。" class="headerlink" title="8.splice() ：方法向/从数组中添加/删除项目，然后返回被删除的项目。"></a>8.splice() ：方法向/从数组中添加/删除项目，然后返回被删除的项目。</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"><span class="keyword">const</span> a = arr.splice(<span class="number">1</span>,<span class="number">2</span>); <span class="comment">// [2,3]</span></span><br><span class="line"><span class="built_in">console</span>.log(arr) <span class="comment">// [1,4,5]</span></span><br><span class="line"><span class="keyword">const</span> b = arr.splice(<span class="number">1</span>,<span class="number">2</span>,)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arrr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"><span class="keyword">const</span> c = arr.splice(<span class="number">1</span>,<span class="number">0</span>, <span class="string">&#x27;a&#x27;</span>) <span class="comment">// []</span></span><br><span class="line"><span class="built_in">console</span>.log(arrr) <span class="comment">// [1, &#x27;a&#x27;,2,3,4,5]</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="9-unshift：将参数添加到原数组开头，并返回数组的长度"><a href="#9-unshift：将参数添加到原数组开头，并返回数组的长度" class="headerlink" title="9.unshift：将参数添加到原数组开头，并返回数组的长度"></a>9.unshift：将参数添加到原数组开头，并返回数组的长度</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line"><span class="keyword">const</span> len = arr.unshift(<span class="number">0</span>); <span class="comment">// 5</span></span><br><span class="line"><span class="built_in">console</span>.log(arr) <span class="comment">// [0,1,2,3,4]</span></span><br></pre></td></tr></table></figure>
<h2 id="10-sort-orderfunction-：按指定的参数对数组进行排序"><a href="#10-sort-orderfunction-：按指定的参数对数组进行排序" class="headerlink" title="10.sort(orderfunction)：按指定的参数对数组进行排序"></a>10.sort(orderfunction)：按指定的参数对数组进行排序</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line"><span class="keyword">const</span> b = arr.sort(); <span class="comment">// [1,2,3,4]</span></span><br><span class="line"><span class="built_in">console</span>.log(b) <span class="comment">// [1,2,3,4]</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>js基础</category>
      </categories>
  </entry>
  <entry>
    <title>javascript面试-常用算法</title>
    <url>/2021/08/19/%E9%9D%A2%E8%AF%95%E6%95%B4%E7%90%86/</url>
    <content><![CDATA[<h1 id="ip协议的首部结构"><a href="#ip协议的首部结构" class="headerlink" title="ip协议的首部结构"></a>ip协议的首部结构</h1><p><img src="/.io//IP%E5%8D%8F%E8%AE%AE%E7%9A%84%E9%A6%96%E9%83%A8%E7%BB%93%E6%9E%84.png" alt="IP协议的首部结构"></p>
<h1 id="说一说-HashRouter-和-HistoryRouter的区别和原理？"><a href="#说一说-HashRouter-和-HistoryRouter的区别和原理？" class="headerlink" title="说一说 HashRouter 和 HistoryRouter的区别和原理？"></a>说一说 HashRouter 和 HistoryRouter的区别和原理？</h1><h1 id="说一说你对闭包的理解？"><a href="#说一说你对闭包的理解？" class="headerlink" title="说一说你对闭包的理解？"></a>说一说你对闭包的理解？</h1><h1 id="说一下浏览器如何渲染页面的？"><a href="#说一下浏览器如何渲染页面的？" class="headerlink" title="说一下浏览器如何渲染页面的？"></a>说一下浏览器如何渲染页面的？</h1><h1 id="编程题"><a href="#编程题" class="headerlink" title="编程题"></a>编程题</h1><p>给定一个整数数组nums，按升序排序，数组中的元素各不相同。<br>nums数组在传递给search函数之前，会在预先未知的某个下标 t（0 &lt;= t &lt;= nums.length-1）上进行旋转，让数组变为[nums[t], nums[t+1], …, nums[nums.length-1], nums[0], nums[1], …, nums[t-1]]。<br>比如，数组[0,2,4,6,8,10]在下标2处旋转之后变为[6,8,10,0,2,4]<br>现在给定一个旋转后的数组nums和一个整数target，请你查找这个数组是不是存在这个target，如果存在，那么返回它的下标，如果不存在，返回-1</p>
]]></content>
      <categories>
        <category>面试</category>
        <category>http</category>
      </categories>
  </entry>
  <entry>
    <title>面试题</title>
    <url>/2021/08/19/%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<h1 id="JavaScript-面试题"><a href="#JavaScript-面试题" class="headerlink" title="JavaScript 面试题"></a>JavaScript 面试题</h1><h2 id><a href="#" class="headerlink" title></a><a href="/2018/07/06/%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E6%96%B9%E5%BC%8F/" title="1.在 JavaScript 中创建对象的可行方法有哪些？">1.在 JavaScript 中创建对象的可行方法有哪些？</a></h2><p>1、对象的构造函数-new object()<br>2、对象的创建方法-Object.create(null)<br>3、对象字面量语法-const obj = {}<br>4、函数构造器<br>5、带有原型的函数构造函数<br>6、es6类语法 class<br>7、单例模式</p>
<h2 id="-1"><a href="#-1" class="headerlink" title></a><a href="/2018/07/06/%E5%8E%9F%E5%9E%8B%E5%8F%8A%E5%8E%9F%E5%9E%8B%E9%93%BE/" title="1.什么是原型链？">1.什么是原型链？</a></h2><p>原型链用于基于现有对象构建新类型的对象。它类似于基于类的语言中的继承。</p>
<p>对象实例上的原型可通过Object.getPrototypeOf(object)或proto属性获得，而构造函数上的原型可通过Object.prototype 获得。</p>
<h2 id="-2"><a href="#-2" class="headerlink" title></a><a href="/2021/08/19/call%E3%80%81apply%E5%92%8Cbind%E5%8C%BA%E5%88%AB/" title="3.call、 bind、apply区别？">3.call、 bind、apply区别？</a></h2><h2 id="-3"><a href="#-3" class="headerlink" title></a><a href="/2021/08/19/%E6%95%B0%E7%BB%84%E6%93%8D%E4%BD%9C/" title="4.数组操作？">4.数组操作？</a></h2>]]></content>
  </entry>
  <entry>
    <title>grid布局</title>
    <url>/2021/10/20/grid%E5%B8%83%E5%B1%80/</url>
    <content><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>网格布局是最强大的css布局方案。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">display: grid;</span><br></pre></td></tr></table></figure>
<style>
#container1 {
    display: grid;
    grid-template-columns: 100px 100px 100px;
    grid-template-rows: 100px 100px 100px;
}
.item {
  font-size: 2em;
  text-align: center;
  border: 1px solid #e5e4e9;
}

.item-1 {
  background-color: #ef342a;
}

.item-2 {
  background-color: #f68f26;
}

.item-3 {
  background-color: #4ba946;
}

.item-4 {
  background-color: #0376c2;
}

.item-5 {
  background-color: #c077af;
}

.item-6 {
  background-color: #f8d29d;
}

.item-7 {
  background-color: #b5a87f;
}

.item-8 {
  background-color: #d0e4a9;
}

.item-9 {
  background-color: #4dc7ec;
}
</style>
<div id="container1">
  <div class="item item-1">1</div>
  <div class="item item-2">2</div>
  <div class="item item-3">3</div>
  <div class="item item-4">4</div>
  <div class="item item-5">5</div>
  <div class="item item-6">6</div>
  <div class="item item-7">7</div>
  <div class="item item-8">8</div>
  <div class="item item-9">9</div>
</div>


<h1 id="容器属性："><a href="#容器属性：" class="headerlink" title="容器属性："></a>容器属性：</h1><p>Grid 布局的属性分成两类。一类定义在容器上面，称为容器属性；另一类定义在项目上面，称为项目属性。</p>
<h2 id="display属性"><a href="#display属性" class="headerlink" title="display属性"></a>display属性</h2><p>display: grid指定一个容器采用网格布局。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">div &#123;</span><br><span class="line">  display: grid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div id="container1">
  <div class="item item-1">1</div>
  <div class="item item-2">2</div>
  <div class="item item-3">3</div>
  <div class="item item-4">4</div>
  <div class="item item-5">5</div>
  <div class="item item-6">6</div>
  <div class="item item-7">7</div>
  <div class="item item-8">8</div>
  <div class="item item-9">9</div>
</div>

<p>默认情况下，容器都是块级元素，但也可以设置为行内元素,会出现什么现象？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.item &#123;</span><br><span class="line">  display: inline-grid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过上图，可发现没有变化。这是因为，容器设为网格布局以后，容器子元素（项目）的float、display: inline-block、display: table-cell、vertical-align和column-*等设置都将失效。</p>
<h2 id="grid-template-columns-属性-grid-template-rows属性"><a href="#grid-template-columns-属性-grid-template-rows属性" class="headerlink" title="grid-template-columns 属性 grid-template-rows属性"></a>grid-template-columns 属性 grid-template-rows属性</h2><p>容器指定了网格布局以后，接着就要划分行和列。grid-template-columns属性定义每一列的列宽，grid-template-rows属性定义每一行的行高。</p>
<p>grid-template-columns: none|auto|max-content|min-content|length|initial|inherit;<br>grid-template-rows: none|auto|max-content|min-content|length|initial|inherit;<br>grid-template-columns: 50px 100px auto; 每个值代表每一列的宽度，有多少列，写多少个值<br>grid-template-rows: 50px 100px auto;每个值代表每一行的宽度，有多少行，写多少个值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.container &#123;</span><br><span class="line">  display: grid;</span><br><span class="line">  grid-template-columns: 100px 100px 100px;</span><br><span class="line">  grid-template-rows: 100px 100px 100px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div id="container1">
  <div class="item item-1">1</div>
  <div class="item item-2">2</div>
  <div class="item item-3">3</div>
  <div class="item item-4">4</div>
  <div class="item item-5">5</div>
  <div class="item item-6">6</div>
  <div class="item item-7">7</div>
  <div class="item item-8">8</div>
  <div class="item item-9">9</div>
</div>

<h3 id="repeat-次数，值"><a href="#repeat-次数，值" class="headerlink" title="repeat(次数，值)"></a>repeat(次数，值)</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">.container &#123;</span><br><span class="line">  display: grid;</span><br><span class="line">  grid-template-columns: repeat(3, 33.33%);</span><br><span class="line">  grid-template-rows: repeat(3, 33.33%);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">grid-template-columns: repeat(2, 100px 20px 80px);// 重复后面的数据</span><br></pre></td></tr></table></figure>
<style>
    #container2 {
        display: grid;
        grid-template-columns: repeat(2, 100px 20px 80px);
    }
</style>
<div id="container2">
  <div class="item item-1">1</div>
  <div class="item item-2">2</div>
  <div class="item item-3">3</div>
  <div class="item item-4">4</div>
  <div class="item item-5">5</div>
  <div class="item item-6">6</div>
  <div class="item item-7">7</div>
  <div class="item item-8">8</div>
  <div class="item item-9">9</div>
</div>

<p>第一列和第四列的宽度为100px，第二列和第五列为20px，第三列和第六列为80px。</p>
<h3 id="auto-fill-关键字"><a href="#auto-fill-关键字" class="headerlink" title="auto-fill 关键字"></a>auto-fill 关键字</h3><p>有时，单元格的大小是固定的，但是容器的大小不确定。如果希望每一行（或每一列）容纳尽可能多的单元格，这时可以使用auto-fill关键字表示自动填充。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.container &#123;</span><br><span class="line">  display: grid;</span><br><span class="line">  grid-template-columns: repeat(auto-fill, 100px);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<style>
    #container3 {
        display: grid;
        grid-template-columns: repeat(auto-fill, 100px);
    }
</style>
<div id="container3">
  <div class="item item-1">1</div>
  <div class="item item-2">2</div>
  <div class="item item-3">3</div>
  <div class="item item-4">4</div>
  <div class="item item-5">5</div>
  <div class="item item-6">6</div>
  <div class="item item-7">7</div>
  <div class="item item-8">8</div>
  <div class="item item-9">9</div>
</div>

<h3 id="fr-关键字"><a href="#fr-关键字" class="headerlink" title="fr 关键字"></a>fr 关键字</h3><p>为了方便表示比例关系，网格布局提供了fr关键字（fraction 的缩写，意为”片段”）。如果两列的宽度分别为1fr和2fr，就表示后者是前者的两倍。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.container &#123;</span><br><span class="line">   display: grid;</span><br><span class="line">  grid-template-columns: 1fr 1fr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<style>
    #container4 {
        display: grid;
        grid-template-columns: 1fr 1fr 1fr;
    }
</style>
<div id="container4">
  <div class="item item-1">1</div>
  <div class="item item-2">2</div>
  <div class="item item-3">3</div>
  <div class="item item-4">4</div>
  <div class="item item-5">5</div>
  <div class="item item-6">6</div>
  <div class="item item-7">7</div>
  <div class="item item-8">8</div>
  <div class="item item-9">9</div>
</div>
fr可以与绝对长度的单位结合使用，这时会非常方便。
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.container &#123;</span><br><span class="line">  display: grid;</span><br><span class="line">  grid-template-columns: 150px 1fr 2fr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<style>
    #container5 {
        display: grid;
        grid-template-columns: 150px 1fr 1fr;
    }
</style>
<div id="container5">
  <div class="item item-1">1</div>
  <div class="item item-2">2</div>
  <div class="item item-3">3</div>
  <div class="item item-4">4</div>
  <div class="item item-5">5</div>
  <div class="item item-6">6</div>
  <div class="item item-7">7</div>
  <div class="item item-8">8</div>
  <div class="item item-9">9</div>
</div>

<h3 id="minmax（）"><a href="#minmax（）" class="headerlink" title="minmax（）"></a>minmax（）</h3><p>minmax()函数产生一个长度范围，表示长度就在这个范围之中。它接受两个参数，分别为最小值和最大值。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">grid-template-columns: 1fr 1fr minmax(100px, 1fr);//表示列宽不小于100px，不大于1fr</span><br></pre></td></tr></table></figure>

<style>
    #container6 {
        display: grid;
        grid-template-columns: 1fr 1fr minmax(100px, 2fr);
    }
</style>
<div id="container6">
  <div class="item item-1">1</div>
  <div class="item item-2">2</div>
  <div class="item item-3">3</div>
  <div class="item item-4">4</div>
  <div class="item item-5">5</div>
  <div class="item item-6">6</div>
  <div class="item item-7">7</div>
  <div class="item item-8">8</div>
  <div class="item item-9">9</div>
</div>

<h3 id="auto-关键字"><a href="#auto-关键字" class="headerlink" title="auto 关键字"></a>auto 关键字</h3><p>auto关键字表示由浏览器自己决定长度。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">grid-template-columns: 100px auto 100px;</span><br></pre></td></tr></table></figure>

<style>
    #container7 {
        display: grid;
        grid-template-columns: 100px auto 100px;
    }
</style>
<div id="container7">
  <div class="item item-1">1</div>
  <div class="item item-2">2</div>
  <div class="item item-3">3</div>
  <div class="item item-4">4</div>
  <div class="item item-5">5</div>
  <div class="item item-6">6</div>
  <div class="item item-7">7</div>
  <div class="item item-8">8</div>
  <div class="item item-9">9</div>
</div>

<h3 id="网格线的名称"><a href="#网格线的名称" class="headerlink" title="网格线的名称"></a>网格线的名称</h3><p>grid-template-columns属性和grid-template-rows属性里面，还可以使用方括号，指定每一根网格线的名字，方便以后的引用。网格布局允许同一根线有多个名字.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.container &#123;</span><br><span class="line">  display: grid;</span><br><span class="line">  grid-template-columns: [c1] 100px [c2] 100px [c3] auto [c4];</span><br><span class="line">  grid-template-rows: [r1] 100px [r2] 100px [r3] auto [r4];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="grid-row-gap-grid-column-gap-grid-gap"><a href="#grid-row-gap-grid-column-gap-grid-gap" class="headerlink" title="grid-row-gap grid-column-gap grid-gap"></a>grid-row-gap grid-column-gap grid-gap</h2><p>grid-row-gap属性设置行与行的间隔（行间距），grid-column-gap属性设置列与列的间隔（列间距）。<br>grid-gap属性是grid-column-gap和grid-row-gap的合并简写形式，语法如下。</p>
<p>根据最新标准，上面三个属性名的grid-前缀已经删除，grid-column-gap和grid-row-gap写成column-gap和row-gap，grid-gap写成gap。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">grid-gap: &lt;grid-row-gap&gt; &lt;grid-column-gap&gt;;</span><br><span class="line">.container &#123;</span><br><span class="line">  grid-row-gap: 20px;</span><br><span class="line">  grid-column-gap: 20px;</span><br><span class="line">  // grid-gap: 20px 20px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<style>
    #container8 {
        display: grid;
        grid-template-columns: 100px 100px 100px;
        column-gap: 20px;
        row-gap: 20px;
        /* grid-gap: 20px 20px; // 简写 */
    }
</style>
<div id="container8">
  <div class="item item-1">1</div>
  <div class="item item-2">2</div>
  <div class="item item-3">3</div>
  <div class="item item-4">4</div>
  <div class="item item-5">5</div>
  <div class="item item-6">6</div>
  <div class="item item-7">7</div>
  <div class="item item-8">8</div>
  <div class="item item-9">9</div>
</div>

<h2 id="grid-template-areas"><a href="#grid-template-areas" class="headerlink" title="grid-template-areas"></a>grid-template-areas</h2><p>网格布局允许指定”区域”（area），一个区域由单个或多个单元格组成。grid-template-areas属性用于定义区域。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.container &#123;</span><br><span class="line">  display: grid;</span><br><span class="line">  grid-template-columns: 100px 100px 100px;</span><br><span class="line">  grid-template-rows: 100px 100px 100px;</span><br><span class="line">  grid-template-areas: &#x27;a b c&#x27;</span><br><span class="line">                       &#x27;d e f&#x27;</span><br><span class="line">                       &#x27;g h i&#x27;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果某些区域不需要利用，则使用”点”（.）表示。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.container &#123;</span><br><span class="line">  display: grid;</span><br><span class="line">  grid-template-columns: 100px 100px 100px;</span><br><span class="line">  grid-template-rows: 100px 100px 100px;</span><br><span class="line">  grid-template-areas: &#x27;a . c&#x27;</span><br><span class="line">                       &#x27;d . f&#x27;</span><br><span class="line">                       &#x27;g . i&#x27;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，区域的命名会影响到网格线。每个区域的起始网格线，会自动命名为区域名-start，终止网格线自动命名为区域名-end。</p>
<p>比如，区域名为header，则起始位置的水平网格线和垂直网格线叫做header-start，终止位置的水平网格线和垂直网格线叫做header-end。</p>
<h2 id="grid-auto-flow"><a href="#grid-auto-flow" class="headerlink" title="grid-auto-flow"></a>grid-auto-flow</h2><p>顺序由grid-auto-flow属性决定，默认值是row，即”先行后列”。也可以将它设成column，变成”先列后行”。row dense和column dense。这两个值主要用于，某些项目指定位置以后，剩下的项目怎么自动放置<br>设为row dense，表示”先行后列”，并且尽可能紧密填满，尽量不出现空格。</p>
<p>column:</p>
<style>
    #container9 {
        display: grid;
        grid-template-columns: 100px 100px 100px;
        grid-template-rows: 100px 100px 100px;
        grid-auto-flow: column;
    }
</style>
<div id="container9">
  <div class="item item-1">1</div>
  <div class="item item-2">2</div>
  <div class="item item-3">3</div>
  <div class="item item-4">4</div>
  <div class="item item-5">5</div>
  <div class="item item-6">6</div>
  <div class="item item-7">7</div>
  <div class="item item-8">8</div>
  <div class="item item-9">9</div>
</div>
row(默认):
<style>
    #container10 {
        display: grid;
        grid-template-columns: 100px 100px 100px;
        grid-auto-flow: row;
    }
</style>
<div id="container10">
  <div class="item item-1">1</div>
  <div class="item item-2">2</div>
  <div class="item item-3">3</div>
  <div class="item item-4">4</div>
  <div class="item item-5">5</div>
  <div class="item item-6">6</div>
  <div class="item item-7">7</div>
  <div class="item item-8">8</div>
  <div class="item item-9">9</div>
</div>

<p>row dense 之前:</p>
<style>
    #container11 {
        display: grid;
        grid-template-columns: 100px 100px 100px;
        grid-auto-flow: row;
    }
    #container11 .item-1 {
        grid-column-start: 1;
        grid-column-end: 3;
    }
    #container11 .item-2 {
        grid-column-start: 1;
        grid-column-end: 3;
    }
</style>
<div id="container11">
  <div class="item item-1">1</div>
  <div class="item item-2">2</div>
  <div class="item item-3">3</div>
  <div class="item item-4">4</div>
  <div class="item item-5">5</div>
  <div class="item item-6">6</div>
  <div class="item item-7">7</div>
  <div class="item item-8">8</div>
  <div class="item item-9">9</div>
</div>
row dense
<style>
    #container12 {
        display: grid;
        grid-template-columns: 100px 100px 100px;
        grid-auto-flow: row dense;
    }
    #container12 .item-1 {
        grid-column-start: 1;
        grid-column-end: 3;
    }
    #container12 .item-2 {
        grid-column-start: 1;
        grid-column-end: 3;
    }
</style>
<div id="container12">
  <div class="item item-1">1</div>
  <div class="item item-2">2</div>
  <div class="item item-3">3</div>
  <div class="item item-4">4</div>
  <div class="item item-5">5</div>
  <div class="item item-6">6</div>
  <div class="item item-7">7</div>
  <div class="item item-8">8</div>
  <div class="item item-9">9</div>
</div>

<p>column dense 之前:</p>
<style>
    #container13 {
        display: grid;
        grid-template-columns: 100px 100px 100px;
        grid-template-rows: 100px 100px 100px;
        grid-auto-flow: column;
    }
    #container13 .item-1 {
        grid-row-start: 1;
        grid-row-end: 3;
    }
    #container13 .item-2 {
        grid-row-start: 1;
        grid-row-end: 3;
    }
</style>
<div id="container13">
  <div class="item item-1">1</div>
  <div class="item item-2">2</div>
  <div class="item item-3">3</div>
  <div class="item item-4">4</div>
  <div class="item item-5">5</div>
  <div class="item item-6">6</div>
  <div class="item item-7">7</div>
  <div class="item item-8">8</div>
  <div class="item item-9">9</div>
</div>
column dense
<style>
    #container14 {
        display: grid;
        grid-template-columns: 100px 100px 100px;
        grid-template-rows: 100px 100px 100px;
        grid-auto-flow: column dense;
    }
    #container14 .item-1 {
        grid-row-start: 1;
        grid-row-end: 3;
    }
    #container14 .item-2 {
        grid-row-start: 1;
        grid-row-end: 3;
    }
</style>
<div id="container14">
  <div class="item item-1">1</div>
  <div class="item item-2">2</div>
  <div class="item item-3">3</div>
  <div class="item item-4">4</div>
  <div class="item item-5">5</div>
  <div class="item item-6">6</div>
  <div class="item item-7">7</div>
  <div class="item item-8">8</div>
  <div class="item item-9">9</div>
</div>

<h2 id="justify-items-属性，align-items-属性，place-items-属性"><a href="#justify-items-属性，align-items-属性，place-items-属性" class="headerlink" title="justify-items 属性，align-items 属性，place-items 属性"></a>justify-items 属性，align-items 属性，place-items 属性</h2><p>justify-items属性设置单元格内容的水平位置（左中右），align-items属性设置单元格内容的垂直位置（上中下）。<br>place-items属性是align-items属性和justify-items属性的合并简写形式。<br>· start：对齐单元格的起始边缘。<br>· end：对齐单元格的结束边缘。<br>· center：单元格内部居中。<br>· stretch：拉伸，占满单元格的整个宽度（默认值）。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.container &#123;</span><br><span class="line">  justify-items: start | end | center | stretch;</span><br><span class="line">  align-items: start | end | center | stretch;</span><br><span class="line">&#125;</span><br><span class="line">place-items: &lt;align-items&gt; &lt;justify-items&gt;;</span><br><span class="line">place-items: start end;// 如果省略第二个值，则浏览器认为与第一个值相等。</span><br></pre></td></tr></table></figure>
<p>stretch(默认):</p>
<style>
    #container15 {
        display: grid;
        grid-template-columns: 100px 100px 100px;
        grid-template-rows: 100px 100px 100px;
        justify-items: stretch;
    }
</style>
<div id="container15">
  <div class="item item-1">1</div>
  <div class="item item-2">2</div>
  <div class="item item-3">3</div>
  <div class="item item-4">4</div>
  <div class="item item-5">5</div>
  <div class="item item-6">6</div>
  <div class="item item-7">7</div>
  <div class="item item-8">8</div>
  <div class="item item-9">9</div>
</div>
center: 
<style>
    #container16 {
        display: grid;
        grid-template-columns: 100px 100px 100px;
        grid-template-rows: 100px 100px 100px;
        justify-items: center;
    }
</style>
<div id="container16">
  <div class="item item-1">1</div>
  <div class="item item-2">2</div>
  <div class="item item-3">3</div>
  <div class="item item-4">4</div>
  <div class="item item-5">5</div>
  <div class="item item-6">6</div>
  <div class="item item-7">7</div>
  <div class="item item-8">8</div>
  <div class="item item-9">9</div>
</div>


<h2 id="justify-content-属性，align-content-属性，place-content-属性"><a href="#justify-content-属性，align-content-属性，place-content-属性" class="headerlink" title="justify-content 属性，align-content 属性，place-content 属性"></a>justify-content 属性，align-content 属性，place-content 属性</h2><p>justify-content属性是整个内容区域在容器里面的水平位置（左中右），align-content属性是整个内容区域的垂直位置（上中下）。place-content<br> · start - 对齐容器的起始边框。<br> · end - 对齐容器的结束边框。<br> · center - 容器内部居中。<br> · stretch - 项目大小没有指定时，拉伸占据整个网格容器。<br> · space-around - 每个项目两侧的间隔相等。所以，项目之间的间隔比项目与容器边框的间隔大一倍。<br> · space-between - 项目与项目的间隔相等，项目与容器边框之间没有间隔。<br> · space-evenly - 项目与项目的间隔相等，项目与容器边框之间也是同样长度的间隔。<br> ·</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.container &#123;</span><br><span class="line">  justify-content: start | end | center | stretch | space-around | space-between | space-evenly;</span><br><span class="line">  align-content: start | end | center | stretch | space-around | space-between | space-evenly;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>stretch(默认)：项目大小没有指定时，拉伸占据整个网格容器。</p>
<style>
    #container-box17 {
        width: 100%;
    }
    #container17 {
        display: grid;
        grid-template-columns: auto auto auto;
        grid-template-rows: 100px 100px 100px;
        grid-template-rows: 100px 100px 100px;
        justify-content: stretch;
    }
</style>
<div id="container-box17">
    <div id="container17">
  <div class="item item-1">1</div>
  <div class="item item-2">2</div>
  <div class="item item-3">3</div>
  <div class="item item-4">4</div>
  <div class="item item-5">5</div>
  <div class="item item-6">6</div>
  <div class="item item-7">7</div>
  <div class="item item-8">8</div>
  <div class="item item-9">9</div>
</div>
</div>
center:容器内部居中。
<style>
    #container18 {
        display: grid;
        grid-template-columns: 100px 100px 100px;
        grid-template-rows: 100px 100px 100px;
        justify-content: center;
    }
</style>
<div id="container18">
  <div class="item item-1">1</div>
  <div class="item item-2">2</div>
  <div class="item item-3">3</div>
  <div class="item item-4">4</div>
  <div class="item item-5">5</div>
  <div class="item item-6">6</div>
  <div class="item item-7">7</div>
  <div class="item item-8">8</div>
  <div class="item item-9">9</div>
</div>
start:对齐容器的起始边框。
<style>
    #container19 {
        display: grid;
        grid-template-columns: 100px 100px 100px;
        grid-template-rows: 100px 100px 100px;
        justify-content: start;
    }
</style>
<div id="container19">
  <div class="item item-1">1</div>
  <div class="item item-2">2</div>
  <div class="item item-3">3</div>
  <div class="item item-4">4</div>
  <div class="item item-5">5</div>
  <div class="item item-6">6</div>
  <div class="item item-7">7</div>
  <div class="item item-8">8</div>
  <div class="item item-9">9</div>
</div>
end:对齐容器的结束边框。
<style>
    #container20 {
        display: grid;
        grid-template-columns: 100px 100px 100px;
        grid-template-rows: 100px 100px 100px;
        justify-content: end;
    }
</style>
<div id="container20">
  <div class="item item-1">1</div>
  <div class="item item-2">2</div>
  <div class="item item-3">3</div>
  <div class="item item-4">4</div>
  <div class="item item-5">5</div>
  <div class="item item-6">6</div>
  <div class="item item-7">7</div>
  <div class="item item-8">8</div>
  <div class="item item-9">9</div>
</div>
space-around:每个项目两侧的间隔相等。所以，项目之间的间隔比项目与容器边框的间隔大一倍。
<style>
    #container21 {
        display: grid;
        grid-template-columns: 100px 100px 100px;
        grid-template-rows: 100px 100px 100px;
        justify-content: space-around;
    }
</style>
<div id="container21">
  <div class="item item-1">1</div>
  <div class="item item-2">2</div>
  <div class="item item-3">3</div>
  <div class="item item-4">4</div>
  <div class="item item-5">5</div>
  <div class="item item-6">6</div>
  <div class="item item-7">7</div>
  <div class="item item-8">8</div>
  <div class="item item-9">9</div>
</div>

<p>space-between:项目与项目的间隔相等，项目与容器边框之间没有间隔。</p>
<style>
    #container22 {
        display: grid;
        grid-template-columns: 100px 100px 100px;
        grid-template-rows: 100px 100px 100px;
        justify-content: space-between;
    }
</style>
<div id="container22">
  <div class="item item-1">1</div>
  <div class="item item-2">2</div>
  <div class="item item-3">3</div>
  <div class="item item-4">4</div>
  <div class="item item-5">5</div>
  <div class="item item-6">6</div>
  <div class="item item-7">7</div>
  <div class="item item-8">8</div>
  <div class="item item-9">9</div>
</div>

<p>space-evenly:项目与项目的间隔相等，项目与容器边框之间也是同样长度的间隔。</p>
<style>
    #container23 {
        display: grid;
        grid-template-columns: 100px 100px 100px;
        grid-template-rows: 100px 100px 100px;
        justify-content: space-evenly;
    }
</style>
<div id="container23">
  <div class="item item-1">1</div>
  <div class="item item-2">2</div>
  <div class="item item-3">3</div>
  <div class="item item-4">4</div>
  <div class="item item-5">5</div>
  <div class="item item-6">6</div>
  <div class="item item-7">7</div>
  <div class="item item-8">8</div>
  <div class="item item-9">9</div>
</div>


<h2 id="grid-auto-columns-属性，grid-auto-rows-属性"><a href="#grid-auto-columns-属性，grid-auto-rows-属性" class="headerlink" title="grid-auto-columns 属性，grid-auto-rows 属性"></a>grid-auto-columns 属性，grid-auto-rows 属性</h2><p>有时候，一些项目的指定位置，在现有网格的外部。比如网格只有3列，但是某一个项目指定在第5行。这时，浏览器会自动生成多余的网格，以便放置项目。</p>
<p>grid-auto-columns属性和grid-auto-rows属性用来设置，浏览器自动创建的多余网格的列宽和行高。它们的写法与grid-template-columns和grid-template-rows完全相同。如果不指定这两个属性，浏览器完全根据单元格内容的大小，决定新增网格的列宽和行高。</p>
<h2 id="grid-template-属性，grid-属性"><a href="#grid-template-属性，grid-属性" class="headerlink" title="grid-template 属性，grid 属性"></a>grid-template 属性，grid 属性</h2><p>grid-template属性是grid-template-columns、grid-template-rows和grid-template-areas这三个属性的合并简写形式。</p>
<p>grid属性是grid-template-rows、grid-template-columns、grid-template-areas、 grid-auto-rows、grid-auto-columns、grid-auto-flow这六个属性的合并简写形式。</p>
<h1 id="子元素属性"><a href="#子元素属性" class="headerlink" title="子元素属性"></a>子元素属性</h1><h2 id="grid-column-start-属性，grid-column-end-属性，grid-row-start-属，grid-row-end-属性"><a href="#grid-column-start-属性，grid-column-end-属性，grid-row-start-属，grid-row-end-属性" class="headerlink" title="grid-column-start 属性，grid-column-end 属性，grid-row-start 属，grid-row-end 属性"></a>grid-column-start 属性，grid-column-end 属性，grid-row-start 属，grid-row-end 属性</h2><p>· grid-column-start属性：左边框所在的垂直网格线<br>· grid-column-end属性：右边框所在的垂直网格线<br>· grid-row-start属性：上边框所在的水平网格线<br>· grid-row-end属性：下边框所在的水平网格线</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">.item-1 &#123;</span><br><span class="line">  grid-column-start: 1;</span><br><span class="line">  grid-column-end: 3;</span><br><span class="line">  grid-row-start: 2;</span><br><span class="line">  grid-row-end: 4;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.item-2 &#123;</span><br><span class="line">  grid-column-start: header-start;</span><br><span class="line">  grid-column-end: header-end;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<style>
    #container24 {
        display: grid;
        grid-template-columns: 100px 100px 100px;
        grid-template-rows: 100px 100px 100px;
    }
    #container24 .item-1 {
        grid-column-start: 2;
        grid-column-end: 4;
        
    }
</style>
<div id="container24">
  <div class="item item-1">1</div>
  <div class="item item-2">2</div>
  <div class="item item-3">3</div>
  <div class="item item-4">4</div>
  <div class="item item-5">5</div>
  <div class="item item-6">6</div>
  <div class="item item-7">7</div>
  <div class="item item-8">8</div>
  <div class="item item-9">9</div>
</div>

<p>这四个属性的值还可以使用span关键字，表示”跨越”，即左右边框（上下边框）之间跨越多少个网格。</p>
<style>
    #container25 {
        display: grid;
        grid-template-columns: 100px 100px 100px;
        grid-template-rows: 100px 100px 100px;
    }
    #container25 .item-1 {
        grid-column-start: span 2;
        
    }
    #container25 .item-2 {
        grid-row-end: span 4;
        
    }
</style>
<div id="container25">
  <div class="item item-1">1</div>
  <div class="item item-2">2</div>
  <div class="item item-3">3</div>
  <div class="item item-4">4</div>
  <div class="item item-5">5</div>
  <div class="item item-6">6</div>
  <div class="item item-7">7</div>
  <div class="item item-8">8</div>
  <div class="item item-9">9</div>
</div>
2. grid-column 属性，grid-row 属性

<p>grid-column属性是grid-column-start和grid-column-end的合并简写形式，grid-row属性是grid-row-start属性和grid-row-end的合并简写形式。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.item &#123;</span><br><span class="line">  grid-column: &lt;start-line&gt; / &lt;end-line&gt;;</span><br><span class="line">  grid-row: &lt;start-line&gt; / &lt;end-line&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>grid-area属性<br>grid-area属性指定项目放在哪一个区域。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.item-1 &#123;</span><br><span class="line">  grid-area: e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<style>
 #container26 {
     display: grid;
     grid-template-columns: 100px 100px 100px;
     grid-template-rows: 100px 100px 100px;
     grid-template-areas: 'a b c'
                         'd e f'
                         'g h i'
 }
 #container26 .item-1 {
     grid-area: e;
 }</li>
</ol>
<p></style><p></p>
<div id="container26">
  <div class="item item-1">1</div>
  <div class="item item-2">2</div>
  <div class="item item-3">3</div>
  <div class="item item-4">4</div>
  <div class="item item-5">5</div>
  <div class="item item-6">6</div>
  <div class="item item-7">7</div>
  <div class="item item-8">8</div>
  <div class="item item-9">9</div>
</div>
grid-area属性还可用作grid-row-start、grid-column-start、grid-row-end、grid-column-end的合并简写形式，直接指定项目的位置。

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">.item &#123;</span><br><span class="line">  grid-area: &lt;row-start&gt; / &lt;column-start&gt; / &lt;row-end&gt; / &lt;column-end&gt;;</span><br><span class="line">&#125;</span><br><span class="line">.item-1 &#123;</span><br><span class="line">  grid-area: 1 / 1 / 3 / 3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<style>
    #container27 {
        display: grid;
        grid-template-columns: 100px 100px 100px;
        grid-template-rows: 100px 100px 100px;
    }
    #container27 .item-1 {
        grid-area: 1 / 1 / 3 / 3;
        
    }

</style>
<div id="container27">
  <div class="item item-1">1</div>
  <div class="item item-2">2</div>
  <div class="item item-3">3</div>
  <div class="item item-4">4</div>
  <div class="item item-5">5</div>
  <div class="item item-6">6</div>
  <div class="item item-7">7</div>
  <div class="item item-8">8</div>
  <div class="item item-9">9</div>
</div>


<ol start="4">
<li>justify-self 属性，align-self 属性，place-self 属性</li>
</ol>
<p>justify-self属性设置单元格内容的水平位置（左中右），跟justify-items属性的用法完全一致，但只作用于单个项目。</p>
<p>align-self属性设置单元格内容的垂直位置（上中下），跟align-items属性的用法完全一致，也是只作用于单个项目。</p>
<p>place-self属性是align-self属性和justify-self属性的合并简写形式。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.item &#123;</span><br><span class="line">  justify-self: start | end | center | stretch;</span><br><span class="line">  align-self: start | end | center | stretch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>· start：对齐单元格的起始边缘。<br>· end：对齐单元格的结束边缘。<br>· center：单元格内部居中。<br>· stretch：拉伸，占满单元格的整个宽度（默认值）。</p>
</li></ol>]]></content>
      <categories>
        <category>css</category>
      </categories>
  </entry>
  <entry>
    <title>javascript面试-es6</title>
    <url>/2021/08/20/js%E9%9D%A2%E8%AF%95-es6/</url>
    <content><![CDATA[<h1 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a>ES6</h1><h2 id="let、const、var的区别"><a href="#let、const、var的区别" class="headerlink" title="let、const、var的区别"></a>let、const、var的区别</h2><p>1）块级作用域： 块作用域由 { }包括，let和const具有块级作用域，var不存在块级作用域。块级作用域解决了ES5中的两个问题：</p>
<pre><code>1. 内层变量可能覆盖外层变量
2. 用来计数的循环变量泄露为全局变量
</code></pre>
<p>（2）变量提升： var存在变量提升，let和const不存在变量提升，即在变量只能在声明之后使用，否在会报错。<br>（3）给全局添加属性： 浏览器的全局对象是window，Node的全局对象是global。var声明的变量为全局变量，并且会将该变量添加为全局对象的属性，但是let和const不会。<br>（4）重复声明： var声明变量时，可以重复声明变量，后声明的同名变量会覆盖之前声明的遍历。const和let不允许重复声明变量。<br>（5）暂时性死区： 在使用let、const命令声明变量之前，该变量都是不可用的。这在语法上，称为暂时性死区。使用var声明的变量不存在暂时性死区。<br>（6）初始值设置： 在变量声明时，var 和 let 可以不用设置初始值。而const声明变量必须设置初始值。<br>（7）指针指向： let和const都是ES6新增的用于创建变量的语法。 let创建的变量是可以更改指针指向（可以重新赋值）。但const声明的变量是不允许改变指针的指向。</p>
<h2 id="const对象的属性可以修改吗"><a href="#const对象的属性可以修改吗" class="headerlink" title="const对象的属性可以修改吗"></a>const对象的属性可以修改吗</h2><p>const保证的并不是变量的值不能改动，而是变量指向的那个内存地址不能改动。对于基本类型的数据（数值、字符串、布尔值），其值就保存在变量指向的那个内存地址，因此等同于常量。<br>但对于引用类型的数据（主要是对象和数组）来说，变量指向数据的内存地址，保存的只是一个指针，const只能保证这个指针是固定不变的，至于它指向的数据结构是不是可变的，就完全不能控制了。</p>
<h2 id="如果new一个箭头函数的会怎么样"><a href="#如果new一个箭头函数的会怎么样" class="headerlink" title="如果new一个箭头函数的会怎么样"></a>如果new一个箭头函数的会怎么样</h2><p>箭头函数是ES6中的提出来的，它没有prototype，也没有自己的this指向，更不可以使用arguments参数，所以不能New一个箭头函数。<br>new操作符的实现步骤如下：</p>
<p>创建一个对象<br>将构造函数的作用域赋给新对象（也就是将对象的__proto__属性指向构造函数的prototype属性）<br>指向构造函数中的代码，构造函数中的this指向该对象（也就是为这个对象添加属性和方法）<br>返回新的对象</p>
<p>所以，上面的第二、三步，箭头函数都是没有办法执行的。</p>
<h2 id="箭头函数与普通函数的区别"><a href="#箭头函数与普通函数的区别" class="headerlink" title="箭头函数与普通函数的区别"></a>箭头函数与普通函数的区别</h2><p>1.箭头函数比普通函数更加简洁</p>
<pre><code>· 如果没有参数，就直接写一个空括号即可
· 如果只有一个参数，可以省去参数的括号
· 如果有多个参数，用逗号分割
· 如果函数体的返回值只有一句，可以省略大括号
· 如果函数体不需要返回值，且只有一句话，可以给这个语句前面加一个void关键字。
</code></pre>
<p>2.箭头函数没有自己的this</p>
<p>箭头函数不会创建自己的this， 所以它没有自己的this，它只会在自己作用域的上一层继承this。所以箭头函数中this的指向在它在定义时已经确定了，之后不会改变。</p>
<ol start="3">
<li>箭头函数继承来的this指向永远不会改变</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var id = &#x27;GLOBAL&#x27;;</span><br><span class="line">var obj = &#123;</span><br><span class="line">  id: &#x27;OBJ&#x27;,</span><br><span class="line">  a: function()&#123;</span><br><span class="line">    console.log(this.id);</span><br><span class="line">  &#125;,</span><br><span class="line">  b: () =&gt; &#123;</span><br><span class="line">    console.log(this.id);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">obj.a();    // &#x27;OBJ&#x27;</span><br><span class="line">obj.b();    // &#x27;GLOBAL&#x27;</span><br><span class="line">new obj.a()  // undefined</span><br><span class="line">new obj.b()  // Uncaught TypeError: obj.b is not a constructor</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>对象obj的方法b是使用箭头函数定义的，这个函数中的this就永远指向它定义时所处的全局执行环境中的this，即便这个函数是作为对象obj的方法调用，this依旧指向Window对象。需要注意，定义对象的大括号{}是无法形成一个单独的执行环境的，它依旧是处于全局执行环境中。</p>
<ol start="4">
<li>call()、apply()、bind()等方法不能改变箭头函数中this的指向</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var id = &#x27;Global&#x27;;</span><br><span class="line">let fun1 = () =&gt; &#123;</span><br><span class="line">    console.log(this.id)</span><br><span class="line">&#125;;</span><br><span class="line">fun1();                     // &#x27;Global&#x27;</span><br><span class="line">fun1.call(&#123;id: &#x27;Obj&#x27;&#125;);     // &#x27;Global&#x27;</span><br><span class="line">fun1.apply(&#123;id: &#x27;Obj&#x27;&#125;);    // &#x27;Global&#x27;</span><br><span class="line">fun1.bind(&#123;id: &#x27;Obj&#x27;&#125;)();   // &#x27;Global&#x27;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="5">
<li>箭头函数不能作为构造函数使用<br>构造函数在new的步骤在上面已经说过了，实际上第二步就是将函数中的this指向该对象。 但是由于箭头函数时没有自己的this的，且this指向外层的执行环境，且不能改变指向，所以不能当做构造函数使用。</li>
<li>箭头函数没有自己的arguments<br>箭头函数没有自己的arguments对象。在箭头函数中访问arguments实际上获得的是它外层函数的arguments值。</li>
<li>箭头函数没有prototype</li>
<li>箭头函数不能用作Generator函数，不能使用yeild关键字</li>
</ol>
<h2 id="箭头函数的this指向哪⾥？"><a href="#箭头函数的this指向哪⾥？" class="headerlink" title="箭头函数的this指向哪⾥？"></a>箭头函数的this指向哪⾥？</h2><p>箭头函数不同于传统JavaScript中的函数，箭头函数并没有属于⾃⼰的this，它所谓的this是捕获其所在上下⽂的 this 值，作为⾃⼰的 this 值，并且由于没有属于⾃⼰的this，所以是不会被new调⽤的，这个所谓的this也不会被改变。<br>可以⽤Babel理解⼀下箭头函数:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// ES6 </span><br><span class="line">const obj = &#123; </span><br><span class="line">  getArrow() &#123; </span><br><span class="line">    return () =&gt; &#123; </span><br><span class="line">      console.log(this === obj); </span><br><span class="line">    &#125;; </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>转化后</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// ES5，由 Babel 转译</span><br><span class="line">var obj = &#123; </span><br><span class="line">   getArrow: function getArrow() &#123; </span><br><span class="line">     var _this = this; </span><br><span class="line">     return function () &#123; </span><br><span class="line">        console.log(_this === obj); </span><br><span class="line">     &#125;; </span><br><span class="line">   &#125; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="扩展运算符的作用及使用场景"><a href="#扩展运算符的作用及使用场景" class="headerlink" title="扩展运算符的作用及使用场景"></a>扩展运算符的作用及使用场景</h2><ol>
<li>对象扩展运算符</li>
</ol>
<p>对象的扩展运算符(…)用于取出参数对象中的所有可遍历属性，拷贝到当前对象之中。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let bar = &#123; a: 1, b: 2 &#125;;</span><br><span class="line">let baz = &#123; ...bar &#125;; // &#123; a: 1, b: 2 &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上述方法实际上等价于:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let bar = &#123; a: 1, b: 2 &#125;;</span><br><span class="line">let baz = Object.assign(&#123;&#125;, bar); // &#123; a: 1, b: 2 &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>Object.assign方法用于对象的合并，将源对象（source）的所有可枚举属性，复制到目标对象（target）。Object.assign方法的第一个参数是目标对象，后面的参数都是源对象。(如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性)。<br>同样，如果用户自定义的属性，放在扩展运算符后面，则扩展运算符内部的同名属性会被覆盖掉。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let bar = &#123;a: 1, b: 2&#125;;</span><br><span class="line">let baz = &#123;...bar, ...&#123;a:2, b: 4&#125;&#125;;  // &#123;a: 2, b: 4&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>利用上述特性就可以很方便的修改对象的部分属性。在redux中的reducer函数规定必须是一个纯函数，reducer中的state对象要求不能直接修改，可以通过扩展运算符把修改路径的对象都复制一遍，然后产生一个新的对象返回。<br>需要注意：扩展运算符对对象实例的拷贝属于浅拷贝。</p>
<ol start="2">
<li>数组扩展运算符</li>
</ol>
<p>数组的扩展运算符可以将一个数组转为用逗号分隔的参数序列，且每次只能展开一层数组。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">console.log(...[1, 2, 3])</span><br><span class="line">// 1 2 3</span><br><span class="line">console.log(...[1, [2, 3, 4], 5])</span><br><span class="line">// 1 [2, 3, 4] 5</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ol>
<li>将数组转换为参数序列</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function add(x, y) &#123;</span><br><span class="line">  return x + y;</span><br><span class="line">&#125;</span><br><span class="line">const numbers = [1, 2];</span><br><span class="line">add(...numbers) // 3</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ol start="2">
<li>复制数组<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const arr1 = [1, 2];</span><br><span class="line">const arr2 = [...arr1];</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li>合并数组<br>如果想在数组内合并数组，可以这样：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const arr1 = [&#x27;two&#x27;, &#x27;three&#x27;];const arr2 = [&#x27;one&#x27;, ...arr1, &#x27;four&#x27;, &#x27;five&#x27;];// [&quot;one&quot;, &quot;two&quot;, &quot;three&quot;, &quot;four&quot;, &quot;five&quot;]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
扩展运算符与解构赋值结合起来，用于生成数组<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const [first, ...rest] = [1, 2, 3, 4, 5];first // 1rest  // [2, 3, 4, 5]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
需要注意：如果将扩展运算符用于数组赋值，只能放在参数的最后一位，否则会报错。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const [...rest, last] = [1, 2, 3, 4, 5];         // 报错const [first, ...rest, last] = [1, 2, 3, 4, 5];  // 报错</span><br><span class="line"></span><br></pre></td></tr></table></figure>
将字符串转为真正的数组<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[...&#x27;hello&#x27;]    // [ &quot;h&quot;, &quot;e&quot;, &quot;l&quot;, &quot;l&quot;, &quot;o&quot; ]</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="Proxy-可以实现什么功能？"><a href="#Proxy-可以实现什么功能？" class="headerlink" title="Proxy 可以实现什么功能？"></a>Proxy 可以实现什么功能？</h2><p>在 Vue3.0 中通过 Proxy 来替换原本的 Object.defineProperty 来实现数据响应式。</p>
<p>Proxy 是 ES6 中新增的功能，它可以用来自定义对象中的操作。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let p = new Proxy(target, handler)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>target 代表需要添加代理的对象，handler 用来自定义对象中的操作，比如可以用来自定义 set 或者 get 函数。</p>
<p>下面来通过 Proxy 来实现一个数据响应式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let onWatch = (obj, setBind, getLogger) =&gt; &#123;</span><br><span class="line">  let handler = &#123;</span><br><span class="line">    get(target, property, receiver) &#123;</span><br><span class="line">      getLogger(target, property)</span><br><span class="line">      return Reflect.get(target, property, receiver)</span><br><span class="line">    &#125;,</span><br><span class="line">    set(target, property, value, receiver) &#123;</span><br><span class="line">      setBind(value, property)</span><br><span class="line">      return Reflect.set(target, property, value)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return new Proxy(obj, handler)</span><br><span class="line">&#125;</span><br><span class="line">let obj = &#123; a: 1 &#125;</span><br><span class="line">let p = onWatch(</span><br><span class="line">  obj,</span><br><span class="line">  (v, property) =&gt; &#123;</span><br><span class="line">    console.log(`监听到属性$&#123;property&#125;改变为$&#123;v&#125;`)</span><br><span class="line">  &#125;,</span><br><span class="line">  (target, property) =&gt; &#123;</span><br><span class="line">    console.log(`&#x27;$&#123;property&#125;&#x27; = $&#123;target[property]&#125;`)</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br><span class="line">p.a = 2 // 监听到属性a改变</span><br><span class="line">p.a // &#x27;a&#x27; = 2</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在上述代码中，通过自定义 set 和 get 函数的方式，在原本的逻辑中插入了我们的函数逻辑，实现了在对对象任何属性进行读写时发出通知。<br>当然这是简单版的响应式实现，如果需要实现一个 Vue 中的响应式，需要在 get 中收集依赖，在 set 派发更新，之所以 Vue3.0 要使用 Proxy 替换原本的 API 原因在于 Proxy 无需一层层递归为每个属性添加代理，一次即可完成以上操作，性能上更好，并且原本的实现有一些数据更新不能监听到，但是 Proxy 可以完美监听到任何方式的数据改变，唯一缺陷就是浏览器的兼容性不好。</p>
<h2 id="对对象与数组的解构的理解"><a href="#对对象与数组的解构的理解" class="headerlink" title="对对象与数组的解构的理解"></a>对对象与数组的解构的理解</h2><p>解构是 ES6 提供的一种新的提取数据的模式，这种模式能够从对象或数组里有针对性地拿到想要的数值。</p>
<ol>
<li>数组的解构</li>
</ol>
<p>在解构数组时，以元素的位置为匹配条件来提取想要的数据的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const [a, b, c] = [1, 2, 3]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>数组里的0、1、2索引位的元素值，精准地被映射到了左侧的第0、1、2个变量里去，这就是数组解构的工作模式。还可以通过给左侧变量数组设置空占位的方式，实现对数组中某几个元素的精准提取：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const [a,,c] = [1,2,3]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ol start="2">
<li>对象的解构 </li>
</ol>
<p> 对象解构比数组结构稍微复杂一些，也更显强大。在解构对象时，是以属性的名称为匹配条件，来提取想要的数据的。现在定义一个对象：</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> const stu = &#123;</span><br><span class="line">  name: &#x27;Bob&#x27;,</span><br><span class="line">  age: 24</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p> 假如想要解构它的两个自有属性，可以这样：<br> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const &#123; name, age &#125; = stu</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p> 注意，对象解构严格以属性名作为定位依据，所以就算调换了 name 和 age 的位置，结果也是一样的.</p>
<h2 id="如何提取高度嵌套的对象里的指定属性？"><a href="#如何提取高度嵌套的对象里的指定属性？" class="headerlink" title="如何提取高度嵌套的对象里的指定属性？"></a>如何提取高度嵌套的对象里的指定属性？</h2><p> 有时会遇到一些嵌套程度非常深的对象：</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> const school = &#123;</span><br><span class="line">   classes: &#123;</span><br><span class="line">      stu: &#123;</span><br><span class="line">         name: &#x27;Bob&#x27;,</span><br><span class="line">         age: 24,</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const &#123; classes: &#123; stu: &#123; name &#125; &#125;&#125; = school</span><br><span class="line">       </span><br><span class="line">console.log(name)  // &#x27;Bob&#x27;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="对-rest-参数的理解"><a href="#对-rest-参数的理解" class="headerlink" title="对 rest 参数的理解"></a>对 rest 参数的理解</h2><p> 扩展运算符被用在函数形参上时，它还可以把一个分离的参数序列整合成一个数组：</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> function mutiple(...args) &#123;</span><br><span class="line">  let result = 1;</span><br><span class="line">  for (var val of args) &#123;</span><br><span class="line">    result *= val;</span><br><span class="line">  &#125;</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br><span class="line">mutiple(1, 2, 3, 4) // 24</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p> 这里，传入 mutiple 的是四个分离的参数，但是如果在 mutiple 函数里尝试输出 args 的值，会发现它是一个数组：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function mutiple(...args) &#123;</span><br><span class="line">  console.log(args)</span><br><span class="line">&#125;</span><br><span class="line">mutiple(1, 2, 3, 4) // [1, 2, 3, 4]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这就是 … rest运算符的又一层威力了，它可以把函数的多个入参收敛进一个数组里。这一点经常用于获取函数的多余参数，或者像上面这样处理函数参数个数不确定的情况</p>
<h2 id="ES6中模板语法与字符串处理"><a href="#ES6中模板语法与字符串处理" class="headerlink" title="ES6中模板语法与字符串处理"></a>ES6中模板语法与字符串处理</h2><p>ES6 提出了“模板语法”的概念。在 ES6 以前，拼接字符串是很麻烦的事情：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var name = &#x27;css&#x27;   </span><br><span class="line">var career = &#x27;coder&#x27; </span><br><span class="line">var hobby = [&#x27;coding&#x27;, &#x27;writing&#x27;]</span><br><span class="line">var finalString = &#x27;my name is &#x27; + name + &#x27;, I work as a &#x27; + career + &#x27;, I love &#x27; + hobby[0] + &#x27; and &#x27; + hobby[1]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>仅仅几个变量，写了这么多加号，还要时刻小心里面的空格和标点符号有没有跟错地方。但是有了模板字符串，拼接难度直线下降：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var name = &#x27;css&#x27;   </span><br><span class="line">var career = &#x27;coder&#x27; </span><br><span class="line">var hobby = [&#x27;coding&#x27;, &#x27;writing&#x27;]</span><br><span class="line">var finalString = `my name is $&#123;name&#125;, I work as a $&#123;career&#125; I love $&#123;hobby[0]&#125; and $&#123;hobby[1]&#125;`</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>字符串不仅更容易拼了，也更易读了，代码整体的质量都变高了。这就是模板字符串的第一个优势——允许用${}的方式嵌入变量。但这还不是问题的关键，模板字符串的关键优势有两个：</p>
<p>在模板字符串中，空格、缩进、换行都会被保留<br>模板字符串完全支持“运算”式的表达式，可以在${}里完成一些计算</p>
<p>基于第一点，可以在模板字符串里无障碍地直接写 html 代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let list = `</span><br><span class="line">	&lt;ul&gt;</span><br><span class="line">		&lt;li&gt;列表项1&lt;/li&gt;</span><br><span class="line">		&lt;li&gt;列表项2&lt;/li&gt;</span><br><span class="line">	&lt;/ul&gt;</span><br><span class="line">`;</span><br><span class="line">console.log(message); // 正确输出，不存在报错</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>基于第二点，可以把一些简单的计算和调用丢进 ${} 来做：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function add(a, b) &#123;</span><br><span class="line">  const finalString = `$&#123;a&#125; + $&#123;b&#125; = $&#123;a+b&#125;`</span><br><span class="line">  console.log(finalString)</span><br><span class="line">&#125;</span><br><span class="line">add(1, 2) // 输出 &#x27;1 + 2 = 3&#x27;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>除了模板语法外， ES6中还新增了一系列的字符串方法用于提升开发效率：<br>（1）存在性判定：在过去，当判断一个字符/字符串是否在某字符串中时，只能用 indexOf &gt; -1 来做。现在 ES6 提供了三个方法：includes、startsWith、endsWith，它们都会返回一个布尔值来告诉你是否存在。</p>
<ol>
<li><p>includes：判断字符串与子串的包含关系：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const son = &#x27;haha&#x27; </span><br><span class="line">const father = &#x27;xixi haha hehe&#x27;</span><br><span class="line">father.includes(son) // true</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>startsWith：判断字符串是否以某个/某串字符开头：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const father = &#x27;xixi haha hehe&#x27;</span><br><span class="line">father.startsWith(&#x27;haha&#x27;) // false</span><br><span class="line">father.startsWith(&#x27;xixi&#x27;) // true</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>endsWith：判断字符串是否以某个/某串字符结尾：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const father = &#x27;xixi haha hehe&#x27;</span><br><span class="line">  father.endsWith(&#x27;hehe&#x27;) // true</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>（2）自动重复：可以使用 repeat 方法来使同一个字符串输出多次（被连续复制多次）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const sourceCode = &#x27;repeat for 3 times;&#x27;</span><br><span class="line">const repeated = sourceCode.repeat(3) </span><br><span class="line">console.log(repeated) // repeat for 3 times;repeat for 3 times;repeat for 3 times;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="什么是-IIFE-立即调用的函数表达式"><a href="#什么是-IIFE-立即调用的函数表达式" class="headerlink" title="什么是 IIFE (立即调用的函数表达式)"></a>什么是 IIFE (立即调用的函数表达式)</h1><p>IIFE是一个立即调用的函数表达式，它在创建后立即执行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(function IIFE()&#123;</span><br><span class="line">    console.log( &quot;Hello!&quot; );</span><br><span class="line">&#125;)();</span><br><span class="line">// &quot;Hello!&quot;</span><br></pre></td></tr></table></figure>
<p>常常使用此模式来避免污染全局命名空间，因为在IIFE中使用的所有变量(与任何其他普通函数一样)在其作用域之外都是不可见的。</p>
<h1 id="在-JS-中定义枚举的首选语法是什么"><a href="#在-JS-中定义枚举的首选语法是什么" class="headerlink" title="在 JS 中定义枚举的首选语法是什么"></a>在 JS 中定义枚举的首选语法是什么</h1><p>可以 Object.freeze 来实现枚举</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var DaysEnum = Object.freeze(&#123;</span><br><span class="line">    &quot;monday&quot;: 1,</span><br><span class="line">    &quot;tuesday&quot;: 2,</span><br><span class="line">    &quot;wednesday&quot;: 3,</span><br><span class="line">    ...</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var DaysEnum = &#123;</span><br><span class="line">    &quot;monday&quot;: 1,</span><br><span class="line">    &quot;tuesday&quot;: 2,</span><br><span class="line">    &quot;wednesday&quot;: 3,</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">Object.freeze(DaysEnum)</span><br></pre></td></tr></table></figure>
<p>但是，这阻止咱们把值分配给变量：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let day = DaysEnum.tuesday</span><br><span class="line">day = 298832342 // 不会报错</span><br></pre></td></tr></table></figure>

<h1 id="解释一下-Object-freeze-和-const-的区别"><a href="#解释一下-Object-freeze-和-const-的区别" class="headerlink" title="解释一下 Object.freeze() 和 const 的区别"></a>解释一下 Object.freeze() 和 const 的区别</h1><p>const和Object.freeze是两个完全不同的概念。<br>const 声明一个只读的变量，一旦声明，常量的值就不可改变：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">const person = &#123;</span><br><span class="line">    name: &quot;Leonardo&quot;</span><br><span class="line">&#125;;</span><br><span class="line">let animal = &#123;</span><br><span class="line">    species: &quot;snake&quot;</span><br><span class="line">&#125;;</span><br><span class="line">person = animal; // ERROR &quot;person&quot; is read-only    </span><br></pre></td></tr></table></figure>

<p>Object.freeze适用于值，更具体地说，适用于对象值，它使对象不可变，即不能更改其属性。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">let person = &#123;</span><br><span class="line">    name: &quot;Leonardo&quot;</span><br><span class="line">&#125;;</span><br><span class="line">let animal = &#123;</span><br><span class="line">    species: &quot;snake&quot;</span><br><span class="line">&#125;;</span><br><span class="line">Object.freeze(person);</span><br><span class="line">person.name = &quot;Lima&quot;; //TypeError: Cannot assign to read only property &#x27;name&#x27; of object</span><br><span class="line">console.log(person); </span><br></pre></td></tr></table></figure>


<h1 id="解释一下原型设计模式-Prototype-Pattern"><a href="#解释一下原型设计模式-Prototype-Pattern" class="headerlink" title="解释一下原型设计模式(Prototype Pattern)"></a>解释一下原型设计模式(Prototype Pattern)</h1><p>原型模式会创建新的对象，而不是创建未初始化的对象，它会返回使用从原型或样本对象复制的值进行初始化的对象。原型模式也称为属性模式。<br>原型模式有用的一个例子是使用与数据库中的默认值匹配的值初始化业务对象。原型对象保留默认值，这些默认值将被复制到新创建的业务对象中。<br>传统语言很少使用原型模式，但是JavaScript作为一种原型语言，在构建新对象及其原型时使用这种模式。</p>
<h1 id="能否比较模块模式与构造函数-原型模式的用法？"><a href="#能否比较模块模式与构造函数-原型模式的用法？" class="headerlink" title="能否比较模块模式与构造函数/原型模式的用法？"></a>能否比较模块模式与构造函数/原型模式的用法？</h1><p>模块模式通常用于命名空间，在该模式中，使用单个实例作为存储来对相关函数和对象进行分组。这是一个不同于原型设计的用例,它们并不是相互排斥,咱们可以同时使用它们(例如，将一个构造函数放在一个模块中，并使用new MyNamespace.MyModule.MyClass(arguments) )。<br>构造函数和原型是实现类和实例的合理方法之一。它们与模型并不完全对应，因此通常需要选择一个特定的scheme或辅助方法来实现原型中的类。</p>
<h1 id="举一个柯里化函数的例子，并说明柯里化的好处？"><a href="#举一个柯里化函数的例子，并说明柯里化的好处？" class="headerlink" title="举一个柯里化函数的例子，并说明柯里化的好处？"></a>举一个柯里化函数的例子，并说明柯里化的好处？</h1><p>柯里化是一种模式，其中一个具有多个参数的函数被分解成多个函数，当被串联调用时，这些函数将一次累加一个所需的所有参数。这种技术有助于使用函数式编写的代码更容易阅读和编写。需要注意的是，要实现一个函数，它需要从一个函数开始，然后分解成一系列函数，每个函数接受一个参数。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function curry(fn) &#123;</span><br><span class="line">  if (fn.length === 0) &#123;</span><br><span class="line">    return fn;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function _curried(depth, args) &#123;</span><br><span class="line">    return function(newArgument) &#123;</span><br><span class="line">      if (depth - 1 === 0) &#123;</span><br><span class="line">        return fn(...args, newArgument);</span><br><span class="line">      &#125;</span><br><span class="line">      return _curried(depth - 1, [...args, newArgument]);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return _curried(fn.length, []);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function add(a, b) &#123;</span><br><span class="line">  return a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var curriedAdd = curry(add);</span><br><span class="line">var addFive = curriedAdd(5);</span><br><span class="line"></span><br><span class="line">var result = [0, 1, 2, 3, 4, 5].map(addFive); // [5, 6, 7, 8, 9, 10]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="如何在-JS-中“深冻结”对象"><a href="#如何在-JS-中“深冻结”对象" class="headerlink" title="如何在 JS 中“深冻结”对象"></a>如何在 JS 中“深冻结”对象</h1><p>如果咱们想要确保对象被深冻结，就必须创建一个递归函数来冻结对象类型的每个属性：<br>没有深冻结</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let person = &#123;</span><br><span class="line">    name: &quot;Leonardo&quot;,</span><br><span class="line">    profession: &#123;</span><br><span class="line">        name: &quot;developer&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">Object.freeze(person); </span><br><span class="line">person.profession.name = &quot;doctor&quot;;</span><br><span class="line">console.log(person); //output &#123; name: &#x27;Leonardo&#x27;, profession: &#123; name: &#x27;doctor&#x27; &#125; &#125;</span><br></pre></td></tr></table></figure>
<p>深冻结</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function deepFreeze(object) &#123;</span><br><span class="line">    let propNames = Object.getOwnPropertyNames(object);</span><br><span class="line">    for (let name of propNames) &#123;</span><br><span class="line">        let value = object[name];</span><br><span class="line">        object[name] = value &amp;&amp; typeof value === &quot;object&quot; ?</span><br><span class="line">            deepFreeze(value) : value;</span><br><span class="line">    &#125;</span><br><span class="line">    return Object.freeze(object);</span><br><span class="line">&#125;</span><br><span class="line">let person = &#123;</span><br><span class="line">    name: &quot;Leonardo&quot;,</span><br><span class="line">    profession: &#123;</span><br><span class="line">        name: &quot;developer&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">deepFreeze(person);</span><br><span class="line">person.profession.name = &quot;doctor&quot;; // TypeError: Cannot assign to read only property &#x27;name&#x27; of object</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="Reflect是什么，有什么作用？"><a href="#Reflect是什么，有什么作用？" class="headerlink" title="Reflect是什么，有什么作用？"></a>Reflect是什么，有什么作用？</h2><p>Reflect是ES6引入的一个新的对象，他的主要作用有两点，一是将原生的一些零散分布在Object、Function或者全局函数里的方法(如apply、delete、get、set等等)，统一整合到Reflect上，这样可以更加方便更加统一的管理一些原生API。其次就是因为Proxy可以改写默认的原生API，如果一旦原生API别改写可能就找不到了，所以Reflect也可以起到备份原生API的作用，使得即使原生API被改写了之后，也可以在被改写之后的API用上默认的API。</p>
<ul>
<li><p>定义：保持Object方法的默认行为</p>
</li>
<li><p>方法</p>
<ul>
<li>get()：返回对象属性</li>
<li>set()：设置对象属性，返回布尔</li>
<li>has()：检查对象属性，返回布尔</li>
<li>deleteProperty()：删除对象属性，返回布尔</li>
<li>defineProperty()：定义对象属性，返回布尔</li>
<li>ownKeys()：遍历对象属性，返回数组(Object.getOwnPropertyNames()+Object.getOwnPropertySymbols())</li>
<li>getOwnPropertyDescriptor()：返回对象属性描述，返回对象</li>
<li>getPrototypeOf()：返回对象原型，返回对象</li>
<li>setPrototypeOf()：设置对象原型，返回布尔</li>
<li>isExtensible()：返回对象是否可扩展，返回布尔</li>
<li>preventExtensions()：设置对象不可扩展，返回布尔</li>
<li>apply()：绑定this后执行指定函数</li>
<li>construct()：调用构造函数创建实例</li>
</ul>
</li>
<li><p>设计目的</p>
<ul>
<li>将Object属于语言内部的方法放到Reflect上</li>
<li>将某些Object方法报错情况改成返回false</li>
<li>让Object操作变成函数行为</li>
<li>Proxy与Reflect相辅相成</li>
</ul>
</li>
<li><p>废弃方法</p>
<ul>
<li>Object.defineProperty() =&gt; Reflect.defineProperty()</li>
<li>Object.getOwnPropertyDescriptor() =&gt; Reflect.getOwnPropertyDescriptor()</li>
</ul>
</li>
<li><p>重点难点</p>
<ul>
<li>Proxy方法和Reflect方法一一对应</li>
<li>Proxy和Reflect联合使用，前者负责拦截赋值操作，后者负责完成赋值操作</li>
</ul>
</li>
</ul>
<ul>
<li>数据绑定：观察者模式</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const observerQueue = new Set();</span><br><span class="line">const observe = fn =&gt; observerQueue.add(fn);</span><br><span class="line">const observable = obj =&gt; new Proxy(obj, &#123;</span><br><span class="line">    set(tgt, key, val, receiver) &#123;</span><br><span class="line">        const result = Reflect.set(tgt, key, val, receiver);</span><br><span class="line">        observerQueue.forEach(v =&gt; v());</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">const person = observable(&#123; age: 25, name: &quot;Yajun&quot; &#125;);</span><br><span class="line">const print = () =&gt; console.log(`$&#123;person.name&#125; is $&#123;person.age&#125; years old`);</span><br><span class="line">observe(print);</span><br><span class="line">person.name = &quot;Joway&quot;;</span><br></pre></td></tr></table></figure>

<h1 id="Iterator是什么，有什么作用？"><a href="#Iterator是什么，有什么作用？" class="headerlink" title="Iterator是什么，有什么作用？"></a>Iterator是什么，有什么作用？</h1><p>  Iterator是ES6中一个很重要概念，它并不是对象，也不是任何一种数据类型。因为ES6新增了Set、Map类型，他们和Array、Object类型很像，Array、Object都是可以遍历的，但是Set、Map都不能用for循环遍历，解决这个问题有两种方案，一种是为Set、Map单独新增一个用来遍历的API，另一种是为Set、Map、Array、Object新增一个统一的遍历API，显然，第二种更好，ES6也就顺其自然的需要一种设计标准，来统一所有可遍历类型的遍历方式。Iterator正是这样一种标准。或者说是一种规范理念。<br>就好像JavaScript是ECMAScript标准的一种具体实现一样，Iterator标准的具体实现是Iterator遍历器。Iterator标准规定，所有部署了key值为[Symbol.iterator]，且[Symbol.iterator]的value是标准的Iterator接口函数(标准的Iterator接口函数: 该函数必须返回一个对象，且对象中包含next方法，且执行next()能返回包含value/done属性的Iterator对象)的对象，都称之为可遍历对象，next()后返回的Iterator对象也就是Iterator遍历器。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//obj就是可遍历的，因为它遵循了Iterator标准，且包含[Symbol.iterator]方法，方法函数也符合标准的Iterator接口规范。</span><br><span class="line">//obj.[Symbol.iterator]() 就是Iterator遍历器</span><br><span class="line">let obj = &#123;</span><br><span class="line">  data: [ &#x27;hello&#x27;, &#x27;world&#x27; ],</span><br><span class="line">  [Symbol.iterator]() &#123;</span><br><span class="line">    const self = this;</span><br><span class="line">    let index = 0;</span><br><span class="line">    return &#123;</span><br><span class="line">      next() &#123;</span><br><span class="line">        if (index &lt; self.data.length) &#123;</span><br><span class="line">          return &#123;</span><br><span class="line">            value: self.data[index++],</span><br><span class="line">            done: false</span><br><span class="line">          &#125;;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          return &#123; value: undefined, done: true &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>ES6给Set、Map、Array、String都加上了[Symbol.iterator]方法，且[Symbol.iterator]方法函数也符合标准的Iterator接口规范，所以Set、Map、Array、String默认都是可以遍历的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//Array</span><br><span class="line">let array = [&#x27;red&#x27;, &#x27;green&#x27;, &#x27;blue&#x27;];</span><br><span class="line">array[Symbol.iterator]() //Iterator遍历器</span><br><span class="line">array[Symbol.iterator]().next() //&#123;value: &quot;red&quot;, done: false&#125;</span><br><span class="line"></span><br><span class="line">//String</span><br><span class="line">let string = &#x27;1122334455&#x27;;</span><br><span class="line">string[Symbol.iterator]() //Iterator遍历器</span><br><span class="line">string[Symbol.iterator]().next() //&#123;value: &quot;1&quot;, done: false&#125;</span><br><span class="line"></span><br><span class="line">//set</span><br><span class="line">let set = new Set([&#x27;red&#x27;, &#x27;green&#x27;, &#x27;blue&#x27;]);</span><br><span class="line">set[Symbol.iterator]() //Iterator遍历器</span><br><span class="line">set[Symbol.iterator]().next() //&#123;value: &quot;red&quot;, done: false&#125;</span><br><span class="line"></span><br><span class="line">//Map</span><br><span class="line">let map = new Map();</span><br><span class="line">let obj= &#123;map: &#x27;map&#x27;&#125;;</span><br><span class="line">map.set(obj, &#x27;mapValue&#x27;);</span><br><span class="line">map[Symbol.iterator]().next()  &#123;value: Array(2), done: false&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="Generator函数是什么，有什么作用？"><a href="#Generator函数是什么，有什么作用？" class="headerlink" title="Generator函数是什么，有什么作用？"></a>Generator函数是什么，有什么作用？</h2><p>如果说JavaScript是ECMAScript标准的一种具体实现、Iterator遍历器是Iterator的具体实现，那么Generator函数可以说是Iterator接口的具体实现方式。<br>执行Generator函数会返回一个遍历器对象，每一次Generator函数里面的yield都相当一次遍历器对象的next()方法，并且可以通过next(value)方法传入自定义的value,来改变Generator函数的行为。<br>Generator函数可以通过配合Thunk 函数更轻松更优雅的实现异步编程和控制流管理。</p>
]]></content>
      <categories>
        <category>面试</category>
        <category>js</category>
      </categories>
  </entry>
  <entry>
    <title>javascript面试-异步编程</title>
    <url>/2021/08/19/js%E9%9D%A2%E8%AF%95-%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="异步编程的实现方式？"><a href="#异步编程的实现方式？" class="headerlink" title="异步编程的实现方式？"></a>异步编程的实现方式？</h1><p>JavaScript中的异步机制可以分为以下几种：</p>
<ul>
<li>回调函数 的方式，使用回调函数的方式有一个缺点是，多个回调函数嵌套的时候会造成回调函数地狱，上下两层的回调函数间的代码耦合度太高，不利于代码的可维护。</li>
<li>Promise 的方式，使用 Promise 的方式可以将嵌套的回调函数作为链式调用。但是使用这种方法，有时会造成多个 then 的链式调用，可能会造成代码的语义不够明确。</li>
<li>generator 的方式，它可以在函数的执行过程中，将函数的执行权转移出去，在函数外部还可以将执行权转移回来。当遇到异步函数执行的时候，将函数执行权转移出去，当异步函数执行完毕时再将执行权给转移回来。因此在 generator 内部对于异步操作的方式，可以以同步的顺序来书写。使用这种方式需要考虑的问题是何时将函数的控制权转移回来，因此需要有一个自动执行 generator 的机制，比如说 co 模块等方式来实现 generator 的自动执行。</li>
<li>async 函数 的方式，async 函数是 generator 和 promise 实现的一个自动执行的语法糖，它内部自带执行器，当函数内部执行到一个 await 语句的时候，如果语句返回一个 promise 对象，那么函数将会等待 promise 对象的状态变为 resolve 后再继续向下执行。因此可以将异步逻辑，转化为同步的顺序来书写，并且这个函数可以自动执行。</li>
</ul>
<h1 id="setTimeout、Promise、Async-Await-的区别"><a href="#setTimeout、Promise、Async-Await-的区别" class="headerlink" title="setTimeout、Promise、Async/Await 的区别"></a>setTimeout、Promise、Async/Await 的区别</h1><p>（1）setTimeout</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">console.log(&#x27;script start&#x27;)	//1. 打印 script start</span><br><span class="line">setTimeout(function()&#123;</span><br><span class="line">    console.log(&#x27;settimeout&#x27;)	// 4. 打印 settimeout</span><br><span class="line">&#125;)	// 2. 调用 setTimeout 函数，并定义其完成后执行的回调函数</span><br><span class="line">console.log(&#x27;script end&#x27;)	//3. 打印 script start</span><br><span class="line">// 输出顺序：script start-&gt;script end-&gt;settimeout</span><br></pre></td></tr></table></figure>
<p>（2）Promise<br>Promise本身是同步的立即执行函数， 当在executor中执行resolve或者reject的时候, 此时是异步操作， 会先执行then/catch等，当主栈完成后，才会去调用resolve/reject中存放的方法执行，打印p的时候，是打印的返回结果，一个Promise实例。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">console.log(&#x27;script start&#x27;)</span><br><span class="line">let promise1 = new Promise(function (resolve) &#123;</span><br><span class="line">    console.log(&#x27;promise1&#x27;)</span><br><span class="line">    resolve()</span><br><span class="line">    console.log(&#x27;promise1 end&#x27;)</span><br><span class="line">&#125;).then(function () &#123;</span><br><span class="line">    console.log(&#x27;promise2&#x27;)</span><br><span class="line">&#125;)</span><br><span class="line">setTimeout(function()&#123;</span><br><span class="line">    console.log(&#x27;settimeout&#x27;)</span><br><span class="line">&#125;)</span><br><span class="line">console.log(&#x27;script end&#x27;)</span><br><span class="line">// 输出顺序: script start-&gt;promise1-&gt;promise1 end-&gt;script end-&gt;promise2-&gt;settimeout</span><br></pre></td></tr></table></figure>
<p>当JS主线程执行到Promise对象时：</p>
<ul>
<li>promise1.then() 的回调就是一个 task</li>
<li>promise1 是 resolved或rejected: 那这个 task 就会放入当前事件循环回合的 microtask queue</li>
<li>promise1 是 pending: 这个 task 就会放入 事件循环的未来的某个(可能下一个)回合的 microtask queue 中</li>
<li>setTimeout 的回调也是个 task ，它会被放入 macrotask queue 即使是 0ms 的情况</li>
</ul>
<p>（3）async/await</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">async function async1()&#123;</span><br><span class="line">   console.log(&#x27;async1 start&#x27;);</span><br><span class="line">    await async2();</span><br><span class="line">    console.log(&#x27;async1 end&#x27;)</span><br><span class="line">&#125;</span><br><span class="line">async function async2()&#123;</span><br><span class="line">    console.log(&#x27;async2&#x27;)</span><br><span class="line">&#125;</span><br><span class="line">console.log(&#x27;script start&#x27;);</span><br><span class="line">async1();</span><br><span class="line">console.log(&#x27;script end&#x27;)</span><br><span class="line">// 输出顺序：script start-&gt;async1 start-&gt;async2-&gt;script end-&gt;async1 end</span><br></pre></td></tr></table></figure>
<p>async 函数返回一个 Promise 对象，当函数执行的时候，一旦遇到 await 就会先返回，等到触发的异步操作完成，再执行函数体内后面的语句。可以理解为，是让出了线程，跳出了 async 函数体。<br>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">async function func1() &#123;</span><br><span class="line">    return 1</span><br><span class="line">&#125;</span><br><span class="line">console.log(func1())</span><br></pre></td></tr></table></figure>

<p>func1的运行结果其实就是一个Promise对象。因此也可以使用then来处理后续逻辑。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">func1().then(res =&gt; &#123;</span><br><span class="line">    console.log(res);  // 30</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>await的含义为等待，也就是 async 函数需要等待await后的函数执行完成并且有了返回结果（Promise对象）之后，才能继续执行下面的代码。await通过返回一个Promise对象来实现同步的效果。</p>
<h1 id="对Promise的理解"><a href="#对Promise的理解" class="headerlink" title="对Promise的理解"></a>对Promise的理解</h1><p>Promise是异步编程的一种解决方案，它是一个对象，可以获取异步操作的消息，他的出现大大改善了异步编程的困境，避免了地狱回调，它比传统的解决方案回调函数和事件更合理和更强大。<br>所谓Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。</p>
<h2 id="Promise的实例有三个状态"><a href="#Promise的实例有三个状态" class="headerlink" title="Promise的实例有三个状态:"></a>Promise的实例有三个状态:</h2><ul>
<li>Pending（进行中）</li>
<li>Resolved（已完成）</li>
<li>Rejected（已拒绝）</li>
</ul>
<p>当把一件事情交给promise时，它的状态就是Pending，任务完成了状态就变成了Resolved、没有完成失败了就变成了Rejected。</p>
<h2 id="Promise的实例有两个过程："><a href="#Promise的实例有两个过程：" class="headerlink" title="Promise的实例有两个过程："></a>Promise的实例有两个过程：</h2><ul>
<li>pending -&gt; fulfilled : Resolved（已完成）</li>
<li>pending -&gt; rejected：Rejected（已拒绝）</li>
</ul>
<p>注意：一旦从进行状态变成为其他状态就永远不能更改状态了。<br>Promise的特点：</p>
<ul>
<li>对象的状态不受外界影响。promise对象代表一个异步操作，有三种状态，pending（进行中）、fulfilled（已成功）、rejected（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态，这也是promise这个名字的由来——“承诺”；</li>
<li>一旦状态改变就不会再变，任何时候都可以得到这个结果。promise对象的状态改变，只有两种可能：从pending变为fulfilled，从pending变为rejected。这时就称为resolved（已定型）。如果改变已经发生了，你再对promise对象添加回调函数，也会立即得到这个结果。这与事件（event）完全不同，事件的特点是：如果你错过了它，再去监听是得不到结果的。</li>
</ul>
<p>Promise的缺点：</p>
<ul>
<li>无法取消Promise，一旦新建它就会立即执行，无法中途取消。</li>
<li>如果不设置回调函数，Promise内部抛出的错误，不会反应到外部。</li>
<li>当处于pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。</li>
</ul>
<p>总结：<br>Promise 对象是异步编程的一种解决方案，最早由社区提出。Promise 是一个构造函数，接收一个函数作为参数，返回一个 Promise 实例。一个 Promise 实例有三种状态，分别是pending、resolved 和 rejected，分别代表了进行中、已成功和已失败。实例的状态只能由 pending 转变 resolved 或者rejected 状态，并且状态一经改变，就凝固了，无法再被改变了。<br>状态的改变是通过 resolve() 和 reject() 函数来实现的，可以在异步操作结束后调用这两个函数改变 Promise 实例的状态，它的原型上定义了一个 then 方法，使用这个 then 方法可以为两个状态的改变注册回调函数。这个回调函数属于微任务，会在本轮事件循环的末尾执行。<br>注意： 在构造 Promise 的时候，构造函数内部的代码是立即执行的</p>
<h1 id="Promise的基本用法"><a href="#Promise的基本用法" class="headerlink" title="Promise的基本用法"></a>Promise的基本用法</h1><h2 id="创建Promise对象"><a href="#创建Promise对象" class="headerlink" title="创建Promise对象"></a>创建Promise对象</h2><p>Promise对象代表一个异步操作，有三种状态：pending（进行中）、fulfilled（已成功）和rejected（已失败）。<br>Promise构造函数接受一个函数作为参数，该函数的两个参数分别是resolve和reject。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const promise = new Promise(function(resolve, reject) &#123;</span><br><span class="line">  // ... some code</span><br><span class="line">  if (/* 异步操作成功 */)&#123;</span><br><span class="line">    resolve(value);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    reject(error);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>一般情况下都会使用new Promise()来创建promise对象，但是也可以使用promise.resolve和promise.reject这两个方法：</p>
<ol>
<li>Promise.resolve</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Promise.resolve(value)的返回值也是一个promise对象，可以对返回值进行.then调用，代码如下：</span><br><span class="line">Promise.resolve(11).then(function(value)&#123;</span><br><span class="line">  console.log(value); // 打印出11</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>resolve(11)代码中，会让promise对象进入确定(resolve状态)，并将参数11传递给后面的then所指定的onFulfilled 函数；<br>创建promise对象可以使用new Promise的形式创建对象，也可以使用Promise.resolve(value)的形式创建promise对象；</p>
<ol start="2">
<li>Promise.reject</li>
</ol>
<p>Promise.reject 也是new Promise的快捷形式，也创建一个promise对象。代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Promise.reject(new Error(“我错了，请原谅俺！！”));</span><br></pre></td></tr></table></figure>
<p>就是下面的代码new Promise的简单形式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">new Promise(function(resolve,reject)&#123;</span><br><span class="line">   reject(new Error(&quot;我错了！&quot;));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>下面是使用resolve方法和reject方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function testPromise(ready) &#123;</span><br><span class="line">  return new Promise(function(resolve,reject)&#123;</span><br><span class="line">    if(ready) &#123;</span><br><span class="line">      resolve(&quot;hello world&quot;);</span><br><span class="line">    &#125;else &#123;</span><br><span class="line">      reject(&quot;No thanks&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line">// 方法调用</span><br><span class="line">testPromise(true).then(function(msg)&#123;</span><br><span class="line">  console.log(msg);</span><br><span class="line">&#125;,function(error)&#123;</span><br><span class="line">  console.log(error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>上面的代码的含义是给testPromise方法传递一个参数，返回一个promise对象，如果为true的话，那么调用promise对象中的resolve()方法，并且把其中的参数传递给后面的then第一个函数内，因此打印出 “hello world”, 如果为false的话，会调用promise对象中的reject()方法，则会进入then的第二个函数内，会打印No thanks；</p>
<h2 id="Promise方法"><a href="#Promise方法" class="headerlink" title="Promise方法"></a>Promise方法</h2><p>Promise有五个常用的方法：then()、catch()、all()、race()、finally。下面就来看一下这些方法。</p>
<ol>
<li>then()</li>
</ol>
<p>当Promise执行的内容符合成功条件时，调用resolve函数，失败就调用reject函数。Promise创建完了，那该如何调用呢？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">promise.then(function(value) &#123;</span><br><span class="line">  // success</span><br><span class="line">&#125;, function(error) &#123;</span><br><span class="line">  // failure</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>then方法可以接受两个回调函数作为参数。第一个回调函数是Promise对象的状态变为resolved时调用，第二个回调函数是Promise对象的状态变为rejected时调用。其中第二个参数可以省略。<br>then方法返回的是一个新的Promise实例（不是原来那个Promise实例）。因此可以采用链式写法，即then方法后面再调用另一个then方法。<br>当要写有顺序的异步事件时，需要串行时，可以这样写：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let promise = new Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">    ajax(&#x27;first&#x27;).success(function(res)&#123;</span><br><span class="line">        resolve(res);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line">promise.then(res=&gt;&#123;</span><br><span class="line">    return new Promise((resovle,reject)=&gt;&#123;</span><br><span class="line">        ajax(&#x27;second&#x27;).success(function(res)&#123;</span><br><span class="line">            resolve(res)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;).then(res=&gt;&#123;</span><br><span class="line">    return new Promise((resovle,reject)=&gt;&#123;</span><br><span class="line">        ajax(&#x27;second&#x27;).success(function(res)&#123;</span><br><span class="line">            resolve(res)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;).then(res=&gt;&#123;</span><br><span class="line">    </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>那当要写的事件没有顺序或者关系时，还如何写呢？可以使用all 方法来解决。<br>2. catch()<br>Promise对象除了有then方法，还有一个catch方法，该方法相当于then方法的第二个参数，指向reject的回调函数。不过catch方法还有一个作用，就是在执行resolve回调函数时，如果出现错误，抛出异常，不会停止运行，而是进入catch方法中。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">p.then((data) =&gt; &#123;</span><br><span class="line">     console.log(&#x27;resolved&#x27;,data);</span><br><span class="line">&#125;,(err) =&gt; &#123;</span><br><span class="line">     console.log(&#x27;rejected&#x27;,err);</span><br><span class="line">     &#125;</span><br><span class="line">); </span><br><span class="line">p.then((data) =&gt; &#123;</span><br><span class="line">    console.log(&#x27;resolved&#x27;,data);</span><br><span class="line">&#125;).catch((err) =&gt; &#123;</span><br><span class="line">    console.log(&#x27;rejected&#x27;,err);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>all()<br>all方法可以完成并行任务， 它接收一个数组，数组的每一项都是一个promise对象。当数组中所有的promise的状态都达到resolved的时候，all方法的状态就会变成resolved，如果有一个状态变成了rejected，那么all方法的状态就会变成rejected。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let promise1 = new Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">	setTimeout(()=&gt;&#123;</span><br><span class="line">       resolve(1);</span><br><span class="line">	&#125;,2000)</span><br><span class="line">&#125;);</span><br><span class="line">let promise2 = new Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">	setTimeout(()=&gt;&#123;</span><br><span class="line">       resolve(2);</span><br><span class="line">	&#125;,1000)</span><br><span class="line">&#125;);</span><br><span class="line">let promise3 = new Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">	setTimeout(()=&gt;&#123;</span><br><span class="line">       resolve(3);</span><br><span class="line">	&#125;,3000)</span><br><span class="line">&#125;);</span><br><span class="line">Promise.all([promise1,promise2,promise3]).then(res=&gt;&#123;</span><br><span class="line">    console.log(res);</span><br><span class="line">    //结果为：[1,2,3] </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
调用all方法时的结果成功的时候是回调函数的参数也是一个数组，这个数组按顺序保存着每一个promise对象resolve执行时的值。<br>（4）race()<br>race方法和all一样，接受的参数是一个每项都是promise的数组，但是与all不同的是，当最先执行完的事件执行完之后，就直接返回该promise对象的值。如果第一个promise对象状态变成resolved，那自身的状态变成了resolved；反之第一个promise变成rejected，那自身状态就会变成rejected。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let promise1 = new Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">	setTimeout(()=&gt;&#123;</span><br><span class="line">       reject(1);</span><br><span class="line">	&#125;,2000)</span><br><span class="line">&#125;);</span><br><span class="line">let promise2 = new Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">	setTimeout(()=&gt;&#123;</span><br><span class="line">       resolve(2);</span><br><span class="line">	&#125;,1000)</span><br><span class="line">&#125;);</span><br><span class="line">let promise3 = new Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">	setTimeout(()=&gt;&#123;</span><br><span class="line">       resolve(3);</span><br><span class="line">	&#125;,3000)</span><br><span class="line">&#125;);</span><br><span class="line">Promise.race([promise1,promise2,promise3]).then(res=&gt;&#123;</span><br><span class="line">	console.log(res);</span><br><span class="line">	//结果：2</span><br><span class="line">&#125;,rej=&gt;&#123;</span><br><span class="line">    console.log(rej)&#125;;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
那么race方法有什么实际作用呢？当要做一件事，超过多长时间就不做了，可以用这个方法来解决：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Promise.race([promise1,timeOutPromise(5000)]).then(res=&gt;&#123;&#125;)</span><br></pre></td></tr></table></figure></li>
<li>finally()<br>finally方法用于指定不管 Promise 对象最后状态如何，都会执行的操作。该方法是 ES2018 引入标准的。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">promise</span><br><span class="line">.then(result =&gt; &#123;···&#125;)</span><br><span class="line">.catch(error =&gt; &#123;···&#125;)</span><br><span class="line">.finally(() =&gt; &#123;···&#125;);</span><br></pre></td></tr></table></figure>
上面代码中，不管promise最后的状态，在执行完then或catch指定的回调函数以后，都会执行finally方法指定的回调函数。<br>下面是一个例子，服务器使用 Promise 处理请求，然后使用finally方法关掉服务器。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">server.listen(port)</span><br><span class="line">  .then(function () &#123;</span><br><span class="line">    // ...</span><br><span class="line">  &#125;)</span><br><span class="line">  .finally(server.stop);</span><br></pre></td></tr></table></figure>
finally方法的回调函数不接受任何参数，这意味着没有办法知道，前面的 Promise 状态到底是fulfilled还是rejected。这表明，finally方法里面的操作，应该是与状态无关的，不依赖于 Promise 的执行结果。finally本质上是then方法的特例：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">promise</span><br><span class="line">.finally(() =&gt; &#123;</span><br><span class="line">  // 语句</span><br><span class="line">&#125;);</span><br><span class="line">// 等同于</span><br><span class="line">promise</span><br><span class="line">.then(</span><br><span class="line">  result =&gt; &#123;</span><br><span class="line">    // 语句</span><br><span class="line">    return result;</span><br><span class="line">  &#125;,</span><br><span class="line">  error =&gt; &#123;</span><br><span class="line">    // 语句</span><br><span class="line">    throw error;</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
上面代码中，如果不使用finally方法，同样的语句需要为成功和失败两种情况各写一次。有了finally方法，则只需要写一次。<h1 id="Promise解决了什么问题"><a href="#Promise解决了什么问题" class="headerlink" title="Promise解决了什么问题"></a>Promise解决了什么问题</h1>在工作中经常会碰到这样一个需求，比如我使用ajax发一个A请求后，成功后拿到数据，需要把数据传给B请求；那么需要如下编写代码：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let fs = require(&#x27;fs&#x27;)</span><br><span class="line">fs.readFile(&#x27;./a.txt&#x27;,&#x27;utf8&#x27;,function(err,data)&#123;</span><br><span class="line">  fs.readFile(data,&#x27;utf8&#x27;,function(err,data)&#123;</span><br><span class="line">    fs.readFile(data,&#x27;utf8&#x27;,function(err,data)&#123;</span><br><span class="line">      console.log(data)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
上面的代码有如下缺点：</li>
</ol>
<ul>
<li>后一个请求需要依赖于前一个请求成功后，将数据往下传递，会导致多个ajax请求嵌套的情况，代码不够直观。</li>
<li>如果前后两个请求不需要传递参数的情况下，那么后一个请求也需要前一个请求成功后再执行下一步操作，这种情况下，那么也需要如上编写代码，导致代码不够直观。</li>
</ul>
<p>Promise出现之后，代码变成这样：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let fs = require(&#x27;fs&#x27;)</span><br><span class="line">function read(url)&#123;</span><br><span class="line">  return new Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">    fs.readFile(url,&#x27;utf8&#x27;,function(error,data)&#123;</span><br><span class="line">      error &amp;&amp; reject(error)</span><br><span class="line">      resolve(data)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line">read(&#x27;./a.txt&#x27;).then(data=&gt;&#123;</span><br><span class="line">  return read(data) </span><br><span class="line">&#125;).then(data=&gt;&#123;</span><br><span class="line">  return read(data)  </span><br><span class="line">&#125;).then(data=&gt;&#123;</span><br><span class="line">  console.log(data)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>这样代码看起了就简洁了很多，解决了地狱回调的问题。</p>
<h1 id="Promise-all和Promise-race的区别的使用场景"><a href="#Promise-all和Promise-race的区别的使用场景" class="headerlink" title="Promise.all和Promise.race的区别的使用场景"></a>Promise.all和Promise.race的区别的使用场景</h1><p>（1）Promise.all<br>Promise.all可以将多个Promise实例包装成一个新的Promise实例。同时，成功和失败的返回值是不同的，成功的时候返回的是一个结果数组，而失败的时候则返回最先被reject失败状态的值。<br>Promise.all中传入的是数组，返回的也是是数组，并且会将进行映射，传入的promise对象返回的值是按照顺序在数组中排列的，但是注意的是他们执行的顺序并不是按照顺序的，除非可迭代对象为空。<br>需要注意，Promise.all获得的成功结果的数组里面的数据顺序和Promise.all接收到的数组顺序是一致的，这样当遇到发送多个请求并根据请求顺序获取和使用数据的场景，就可以使用Promise.all来解决。<br>（2）Promise.race<br>顾名思义，Promse.race就是赛跑的意思，意思就是说，Promise.race([p1, p2, p3])里面哪个结果获得的快，就返回那个结果，不管结果本身是成功状态还是失败状态。当要做一件事，超过多长时间就不做了，可以用这个方法来解决：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Promise.race([promise1,timeOutPromise(5000)]).then(res=&gt;&#123;&#125;)</span><br></pre></td></tr></table></figure>
<h1 id="对async-await-的理解"><a href="#对async-await-的理解" class="headerlink" title="对async/await 的理解"></a>对async/await 的理解</h1><p>async/await其实是Generator 的语法糖，它能实现的效果都能用then链来实现，它是为优化then链而开发出来的。从字面上来看，async是“异步”的简写，await则为等待，所以很好理解async 用于申明一个 function 是异步的，而 await 用于等待一个异步方法执行完成。当然语法上强制规定await只能出现在asnyc函数中，先来看看async函数返回了什么：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">async function testAsy()&#123;</span><br><span class="line">   return &#x27;hello world&#x27;;</span><br><span class="line">&#125;</span><br><span class="line">let result = testAsy(); </span><br><span class="line">console.log(result)</span><br></pre></td></tr></table></figure>

<p>所以，async 函数返回的是一个 Promise 对象。async 函数（包含函数语句、函数表达式、Lambda表达式）会返回一个 Promise 对象，如果在函数中 return 一个直接量，async 会把这个直接量通过 Promise.resolve() 封装成 Promise 对象。<br>async 函数返回的是一个 Promise 对象，所以在最外层不能用 await 获取其返回值的情况下，当然应该用原来的方式：then() 链来处理这个 Promise 对象，就像这样：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">async function testAsy()&#123;</span><br><span class="line">   return &#x27;hello world&#x27;</span><br><span class="line">&#125;</span><br><span class="line">let result = testAsy() </span><br><span class="line">console.log(result)</span><br><span class="line">result.then(v=&gt;&#123;</span><br><span class="line">    console.log(v)   // hello world</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>那如果 async 函数没有返回值，又该如何？很容易想到，它会返回 Promise.resolve(undefined)。<br>联想一下 Promise 的特点——无等待，所以在没有 await 的情况下执行 async 函数，它会立即执行，返回一个 Promise 对象，并且，绝不会阻塞后面的语句。这和普通返回 Promise 对象的函数并无二致。<br>注意：Promise.resolve(x) 可以看作是 new Promise(resolve =&gt; resolve(x)) 的简写，可以用于快速封装字面量对象或其他对象，将其封装成 Promise 实例。</p>
<h1 id="await-到底在等啥？"><a href="#await-到底在等啥？" class="headerlink" title="await 到底在等啥？"></a>await 到底在等啥？</h1><p>await 在等待什么呢？ 一般来说，都认为 await 是在等待一个 async 函数完成。不过按语法说明，await 等待的是一个表达式，这个表达式的计算结果是 Promise 对象或者其它值（换句话说，就是没有特殊限定）。<br>因为 async 函数返回一个 Promise 对象，所以 await 可以用于等待一个 async 函数的返回值——这也可以说是 await 在等 async 函数，但要清楚，它等的实际是一个返回值。注意到 await 不仅仅用于等 Promise 对象，它可以等任意表达式的结果，所以，await 后面实际是可以接普通函数调用或者直接量的。所以下面这个示例完全可以正确运行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function getSomething() &#123;</span><br><span class="line">    return &quot;something&quot;;</span><br><span class="line">&#125;</span><br><span class="line">async function testAsync() &#123;</span><br><span class="line">    return Promise.resolve(&quot;hello async&quot;);</span><br><span class="line">&#125;</span><br><span class="line">async function test() &#123;</span><br><span class="line">    const v1 = await getSomething();</span><br><span class="line">    const v2 = await testAsync();</span><br><span class="line">    console.log(v1, v2);</span><br><span class="line">&#125;</span><br><span class="line">test();</span><br></pre></td></tr></table></figure>
<p>await 表达式的运算结果取决于它等的是什么。</p>
<ul>
<li>如果它等到的不是一个 Promise 对象，那 await 表达式的运算结果就是它等到的东西。</li>
<li>如果它等到的是一个 Promise 对象，await 就忙起来了，它会阻塞后面的代码，等着 Promise 对象 resolve，然后得到 resolve 的值，作为 await 表达式的运算结果。</li>
</ul>
<p>来看一个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function testAsy(x)&#123;</span><br><span class="line">   return new Promise(resolve=&gt;&#123;setTimeout(() =&gt; &#123;</span><br><span class="line">       resolve(x);</span><br><span class="line">     &#125;, 3000)</span><br><span class="line">    &#125;</span><br><span class="line">   )</span><br><span class="line">&#125;</span><br><span class="line">async function testAwt()&#123;    </span><br><span class="line">  let result =  await testAsy(&#x27;hello world&#x27;);</span><br><span class="line">  console.log(result);    // 3秒钟之后出现hello world</span><br><span class="line">  console.log(&#x27;cuger&#x27;)   // 3秒钟之后出现cug</span><br><span class="line">&#125;</span><br><span class="line">testAwt();</span><br><span class="line">console.log(&#x27;cug&#x27;)  //立即输出cug</span><br></pre></td></tr></table></figure>
<p>这就是 await 必须用在 async 函数中的原因。async 函数调用不会造成阻塞，它内部所有的阻塞都被封装在一个 Promise 对象中异步执行。await暂停当前async的执行，所以’cug’’最先输出，hello world’和‘cuger’是3秒钟后同时出现的。</p>
<h1 id="async-await的优势"><a href="#async-await的优势" class="headerlink" title="async/await的优势"></a>async/await的优势</h1><p>单一的 Promise 链并不能发现 async/await 的优势，但是，如果需要处理由多个 Promise 组成的 then 链的时候，优势就能体现出来了（很有意思，Promise 通过 then 链来解决多层回调的问题，现在又用 async/await 来进一步优化它）。<br>假设一个业务，分多个步骤完成，每个步骤都是异步的，而且依赖于上一个步骤的结果。仍然用 setTimeout 来模拟异步操作：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 传入参数 n，表示这个函数执行的时间（毫秒）</span><br><span class="line"> * 执行的结果是 n + 200，这个值将用于下一步骤</span><br><span class="line"> */</span><br><span class="line">function takeLongTime(n) &#123;</span><br><span class="line">    return new Promise(resolve =&gt; &#123;</span><br><span class="line">        setTimeout(() =&gt; resolve(n + 200), n);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">function step1(n) &#123;</span><br><span class="line">    console.log(`step1 with $&#123;n&#125;`);</span><br><span class="line">    return takeLongTime(n);</span><br><span class="line">&#125;</span><br><span class="line">function step2(n) &#123;</span><br><span class="line">    console.log(`step2 with $&#123;n&#125;`);</span><br><span class="line">    return takeLongTime(n);</span><br><span class="line">&#125;</span><br><span class="line">function step3(n) &#123;</span><br><span class="line">    console.log(`step3 with $&#123;n&#125;`);</span><br><span class="line">    return takeLongTime(n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在用 Promise 方式来实现这三个步骤的处理：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function doIt() &#123;</span><br><span class="line">    console.time(&quot;doIt&quot;);</span><br><span class="line">    const time1 = 300;</span><br><span class="line">    step1(time1)</span><br><span class="line">        .then(time2 =&gt; step2(time2))</span><br><span class="line">        .then(time3 =&gt; step3(time3))</span><br><span class="line">        .then(result =&gt; &#123;</span><br><span class="line">            console.log(`result is $&#123;result&#125;`);</span><br><span class="line">            console.timeEnd(&quot;doIt&quot;);</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;</span><br><span class="line">doIt();</span><br><span class="line">// c:\var\test&gt;node --harmony_async_await .</span><br><span class="line">// step1 with 300</span><br><span class="line">// step2 with 500</span><br><span class="line">// step3 with 700</span><br><span class="line">// result is 900</span><br><span class="line">// doIt: 1507.251ms</span><br></pre></td></tr></table></figure>
<p>输出结果 result 是 step3() 的参数 700 + 200 = 900。doIt() 顺序执行了三个步骤，一共用了 300 + 500 + 700 = 1500 毫秒，和 console.time()/console.timeEnd() 计算的结果一致。<br>如果用 async/await 来实现呢，会是这样：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">async function doIt() &#123;</span><br><span class="line">    console.time(&quot;doIt&quot;);</span><br><span class="line">    const time1 = 300;</span><br><span class="line">    const time2 = await step1(time1);</span><br><span class="line">    const time3 = await step2(time2);</span><br><span class="line">    const result = await step3(time3);</span><br><span class="line">    console.log(`result is $&#123;result&#125;`);</span><br><span class="line">    console.timeEnd(&quot;doIt&quot;);</span><br><span class="line">&#125;</span><br><span class="line">doIt();</span><br></pre></td></tr></table></figure>
<p>结果和之前的 Promise 实现是一样的，但是这个代码看起来是不是清晰得多，几乎跟同步代码一样</p>
<h1 id="async-await对比Promise的优势"><a href="#async-await对比Promise的优势" class="headerlink" title="async/await对比Promise的优势"></a>async/await对比Promise的优势</h1><ul>
<li>代码读起来更加同步，Promise虽然摆脱了回调地狱，但是then的链式调⽤也会带来额外的阅读负担</li>
<li>Promise传递中间值⾮常麻烦，⽽async/await⼏乎是同步的写法，⾮常优雅</li>
<li>错误处理友好，async/await可以⽤成熟的try/catch，Promise的错误捕获⾮常冗余</li>
<li>调试友好，Promise的调试很差，由于没有代码块，你不能在⼀个返回表达式的箭头函数中设置断点，如果你在⼀个.then代码块中使⽤调试器的步进(step-over)功能，调试器并不会进⼊后续的.then代码块，因为调试器只能跟踪同步代码的每⼀步。</li>
</ul>
<h1 id="async-await-如何捕获异常"><a href="#async-await-如何捕获异常" class="headerlink" title="async/await 如何捕获异常"></a>async/await 如何捕获异常</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">async function fn()&#123;</span><br><span class="line">    try&#123;</span><br><span class="line">        let a = await Promise.reject(&#x27;error&#x27;)</span><br><span class="line">    &#125;catch(error)&#123;</span><br><span class="line">        console.log(error)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="并发与并行的区别？"><a href="#并发与并行的区别？" class="headerlink" title="并发与并行的区别？"></a>并发与并行的区别？</h1><ul>
<li>并发是宏观概念，我分别有任务 A 和任务 B，在一段时间内通过任务间的切换完成了这两个任务，这种情况就可以称之为并发。</li>
<li>并行是微观概念，假设 CPU 中存在两个核心，那么我就可以同时完成任务 A、B。同时完成多个任务的情况就可以称之为并行。</li>
</ul>
<h1 id="什么是回调函数？回调函数有什么缺点？如何解决回调地狱问题？"><a href="#什么是回调函数？回调函数有什么缺点？如何解决回调地狱问题？" class="headerlink" title="什么是回调函数？回调函数有什么缺点？如何解决回调地狱问题？"></a>什么是回调函数？回调函数有什么缺点？如何解决回调地狱问题？</h1><p>以下代码就是一个回调函数的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ajax(url, () =&gt; &#123;</span><br><span class="line">    // 处理逻辑</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>回调函数有一个致命的弱点，就是容易写出回调地狱（Callback hell）。假设多个请求存在依赖性，可能会有如下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ajax(url, () =&gt; &#123;</span><br><span class="line">    // 处理逻辑</span><br><span class="line">    ajax(url1, () =&gt; &#123;</span><br><span class="line">        // 处理逻辑</span><br><span class="line">        ajax(url2, () =&gt; &#123;</span><br><span class="line">            // 处理逻辑</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>以上代码看起来不利于阅读和维护，当然，也可以把函数分开来写：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function firstAjax() &#123;</span><br><span class="line">  ajax(url1, () =&gt; &#123;</span><br><span class="line">    // 处理逻辑</span><br><span class="line">    secondAjax()</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line">function secondAjax() &#123;</span><br><span class="line">  ajax(url2, () =&gt; &#123;</span><br><span class="line">    // 处理逻辑</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line">ajax(url, () =&gt; &#123;</span><br><span class="line">  // 处理逻辑</span><br><span class="line">  firstAjax()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>以上的代码虽然看上去利于阅读了，但是还是没有解决根本问题。回调地狱的根本问题就是：</p>
<ol>
<li>嵌套函数存在耦合性，一旦有所改动，就会牵一发而动全身</li>
<li>嵌套函数一多，就很难处理错误</li>
</ol>
<p>当然，回调函数还存在着别的几个缺点，比如不能使用 try catch 捕获错误，不能直接 return。</p>
<h1 id="setTimeout、setInterval、requestAnimationFrame-各有什么特点？"><a href="#setTimeout、setInterval、requestAnimationFrame-各有什么特点？" class="headerlink" title="setTimeout、setInterval、requestAnimationFrame 各有什么特点？"></a>setTimeout、setInterval、requestAnimationFrame 各有什么特点？</h1><p>异步编程当然少不了定时器了，常见的定时器函数有 setTimeout、setInterval、requestAnimationFrame。最常用的是setTimeout，很多人认为 setTimeout 是延时多久，那就应该是多久后执行。<br>其实这个观点是错误的，因为 JS 是单线程执行的，如果前面的代码影响了性能，就会导致 setTimeout 不会按期执行。当然了，可以通过代码去修正 setTimeout，从而使定时器相对准确：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let period = 60 * 1000 * 60 * 2</span><br><span class="line">let startTime = new Date().getTime()</span><br><span class="line">let count = 0</span><br><span class="line">let end = new Date().getTime() + period</span><br><span class="line">let interval = 1000</span><br><span class="line">let currentInterval = interval</span><br><span class="line">function loop() &#123;</span><br><span class="line">  count++</span><br><span class="line">  // 代码执行所消耗的时间</span><br><span class="line">  let offset = new Date().getTime() - (startTime + count * interval);</span><br><span class="line">  let diff = end - new Date().getTime()</span><br><span class="line">  let h = Math.floor(diff / (60 * 1000 * 60))</span><br><span class="line">  let hdiff = diff % (60 * 1000 * 60)</span><br><span class="line">  let m = Math.floor(hdiff / (60 * 1000))</span><br><span class="line">  let mdiff = hdiff % (60 * 1000)</span><br><span class="line">  let s = mdiff / (1000)</span><br><span class="line">  let sCeil = Math.ceil(s)</span><br><span class="line">  let sFloor = Math.floor(s)</span><br><span class="line">  // 得到下一次循环所消耗的时间</span><br><span class="line">  currentInterval = interval - offset </span><br><span class="line">  console.log(&#x27;时：&#x27;+h, &#x27;分：&#x27;+m, &#x27;毫秒：&#x27;+s, &#x27;秒向上取整：&#x27;+sCeil, &#x27;代码执行时间：&#x27;+offset, &#x27;下次循环间隔&#x27;+currentInterval) </span><br><span class="line">  setTimeout(loop, currentInterval)</span><br><span class="line">&#125;</span><br><span class="line">setTimeout(loop, currentInterval)</span><br></pre></td></tr></table></figure>
<p>接下来看 setInterval，其实这个函数作用和 setTimeout 基本一致，只是该函数是每隔一段时间执行一次回调函数。<br>通常来说不建议使用 setInterval。第一，它和 setTimeout 一样，不能保证在预期的时间执行任务。第二，它存在执行累积的问题，请看以下伪代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function demo() &#123;</span><br><span class="line">  setInterval(function()&#123;</span><br><span class="line">    console.log(2)</span><br><span class="line">  &#125;,1000)</span><br><span class="line">  sleep(2000)</span><br><span class="line">&#125;</span><br><span class="line">demo()</span><br></pre></td></tr></table></figure>
<p>以上代码在浏览器环境中，如果定时器执行过程中出现了耗时操作，多个回调函数会在耗时操作结束以后同时执行，这样可能就会带来性能上的问题。<br>如果有循环定时器的需求，其实完全可以通过 requestAnimationFrame 来实现：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function setInterval(callback, interval) &#123;</span><br><span class="line">  let timer</span><br><span class="line">  const now = Date.now</span><br><span class="line">  let startTime = now()</span><br><span class="line">  let endTime = startTime</span><br><span class="line">  const loop = () =&gt; &#123;</span><br><span class="line">    timer = window.requestAnimationFrame(loop)</span><br><span class="line">    endTime = now()</span><br><span class="line">    if (endTime - startTime &gt;= interval) &#123;</span><br><span class="line">      startTime = endTime = now()</span><br><span class="line">      callback(timer)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  timer = window.requestAnimationFrame(loop)</span><br><span class="line">  return timer</span><br><span class="line">&#125;</span><br><span class="line">let a = 0</span><br><span class="line">setInterval(timer =&gt; &#123;</span><br><span class="line">  console.log(1)</span><br><span class="line">  a++</span><br><span class="line">  if (a === 3) cancelAnimationFrame(timer)</span><br><span class="line">&#125;, 1000)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>面试</category>
        <category>js</category>
      </categories>
  </entry>
  <entry>
    <title>javascript面试-数据类型</title>
    <url>/2021/08/19/js%E9%9D%A2%E8%AF%95-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><h1 id="js中有哪些数据类型，他们的区别是？"><a href="#js中有哪些数据类型，他们的区别是？" class="headerlink" title="js中有哪些数据类型，他们的区别是？"></a>js中有哪些数据类型，他们的区别是？</h1><p>8种原始数据类型：Null, Undefined, Boolean, Number, String,Object,Symbol,BigInt</p>
<p>其中Symbol和BigInt是新增的数据类型：</p>
<ol>
<li>Symbol代表创建后独一无二的数据类型，它主要是为了解决可能出现的全局变量冲突的问题。</li>
<li>BigInt是一种数字类型的数据，它可以表示任意精度格式的整数，使用BigInt可以安全的存储和操作大数据，即使这个数已经超出了Number能够表示的安全整数范围（-2^53 到 2^53 之间（不含两个端点）.）。</li>
</ol>
<p>这些数据可以分为原始数据类型和引用数据类型：</p>
<ol>
<li>栈：原始数据类型（Undefined,Null,Boolean,Number,String）</li>
<li>堆：引用数据类型（对象，数组和函数）</li>
</ol>
<p>两种类型的区别在于存位置的不同：</p>
<ol>
<li>原始数据类型直接存储在栈（stack）中的简单数据段，占据空间小，大小固定，属于被频繁使用数据，所以放入栈中存储；</li>
<li>引用数据类型存储在堆（heap）中的对象，占据空间大，大小不固定。如果存储在栈中，将会影响程序运行的性能；引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索起在栈中的地址，取得地址后从堆中获得实体。</li>
</ol>
<p>堆和栈的概念存在与数据结构和操作系统内存中，在数据结构中：</p>
<ol>
<li>在数据结构中，栈中数据的存取方式为先进后出。</li>
<li>堆是一个优先队列，是按优先级来进行排序的，优先级可以按照大小来规定。</li>
</ol>
<p>在操作系统中，内存被分为栈区和堆区：</p>
<ol>
<li>栈区内存由编译器自动分配释放，存放函数的参数值，局部变量的值等。其操作方式类似与数据结构中的栈。</li>
<li>堆区内存一般由开发者分配释放，若开发者不释放，程序结束时可能由垃圾回收机制回收。</li>
</ol>
<h1 id="JS中Number是双精度浮点型，-意味着可以表示的范围是2-63次方么？如果不是的话，应该是多少呢？"><a href="#JS中Number是双精度浮点型，-意味着可以表示的范围是2-63次方么？如果不是的话，应该是多少呢？" class="headerlink" title="JS中Number是双精度浮点型， 意味着可以表示的范围是2^63次方么？如果不是的话，应该是多少呢？"></a>JS中Number是双精度浮点型， 意味着可以表示的范围是2^63次方么？如果不是的话，应该是多少呢？</h1><p>JavaScript 的 Number 类型使用 53 位表示小数位，10 位表示指数位，1 位表示符号位。<br>-2^53 到 2^53 之间（不含两个端点）</p>
<h1 id="数据类型检测的方式有哪些？"><a href="#数据类型检测的方式有哪些？" class="headerlink" title="数据类型检测的方式有哪些？"></a>数据类型检测的方式有哪些？</h1><ol>
<li><p>typeof</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">console.log(typeof 2);               // number</span><br><span class="line">console.log(typeof true);            // boolean</span><br><span class="line">console.log(typeof &#x27;str&#x27;);           // string</span><br><span class="line">console.log(typeof []);              // object    </span><br><span class="line">console.log(typeof function()&#123;&#125;);    // function</span><br><span class="line">console.log(typeof &#123;&#125;);              // object</span><br><span class="line">console.log(typeof undefined);       // undefined</span><br><span class="line">console.log(typeof null);            // object （表示一个空对象引用）</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>其中数组、对象、null都会被判断为object，其他判断都正确</p>
</li>
<li><p>instanceof<br>instanceof 可以正确判断对象的类型，其内部运行机制是判断在其原型链中能否找到该类型的原型。</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">console.log(2 instanceof Number);                    // false</span><br><span class="line">console.log(true instanceof Boolean);                // false </span><br><span class="line">console.log(&#x27;str&#x27; instanceof String);                // false </span><br><span class="line"> </span><br><span class="line">console.log([] instanceof Array);                    // true</span><br><span class="line">console.log(function()&#123;&#125; instanceof Function);       // true</span><br><span class="line">console.log(&#123;&#125; instanceof Object);                   // true</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以看到，instanceof只能正确判断引用数据类型，而不能判断基本数据类型。instanceof运算符可以用来测试一个对象在其原型链中是否存在一个构造函数的prototype属性。</p>
<ol start="3">
<li>constructor</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">console.log((2).constructor === Number); // true</span><br><span class="line">console.log((true).constructor === Boolean); // true</span><br><span class="line">console.log((&#x27;str&#x27;).constructor === String); // true</span><br><span class="line">console.log(([]).constructor === Array); // true</span><br><span class="line">console.log((function() &#123;&#125;).constructor === Function); // true</span><br><span class="line">console.log((&#123;&#125;).constructor === Object); // true</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>constructor有两个作用，一是判断数据的类型，二是对象实例通过constructor对象访问它的构造函数。需要注意，如果创建一个对象来改变它的原型，constructor就不能用来判断数据类型来：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function Fn()&#123;&#125;;</span><br><span class="line"> </span><br><span class="line">Fn.prototype = new Array();</span><br><span class="line"> </span><br><span class="line">var f = new Fn();</span><br><span class="line"> </span><br><span class="line">console.log(f.constructor===Fn);    // false</span><br><span class="line">console.log(f.constructor===Array); // true</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="4">
<li>Object.prototype.toString.call()</li>
</ol>
<p>Object.prototype.toString.call()使用Object对象的原型方法toString来判断数据类型：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var a = Object.prototype.toString;</span><br><span class="line"> </span><br><span class="line">console.log(a.call(2));</span><br><span class="line">console.log(a.call(true));</span><br><span class="line">console.log(a.call(&#x27;str&#x27;));</span><br><span class="line">console.log(a.call([]));</span><br><span class="line">console.log(a.call(function()&#123;&#125;));</span><br><span class="line">console.log(a.call(&#123;&#125;));</span><br><span class="line">console.log(a.call(undefined));</span><br><span class="line">console.log(a.call(null));</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>同样是检测对象obj调用toString方法，obj.toString()的结果和Object.prototype.toString.call(obj)的结果不一样，这是为什么？<br>这是因为toString是Object的原型方法，而Array、function等类型作为Object的实例，都重写了toString方法。不同的对象类型调用toString方法时，根据原型链的知识，调用的是对应的重写之后的toString方法（function类型返回内容为函数体的字符串，Array类型返回元素组成的字符串…），而不会去调用Object上原型toString方法（返回对象的具体类型），所以采用obj.toString()不能得到其对象类型，只能将obj转换为字符串类型；因此，在想要得到对象的具体类型时，应该调用Object原型上的toString方法。</p>
<h1 id="判断数组的方式有哪些"><a href="#判断数组的方式有哪些" class="headerlink" title="判断数组的方式有哪些"></a>判断数组的方式有哪些</h1><ol>
<li>通过Object.prototype.toString.call()做判断</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Object.prototype.toString.call(obj).slice(8,-1) === &#x27;Array&#x27;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>通过原型链做判断</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">obj.__proto__ === Array.prototype;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>通过ES6的Array.isArray()做判断</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Array.isArrray(obj);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="4">
<li>通过instanceof做判断</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">obj instanceof Array</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="5">
<li>通过Array.prototype.isPrototypeOf<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Array.prototype.isPrototypeOf(obj)</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="null和undefined区别"><a href="#null和undefined区别" class="headerlink" title="null和undefined区别"></a>null和undefined区别</h1><p>首先 Undefined 和 Null 都是基本数据类型，这两个基本数据类型分别都只有一个值，就是 undefined 和 null。<br>undefined 代表的含义是未定义，null 代表的含义是空对象。一般变量声明了但还没有定义的时候会返回 undefined，null主要用于赋值给一些可能会返回对象的变量，作为初始化。<br>undefined 在 JavaScript 中不是一个保留字，这意味着可以使用 undefined 来作为一个变量名，但是这样的做法是非常危险的，它会影响对 undefined 值的判断。我们可以通过一些方法获得安全的 undefined 值，比如说 void 0。<br>当对这两种类型使用 typeof 进行判断时，Null 类型化会返回 “object”，这是一个历史遗留的问题。当使用双等号对两种类型的值进行比较时会返回 true，使用三个等号时会返回 false。</p>
<h1 id="typeof-null-的结果是什么，为什么？"><a href="#typeof-null-的结果是什么，为什么？" class="headerlink" title="typeof null 的结果是什么，为什么？"></a>typeof null 的结果是什么，为什么？</h1><p>typeof null 的结果是Object。<br>在 JavaScript 第一个版本中，所有值都存储在 32 位的单元中，每个单元包含一个小的 类型标签(1-3 bits) 以及当前要存储值的真实数据。类型标签存储在每个单元的低位中，共有五种数据类型：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">000: object   - 当前存储的数据指向一个对象。</span><br><span class="line">  1: int      - 当前存储的数据是一个 31 位的有符号整数。</span><br><span class="line">010: double   - 当前存储的数据指向一个双精度的浮点数。</span><br><span class="line">100: string   - 当前存储的数据指向一个字符串。</span><br><span class="line">110: boolean  - 当前存储的数据是布尔值。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果最低位是 1，则类型标签标志位的长度只有一位；如果最低位是 0，则类型标签标志位的长度占三位，为存储其他四种数据类型提供了额外两个 bit 的长度。<br>有两种特殊数据类型：</p>
<p>undefined的值是 (-2)30(一个超出整数范围的数字)；<br>null 的值是机器码 NULL 指针(null 指针的值全是 0)</p>
<p>那也就是说null的类型标签也是000，和Object的类型标签一样，所以会被判定为Object。</p>
<h1 id="intanceof-操作符的实现原理及实现"><a href="#intanceof-操作符的实现原理及实现" class="headerlink" title="intanceof 操作符的实现原理及实现"></a>intanceof 操作符的实现原理及实现</h1><p>instanceof 运算符用于判断构造函数的 prototype 属性是否出现在对象的原型链中的任何位置。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function myInstanceof(left, right) &#123;</span><br><span class="line">  // 获取对象的原型</span><br><span class="line">  let proto = Object.getPrototypeOf(left)</span><br><span class="line">  // 获取构造函数的 prototype 对象</span><br><span class="line">  let prototype = right.prototype; </span><br><span class="line"> </span><br><span class="line">  // 判断构造函数的 prototype 对象是否在对象的原型链上</span><br><span class="line">  while (true) &#123;</span><br><span class="line">    if (!proto) return false;</span><br><span class="line">    if (proto === prototype) return true;</span><br><span class="line">    // 如果没有找到，就继续从其原型上找，Object.getPrototypeOf方法用来获取指定对象的原型</span><br><span class="line">    proto = Object.getPrototypeOf(proto);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="为什么0-1-0-2-0-3，如何让其相等"><a href="#为什么0-1-0-2-0-3，如何让其相等" class="headerlink" title="为什么0.1+0.2 ! == 0.3，如何让其相等"></a>为什么0.1+0.2 ! == 0.3，如何让其相等</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0.1+0.2 = 0.30000000000000004 !== 0.3</span><br></pre></td></tr></table></figure>
<p>这里得到的不是想要的结果，要想等于0.3，就要把它进行转化：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(n1 + n2).toFixed(2) // 注意，toFixed为四舍五入</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol>
<li><p>toFixed(num) 方法</p>
</li>
<li><p>设置一个误差范围，通常称为“机器精度”。对JavaScript来说，这个值通常为2-52，在ES6中，提供了Number.EPSILON属性，而它的值就是2-52，只要判断0.1+0.2-0.3是否小于Number.EPSILON，如果小于，就可以判断为0.1+0.2 ===0.3</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function numberepsilon(arg1,arg2)&#123;                   </span><br><span class="line">  return Math.abs(arg1 - arg2) &lt; Number.EPSILON;        </span><br><span class="line">&#125;        </span><br><span class="line"></span><br><span class="line">console.log(numberepsilon(0.1 + 0.2, 0.3)); // true</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="如何获取安全的-undefined-值？"><a href="#如何获取安全的-undefined-值？" class="headerlink" title="如何获取安全的 undefined 值？"></a>如何获取安全的 undefined 值？</h1><p>因为 undefined 是一个标识符，所以可以被当作变量来使用和赋值，但是这样会影响 undefined 的正常判断。表达式 void ___ 没有返回值，因此返回结果是 undefined。void 并不改变表达式的结果，只是让表达式不返回值。因此可以用 void 0 来获得 undefined。</p>
<h1 id="typeof-NaN-的结果是什么？"><a href="#typeof-NaN-的结果是什么？" class="headerlink" title="typeof NaN 的结果是什么？"></a>typeof NaN 的结果是什么？</h1><p>NaN 指“不是一个数字”（not a number），NaN 是一个“警戒值”（sentinel value，有特殊用途的常规值），用于指出数字类型中的错误情况，即“执行数学运算没有成功，这是失败后返回的结果”。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">typeof NaN; // &quot;number&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>NaN 是一个特殊值，它和自身不相等，是唯一一个非自反（自反，reflexive，即 x === x 不成立）的值。而 NaN !== NaN 为 true。</p>
<h1 id="isNaN-和-Number-isNaN-函数的区别？"><a href="#isNaN-和-Number-isNaN-函数的区别？" class="headerlink" title="isNaN 和 Number.isNaN 函数的区别？"></a>isNaN 和 Number.isNaN 函数的区别？</h1><ol>
<li>函数 isNaN 接收参数后，会尝试将这个参数转换为数值，任何不能被转换为数值的的值都会返回 true，因此非数字值传入也会返回 true ，会影响 NaN 的判断。</li>
<li>函数 Number.isNaN 会首先判断传入参数是否为数字，如果是数字再继续判断是否为 NaN ，不会进行数据类型的转换，这种方法对于 NaN 的判断更为准确。</li>
</ol>
<h1 id="操作符的强制类型转换规则？"><a href="#操作符的强制类型转换规则？" class="headerlink" title="== 操作符的强制类型转换规则？"></a>== 操作符的强制类型转换规则？</h1><p>对于 == 来说，如果对比双方的类型不一样，就会进行类型转换。假如对比 x 和 y 是否相同，就会进行如下判断流程：</p>
<ol>
<li><p>首先会判断两者类型是否<strong>相同，</strong>相同的话就比较两者的大小；</p>
</li>
<li><p>类型不相同的话，就会进行类型转换；</p>
</li>
<li><p>会先判断是否在对比 null 和 undefined，是的话就会返回 true</p>
</li>
<li><p>判断两者类型是否为 string 和 number，是的话就会将字符串转换为 number</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 == &#x27;1&#x27;</span><br><span class="line">      ↓</span><br><span class="line">1 ==  1</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>判断其中一方是否为 boolean，是的话就会把 boolean 转为 number 再进行判断</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#x27;1&#x27; == true</span><br><span class="line">        ↓</span><br><span class="line">&#x27;1&#x27; ==  1</span><br><span class="line">        ↓</span><br><span class="line"> 1  ==  1</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="6">
<li>判断其中一方是否为 object 且另一方为 string、number 或者 symbol，是的话就会把 object 转为原始类型再进行判断</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#x27;1&#x27; == &#123; name: &#x27;js&#x27; &#125;        ↓&#x27;1&#x27; == &#x27;[object Object]&#x27;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="其他值到字符串的转换规则？"><a href="#其他值到字符串的转换规则？" class="headerlink" title="其他值到字符串的转换规则？"></a>其他值到字符串的转换规则？</h1><ol>
<li>Null 和 Undefined 类型 ，null 转换为 “null”，undefined 转换为 “undefined”，</li>
<li>Boolean 类型，true 转换为 “true”，false 转换为 “false”。</li>
<li>Number 类型的值直接转换，不过那些极小和极大的数字会使用指数形式。</li>
<li>Symbol 类型的值直接转换，但是只允许显式强制类型转换，使用隐式强制类型转换会产生错误。</li>
<li>对普通对象来说，除非自行定义 toString() 方法，否则会调用 toString()（Object.prototype.toString()）来返回内部属性 [[Class]] 的值，如”[object Object]”。如果对象有自己的 toString() 方法，字符串化时就会调用该方法并使用其返回值。</li>
</ol>
<h1 id="其他值到数字值的转换规则？"><a href="#其他值到数字值的转换规则？" class="headerlink" title="其他值到数字值的转换规则？"></a>其他值到数字值的转换规则？</h1><ol>
<li>Undefined 类型的值转换为 NaN。</li>
<li>Null 类型的值转换为 0。</li>
<li>Boolean 类型的值，true 转换为 1，false 转换为 0。</li>
<li>String 类型的值转换如同使用 Number() 函数进行转换，如果包含非数字值则转换为 NaN，空字符串为 0。</li>
<li>Symbol 类型的值不能转换为数字，会报错。</li>
<li>对象（包括数组）会首先被转换为相应的基本类型值，如果返回的是非数字的基本类型值，则再遵循以上规则将其强制转换为数字。</li>
</ol>
<p>为了将值转换为相应的基本类型值，抽象操作 ToPrimitive 会首先（通过内部操作 DefaultValue）检查该值是否有valueOf()方法。如果有并且返回基本类型值，就使用该值进行强制类型转换。如果没有就使用 toString() 的返回值（如果存在）来进行强制类型转换。<br>如果 valueOf() 和 toString() 均不返回基本类型值，会产生 TypeError 错误。</p>
<h1 id="其他值到布尔类型的值的转换规则？"><a href="#其他值到布尔类型的值的转换规则？" class="headerlink" title="其他值到布尔类型的值的转换规则？"></a>其他值到布尔类型的值的转换规则？</h1><p>以下这些是假值： • undefined • null • false • +0、-0 和 NaN • “”</p>
<p>假值的布尔强制类型转换结果为 false。从逻辑上说，假值列表以外的都应该是真值。</p>
<h1 id="和-amp-amp-操作符的返回值？"><a href="#和-amp-amp-操作符的返回值？" class="headerlink" title="|| 和 &amp;&amp; 操作符的返回值？"></a>|| 和 &amp;&amp; 操作符的返回值？</h1><p>|| 和 &amp;&amp; 首先会对第一个操作数执行条件判断，如果其不是布尔值就先强制转换为布尔类型，然后再执行条件判断。</p>
<ol>
<li>对于 || 来说，如果条件判断结果为 true 就返回第一个操作数的值，如果为 false 就返回第二个操作数的值。</li>
<li>&amp;&amp; 则相反，如果条件判断结果为 true 就返回第二个操作数的值，如果为 false 就返回第一个操作数的值。</li>
</ol>
<p>|| 和 &amp;&amp; 返回它们其中一个操作数的值，而非条件判断的结果</p>
<h1 id="Object-is-与比较操作符-“-”、“-”-的区别？"><a href="#Object-is-与比较操作符-“-”、“-”-的区别？" class="headerlink" title="Object.is() 与比较操作符 “===”、“==” 的区别？"></a>Object.is() 与比较操作符 “===”、“==” 的区别？</h1><ol>
<li>使用双等号（==）进行相等判断时，如果两边的类型不一致，则会进行强制类型转化后再进行比较。</li>
<li>使用三等号（===）进行相等判断时，如果两边的类型不一致时，不会做强制类型准换，直接返回 false。</li>
<li>使用 Object.is 来进行相等判断时，一般情况下和三等号的判断相同，它处理了一些特殊的情况，比如 -0 和 +0 不再相等，两个 NaN 是相等的。</li>
</ol>
<h1 id="什么是-JavaScript-中的包装类型？"><a href="#什么是-JavaScript-中的包装类型？" class="headerlink" title="什么是 JavaScript 中的包装类型？"></a>什么是 JavaScript 中的包装类型？</h1><p>在 JavaScript 中，基本类型是没有属性和方法的，但是为了便于操作基本类型的值，在调用基本类型的属性或方法时 JavaScript 会在后台隐式地将基本类型的值转换为对象，如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const a = &quot;abc&quot;;</span><br><span class="line">a.length; // 3</span><br><span class="line">a.toUpperCase(); // &quot;ABC&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在访问’abc’.length时，JavaScript 将’abc’在后台转换成String(‘abc’)，然后再访问其length属性。</p>
<p>JavaScript也可以使用Object函数显式地将基本类型转换为包装类型：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var a = &#x27;abc&#x27;</span><br><span class="line">Object(a) // String &#123;&quot;abc&quot;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>也可以使用valueOf方法将包装类型倒转成基本类型：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var a = &#x27;abc&#x27;</span><br><span class="line">var b = Object(a)</span><br><span class="line">var c = b.valueOf() // &#x27;abc&#x27;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>看看如下代码会打印出什么：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var a = new Boolean( false );</span><br><span class="line">if (!a) &#123;</span><br><span class="line">	console.log( &quot;Oops&quot; ); // never runs</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>答案是什么都不会打印，因为虽然包裹的基本类型是false，但是false被包裹成包装类型后就成了对象，所以其非值为false，所以循环体中的内容不会运行。</p>
<h1 id="JavaScript-中如何进行隐式类型转换？"><a href="#JavaScript-中如何进行隐式类型转换？" class="headerlink" title="JavaScript 中如何进行隐式类型转换？"></a>JavaScript 中如何进行隐式类型转换？</h1><p>首先要介绍ToPrimitive方法，这是 JavaScript 中每个值隐含的自带的方法，用来将值 （无论是基本类型值还是对象）转换为基本类型值。如果值为基本类型，则直接返回值本身；如果值为对象，其看起来大概是这样：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line">* @obj 需要转换的对象</span><br><span class="line">* @type 期望的结果类型</span><br><span class="line">*/</span><br><span class="line">ToPrimitive(obj,type)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>type的值为number或者string。<br>（1）当type为number时规则如下：</p>
<ol>
<li>调用obj的valueOf方法，如果为原始值，则返回，否则下一步；</li>
<li>调用obj的toString方法，后续同上；</li>
<li>抛出TypeError 异常。</li>
</ol>
<p>（2）当type为string时规则如下：</p>
<ol>
<li>调用obj的toString方法，如果为原始值，则返回，否则下一步；</li>
<li>调用obj的valueOf方法，后续同上；</li>
<li>抛出TypeError 异常。</li>
</ol>
<p>可以看出两者的主要区别在于调用toString和valueOf的先后顺序。默认情况下：</p>
<ol>
<li>如果对象为 Date 对象，则type默认为string；</li>
<li>其他情况下，type默认为number。</li>
</ol>
<p>总结上面的规则，对于 Date 以外的对象，转换为基本类型的大概规则可以概括为一个函数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var objToNumber = value =&gt; Number(value.valueOf().toString())</span><br><span class="line">objToNumber([]) === 0</span><br><span class="line">objToNumber(&#123;&#125;) === NaN</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>而 JavaScript 中的隐式类型转换主要发生在+、-、*、/以及==、&gt;、&lt;这些运算符之间。而这些运算符只能操作基本类型值，所以在进行这些运算前的第一步就是将两边的值用ToPrimitive转换成基本类型，再进行操作。<br>以下是基本类型的值在不同操作符的情况下隐式转换的规则 （对于对象，其会被ToPrimitive转换成基本类型，所以最终还是要应用基本类型转换规则）：</p>
<ol>
<li>+操作符</li>
</ol>
<p>+操作符的两边有至少一个string类型变量时，两边的变量都会被隐式转换为字符串；其他情况下两边的变量都会被转换为数字。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 + &#x27;23&#x27; // &#x27;123&#x27;</span><br><span class="line"> 1 + false // 1 </span><br><span class="line"> 1 + Symbol() // Uncaught TypeError: Cannot convert a Symbol value to a number</span><br><span class="line"> &#x27;1&#x27; + false // &#x27;1false&#x27;</span><br><span class="line"> false + true // 1</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ol start="2">
<li>-、*、\操作符<br>NaN也是一个数字</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 * &#x27;23&#x27; // 23</span><br><span class="line"> 1 * false // 0</span><br><span class="line"> 1 / &#x27;aa&#x27; // NaN</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ol start="3">
<li>对于==操作符<br>操作符两边的值都尽量转成number：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3 == true // false, 3 转为number为3，true转为number为1</span><br><span class="line">&#x27;0&#x27; == false //true, &#x27;0&#x27;转为number为0，false转为number为0</span><br><span class="line">&#x27;0&#x27; == 0 // &#x27;0&#x27;转为number为0</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="4">
<li>对于&lt;和&gt;比较符<br>如果两边都是字符串，则比较字母表顺序：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#x27;ca&#x27; &lt; &#x27;bd&#x27; // false</span><br><span class="line">&#x27;a&#x27; &lt; &#x27;b&#x27; // true</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
<p>其他情况下，转换为数字再比较：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#x27;12&#x27; &lt; 13 // true</span><br><span class="line">false &gt; -1 // true</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>以上说的是基本类型的隐式转换，而对象会被ToPrimitive转换为基本类型再进行转换：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var a = &#123;&#125;</span><br><span class="line">a &gt; 2 // false</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>其对比过程如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a.valueOf() // &#123;&#125;, 上面提到过，ToPrimitive默认type为number，所以先valueOf，结果还是个对象，下一步</span><br><span class="line">a.toString() // &quot;[object Object]&quot;，现在是一个字符串了</span><br><span class="line">Number(a.toString()) // NaN，根据上面 &lt; 和 &gt; 操作符的规则，要转换成数字</span><br><span class="line">NaN &gt; 2 //false，得出比较结果</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>又比如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var a = &#123;name:&#x27;Jack&#x27;&#125;</span><br><span class="line">var b = &#123;age: 18&#125;</span><br><span class="line">a + b // &quot;[object Object][object Object]&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>运算过程如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a.valueOf() // &#123;&#125;，上面提到过，ToPrimitive默认type为number，所以先valueOf，结果还是个对象，下一步</span><br><span class="line">a.toString() // &quot;[object Object]&quot;</span><br><span class="line">b.valueOf() // 同理</span><br><span class="line">b.toString() // &quot;[object Object]&quot;</span><br><span class="line">a + b // &quot;[object Object][object Object]&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="操作符什么时候用于字符串的拼接？"><a href="#操作符什么时候用于字符串的拼接？" class="headerlink" title="+ 操作符什么时候用于字符串的拼接？"></a>+ 操作符什么时候用于字符串的拼接？</h1><p>根据 ES5 规范，如果某个操作数是字符串或者能够通过以下步骤转换为字符串的话，+ 将进行拼接操作。如果其中一个操作数是对象（包括数组），则首先对其调用 ToPrimitive 抽象操作，该抽象操作再调用 [[DefaultValue]]，以数字作为上下文。如果不能转换为字符串，则会将其转换为数字类型来进行计算。<br>简单来说就是，如果 + 的其中一个操作数是字符串（或者通过以上步骤最终得到字符串），则执行字符串拼接，否则执行数字加法。<br>那么对于除了加法的运算符来说，只要其中一方是数字，那么另一方就会被转为数字。</p>
<h1 id="为什么会有BigInt的提案？"><a href="#为什么会有BigInt的提案？" class="headerlink" title="为什么会有BigInt的提案？"></a>为什么会有BigInt的提案？</h1><p>JavaScript中Number.MAX_SAFE_INTEGER表示最⼤安全数字，计算结果是9007199254740991，即在这个数范围内不会出现精度丢失（⼩数除外）。但是⼀旦超过这个范围，js就会出现计算不准确的情况，这在⼤数计算的时候不得不依靠⼀些第三⽅库进⾏解决，因此官⽅提出了BigInt来解决此问题。</p>
<h1 id="object-assign和扩展运算法是深拷贝还是浅拷贝，两者区别"><a href="#object-assign和扩展运算法是深拷贝还是浅拷贝，两者区别" class="headerlink" title="object.assign和扩展运算法是深拷贝还是浅拷贝，两者区别"></a>object.assign和扩展运算法是深拷贝还是浅拷贝，两者区别</h1><p>扩展运算符：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let outObj = &#123;</span><br><span class="line">  inObj: &#123;a: 1, b: 2&#125;</span><br><span class="line">&#125;</span><br><span class="line">let newObj = &#123;...outObj&#125;</span><br><span class="line">newObj.inObj.a = 2</span><br><span class="line">console.log(outObj) // &#123;inObj: &#123;a: 2, b: 2&#125;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>Object.assign():</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let outObj = &#123;</span><br><span class="line">  inObj: &#123;a: 1, b: 2&#125;</span><br><span class="line">&#125;</span><br><span class="line">let newObj = Object.assign(&#123;&#125;, outObj)</span><br><span class="line">newObj.inObj.a = 2</span><br><span class="line">console.log(outObj) // &#123;inObj: &#123;a: 2, b: 2&#125;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>可以看到，两者都是浅拷贝。</p>
<ol>
<li>Object.assign()方法接收的第一个参数作为目标对象，后面的所有参数作为源对象。然后把所有的源对象合并到目标对象中。它会修改了一个对象，因此会触发 ES6 setter。</li>
<li>扩展操作符（…）使用它时，数组或对象中的每一个值都会被拷贝到一个新的数组或对象中。它不复制继承的属性或类的属性，但是它会复制ES6的 symbols 属性。</li>
</ol>
<h1 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h1><p>定义：独一无二的值<br>声明：const set = Symbol(str)<br>入参：字符串(可选)</p>
<ol>
<li>方法</li>
</ol>
<ul>
<li>Symbol()：创建以参数作为描述的Symbol值(不登记在全局环境)</li>
<li>Symbol.for()：创建以参数作为描述的Symbol值，如存在此参数则返回原有的Symbol值(先搜索后创建，登记在全局环境)</li>
<li>Symbol.keyFor()：返回已登记的Symbol值的描述(只能返回Symbol.for()的key)</li>
<li>Object.getOwnPropertySymbols()：返回对象中所有用作属性名的Symbol值的数组</li>
</ul>
<ol start="2">
<li>内置</li>
</ol>
<ul>
<li>Symbol.hasInstance：指向一个内部方法，当其他对象使用instanceof运算符判断是否为此对象的实例时会调用此方法</li>
<li>Symbol.isConcatSpreadable：指向一个布尔，定义对象用于Array.prototype.concat()时是否可展开</li>
<li>Symbol.species：指向一个构造函数，当实例对象使用自身构造函数时会调用指定的构造函数</li>
<li>Symbol.match：指向一个函数，当实例对象被String.prototype.match()调用时会重新定义match()的行为</li>
<li>Symbol.replace：指向一个函数，当实例对象被String.prototype.replace()调用时会重新定义replace()的行为</li>
<li>Symbol.search：指向一个函数，当实例对象被String.prototype.search()调用时会重新定义search()的行为</li>
<li>Symbol.split：指向一个函数，当实例对象被String.prototype.split()调用时会重新定义split()的行为</li>
<li>Symbol.iterator：指向一个默认遍历器方法，当实例对象执行for-of时会调用指定的默认遍历器</li>
<li>Symbol.toPrimitive：指向一个函数，当实例对象被转为原始类型的值时会返回此对象对应的原始类型值</li>
<li>Symbol.toStringTag：指向一个函数，当实例对象被Object.prototype.toString()调用时其返回值会出现在toString()返回的字符串之中表示对象的类型</li>
<li>Symbol.unscopables：指向一个对象，指定使用with时哪些属性会被with环境排除</li>
</ul>
<ol start="3">
<li>应用场景</li>
</ol>
<ul>
<li>唯一化对象属性名：属性名属于Symbol类型，就都是独一无二的，可保证不会与其他属性名产生冲突</li>
<li>消除魔术字符串：在代码中多次出现且与代码形成强耦合的某一个具体的字符串或数值</li>
<li>遍历属性名：无法通过for-in、for-of、Object.keys()、Object.getOwnPropertyNames()、JSON.stringify()返回，只能通过Object.+ getOwnPropertySymbols返回</li>
<li>启用模块的Singleton模式：调用一个类在任何时候返回同一个实例(window和global)，使用Symbol.for()来模拟全局的Singleton模式</li>
</ul>
<ol start="4">
<li>重点难点</li>
</ol>
<ul>
<li>Symbol()生成一个原始类型的值不是对象，因此Symbol()前不能使用new命令</li>
<li>Symbol()参数表示对当前Symbol值的描述，相同参数的Symbol()返回值不相等</li>
<li>Symbol值不能与其他类型的值进行运算</li>
<li>Symbol值可通过String()或toString()显式转为字符串</li>
<li>Symbol值作为对象属性名时，此属性是公开属性，但不是私有属性</li>
<li>Symbol值作为对象属性名时，只能用方括号运算符([])读取，不能用点运算符(.)读取</li>
<li>Symbol值作为对象属性名时，不会被常规方法遍历得到，可利用此特性为对象定义非私有但又只用于内部的方法</li>
</ul>
<h1 id="BigInt"><a href="#BigInt" class="headerlink" title="BigInt"></a>BigInt</h1><p>定义：任何位数的整数(新增的数据类型，使用n结尾)<br>声明：const n = BigInt()<br>入参：数字</p>
<ul>
<li>BigInt.asUintN()：转换BigInt为0到2n-1之间对应的值</li>
<li>BigInt.asIntN()：转换BigInt为-2n-1 到2n-1-1</li>
<li>BigInt.parseInt()：近似于Number.parseInt()，将一个字符串转换成指定进制的BigInt类型</li>
</ul>
<p>重点难点</p>
<ul>
<li>BigInt同样可使用各种进制表示，都要加上后缀</li>
<li>BigInt与普通整数是两种值，它们之间并不相等</li>
<li>typeof运算符对于BigInt类型的数据返回bigint</li>
</ul>
<h1 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h1><ul>
<li><p>定义：类似于数组的数据结构，成员值都是唯一且没有重复的值</p>
</li>
<li><p>声明：const set = new Set(arr)</p>
</li>
<li><p>入参：具有Iterator接口的数据结构</p>
</li>
<li><p>属性</p>
<ul>
<li>constructor：构造函数，返回Set</li>
<li>size：返回实例成员总数</li>
</ul>
</li>
<li><p>方法</p>
<ul>
<li>add()：添加值，返回实例</li>
<li>delete()：删除值，返回布尔</li>
<li>has()：检查值，返回布尔</li>
<li>clear()：清除所有成员</li>
<li>keys()：返回以属性值为遍历器的对象</li>
<li>values()：返回以属性值为遍历器的对象</li>
<li>entries()：返回以属性值和属性值为遍历器的对象</li>
<li>forEach()：使用回调函数遍历每个成员</li>
</ul>
</li>
<li><p>应用场景</p>
<ul>
<li>去重字符串：[…new Set(str)].join(“”)</li>
<li>去重数组：[…new Set(arr)]或Array.from(new Set(arr))</li>
</ul>
</li>
<li><p>集合数组</p>
<ul>
<li>声明：const a = new Set(arr1)、const b = new Set(arr2)</li>
<li>并集：new Set([…a, …b])</li>
<li>交集：new Set([…a].filter(v =&gt; b.has(v)))</li>
<li>差集：new Set([…a].filter(v =&gt; !b.has(v)))</li>
</ul>
</li>
<li><p>映射集合</p>
<ul>
<li>声明：let set = new Set(arr)</li>
<li>映射：set = new Set([…set].map(v =&gt; v * 2))或set = new Set(Array.from(set, v =&gt; v * 2))</li>
</ul>
</li>
<li><p>重点难点</p>
<ul>
<li>遍历顺序：插入顺序</li>
<li>没有键只有值，可认为键和值两值相等</li>
<li>添加多个NaN时，只会存在一个NaN</li>
<li>添加相同的对象时，会认为是不同的对象</li>
<li>添加值时不会发生类型转换(5 !== “5”)</li>
<li>keys()和values()的行为完全一致，entries()返回的遍历器同时包括键和值且两值相等</li>
</ul>
</li>
</ul>
<h1 id="WeakSet"><a href="#WeakSet" class="headerlink" title="WeakSet"></a>WeakSet</h1><ul>
<li><p>定义：和Set结构类似，成员值只能是对象</p>
</li>
<li><p>声明：const set = new WeakSet(arr)</p>
</li>
<li><p>入参：具有Iterator接口的数据结构</p>
</li>
<li><p>属性</p>
<ul>
<li>constructor：构造函数，返回WeakSet</li>
</ul>
</li>
<li><p>方法</p>
<ul>
<li>add()：添加值，返回实例</li>
<li>delete()：删除值，返回布尔</li>
<li>has()：检查值，返回布尔</li>
</ul>
</li>
<li><p>应用场景</p>
<ul>
<li>储存DOM节点：DOM节点被移除时自动释放此成员，不用担心这些节点从文档移除时会引发内存泄漏</li>
<li>临时存放一组对象或存放跟对象绑定的信息：只要这些对象在外部消失，它在WeakSet结构中的引用就会自动消</li>
</ul>
</li>
<li><p>重点难点</p>
<ul>
<li>成员都是弱引用，垃圾回收机制不考虑WeakSet结构对此成员的引用</li>
<li>成员不适合引用，它会随时消失，因此ES6规定WeakSet结构不可遍历</li>
<li>其他对象不再引用成员时，垃圾回收机制会自动回收此成员所占用的内存，不考虑此成员是否还存在于WeakSet结构中</li>
</ul>
</li>
</ul>
<h1 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h1><ul>
<li><p>定义：类似于对象的数据结构，成员键是任何类型的值</p>
</li>
<li><p>声明：const map = new Map(arr)</p>
</li>
<li><p>入参：具有Iterator接口且每个成员都是一个双元素数组的数据结构</p>
</li>
<li><p>属性</p>
<ul>
<li>constructor：构造函数，返回Map</li>
<li>size：返回实例成员总数</li>
</ul>
</li>
<li><p>方法</p>
<ul>
<li>get()：返回键值对</li>
<li>set()：添加键值对，返回实例</li>
<li>delete()：删除键值对，返回布尔</li>
<li>has()：检查键值对，返回布尔</li>
<li>clear()：清除所有成员</li>
<li>keys()：返回以键为遍历器的对象</li>
<li>values()：返回以值为遍历器的对象</li>
<li>entries()：返回以键和值为遍历器的对象</li>
<li>forEach()：使用回调函数遍历每个成员</li>
</ul>
</li>
<li><p>重点难点</p>
<ul>
<li>遍历顺序：插入顺序</li>
<li>对同一个键多次赋值，后面的值将覆盖前面的值</li>
<li>对同一个对象的引用，被视为一个键</li>
<li>对同样值的两个实例，被视为两个键</li>
<li>键跟内存地址绑定，只要内存地址不一样就视为两个键</li>
<li>添加多个以NaN作为键时，只会存在一个以NaN作为键的值</li>
<li>Object结构提供字符串—值的对应，Map结构提供值—值的对应</li>
</ul>
</li>
</ul>
<h1 id="WeakMap"><a href="#WeakMap" class="headerlink" title="WeakMap"></a>WeakMap</h1><ul>
<li>定义：和Map结构类似，成员键只能是对象</li>
<li>声明：const set = new WeakMap(arr)</li>
<li>入参：具有Iterator接口且每个成员都是一个双元素数组的数据结构</li>
<li>属性<ul>
<li>constructor：构造函数，返回WeakMap</li>
</ul>
</li>
<li>方法<ul>
<li>get()：返回键值对</li>
<li>set()：添加键值对，返回实例</li>
<li>delete()：删除键值对，返回布尔</li>
<li>has()：检查键值对，返回布尔</li>
</ul>
</li>
<li>应用场景<ul>
<li>储存DOM节点：DOM节点被移除时自动释放此成员键，不用担心这些节点从文档移除时会引发内存泄漏</li>
<li>部署私有属性：内部属性是实例的弱引用，删除实例时它们也随之消失，不会造成内存泄漏</li>
</ul>
</li>
<li>重点难点<ul>
<li>成员键都是弱引用，垃圾回收机制不考虑WeakMap结构对此成员键的引用</li>
<li>成员键不适合引用，它会随时消失，因此ES6规定WeakMap结构不可遍历</li>
<li>其他对象不再引用成员键时，垃圾回收机制会自动回收此成员所占用的内存，不考虑此成员是否还存在于WeakMap结构中</li>
<li>一旦不再需要，成员会自动消失，不用手动删除引用</li>
<li>弱引用的只是键而不是值，值依然是正常引用</li>
<li>即使在外部消除了成员键的引用，内部的成员值依然存在</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>面试</category>
        <category>js</category>
      </categories>
  </entry>
  <entry>
    <title>javascript面试-面向对象</title>
    <url>/2021/08/19/js%E9%9D%A2%E8%AF%95-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<h1 id="对象创建的方式有哪些？"><a href="#对象创建的方式有哪些？" class="headerlink" title="对象创建的方式有哪些？"></a>对象创建的方式有哪些？</h1><p>一般使用字面量的形式直接创建对象，但是这种创建方式对于创建大量相似对象的时候，会产生大量的重复代码。但 js和一般的面向对象的语言不同，在 ES6 之前它没有类的概念。但是可以使用函数来进行模拟，从而产生出可复用的对象创建方式，常见的有以下几种：<br>（1）第一种是工厂模式，工厂模式的主要工作原理是用函数来封装创建对象的细节，从而通过调用函数来达到复用的目的。但是它有一个很大的问题就是创建出来的对象无法和某个类型联系起来，它只是简单的封装了复用代码，而没有建立起对象和类型间的关系。<br>（2）第二种是构造函数模式。js 中每一个函数都可以作为构造函数，只要一个函数是通过 new 来调用的，那么就可以把它称为构造函数。执行构造函数首先会创建一个对象，然后将对象的原型指向构造函数的 prototype 属性，然后将执行上下文中的 this 指向这个对象，最后再执行整个函数，如果返回值不是对象，则返回新建的对象。因为 this 的值指向了新建的对象，因此可以使用 this 给对象赋值。构造函数模式相对于工厂模式的优点是，所创建的对象和构造函数建立起了联系，因此可以通过原型来识别对象的类型。但是构造函数存在一个缺点就是，造成了不必要的函数对象的创建，因为在 js 中函数也是一个对象，因此如果对象属性中如果包含函数的话，那么每次都会新建一个函数对象，浪费了不必要的内存空间，因为函数是所有的实例都可以通用的。<br>（3）第三种模式是原型模式，因为每一个函数都有一个 prototype 属性，这个属性是一个对象，它包含了通过构造函数创建的所有实例都能共享的属性和方法。因此可以使用原型对象来添加公用属性和方法，从而实现代码的复用。这种方式相对于构造函数模式来说，解决了函数对象的复用问题。但是这种模式也存在一些问题，一个是没有办法通过传入参数来初始化值，另一个是如果存在一个引用类型如 Array 这样的值，那么所有的实例将共享一个对象，一个实例对引用类型值的改变会影响所有的实例。<br>（4）第四种模式是组合使用构造函数模式和原型模式，这是创建自定义类型的最常见方式。因为构造函数模式和原型模式分开使用都存在一些问题，因此可以组合使用这两种模式，通过构造函数来初始化对象的属性，通过原型对象来实现函数方法的复用。这种方法很好的解决了两种模式单独使用时的缺点，但是有一点不足的就是，因为使用了两种不同的模式，所以对于代码的封装性不够好。<br>（5）第五种模式是动态原型模式，这一种模式将原型方法赋值的创建过程移动到了构造函数的内部，通过对属性是否存在的判断，可以实现仅在第一次调用函数时对原型对象赋值一次的效果。这一种方式很好地对上面的混合模式进行了封装。<br>（6）第六种模式是寄生构造函数模式，这一种模式和工厂模式的实现基本相同，我对这个模式的理解是，它主要是基于一个已有的类型，在实例化时对实例化的对象进行扩展。这样既不用修改原来的构造函数，也达到了扩展对象的目的。它的一个缺点和工厂模式一样，无法实现对象的识别。</p>
<h2 id="1、对象的构造函数"><a href="#1、对象的构造函数" class="headerlink" title="1、对象的构造函数"></a>1、对象的构造函数</h2><p>创建空对象的最简单方法是使用object构造函数，目前不推荐这种方法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = <span class="keyword">new</span> object() <span class="comment">// 对象构造函数</span></span><br></pre></td></tr></table></figure>
<h2 id="2、对象的创建方法："><a href="#2、对象的创建方法：" class="headerlink" title="2、对象的创建方法："></a>2、对象的创建方法：</h2><p>Object的create方法通过将原型对象作为参数传递来创建一个新对象</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = <span class="built_in">Object</span>.create(<span class="literal">null</span>)</span><br></pre></td></tr></table></figure>
<h2 id="3、对象字面量语法"><a href="#3、对象字面量语法" class="headerlink" title="3、对象字面量语法"></a>3、对象字面量语法</h2><p>当传递null作为参数时，对象字面量语法等效于create方法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4、函数构造器"><a href="#4、函数构造器" class="headerlink" title="4、函数构造器"></a>4、函数构造器</h2><p>创建任何函数并应用new运算符来创建对象实例</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> obj = &#123;&#125;</span><br><span class="line">    obj.name = name</span><br><span class="line">    <span class="keyword">return</span> obj</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> obj1 = <span class="keyword">new</span> Person(<span class="string">&quot;哈哈&quot;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="5、带有原型的函数构造函数"><a href="#5、带有原型的函数构造函数" class="headerlink" title="5、带有原型的函数构造函数"></a>5、带有原型的函数构造函数</h2><p>这类似于函数构造函数，但它使用原型作为其属性和方法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">Person.prototype.name = <span class="string">&quot;哈哈&quot;</span></span><br><span class="line"><span class="keyword">var</span> obj = New Person()</span><br></pre></td></tr></table></figure>

<h2 id="6、es6类语法"><a href="#6、es6类语法" class="headerlink" title="6、es6类语法"></a>6、es6类语法</h2><p>es6引入类特性来创建对象</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="title">construtor</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> object = <span class="keyword">new</span> Person(<span class="string">&quot;哈哈&quot;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="7、单例模式"><a href="#7、单例模式" class="headerlink" title="7、单例模式"></a>7、单例模式</h2><p>Singleton是一个只能实例化一次的对象。对其构造函数的重复调用返回相同的实例，这样可以确保它们不会意外创建多个实例</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = <span class="keyword">new</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = <span class="string">&quot;哈哈&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="对象继承的方式有哪些？"><a href="#对象继承的方式有哪些？" class="headerlink" title="对象继承的方式有哪些？"></a>对象继承的方式有哪些？</h1><p>（1）第一种是以原型链的方式来实现继承，但是这种实现方式存在的缺点是，在包含有引用类型的数据时，会被所有的实例对象所共享，容易造成修改的混乱。还有就是在创建子类型的时候不能向超类型传递参数。<br>（2）第二种方式是使用借用构造函数的方式，这种方式是通过在子类型的函数中调用超类型的构造函数来实现的，这一种方法解决了不能向超类型传递参数的缺点，但是它存在的一个问题就是无法实现函数方法的复用，并且超类型原型定义的方法子类型也没有办法访问到。<br>（3）第三种方式是组合继承，组合继承是将原型链和借用构造函数组合起来使用的一种方式。通过借用构造函数的方式来实现类型的属性的继承，通过将子类型的原型设置为超类型的实例来实现方法的继承。这种方式解决了上面的两种模式单独使用时的问题，但是由于我们是以超类型的实例来作为子类型的原型，所以调用了两次超类的构造函数，造成了子类型的原型中多了很多不必要的属性。<br>（4）第四种方式是原型式继承，原型式继承的主要思路就是基于已有的对象来创建新的对象，实现的原理是，向函数中传入一个对象，然后返回一个以这个对象为原型的对象。这种继承的思路主要不是为了实现创造一种新的类型，只是对某个对象实现一种简单继承，ES5 中定义的 Object.create() 方法就是原型式继承的实现。缺点与原型链方式相同。<br>（5）第五种方式是寄生式继承，寄生式继承的思路是创建一个用于封装继承过程的函数，通过传入一个对象，然后复制一个对象的副本，然后对象进行扩展，最后返回这个对象。这个扩展的过程就可以理解是一种继承。这种继承的优点就是对一个简单对象实现继承，如果这个对象不是自定义类型时。缺点是没有办法实现函数的复用。<br>（6）第六种方式是寄生式组合继承，组合继承的缺点就是使用超类型的实例做为子类型的原型，导致添加了不必要的原型属性。寄生式组合继承的方式是使用超类型的原型的副本来作为子类型的原型，这样就避免了创建不必要的属性。</p>
<h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><h2 id="何为继承"><a href="#何为继承" class="headerlink" title="何为继承"></a>何为继承</h2><p>一个类获取另一个或者多个类的属性或者方法。继承可以使得子类具有父类的各种方法和属性。以免重复输出很多代码。</p>
<h2 id="继承的原理"><a href="#继承的原理" class="headerlink" title="继承的原理"></a>继承的原理</h2><p>复制父类的方法和属性来重写子类的原型对象。</p>
<h2 id="原型链继承"><a href="#原型链继承" class="headerlink" title="原型链继承"></a>原型链继承</h2><p>构造函数、原型和实例之间的关系：每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，而实例都包含一个原型对象的指针。</p>
<p>继承的本质就是复制，即重写原型对象，代之以一个新类型的实例。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function SuperType() &#123;</span><br><span class="line">    this.property = true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SuperType.prototype.getSuperValue = function() &#123;</span><br><span class="line">    return this.property;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function SubType() &#123;</span><br><span class="line">    this.subproperty = false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 这里是关键，创建SuperType的实例，并将该实例赋值给SubType.prototype</span><br><span class="line">SubType.prototype = new SuperType(); </span><br><span class="line"></span><br><span class="line">SubType.prototype.getSubValue = function() &#123;</span><br><span class="line">    return this.subproperty;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var instance = new SubType();</span><br><span class="line">console.log(instance.getSuperValue()); // true</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>注意：原型链方案存在的缺点：多个实例对引用类型的操作会被篡改。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function SuperType()&#123;</span><br><span class="line">  this.colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;];</span><br><span class="line">&#125;</span><br><span class="line">function SubType()&#123;&#125;</span><br><span class="line"></span><br><span class="line">SubType.prototype = new SuperType();</span><br><span class="line"></span><br><span class="line">var instance1 = new SubType();</span><br><span class="line">instance1.colors.push(&quot;black&quot;);</span><br><span class="line">alert(instance1.colors); //&quot;red,blue,green,black&quot;</span><br><span class="line"></span><br><span class="line">var instance2 = new SubType(); </span><br><span class="line">alert(instance2.colors); //&quot;red,blue,green,black&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="借用构造函数继承"><a href="#借用构造函数继承" class="headerlink" title="借用构造函数继承"></a>借用构造函数继承</h2><p>使用父类的构造函数来增强子类实例，等同于复制父类的实例给子类（不使用原型）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function  SuperType()&#123;</span><br><span class="line">    this.color=[&quot;red&quot;,&quot;green&quot;,&quot;blue&quot;];</span><br><span class="line">&#125;</span><br><span class="line">function  SubType()&#123;</span><br><span class="line">    //继承自SuperType</span><br><span class="line">    SuperType.call(this);</span><br><span class="line">&#125;</span><br><span class="line">var instance1 = new SubType();</span><br><span class="line">instance1.color.push(&quot;black&quot;);</span><br><span class="line">alert(instance1.color);//&quot;red,green,blue,black&quot;</span><br><span class="line"></span><br><span class="line">var instance2 = new SubType();</span><br><span class="line">alert(instance2.color);//&quot;red,green,blue&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>核心代码是SuperType.call(this)，创建子类实例时调用SuperType构造函数，于是SubType的每个实例都会将SuperType中的属性复制一份。<br>缺点：</p>
<p>只能继承父类的实例属性和方法，不能继承原型属性/方法<br>无法实现复用，每个子类都有父类实例函数的副本，影响性能</p>
<h2 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h2><p>组合上述两种方法就是组合继承。用原型链实现对原型属性和方法的继承，用借用构造函数技术来实现实例属性的继承。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function SuperType(name)&#123;</span><br><span class="line">  this.name = name;</span><br><span class="line">  this.colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;];</span><br><span class="line">&#125;</span><br><span class="line">SuperType.prototype.sayName = function()&#123;</span><br><span class="line">  alert(this.name);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function SubType(name, age)&#123;</span><br><span class="line">  // 继承属性</span><br><span class="line">  // 第二次调用SuperType()</span><br><span class="line">  SuperType.call(this, name);</span><br><span class="line">  this.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 继承方法</span><br><span class="line">// 构建原型链</span><br><span class="line">// 第一次调用SuperType()</span><br><span class="line">SubType.prototype = new SuperType(); </span><br><span class="line">// 重写SubType.prototype的constructor属性，指向自己的构造函数SubType</span><br><span class="line">SubType.prototype.constructor = SubType; </span><br><span class="line">SubType.prototype.sayAge = function()&#123;</span><br><span class="line">    alert(this.age);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var instance1 = new SubType(&quot;Nicholas&quot;, 29);</span><br><span class="line">instance1.colors.push(&quot;black&quot;);</span><br><span class="line">alert(instance1.colors); //&quot;red,blue,green,black&quot;</span><br><span class="line">instance1.sayName(); //&quot;Nicholas&quot;;</span><br><span class="line">instance1.sayAge(); //29</span><br><span class="line"></span><br><span class="line">var instance2 = new SubType(&quot;Greg&quot;, 27);</span><br><span class="line">alert(instance2.colors); //&quot;red,blue,green&quot;</span><br><span class="line">instance2.sayName(); //&quot;Greg&quot;;</span><br><span class="line">instance2.sayAge(); //27</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>缺点：</p>
<ul>
<li>第一次调用SuperType()：给SubType.prototype写入两个属性name，color。</li>
<li>第二次调用SuperType()：给instance1写入两个属性name，color。</li>
</ul>
<p>实例对象instance1上的两个属性就屏蔽了其原型对象SubType.prototype的两个同名属性。所以，组合模式的缺点就是在使用子类创建实例对象时，其原型中会存在两份相同的属性/方法。</p>
<h2 id="原型式继承"><a href="#原型式继承" class="headerlink" title="原型式继承"></a>原型式继承</h2><p>利用一个空对象作为中介，将某个对象直接赋值给空对象构造函数的原型。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function object(obj)&#123;</span><br><span class="line">  function F()&#123;&#125;</span><br><span class="line">  F.prototype = obj;</span><br><span class="line">  return new F();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>object()对传入其中的对象执行了一次浅复制，将构造函数F的原型直接指向传入的对象。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var person = &#123;</span><br><span class="line">  name: &quot;Nicholas&quot;,</span><br><span class="line">  friends: [&quot;Shelby&quot;, &quot;Court&quot;, &quot;Van&quot;]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var anotherPerson = object(person);</span><br><span class="line">anotherPerson.name = &quot;Greg&quot;;</span><br><span class="line">anotherPerson.friends.push(&quot;Rob&quot;);</span><br><span class="line"></span><br><span class="line">var yetAnotherPerson = object(person);</span><br><span class="line">yetAnotherPerson.name = &quot;Linda&quot;;</span><br><span class="line">yetAnotherPerson.friends.push(&quot;Barbie&quot;);</span><br><span class="line"></span><br><span class="line">alert(person.friends);   //&quot;Shelby,Court,Van,Rob,Barbie&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>缺点：</p>
<p>原型链继承多个实例的引用类型属性指向相同，存在篡改的可能。<br>无法传递参数<br>另外，ES5中存在Object.create()的方法，能够代替上面的object方法。</p>
<h2 id="5、寄生式继承"><a href="#5、寄生式继承" class="headerlink" title="5、寄生式继承"></a>5、寄生式继承</h2><p>核心：在原型式继承的基础上，增强对象，返回构造函数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function createAnother(original)&#123;</span><br><span class="line">  var clone = object(original); // 通过调用 object() 函数创建一个新对象</span><br><span class="line">  clone.sayHi = function()&#123;  // 以某种方式来增强对象</span><br><span class="line">    alert(&quot;hi&quot;);</span><br><span class="line">  &#125;;</span><br><span class="line">  return clone; // 返回这个对象</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>函数的主要作用是为构造函数新增属性和方法，以增强函数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var person = &#123;</span><br><span class="line">  name: &quot;Nicholas&quot;,</span><br><span class="line">  friends: [&quot;Shelby&quot;, &quot;Court&quot;, &quot;Van&quot;]</span><br><span class="line">&#125;;</span><br><span class="line">var anotherPerson = createAnother(person);</span><br><span class="line">anotherPerson.sayHi(); //&quot;hi&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>缺点（同原型式继承）：</p>
<ul>
<li>原型链继承多个实例的引用类型属性指向相同，存在篡改的可能。</li>
<li>无法传递参数</li>
</ul>
<h2 id="寄生组合式继承"><a href="#寄生组合式继承" class="headerlink" title="寄生组合式继承"></a>寄生组合式继承</h2><p>结合借用构造函数传递参数和寄生模式实现继承</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function init (sub, super)&#123;</span><br><span class="line">    const pro = Object.create(super.prototype)</span><br><span class="line">    pro.constructor = sub</span><br><span class="line">    sub.prototype = pro</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function super(name)&#123;</span><br><span class="line">    this.name = name</span><br><span class="line">&#125;</span><br><span class="line">function sub(name, age)&#123;</span><br><span class="line">    super.call(this, name)</span><br><span class="line">    this.age = age</span><br><span class="line">&#125;</span><br><span class="line">init(sub, super)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这个例子的高效率体现在它只调用了一次SuperType 构造函数，并且因此避免了在SubType.prototype 上创建不必要的、多余的属性。于此同时，原型链还能保持不变；因此，还能够正常使用instanceof 和isPrototypeOf()<br>这是最成熟的方法，也是现在库实现的方法</p>
<h2 id="混入方式继承多个对象"><a href="#混入方式继承多个对象" class="headerlink" title="混入方式继承多个对象"></a>混入方式继承多个对象</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function MyClass() &#123;</span><br><span class="line">     SuperClass.call(this);</span><br><span class="line">     OtherSuperClass.call(this);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 继承一个类</span><br><span class="line">MyClass.prototype = Object.create(SuperClass.prototype);</span><br><span class="line">// 混合其它</span><br><span class="line">Object.assign(MyClass.prototype, OtherSuperClass.prototype);</span><br><span class="line">// 重新指定constructor</span><br><span class="line">MyClass.prototype.constructor = MyClass;</span><br><span class="line"></span><br><span class="line">MyClass.prototype.myMethod = function() &#123;</span><br><span class="line">     // do something</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>Object.assign会把 OtherSuperClass原型上的函数拷贝到 MyClass原型上，使 MyClass 的所有实例都可用 OtherSuperClass 的方法。</p>
<h2 id="ES6类继承extends"><a href="#ES6类继承extends" class="headerlink" title="ES6类继承extends"></a>ES6类继承extends</h2><p>extends关键字主要用于类声明或者类表达式中，以创建一个类，该类是另一个类的子类。其中constructor表示构造函数，一个类中只能有一个构造函数，有多个会报出SyntaxError错误,如果没有显式指定构造方法，则会添加默认的 constructor方法，使用例子如下。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Rectangle &#123;</span><br><span class="line">    // constructor</span><br><span class="line">    constructor(height, width) &#123;</span><br><span class="line">        this.height = height;</span><br><span class="line">        this.width = width;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // Getter</span><br><span class="line">    get area() &#123;</span><br><span class="line">        return this.calcArea()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // Method</span><br><span class="line">    calcArea() &#123;</span><br><span class="line">        return this.height * this.width;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const rectangle = new Rectangle(10, 20);</span><br><span class="line">console.log(rectangle.area);</span><br><span class="line">// 输出 200</span><br><span class="line"></span><br><span class="line">-----------------------------------------------------------------</span><br><span class="line">// 继承</span><br><span class="line">class Square extends Rectangle &#123;</span><br><span class="line"></span><br><span class="line">  constructor(length) &#123;</span><br><span class="line">    super(length, length);</span><br><span class="line">    </span><br><span class="line">    // 如果子类中存在构造函数，则需要在使用“this”之前首先调用 super()。</span><br><span class="line">    this.name = &#x27;Square&#x27;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  get area() &#123;</span><br><span class="line">    return this.height * this.width;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const square = new Square(10);</span><br><span class="line">console.log(square.area);</span><br><span class="line">// 输出 100</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>extends继承的核心代码如下，其实现和上述的寄生组合式继承方式一样</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function _inherits(subType, superType) &#123;</span><br><span class="line">  </span><br><span class="line">    // 创建对象，创建父类原型的一个副本</span><br><span class="line">    // 增强对象，弥补因重写原型而失去的默认的constructor 属性</span><br><span class="line">    // 指定对象，将新创建的对象赋值给子类的原型</span><br><span class="line">    subType.prototype = Object.create(superType &amp;&amp; superType.prototype, &#123;</span><br><span class="line">        constructor: &#123;</span><br><span class="line">            value: subType,</span><br><span class="line">            enumerable: false,</span><br><span class="line">            writable: true,</span><br><span class="line">            configurable: true</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    if (superType) &#123;</span><br><span class="line">        Object.setPrototypeOf </span><br><span class="line">            ? Object.setPrototypeOf(subType, superType) </span><br><span class="line">            : subType.__proto__ = superType;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="ES5继承和ES6继承的区别"><a href="#ES5继承和ES6继承的区别" class="headerlink" title="ES5继承和ES6继承的区别"></a>ES5继承和ES6继承的区别</h2><p>ES5的继承实质上是先创建子类的实例对象，然后再将父类的方法添加到this上（Parent.call(this)）.</p>
<p>ES6的继承有所不同，实质上是先创建父类的实例对象this，然后再用子类的构造函数修改this。因为子类没有自己的this对象，所以必须先调用父类的super()方法，否则新建实例报错。</p>
]]></content>
      <categories>
        <category>面试</category>
        <category>js</category>
      </categories>
  </entry>
  <entry>
    <title>javascript面试-高频手写代码</title>
    <url>/2021/08/19/js%E9%9D%A2%E8%AF%95-%E9%AB%98%E9%A2%91%E6%89%8B%E5%86%99%E4%BB%A3%E7%A0%81/</url>
    <content><![CDATA[<h1 id="call"><a href="#call" class="headerlink" title="call"></a>call</h1><ol>
<li>判断调用对象是否是函数，即使是定义在函数的原型上的，但是可能出现使用call等方式调用的情况；</li>
<li>判断上下文对象是否存在，如果不存在，则设置为window</li>
<li>处理传入的参数，截取第一个参数后的所有参数。</li>
<li>将函数作为上下文对象的一个属性。</li>
<li>使用上下文对象来调用这个方法，并保留返回结果。</li>
<li>删除刚才新增的属性</li>
<li>返回结果。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Fuction.prototype.myCall = function (context) &#123;</span><br><span class="line">  // 判断调用对象</span><br><span class="line">  if (typeof this !== &#x27;function&#x27;) &#123;</span><br><span class="line">    throw new Error(&quot;type error&quot;)</span><br><span class="line">  &#125;</span><br><span class="line">  let result;</span><br><span class="line">  // 获取参数</span><br><span class="line">  let arg = [...argument].slice(1)</span><br><span class="line">  // 判断context是否传入，如果为传入，设置为window</span><br><span class="line">  context = context || window</span><br><span class="line">  // 将调用函数设为对象的方法</span><br><span class="line">  context.fn = this</span><br><span class="line"></span><br><span class="line">  result = context.fn(arg)</span><br><span class="line">  // 将属性删除</span><br><span class="line">  delete context.fn</span><br><span class="line">  return result</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="apply"><a href="#apply" class="headerlink" title="apply"></a>apply</h1><ol>
<li>判断调用对象是否为函数，即使是定义在函数的原型上的，但是可能出现使用 call 等方式调用的情况。</li>
<li>判断传入上下文对象是否存在，如果不存在，则设置为 window 。</li>
<li>将函数作为上下文对象的一个属性。</li>
<li>判断参数值是否传入</li>
<li>使用上下文对象来调用这个方法，并保存返回结果。</li>
<li>删除刚才新增的属性</li>
<li>返回结果</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Function.prototype.myApply = function(context) &#123;</span><br><span class="line">  if (typeof this !== &#x27;function&#x27;) &#123;</span><br><span class="line">    throw new Error(&#x27;type error&#x27;)</span><br><span class="line">  &#125;</span><br><span class="line">  let result;</span><br><span class="line">  context = context || window</span><br><span class="line">  context.fn = this</span><br><span class="line"></span><br><span class="line">  if (arguments[1]) &#123;</span><br><span class="line">    result = context.fn(...arguments[1])</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    result = context.fn()</span><br><span class="line">  &#125;</span><br><span class="line">  delte context.fn</span><br><span class="line">  return result</span><br><span class="line">&#125;; </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h1><ol>
<li>判断调用对象是否为函数，即使是定义在函数的原型上的，但是可能出现使用 call 等方式调用的情况</li>
<li>保存当前函数的引用，获取其余传入参数值。</li>
<li>创建一个函数返回</li>
<li>函数内部使用apply来绑定函数调用，需要判断函数作为构造函数的情况，这个时候需要传入当前的this给apply调用，其余情况都传入制定的上下文对象</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Function.prototype.myBind = function (context) &#123;</span><br><span class="line">  if (typeof this !== &#x27;function&#x27;) &#123;</span><br><span class="line">    throw new Error(&#x27;type error&#x27;)</span><br><span class="line">  &#125;</span><br><span class="line">  let _self = this</span><br><span class="line">  let args = [...arguments].slice(1)</span><br><span class="line">  return function () &#123;</span><br><span class="line">    return _self.apply(</span><br><span class="line">      context,</span><br><span class="line">      args.concat([...arguments])</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="什么是防抖和节流，他们的应用场景有哪些"><a href="#什么是防抖和节流，他们的应用场景有哪些" class="headerlink" title="什么是防抖和节流，他们的应用场景有哪些"></a>什么是防抖和节流，他们的应用场景有哪些</h1><h2 id="防抖-debounce"><a href="#防抖-debounce" class="headerlink" title="防抖(debounce)"></a>防抖(debounce)</h2><p>触发高频事件后 n 秒内函数只会执行一次，如果 n 秒内高频事件再次被触发，则重新计算时间</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 防抖函数</span><br><span class="line"></span><br><span class="line">function debounce(fn, wait) &#123;</span><br><span class="line">  let timer = null</span><br><span class="line"></span><br><span class="line">  return function () &#123;</span><br><span class="line">    let context = this</span><br><span class="line">    let args = arguments;</span><br><span class="line">    if (timer) &#123;</span><br><span class="line">      clearTimeout(timer)</span><br><span class="line">      timer = null</span><br><span class="line">    &#125;</span><br><span class="line">    timer = setTimeout(() =&gt; &#123;</span><br><span class="line">      fn.apply(context, args);</span><br><span class="line">    &#125;, wait)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="节流-throttle"><a href="#节流-throttle" class="headerlink" title="节流(throttle)"></a>节流(throttle)</h2><p>高频事件触发，但在 n 秒内只会执行一次，所以节流会稀释函数的执行频率</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 方式1: 使用时间戳</span><br><span class="line">function throttle1(fn, wait) &#123;</span><br><span class="line">  let time = 0;</span><br><span class="line">  return function () &#123;</span><br><span class="line">    let _this = this;</span><br><span class="line">    let args = arguments;</span><br><span class="line">    let now = Date.now();</span><br><span class="line">    if (now - time &gt; wait) &#123;</span><br><span class="line">      fn.apply(_this, args);</span><br><span class="line">      time = now;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">// 方式2: 使用定时器</span><br><span class="line">function thorttle2(fn, wait) &#123;</span><br><span class="line">  let timer;</span><br><span class="line">  return function () &#123;</span><br><span class="line">    let _this = this;</span><br><span class="line">    let args = arguments;</span><br><span class="line"></span><br><span class="line">    if (!timer) &#123;</span><br><span class="line">      timer = setTimeout(function () &#123;</span><br><span class="line">        timer = null;</span><br><span class="line">        fn.apply(_this, args);</span><br><span class="line">      &#125;, wait);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>上面节流和防抖实现方式比较简单，但是已经可以满足日常使用，如果想更近一步了解可以查看underscore (opens new window)和lodash (opens new window)文档中debounce和thorttle</p>
<p>防抖：防止抖动，单位时间内事件触发会被重置，避免事件被误伤触发多次。代码实现重在清零 clearTimeout。防抖可以比作等电梯，只要有一个人进来，就需要再等一会儿。业务场景有避免登录按钮多次点击的重复提交。<br>节流：控制流量，单位时间内事件只能触发一次，与服务器端的限流 (Rate Limit) 类似。代码实现重在开锁关锁 timer=timeout; timer=null。节流可以比作过红绿灯，每等一个红灯时间就可以过一批。</p>
<h1 id="手写object-create"><a href="#手写object-create" class="headerlink" title="手写object.create"></a>手写object.create</h1><p>思路：将传入的对象作为原型</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function create(obj) &#123;</span><br><span class="line">  function Fn() &#123;&#125;</span><br><span class="line">  Fn.prototype = obj</span><br><span class="line">  return new Fn()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="手写类型判断"><a href="#手写类型判断" class="headerlink" title="手写类型判断"></a>手写类型判断</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function mytypeof(value) &#123;</span><br><span class="line">  if (value === null) &#123;</span><br><span class="line">    return &#x27;null&#x27;</span><br><span class="line">  &#125;</span><br><span class="line">  let type = typeof value</span><br><span class="line">  if (type === &#x27;object&#x27;) &#123;</span><br><span class="line">    let objectType = Object.prototype.toString.call(value);</span><br><span class="line">    type = objectType.split(&quot; &quot;)[1]</span><br><span class="line">    return type.toLowerCase();</span><br><span class="line">  &#125;</span><br><span class="line">  return type</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="手写instanceOf方法"><a href="#手写instanceOf方法" class="headerlink" title="手写instanceOf方法"></a>手写instanceOf方法</h1><p>instanceof运算符用于判断构造函数的prototype属性是否出现在对象的原型链中的任何位置。</p>
<p>实现步骤：</p>
<ol>
<li>首先获取类型的原型</li>
<li>然后获取对象的原型</li>
<li>循环判读对象的原型是否等于类型的原型，直到对象原型为null,因为 Object.prototype.<strong>proto</strong> = null<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">function instance(left, right) &#123;</span><br><span class="line">  let proto = Object.getPrototypeOf(left)</span><br><span class="line">  let prototype = right.prototype</span><br><span class="line"></span><br><span class="line">  while(true) &#123;</span><br><span class="line">    if (!proto) return false</span><br><span class="line">    if (proto === prototype) return true</span><br><span class="line"></span><br><span class="line">    proto = Object.getPrototypeOf(proto)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="手写new-操作符"><a href="#手写new-操作符" class="headerlink" title="手写new 操作符"></a>手写new 操作符</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function objectFactory() &#123;</span><br><span class="line">  let newObject = null;</span><br><span class="line">  let constructor = Array.prototype.shift.call(arguments);</span><br><span class="line">  let result = null;</span><br><span class="line">  // 判断参数是否是一个函数</span><br><span class="line">  if (typeof constructor !== &quot;function&quot;) &#123;</span><br><span class="line">    console.error(&quot;type error&quot;);</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line">  // 新建一个空对象，对象的原型为构造函数的 prototype 对象</span><br><span class="line">  newObject = Object.create(constructor.prototype);</span><br><span class="line">  // 将 this 指向新建对象，并执行函数</span><br><span class="line">  result = constructor.apply(newObject, arguments);</span><br><span class="line">  // 判断返回对象</span><br><span class="line">  let flag = result &amp;&amp; (typeof result === &quot;object&quot; || typeof result === &quot;function&quot;);</span><br><span class="line">  // 判断返回结果</span><br><span class="line">  return flag ? result : newObject;</span><br><span class="line">&#125;</span><br><span class="line">// 使用方法</span><br><span class="line">objectFactory(构造函数, 初始化参数);</span><br></pre></td></tr></table></figure>

<h1 id="函数柯里化的实现"><a href="#函数柯里化的实现" class="headerlink" title="函数柯里化的实现"></a>函数柯里化的实现</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 第一种</span><br><span class="line"></span><br><span class="line">function curry (fn, args) &#123;</span><br><span class="line">  let length = fn.length</span><br><span class="line">  args = args || []</span><br><span class="line"></span><br><span class="line">  return function () &#123;</span><br><span class="line">    let subargs = args.slice(0)</span><br><span class="line">    subargs.push(...arguments)</span><br><span class="line">    if (subargs.length &gt;= length) &#123;</span><br><span class="line">      return fn.apply(this, subargs)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      return curry.apply(this, fn, subargs)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function curry2(fn, ...args) &#123;</span><br><span class="line">  return fn.length &lt;= args.length ? fn(...args) : curry2.bind(this, fn, ...args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="实现AJAX请求"><a href="#实现AJAX请求" class="headerlink" title="实现AJAX请求"></a>实现AJAX请求</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// promise 封装实现：</span><br><span class="line">function getJSON(url) &#123;</span><br><span class="line">  // 创建一个 promise 对象</span><br><span class="line">  let promise = new Promise(function(resolve, reject) &#123;</span><br><span class="line">    let xhr = new XMLHttpRequest();</span><br><span class="line">    // 新建一个 http 请求</span><br><span class="line">    xhr.open(&quot;GET&quot;, url, true);</span><br><span class="line">    // 设置状态的监听函数</span><br><span class="line">    xhr.onreadystatechange = function() &#123;</span><br><span class="line">      if (this.readyState !== 4) return;</span><br><span class="line">      // 当请求成功或失败时，改变 promise 的状态</span><br><span class="line">      if (this.status === 200) &#123;</span><br><span class="line">        resolve(this.response);</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        reject(new Error(this.statusText));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    // 设置错误监听函数</span><br><span class="line">    xhr.onerror = function() &#123;</span><br><span class="line">      reject(new Error(this.statusText));</span><br><span class="line">    &#125;;</span><br><span class="line">    // 设置响应的数据类型</span><br><span class="line">    xhr.responseType = &quot;json&quot;;</span><br><span class="line">    // 设置请求头信息</span><br><span class="line">    xhr.setRequestHeader(&quot;Accept&quot;, &quot;application/json&quot;);</span><br><span class="line">    // 发送 http 请求</span><br><span class="line">    xhr.send(null);</span><br><span class="line">  &#125;);</span><br><span class="line">  return promise;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h1><ul>
<li>object.assign()</li>
<li>{…object}</li>
<li>手写浅拷贝<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function assign(obj) &#123;</span><br><span class="line">  if (!obj ||  typeof obj !== &#x27;object&#x27; ) return;</span><br><span class="line">  let newObj = Array.isArray(obj) ? [] : &#123;&#125;</span><br><span class="line">  for (let key in obj) &#123;</span><br><span class="line">    if (obj.hasOwnPrototype(key)) &#123;</span><br><span class="line">      newObj[key] = obj[key]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return newObj</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h1><ul>
<li>JSON.parse(JSON.stringify(obj))</li>
<li>手写<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function deepCopy(obj) &#123;</span><br><span class="line">  if (!obj || typeof obj !==&#x27;object&#x27;) return</span><br><span class="line">  let newObj = Array.isArray(obj) ? [] : &#123;&#125;</span><br><span class="line">  for (let key in obj) &#123;</span><br><span class="line">    if (obj.hasOwnPrototype(key)) &#123;</span><br><span class="line">      newObj[key] = typeof obj[key] === &#x27;object&#x27; ? deepCopy(obj) : obj[key]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return newObj</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="实现日期格式化函数"><a href="#实现日期格式化函数" class="headerlink" title="实现日期格式化函数"></a>实现日期格式化函数</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const dateFormat = (dateInput, format) =&gt; &#123;</span><br><span class="line">  const day = dateInput.getDate()</span><br><span class="line">  const month = dateInput.getMonth() + 1</span><br><span class="line">  const year = dateInput.getFullYear()</span><br><span class="line">  format = format.replace(&#x27;/yyyy/&#x27;, year).replace(&#x27;/MM/&#x27;, month).replace(&#x27;/dd/&#x27;, day)</span><br><span class="line">  return format</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="交换a-b的值，不能使用临时变量"><a href="#交换a-b的值，不能使用临时变量" class="headerlink" title="交换a,b的值，不能使用临时变量"></a>交换a,b的值，不能使用临时变量</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a = a + b</span><br><span class="line">b = a - b</span><br><span class="line">a = a- b</span><br><span class="line"></span><br><span class="line">[a, b] = [b, a]</span><br></pre></td></tr></table></figure>

<h1 id="实现数组的乱序输出"><a href="#实现数组的乱序输出" class="headerlink" title="实现数组的乱序输出"></a>实现数组的乱序输出</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let arr = []</span><br><span class="line">for (let i = 0; i &lt; arr.length; i ++) &#123;</span><br><span class="line">  let random = Math.round(Math.random() * (arr.length - 1 - i)) + i</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="实现数组元素求和"><a href="#实现数组元素求和" class="headerlink" title="实现数组元素求和"></a>实现数组元素求和</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let arr = []</span><br><span class="line">let sum = arr.reduce((total, i) =&gt; total += i, 0 )</span><br></pre></td></tr></table></figure>

<h1 id="数组扁平化"><a href="#数组扁平化" class="headerlink" title="数组扁平化"></a>数组扁平化</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.</span><br><span class="line">let arr = [1, [2, [3, 4, 5]]];</span><br><span class="line">function flatten(arr) &#123;</span><br><span class="line">  let result = [];</span><br><span class="line"></span><br><span class="line">  for(let i = 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">    if(Array.isArray(arr[i])) &#123;</span><br><span class="line">      result = result.concat(flatten(arr[i]));</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      result.push(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br><span class="line">flatten(arr);  //  [1, 2, 3, 4，5]</span><br><span class="line"></span><br><span class="line">2.</span><br><span class="line">let arr = [1, [2, [3, 4]]];</span><br><span class="line">function flatten(arr) &#123;</span><br><span class="line">    return arr.reduce(function(prev, next)&#123;</span><br><span class="line">        return prev.concat(Array.isArray(next) ? flatten(next) : next)</span><br><span class="line">    &#125;, [])</span><br><span class="line">&#125;</span><br><span class="line">console.log(flatten(arr));//  [1, 2, 3, 4，5]</span><br><span class="line"></span><br><span class="line">3. </span><br><span class="line">let arr = [1, [2, [3, 4]]];</span><br><span class="line">function flatten(arr) &#123;</span><br><span class="line">    while (arr.some(item =&gt; Array.isArray(item))) &#123;</span><br><span class="line">        arr = [].concat(...arr);</span><br><span class="line">    &#125;</span><br><span class="line">    return arr;</span><br><span class="line">&#125;</span><br><span class="line">console.log(flatten(arr)); //  [1, 2, 3, 4，5]</span><br><span class="line"></span><br><span class="line">4. </span><br><span class="line">let arr = [1, [2, [3, 4]]];</span><br><span class="line">function flatten(arr) &#123;</span><br><span class="line">    return arr.toString().split(&#x27;,&#x27;);</span><br><span class="line">&#125;</span><br><span class="line">console.log(flatten(arr)); //  [1, 2, 3, 4，5]</span><br><span class="line">5.</span><br><span class="line">let arr = [1, [2, [3, 4]]];</span><br><span class="line">function flatten(arr) &#123;</span><br><span class="line">  return arr.flat(Infinity);</span><br><span class="line">&#125;</span><br><span class="line">console.log(flatten(arr)); //  [1, 2, 3, 4，5]</span><br><span class="line"></span><br><span class="line">6. </span><br><span class="line">let arr = [1, [2, [3, [4, 5]]], 6];</span><br><span class="line">function flatten(arr) &#123;</span><br><span class="line">  let str = JSON.stringify(arr);</span><br><span class="line">  str = str.replace(/(\[|\])/g, &#x27;&#x27;);</span><br><span class="line">  str = &#x27;[&#x27; + str + &#x27;]&#x27;;</span><br><span class="line">  return JSON.parse(str); </span><br><span class="line">&#125;</span><br><span class="line">console.log(flatten(arr)); //  [1, 2, 3, 4，5]</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="实现数组去重"><a href="#实现数组去重" class="headerlink" title="实现数组去重"></a>实现数组去重</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. new set()</span><br><span class="line">const array = [1, 2, 3, 5, 1, 5, 9, 1, 2, 8];</span><br><span class="line"></span><br><span class="line">Array.from(new Set(array)); // [1, 2, 3, 5, 9, 8]</span><br><span class="line"></span><br><span class="line">2. const array = [1, 2, 3, 5, 1, 5, 9, 1, 2, 8];</span><br><span class="line"></span><br><span class="line">uniqueArray(array); // [1, 2, 3, 5, 9, 8]</span><br><span class="line"></span><br><span class="line">function uniqueArray(array) &#123;</span><br><span class="line">  let map = &#123;&#125;;</span><br><span class="line">  let res = [];</span><br><span class="line">  for(var i = 0; i &lt; array.length; i++) &#123;</span><br><span class="line">    if(!map.hasOwnProperty([array[i]])) &#123;</span><br><span class="line">      map[array[i]] = 1;</span><br><span class="line">      res.push(array[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="实现数组的flat方法"><a href="#实现数组的flat方法" class="headerlink" title="实现数组的flat方法"></a>实现数组的flat方法</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function _flat(arr, depth) &#123;</span><br><span class="line">  if(!Array.isArray(arr) || depth &lt;= 0) &#123;</span><br><span class="line">    return arr;</span><br><span class="line">  &#125;</span><br><span class="line">  return arr.reduce((prev, cur) =&gt; &#123;</span><br><span class="line">    if (Array.isArray(cur)) &#123;</span><br><span class="line">      return prev.concat(_flat(cur, depth - 1))</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      return prev.concat(cur);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, []);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="实现数组的push方法"><a href="#实现数组的push方法" class="headerlink" title="实现数组的push方法"></a>实现数组的push方法</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let arr = [];</span><br><span class="line">Array.prototype.push = function() &#123;</span><br><span class="line">	for( let i = 0 ; i &lt; arguments.length ; i++)&#123;</span><br><span class="line">		this[this.length] = arguments[i] ;</span><br><span class="line">	&#125;</span><br><span class="line">	return this.length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="实现数组的filter方法"><a href="#实现数组的filter方法" class="headerlink" title="实现数组的filter方法"></a>实现数组的filter方法</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Array.prototype.filter = function(fn) &#123;</span><br><span class="line">  if (typeof fn !== &#x27;function&#x27;) &#123;</span><br><span class="line">    throw new Error(&#x27;type error&#x27;)</span><br><span class="line">  &#125;</span><br><span class="line">  let res = []</span><br><span class="line">  for (let i = 0; i &lt; this.lenght; i ++) &#123;</span><br><span class="line">    let cur = this[i]</span><br><span class="line">    let f = fn(cur)</span><br><span class="line">    if (f) &#123;</span><br><span class="line">      res.push(cur</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="实现数组的map方法"><a href="#实现数组的map方法" class="headerlink" title="实现数组的map方法"></a>实现数组的map方法</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Array.prototype.map = function(fn)&#123;</span><br><span class="line">  if (typeof fn !== &#x27;function&#x27;) &#123;</span><br><span class="line">    throw new Error(&#x27;type error&#x27;)</span><br><span class="line">  &#125;</span><br><span class="line">  let res = []</span><br><span class="line">  for (let i = 0; i &lt; this.lenght; i ++) &#123;</span><br><span class="line">    let cur = this[i]</span><br><span class="line">    res.push(fn(cur))</span><br><span class="line">  &#125;</span><br><span class="line">  return res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="实现字符串的repeat方法"><a href="#实现字符串的repeat方法" class="headerlink" title="实现字符串的repeat方法"></a>实现字符串的repeat方法</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function repeat (s, n) &#123;</span><br><span class="line">  return (new Array(n + 1)).join(s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function repeat(s, n) &#123;</span><br><span class="line">    return (n &gt; 0) ? s.concat(repeat(s, --n)) : &quot;&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="实现字符串翻转"><a href="#实现字符串翻转" class="headerlink" title="实现字符串翻转"></a>实现字符串翻转</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String.prototype._reverse = function(a)&#123;</span><br><span class="line">    return a.split(&quot;&quot;).reverse().join(&quot;&quot;);</span><br><span class="line">&#125;</span><br><span class="line">var obj = new String();</span><br><span class="line">var res = obj._reverse (&#x27;hello&#x27;);</span><br><span class="line">console.log(res);    // olleh</span><br><span class="line"></span><br><span class="line">function _reverse(s) &#123;</span><br><span class="line">  let left = 0;</span><br><span class="line">  let right = s.length - 1</span><br><span class="line">  while(left++ &lt; right--) &#123;</span><br><span class="line">    [s[left], s[right]] = [s[right], s[left]]</span><br><span class="line">  &#125;</span><br><span class="line">  return s</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="将数字每千分位用逗号隔开"><a href="#将数字每千分位用逗号隔开" class="headerlink" title="将数字每千分位用逗号隔开"></a>将数字每千分位用逗号隔开</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let format = n =&gt; &#123;</span><br><span class="line">    let num = n.toString() // 转成字符串</span><br><span class="line">    let decimals = &#x27;&#x27;</span><br><span class="line">        // 判断是否有小数</span><br><span class="line">    num.indexOf(&#x27;.&#x27;) &gt; -1 ? decimals = num.split(&#x27;.&#x27;)[1] : decimals</span><br><span class="line">    let len = num.length</span><br><span class="line">    if (len &lt;= 3) &#123;</span><br><span class="line">        return num</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        let temp = &#x27;&#x27;</span><br><span class="line">        let remainder = len % 3</span><br><span class="line">        decimals ? temp = &#x27;.&#x27; + decimals : temp</span><br><span class="line">        if (remainder &gt; 0) &#123; // 不是3的整数倍</span><br><span class="line">            return num.slice(0, remainder) + &#x27;,&#x27; + num.slice(remainder, len).match(/\d&#123;3&#125;/g).join(&#x27;,&#x27;) + temp</span><br><span class="line">        &#125; else &#123; // 是3的整数倍</span><br><span class="line">            return num.slice(0, len).match(/\d&#123;3&#125;/g).join(&#x27;,&#x27;) + temp </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">format(12323.33)  // &#x27;12,323.33&#x27;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="实现非负大整数相加"><a href="#实现非负大整数相加" class="headerlink" title="实现非负大整数相加"></a>实现非负大整数相加</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function sumBigNumber(a, b) &#123;</span><br><span class="line">  let res = &#x27;&#x27;;</span><br><span class="line">  let temp = 0;</span><br><span class="line">  </span><br><span class="line">  a = a.split(&#x27;&#x27;);</span><br><span class="line">  b = b.split(&#x27;&#x27;);</span><br><span class="line">  </span><br><span class="line">  while (a.length || b.length || temp) &#123;</span><br><span class="line">    temp += ~~a.pop() + ~~b.pop();</span><br><span class="line">    res = (temp % 10) + res;</span><br><span class="line">    temp  = temp &gt; 9</span><br><span class="line">  &#125;</span><br><span class="line">  return res.replace(/^0+/, &#x27;&#x27;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="实现-add-1-2-3"><a href="#实现-add-1-2-3" class="headerlink" title="实现 add(1)(2)(3)"></a>实现 add(1)(2)(3)</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function curry(fn, ...args) &#123;</span><br><span class="line">    let nums = []</span><br><span class="line"></span><br><span class="line">    return function temp(...newArgs) &#123;</span><br><span class="line">      if (newArgs.length) &#123;</span><br><span class="line">        nums = [...nums, ...newArgs]</span><br><span class="line">        return temp</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        return f(...nums)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function f(...args) &#123;</span><br><span class="line">    return [...args].reduce((total, i) =&gt; total += i, 0)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  console.log(curry(f)(1)(2)(3, 4, 5)())</span><br><span class="line">  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="实现类数组转化为数组"><a href="#实现类数组转化为数组" class="headerlink" title="实现类数组转化为数组"></a>实现类数组转化为数组</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Array.prototype.slice.call(arrayLike);</span><br><span class="line"></span><br><span class="line">Array.prototype.splice.call(arrayLike, 0);</span><br><span class="line"></span><br><span class="line">Array.prototype.concat.apply([], arrayLike);</span><br><span class="line"></span><br><span class="line">Array.from(arrayLike);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="将js对象转化为树形结构"><a href="#将js对象转化为树形结构" class="headerlink" title="将js对象转化为树形结构"></a>将js对象转化为树形结构</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 转换前：</span><br><span class="line">source = [&#123;</span><br><span class="line">            id: 1,</span><br><span class="line">            pid: 0,</span><br><span class="line">            name: &#x27;body&#x27;</span><br><span class="line">          &#125;, &#123;</span><br><span class="line">            id: 2,</span><br><span class="line">            pid: 1,</span><br><span class="line">            name: &#x27;title&#x27;</span><br><span class="line">          &#125;, &#123;</span><br><span class="line">            id: 3,</span><br><span class="line">            pid: 2,</span><br><span class="line">            name: &#x27;div&#x27;</span><br><span class="line">          &#125;]</span><br><span class="line">// 转换为: </span><br><span class="line">tree = [&#123;</span><br><span class="line">          id: 1,</span><br><span class="line">          pid: 0,</span><br><span class="line">          name: &#x27;body&#x27;,</span><br><span class="line">          children: [&#123;</span><br><span class="line">            id: 2,</span><br><span class="line">            pid: 1,</span><br><span class="line">            name: &#x27;title&#x27;,</span><br><span class="line">            children: [&#123;</span><br><span class="line">              id: 3,</span><br><span class="line">              pid: 1,</span><br><span class="line">              name: &#x27;div&#x27;</span><br><span class="line">            &#125;]</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function buildTree(data) &#123;</span><br><span class="line">  let result = []</span><br><span class="line">  let map = &#123;&#125;</span><br><span class="line">  data.forEach(item =&gt; &#123;</span><br><span class="line">    map[item.id] = item</span><br><span class="line">  &#125;)</span><br><span class="line">  data.forEach(item =&gt; &#123;</span><br><span class="line">    let parent = map[item.pid]</span><br><span class="line">    if (paent) &#123;</span><br><span class="line">      parent.children ? parent.children.push(item) ? parent.children = [item]</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      result.push(item)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  return result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="使用ES5和ES6求函数参数的和"><a href="#使用ES5和ES6求函数参数的和" class="headerlink" title="使用ES5和ES6求函数参数的和"></a>使用ES5和ES6求函数参数的和</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function sum() &#123;</span><br><span class="line">    let sum = 0</span><br><span class="line">    Array.prototype.forEach.call(arguments, function(item) &#123;</span><br><span class="line">        sum += item * 1</span><br><span class="line">    &#125;)</span><br><span class="line">    return sum</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function sum(...nums) &#123;</span><br><span class="line">    let sum = 0</span><br><span class="line">    nums.forEach(function(item) &#123;</span><br><span class="line">        sum += item * 1</span><br><span class="line">    &#125;)</span><br><span class="line">    return sum</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="解析-URL-Params-为对象"><a href="#解析-URL-Params-为对象" class="headerlink" title="解析 URL Params 为对象"></a>解析 URL Params 为对象</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">let url = &#x27;http://www.domain.com/?user=anonymous&amp;id=123&amp;id=456&amp;city=%E5%8C%97%E4%BA%AC&amp;enabled&#x27;;</span><br><span class="line">parseParam(url)</span><br><span class="line">/* 结果</span><br><span class="line">&#123; user: &#x27;anonymous&#x27;,</span><br><span class="line">  id: [ 123, 456 ], // 重复出现的 key 要组装成数组，能被转成数字的就转成数字类型</span><br><span class="line">  city: &#x27;北京&#x27;, // 中文需解码</span><br><span class="line">  enabled: true, // 未指定值得 key 约定为 true</span><br><span class="line">&#125;</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function parseParam(url) &#123;</span><br><span class="line">  const paramsStr = /.+\?(.+)$/.exec(url)[1]; // 将 ? 后面的字符串取出来</span><br><span class="line">  const paramsArr = paramsStr.split(&#x27;&amp;&#x27;); // 将字符串以 &amp; 分割后存到数组中</span><br><span class="line">  let paramsObj = &#123;&#125;;</span><br><span class="line">  // 将 params 存到对象中</span><br><span class="line">  paramsArr.forEach(param =&gt; &#123;</span><br><span class="line">    if (/=/.test(param)) &#123; // 处理有 value 的参数</span><br><span class="line">      let [key, val] = param.split(&#x27;=&#x27;); // 分割 key 和 value</span><br><span class="line">      val = decodeURIComponent(val); // 解码</span><br><span class="line">      val = /^\d+$/.test(val) ? parseFloat(val) : val; // 判断是否转为数字</span><br><span class="line">      if (paramsObj.hasOwnProperty(key)) &#123; // 如果对象有 key，则添加一个值</span><br><span class="line">        paramsObj[key] = [].concat(paramsObj[key], val);</span><br><span class="line">      &#125; else &#123; // 如果对象没有这个 key，创建 key 并设置值</span><br><span class="line">        paramsObj[key] = val;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; else &#123; // 处理没有 value 的参数</span><br><span class="line">      paramsObj[param] = true;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  return paramsObj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="循环打印红黄绿"><a href="#循环打印红黄绿" class="headerlink" title="循环打印红黄绿"></a>循环打印红黄绿</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const taskRunner =  async () =&gt; &#123;</span><br><span class="line">    await task(3000, &#x27;red&#x27;)</span><br><span class="line">    await task(2000, &#x27;green&#x27;)</span><br><span class="line">    await task(2100, &#x27;yellow&#x27;)</span><br><span class="line">    taskRunner()</span><br><span class="line">&#125;</span><br><span class="line">taskRunner()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="实现每隔一秒打印-1-2-3-4"><a href="#实现每隔一秒打印-1-2-3-4" class="headerlink" title="实现每隔一秒打印 1,2,3,4"></a>实现每隔一秒打印 1,2,3,4</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for (let i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">  setTimeout(function() &#123;</span><br><span class="line">    console.log(i);</span><br><span class="line">  &#125;, i * 1000);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="小孩报数问题"><a href="#小孩报数问题" class="headerlink" title="小孩报数问题"></a>小孩报数问题</h1><p>有30个小孩儿，编号从1-30，围成一圈依此报数，1、2、3 数到 3 的小孩儿退出这个圈， 然后下一个小孩 重新报数 1、2、3，问最后剩下的那个小孩儿的编号是多少?</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function live(nums, count) &#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>面试</category>
        <category>js</category>
      </categories>
  </entry>
  <entry>
    <title>javascript面试-react</title>
    <url>/2021/08/19/js%E9%9D%A2%E8%AF%95%E9%A2%98-react/</url>
    <content><![CDATA[<h1 id="请说一下你对React的理解"><a href="#请说一下你对React的理解" class="headerlink" title="请说一下你对React的理解"></a>请说一下你对React的理解</h1><pre><code>+ 解题思路
    - 是什么？一句话直达本质
    - 能干什么？ 用途和应用场景
    - 如何干的？核心的工作原理
    干的怎么样？优缺点
</code></pre>
<h2 id="React是什么？"><a href="#React是什么？" class="headerlink" title="React是什么？"></a>React是什么？</h2><pre><code>React是一个用于构建用户界面的js库
</code></pre>
<h2 id="React能干什么"><a href="#React能干什么" class="headerlink" title="React能干什么"></a>React能干什么</h2><pre><code>React通过组件化的方式构建快速响应的大型Web应用程序
</code></pre>
<h2 id="React如何干的"><a href="#React如何干的" class="headerlink" title="React如何干的"></a>React如何干的</h2><h3 id="声明式"><a href="#声明式" class="headerlink" title="声明式"></a>声明式</h3><pre><code>+ 声明式使用声明式的编写用户界面，代码可方便调试
+ 声明式渲染和命令式渲染
    - 命令式渲染 命令我们的程序去做什么，程序就会跟着你的命令去一步步执行
    - 声明式渲染 我们只要告诉程序我们想要什么效果，其他的交给程序来做
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let root = document.getElementById(&#x27;root&#x27;)</span><br><span class="line">// 声明式</span><br><span class="line">ReactDOM.render(&lt;h1&gt;声明式&lt;/h1&gt;, root);</span><br><span class="line">let h1 = document.creatElement(&#x27;h1&#x27;)</span><br><span class="line">root.appendCHild(h1)</span><br><span class="line">// </span><br></pre></td></tr></table></figure>
</code></pre>
<h3 id="组件化"><a href="#组件化" class="headerlink" title="组件化"></a>组件化</h3><pre><code> 组件化 把页面拆分为一个个组件，方便视图的拆分和复用，还可以做到高内聚和低耦合
</code></pre>
<h3 id="一次学习，随处编写"><a href="#一次学习，随处编写" class="headerlink" title="一次学习，随处编写"></a>一次学习，随处编写</h3><pre><code>+ 开发web,android,ios,VR,和命令行程序
+ reactNative使用react来创建android和iOS的原生应用
+ react 360是一个创建3D和VR用户交互的框架
</code></pre>
<h2 id="React干的怎么样？"><a href="#React干的怎么样？" class="headerlink" title="React干的怎么样？"></a>React干的怎么样？</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><pre><code>+ 开发团队和社区强大
+ 一次学习，随处编写
+ API比较简洁
</code></pre>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><pre><code>+ 没有官方系统解决方案，选型成本高
+ 过于灵活，不容易写出高质量的应用
</code></pre>
<h2 id="其他扩展"><a href="#其他扩展" class="headerlink" title="其他扩展"></a>其他扩展</h2><pre><code>+ JSX实现声明式
+ 虚拟DOM可以实现跨平台
+ React使用的设计模式 
+ 自己React大型架构经验
</code></pre>
<h1 id="为什么React会引入JSX"><a href="#为什么React会引入JSX" class="headerlink" title="为什么React会引入JSX"></a>为什么React会引入JSX</h1><pre><code>+ 题目分析 方案选型，考察知识扩展
+ 解题思路
    - 即使概念
    - 想实现什么目的？
    - 有哪些可选方案，为什么这个方案最好
    - JSX的工作原理？
</code></pre>
<h2 id="JSX是什么"><a href="#JSX是什么" class="headerlink" title="JSX是什么"></a>JSX是什么</h2><pre><code>+ jsx是一个js的语法扩展，jsx可以很好的描述UI应该呈现出它应有交互的本质形式
+ jsx其实式React.createElement的语法糖
</code></pre>
<h2 id="React想实现什么目的"><a href="#React想实现什么目的" class="headerlink" title="React想实现什么目的"></a>React想实现什么目的</h2><pre><code>+ 需要实现声明式
+ 代码结构需要非常清晰和简洁，可读性强
+ 结构、样式、和事件等能够实现高内聚低耦合，方便重用和组合
+ 不想引入新的概念和语法，只写js
</code></pre>
<h2 id="为什么JSX最好（列举其他）"><a href="#为什么JSX最好（列举其他）" class="headerlink" title="为什么JSX最好（列举其他）"></a>为什么JSX最好（列举其他）</h2><pre><code>+ Vue.js使用了基于HTML的模版语法，允许开发者声明式的将DOM绑定至底层VUE实例的数据
+ 引入太多概念，比如ng就引入了控制器、作用域、服务等概念
</code></pre>
<h2 id="JSX工作原理"><a href="#JSX工作原理" class="headerlink" title="JSX工作原理"></a>JSX工作原理</h2><h3 id="AST抽象语法树"><a href="#AST抽象语法树" class="headerlink" title="AST抽象语法树"></a>AST抽象语法树</h3><p>抽象语法树式源代码语法结构的一种抽象表示，它以树状的形式表现编程语言的语法结构，树上的每个节点都表示源中的一种结构。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">type,props,children</span><br></pre></td></tr></table></figure>

<h3 id="babel工作流"><a href="#babel工作流" class="headerlink" title="babel工作流"></a>babel工作流</h3><p>code =&gt;词法分析=&gt;语法分析=&gt;转换新的树=&gt;code源代码</p>
<h3 id="旧转换-classic"><a href="#旧转换-classic" class="headerlink" title="旧转换 classic"></a>旧转换 classic</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const babel = require(&#x27;@babel/core&#x27;)</span><br><span class="line">const source = &#x27;&lt;h1&gt;111&lt;/h1&gt;&#x27;</span><br><span class="line">const result = babel.transform(source, &#123;</span><br><span class="line">    plugin: [</span><br><span class="line">        [</span><br><span class="line">            &#x27;@babel/plugin-transform-react-jsx&#x27;, &#123;</span><br><span class="line">                runtime: &#x27;classic&#x27;</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="新转换-automatic"><a href="#新转换-automatic" class="headerlink" title="新转换 automatic"></a>新转换 automatic</h3><p>automatic不需要引入React</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">const babel = require(&#x27;@babel/core&#x27;)</span><br><span class="line">const source = &#x27;&lt;h1&gt;111&lt;/h1&gt;&#x27;</span><br><span class="line">const result = babel.transform(source, &#123;</span><br><span class="line">    plugin: [</span><br><span class="line">        [</span><br><span class="line">            &#x27;@babel/plugin-transform-react-jsx&#x27;, &#123;</span><br><span class="line">                runtime: &#x27;automatic&#x27;</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>


<h1 id="请说一下你对Virtual-Dom的理解"><a href="#请说一下你对Virtual-Dom的理解" class="headerlink" title="请说一下你对Virtual Dom的理解"></a>请说一下你对Virtual Dom的理解</h1><p>题目分析 本题属于概念题<br>解题思路<br>    + 是什么？一句话直达本质<br>    + 能干什么？用途和应用场景<br>    + 如何干的？核心的工作原理<br>    + 干的怎么样？优缺点<br>    + 其他扩展</p>
<h2 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h2><p>虚拟DOM就是一个描述真实DOM的纯JS对象</p>
<h2 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h2><ul>
<li>处理了浏览器的兼容性问题，避免用户操作真实DOM，</li>
<li>内容经过了XSS处理，可以防范XSS攻击</li>
<li>更容易实现跨平台开发Android,ios,VR 应用</li>
<li>更新的时候可以实现差异化更新，减少更新DOM的操作</li>
</ul>
<h2 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h2><ul>
<li>虚拟DOM需要消耗额外的内存</li>
<li>首次渲染其实并不一定更快</li>
</ul>
<h1 id="函数组件和类组件的相同点和不同点？"><a href="#函数组件和类组件的相同点和不同点？" class="headerlink" title="函数组件和类组件的相同点和不同点？"></a>函数组件和类组件的相同点和不同点？</h1><p>题目分析 本题属于差异题<br>解题思路</p>
<ul>
<li>相同点</li>
<li>不同点</li>
</ul>
<h2 id="函数组件"><a href="#函数组件" class="headerlink" title="函数组件"></a>函数组件</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let v = (</span><br><span class="line">    &lt;div&gt;hello word&lt;/div&gt;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">function VF (props) &#123;</span><br><span class="line">    return v</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let fdom = &lt;VF /&gt;</span><br></pre></td></tr></table></figure>

<h2 id="类组件"><a href="#类组件" class="headerlink" title="类组件"></a>类组件</h2><h2 id="源代码怎么区分普通函数还是类组件"><a href="#源代码怎么区分普通函数还是类组件" class="headerlink" title="源代码怎么区分普通函数还是类组件"></a>源代码怎么区分普通函数还是类组件</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function Component(props) &#123;</span><br><span class="line">    this.props = props</span><br><span class="line">&#125;</span><br><span class="line">Component.prototype.isReactComponent = &#123;&#125;</span><br></pre></td></tr></table></figure>

<h2 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a>相同点</h2><p>他们都可以接收属性并且返回React元素</p>
<h2 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h2><ul>
<li>编程思想不同：类组件需要创建实例，是基于面向对象的方式编程，而函数组件不需要创建实例，接收输入，返回输出，是基于函数式编程思想写的</li>
<li>内存占用：类组件需要创建并保存实例，会占用一定内存，函数组件不需要创建实例，可以节约内存占用</li>
<li>捕获特性：函数组件具有捕获特性</li>
<li>可测试性：函数组件更方便写单元测试</li>
<li>状态：类组件有自己的实例，可以定义状态，而且可以修改状态更新组件，函数组件以前没有状态，现在可以使用useState使用状态</li>
<li>声明周期：类组件有自己完整的生命周期，可以在声明周期里面写逻辑，函数组件没有声明周期，现在可以使用useEffect实现类似声明周期的功能</li>
<li>逻辑复用：类组件可以通过继承实现逻辑的复用，但官方推荐组件优先继承，函数组件可以通过自定义hooks实现逻辑复用</li>
<li>跳过更新：类组件可以通过shouldComponentUpdate和PureCompinent来跳过更新，而函数式组件可以使用React.momo来跳过更新</li>
<li>发展前景：未来函数式组件将成为主流，因为它可以更好的屏蔽this问题，规范和复用逻辑，更好的适合时间分片和并发渲染</li>
</ul>
<h2 id="值捕获"><a href="#值捕获" class="headerlink" title="值捕获"></a>值捕获</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import &#123;useState&#125; from &#x27;react&#x27;</span><br><span class="line">function () &#123;</span><br><span class="line">    const [number, setNumber] = useState(0)</span><br><span class="line"></span><br><span class="line">    handleClick = () =&gt; &#123;</span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">            console.log(number) // 0</span><br><span class="line">        &#125;, 3000)</span><br><span class="line">        setNumber(number+1)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return (</span><br><span class="line">        &lt;div onClick=&#123;handleClick&#125;&gt;&#123;number&#125;&lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class...</span><br><span class="line">this.state = &#123;number: 0&#125;</span><br><span class="line"> handleClick = () =&gt; &#123;</span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">            console.log() // 1</span><br><span class="line">        &#125;, 3000)</span><br><span class="line">        this.setState(&#123;</span><br><span class="line">            number: this.state.number + 1</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    render (</span><br><span class="line">        &lt;div onClick=&#123;handleClick&#125;&gt;&#123;number&#125;&lt;/div&gt;</span><br><span class="line">    )</span><br></pre></td></tr></table></figure>

<h1 id="请说一下React中的渲染流程"><a href="#请说一下React中的渲染流程" class="headerlink" title="请说一下React中的渲染流程"></a>请说一下React中的渲染流程</h1><p>解题思路</p>
<ul>
<li>宏观的设计理念</li>
<li>关键原理清晰描述，抽象和具象相结合</li>
<li>结合工程实践和工作成果</li>
</ul>
<h2 id="设计理念"><a href="#设计理念" class="headerlink" title="设计理念"></a>设计理念</h2><ul>
<li>跨平台渲染 =&gt;虚拟DOM</li>
<li>快速响应 =&gt; 异步可中断+ 增量更新</li>
</ul>
<h2 id="性能瓶颈"><a href="#性能瓶颈" class="headerlink" title="性能瓶颈"></a>性能瓶颈</h2><p>js任务执行实践过长</p>
<ul>
<li>浏览器刷新的频率为60HZ，大概16.6毫秒（1/ 60 * 1000）渲染一次，而js线程和渲染线程是互斥的，所以如果js线程执行任务时间超过了16.6ms的话，就会导致掉帧，导致卡顿，解决方案就是React利用空闲的实践进行更新，不影响渲染进行的渲染</li>
<li>把一个耗时的任务分成一个个小任务，分布在每一帧里的方式就叫做时间切片</li>
</ul>
<h2 id="屏幕刷新率"><a href="#屏幕刷新率" class="headerlink" title="屏幕刷新率"></a>屏幕刷新率</h2><h2 id="桢"><a href="#桢" class="headerlink" title="桢"></a>桢</h2><h2 id="requestIdelCallback-React使用MessageChannel-requestAnimationFrame模拟RequestIdleCallback"><a href="#requestIdelCallback-React使用MessageChannel-requestAnimationFrame模拟RequestIdleCallback" class="headerlink" title="requestIdelCallback(React使用MessageChannel+requestAnimationFrame模拟RequestIdleCallback)"></a>requestIdelCallback(React使用MessageChannel+requestAnimationFrame模拟RequestIdleCallback)</h2><ul>
<li>我们希望快速响应用户，让用户觉得够快，不能阻塞用户的交互</li>
<li>requestIdleCallback使开发者能够在主事件循环上执行后台和低优先级工作，而不会影响延迟关键事件，如动画和输入响应</li>
<li>正常桢任务完成后没超过16.6ms，说明时间有富裕，此时就会执行requestIdleCallback里注册的任务<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">requestIdleCallback(fn)</span><br><span class="line">function fn(deadline) &#123;</span><br><span class="line">    deadline.timeRemaining()</span><br><span class="line">    while(deading.timeRemaining() &gt; 0) &#123;</span><br><span class="line">        doSomeThing()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="fiber"><a href="#fiber" class="headerlink" title="fiber"></a>fiber</h2></li>
<li>我们可以通过某些调度策略合理分配CPU资源，从而提高用户的响应速度</li>
<li>通过fiber架构，让自己的调和过程变成可被中断。适时让出CPU执行权，可以让浏览器及时响应用户的交互<h3 id="fiber是一个执行单元"><a href="#fiber是一个执行单元" class="headerlink" title="fiber是一个执行单元"></a>fiber是一个执行单元</h3></li>
<li>Fiber是一个执行单元，每次执行完一个执行单元，React就会检查现在还剩下多少时间，如果没有时间就将控制权让出去</li>
</ul>
<h1 id="react-hooks"><a href="#react-hooks" class="headerlink" title="react hooks"></a>react hooks</h1><p>hooks可以让你在不编写class的情况下使用state以及其他的React特性</p>
<h2 id="hooks的优点"><a href="#hooks的优点" class="headerlink" title="hooks的优点"></a>hooks的优点</h2><ul>
<li>可以抽离公共方法和逻辑，提高代码的可复用性</li>
<li>函数式组件更简洁，开发效率更高</li>
</ul>
<h2 id="自定义hooks"><a href="#自定义hooks" class="headerlink" title="自定义hooks"></a>自定义hooks</h2><ul>
<li>通过自定义hook，可以将组件逻辑提取到可重用的函数中</li>
<li>自定义hook是一个函数，其名称以use开头，函数内部可以调用其他的hook</li>
</ul>
<h1 id="请说一下React中的DOM-DIff算法"><a href="#请说一下React中的DOM-DIff算法" class="headerlink" title="请说一下React中的DOM-DIff算法"></a>请说一下React中的DOM-DIff算法</h1><p>DOM-DIFF就是根据老得fiber树和最新的JSX对比生成新的fiber树的过程</p>
<h2 id="react优化原则"><a href="#react优化原则" class="headerlink" title="react优化原则"></a>react优化原则</h2><ul>
<li>只对同级节点进行对比，如果DOM节点跨层移动，则React不会复用</li>
<li>不同类型的元素会产生不同的结构，会销毁老得结构，创建新的结构</li>
<li>可以通过key标示移动的元素</li>
</ul>
<p>具体的流程如下：</p>
<ul>
<li>真实的 DOM 首先会映射为虚拟 DOM；</li>
<li>当虚拟 DOM 发生变化后，就会根据差距计算生成 patch，这个 patch 是一个结构化的数据，内容包含了增加、更新、移除等；</li>
<li>根据 patch 去更新真实的 DOM，反馈到用户的界面上。</li>
</ul>
<p>diff算法可以总结为三个策略，分别从树、组件及元素三个层面进行复杂度的优化：</p>
<ol>
<li>策略一：忽略节点跨层级操作场景，提升比对效率。（基于树进行对比）<br>这一策略需要进行树比对，即对树进行分层比较。树比对的处理手法是非常“暴力”的，即两棵树只对同一层次的节点进行比较，如果发现节点已经不存在了，则该节点及其子节点会被完全删除掉，不会用于进一步的比较，这就提升了比对效率。</li>
<li>策略二：如果组件的 class 一致，则默认为相似的树结构，否则默认为不同的树结构。（基于组件进行对比）<br>在组件比对的过程中：</li>
</ol>
<ul>
<li>如果组件是同一类型则进行树比对；</li>
<li>如果不是则直接放入补丁中。</li>
</ul>
<p>只要父组件类型不同，就会被重新渲染。这也就是为什么 shouldComponentUpdate、PureComponent 及 React.memo 可以提高性能的原因。<br>3. 策略三：同一层级的子节点，可以通过标记 key 的方式进行列表对比。（基于节点进行对比）<br>元素比对主要发生在同层级中，通过标记节点操作生成补丁。节点操作包含了插入、移动、删除等。其中节点重新排序同时涉及插入、移动、删除三个操作，所以效率消耗最大，此时策略三起到了至关重要的作用。通过标记 key 的方式，React 可以直接移动 DOM 节点，降低内耗。</p>
<ul>
<li>单节点<br>直接对比，更新删除</li>
<li>多节点<br>两次遍历，第一次更新，key或者type不同，就进入第二次遍历<br>第二次遍历，会生成map，进行标记（更新，删除，移动，插入）<br>生成真实dom</li>
</ul>
<h1 id="为什么不能在条件和循环里使用hooks"><a href="#为什么不能在条件和循环里使用hooks" class="headerlink" title="为什么不能在条件和循环里使用hooks"></a>为什么不能在条件和循环里使用hooks</h1><h1 id="为什么不能在函数组件外部使用hooks"><a href="#为什么不能在函数组件外部使用hooks" class="headerlink" title="为什么不能在函数组件外部使用hooks"></a>为什么不能在函数组件外部使用hooks</h1><h1 id="React-Hooks的状态保存在哪里"><a href="#React-Hooks的状态保存在哪里" class="headerlink" title="React Hooks的状态保存在哪里"></a>React Hooks的状态保存在哪里</h1><h1 id="为什么传入两次相同的状态，函数组件不更新"><a href="#为什么传入两次相同的状态，函数组件不更新" class="headerlink" title="为什么传入两次相同的状态，函数组件不更新"></a>为什么传入两次相同的状态，函数组件不更新</h1><h1 id="函数组件的useState和类组件的setState有什么区别"><a href="#函数组件的useState和类组件的setState有什么区别" class="headerlink" title="函数组件的useState和类组件的setState有什么区别"></a>函数组件的useState和类组件的setState有什么区别</h1><h1 id="组件基础"><a href="#组件基础" class="headerlink" title="组件基础"></a>组件基础</h1><h2 id="React-事件机制"><a href="#React-事件机制" class="headerlink" title="React 事件机制"></a>React 事件机制</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div onClick=&#123;this.handleClick.bind(this)&#125;&gt;点我&lt;/div&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>React 并不是将click事件绑定到div的真实DOM 上，而是在document处监听了所有的事件，当事件发生并且冒泡到document处的时候，React将事件内容封装并交由真正的处理函数运行。这样的方式不仅仅减少了内存的消耗，还能在组建挂载销毁时统一订阅和移除事件。</p>
<p>除此之外，冒泡到document上的事件也不是原生的浏览器事件，而是由react自己实现的合成事件。因此如果不想要事件冒泡的话应该调用event.preventDefault()方法，而不是调用event.stopProppagation()方法。</p>
<p>实现合成事件的目的如下：</p>
<ul>
<li>合成事件首先抹平了浏览器之间的兼容问题，另外这是一个跨浏览器原生事件包装器，赋予了跨浏览器开发的能力；</li>
<li>对于原生浏览器事件来说，浏览器会给监听器创建一个事件对象。如果你有很多的事件监听，那么就需要分配很多的事件对象，造成高额的内存分配问题。但是对于合成事件来说，有一个事件池专门来管理它们的创建和销毁，当事件需要被使用时，就会从池子中复用对象，事件回调结束后，就会销毁事件对象上的属性，从而便于下次复用事件对象。</li>
</ul>
<h2 id="React的事件和普通的HTML事件有什么不同？"><a href="#React的事件和普通的HTML事件有什么不同？" class="headerlink" title="React的事件和普通的HTML事件有什么不同？"></a>React的事件和普通的HTML事件有什么不同？</h2><p>区别：</p>
<ul>
<li>对于事件名称命名方式，原生事件为全小写，react 事件采用小驼峰；</li>
<li>对于事件函数处理语法，原生事件为字符串，react 事件为函数；</li>
<li>react 事件不能采用 return false 的方式来阻止浏览器的默认行为，而必须要地明确地调用preventDefault()来阻止默认行为。</li>
</ul>
<p>合成事件是 react 模拟原生 DOM 事件所有能力的一个事件对象，其优点如下：</p>
<ul>
<li>兼容所有浏览器，更好的跨平台；</li>
<li>将事件统一存放在一个数组，避免频繁的新增与删除（垃圾回收）。</li>
<li>方便 react 统一管理和事务机制。</li>
</ul>
<p>事件的执行顺序为原生事件先执行，合成事件后执行，合成事件会冒泡绑定到 document 上，所以尽量避免原生事件与合成事件混用，如果原生事件阻止冒泡，可能会导致合成事件不执行，因为需要冒泡到document 上合成事件才会执行。</p>
<h2 id="React-组件中怎么做事件代理？它的原理是什么？"><a href="#React-组件中怎么做事件代理？它的原理是什么？" class="headerlink" title="React 组件中怎么做事件代理？它的原理是什么？"></a>React 组件中怎么做事件代理？它的原理是什么？</h2><p>React基于Virtual DOM实现了一个SyntheticEvent层（合成事件层），定义的事件处理器会接收到一个合成事件对象的实例，它符合W3C标准，且与原生的浏览器事件拥有同样的接口，支持冒泡机制，所有的事件都自动绑定在最外层上。<br>在React底层，主要对合成事件做了两件事：</p>
<ul>
<li>事件委派： React会把所有的事件绑定到结构的最外层，使用统一的事件监听器，这个事件监听器上维持了一个映射来保存所有组件内部事件监听和处理函数。</li>
<li>自动绑定： React组件中，每个方法的上下文都会指向该组件的实例，即自动绑定this为当前组件。</li>
</ul>
<h2 id="React如果没写key，源码不会加上key，而是使用索引来比较"><a href="#React如果没写key，源码不会加上key，而是使用索引来比较" class="headerlink" title="React如果没写key，源码不会加上key，而是使用索引来比较"></a>React如果没写key，源码不会加上key，而是使用索引来比较</h2><h2 id="React-高阶组件、Render-props、hooks-有什么区别，为什么要不断迭代"><a href="#React-高阶组件、Render-props、hooks-有什么区别，为什么要不断迭代" class="headerlink" title="React 高阶组件、Render props、hooks 有什么区别，为什么要不断迭代"></a>React 高阶组件、Render props、hooks 有什么区别，为什么要不断迭代</h2><ol>
<li>HOC<br>高阶组件（HOC）是 React 中用于复用组件逻辑的一种高级技巧。HOC 自身不是 React API 的一部分，它是一种基于 React 的组合特性而形成的设计模式。<br>HOC的优缺点∶</li>
</ol>
<ul>
<li>优点∶ 逻辑服用、不影响被包裹组件的内部逻辑。</li>
<li>缺点∶ hoc传递给被包裹组件的props容易和被包裹后的组件重名，进而被覆盖</li>
</ul>
<ol start="2">
<li>render prop<br>“render prop”是指一种在 React 组件之间使用一个值为函数的 prop 共享代码的简单技术</li>
</ol>
<ul>
<li>优点：数据共享、代码复用，将组件内的state作为props传递给调用者，将渲染逻辑交给调用者。</li>
<li>缺点：无法在 return 语句外访问数据、嵌套写法不够优雅</li>
</ul>
<ol start="3">
<li>Hooks<br>Hook是 React 16.8 的新增特性。它可以让你在不编写 class 的情况下使用 state 以及其他的 React 特性。通过自定义hook，可以复用代码逻辑。</li>
</ol>
<p>优点：</p>
<ul>
<li>使用直观；</li>
<li>解决hoc的prop 重名问题；</li>
<li>解决render props 因共享数据 而出现嵌套地狱的问题；</li>
<li>能在return之外使用数据的问题。</li>
</ul>
<p>总结：Hoc、render props和hook都是为了解决代码复用的问题，但是hoc和render props都有特定的使用场景和明显的缺点。hook是react16.8更新的新的API，让组件逻辑复用更简洁明了，同时也解决了hoc和render props的一些缺点</p>
<h2 id="对React-Fiber的理解，它解决了什么问题？"><a href="#对React-Fiber的理解，它解决了什么问题？" class="headerlink" title="对React-Fiber的理解，它解决了什么问题？"></a>对React-Fiber的理解，它解决了什么问题？</h2><p>React V15 在渲染时，会递归比对 VirtualDOM 树，找出需要变动的节点，然后同步更新它们， 一气呵成。这个过程期间， React 会占据浏览器资源，这会导致用户触发的事件得不到响应，并且会导致掉帧，导致用户感觉到卡顿。<br>为了给用户制造一种应用很快的“假象”，不能让一个任务长期霸占着资源。 可以将浏览器的渲染、布局、绘制、资源加载(例如 HTML 解析)、事件响应、脚本执行视作操作系统的“进程”，需要通过某些调度策略合理地分配 CPU 资源，从而提高浏览器的用户响应速率, 同时兼顾任务执行效率。<br>所以 React 通过Fiber 架构，让这个执行过程变成可被中断。“适时”地让出 CPU 执行权，除了可以让浏览器及时地响应用户的交互，还有其他好处:</p>
<ul>
<li>分批延时对DOM进行操作，避免一次性操作大量 DOM 节点，可以得到更好的用户体验；</li>
<li>给浏览器一点喘息的机会，它会对代码进行编译优化（JIT）及进行热代码优化，或者对 reflow 进行修正。</li>
</ul>
<p>核心思想: Fiber 也称协程或者纤程。它和线程并不一样，协程本身是没有并发或者并行能力的（需要配合线程），它只是一种控制流程的让出机制。让出 CPU 的执行权，让 CPU 能在这段时间执行其他的操作。渲染的过程可以被中断，可以将控制权交回浏览器，让位给高优先级的任务，浏览器空闲后再恢复渲染。</p>
<h2 id="React-Component-和-React-PureComponent-的区别"><a href="#React-Component-和-React-PureComponent-的区别" class="headerlink" title="React.Component 和 React.PureComponent 的区别"></a>React.Component 和 React.PureComponent 的区别</h2><p>PureComponent表示一个纯组件，可以用来优化React程序，减少render函数执行的次数，从而提高组件的性能。<br>在React中，当prop或者state发生变化时，可以通过在shouldComponentUpdate生命周期函数中执行return false来阻止页面的更新，从而减少不必要的render执行。React.PureComponent会自动执行 shouldComponentUpdate。<br>不过，pureComponent中的 shouldComponentUpdate() 进行的是浅比较，也就是说如果是引用数据类型的数据，只会比较不是同一个地址，而不会比较这个地址里面的数据是否一致。浅比较会忽略属性和或状态突变情况，其实也就是数据引用指针没有变化，而数据发生改变的时候render是不会执行的。如果需要重新渲染那么就需要重新开辟空间引用数据。PureComponent一般会用在一些纯展示组件上。<br>使用pureComponent的好处：当组件更新时，如果组件的props或者state都没有改变，render函数就不会触发。省去虚拟DOM的生成和对比过程，达到提升性能的目的。这是因为react自动做了一层浅比较。</p>
<h2 id="Component-Element-Instance-之间有什么区别和联系？"><a href="#Component-Element-Instance-之间有什么区别和联系？" class="headerlink" title="Component, Element, Instance 之间有什么区别和联系？"></a>Component, Element, Instance 之间有什么区别和联系？</h2><ul>
<li>元素： 一个元素element是一个普通对象(plain object)，描述了对于一个DOM节点或者其他组件component，你想让它在屏幕上呈现成什么样子。元素element可以在它的属性props中包含其他元素(译注:用于形成元素树)。创建一个React元素element成本很低。元素element创建之后是不可变的。</li>
<li>组件： 一个组件component可以通过多种方式声明。可以是带有一个render()方法的类，简单点也可以定义为一个函数。这两种情况下，它都把属性props作为输入，把返回的一棵元素树作为输出。</li>
<li>实例： 一个实例instance是你在所写的组件类component class中使用关键字this所指向的东西(译注:组件实例)。它用来存储本地状态和响应生命周期事件很有用。</li>
</ul>
<p>函数式组件(Functional component)根本没有实例instance。类组件(Class component)有实例instance，但是永远也不需要直接创建一个组件的实例，因为React帮我们做了这些。</p>
]]></content>
      <categories>
        <category>面试</category>
        <category>js</category>
      </categories>
  </entry>
  <entry>
    <title>javascript面试-基础</title>
    <url>/2021/08/21/js%E9%9D%A2%E8%AF%95-%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="new操作符的实现原理"><a href="#new操作符的实现原理" class="headerlink" title="new操作符的实现原理"></a>new操作符的实现原理</h1><p>new操作符的执行过程：<br>（1）首先创建了一个新的空对象<br>（2）设置原型，将对象的原型设置为函数的 prototype 对象。<br>（3）让函数的 this 指向这个对象，执行构造函数的代码（为这个新对象添加属性）<br>（4）判断函数的返回值类型，如果是值类型，返回创建的对象。如果是引用类型，就返回这个引用类型的对象。<br>具体实现：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function objectFactory() &#123;</span><br><span class="line">  let newObject = null;</span><br><span class="line">  let constructor = Array.prototype.shift.call(arguments);</span><br><span class="line">  let result = null;</span><br><span class="line">  // 判断参数是否是一个函数</span><br><span class="line">  if (typeof constructor !== &quot;function&quot;) &#123;</span><br><span class="line">    console.error(&quot;type error&quot;);</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line">  // 新建一个空对象，对象的原型为构造函数的 prototype 对象</span><br><span class="line">  newObject = Object.create(constructor.prototype);</span><br><span class="line">  // 将 this 指向新建对象，并执行函数</span><br><span class="line">  result = constructor.apply(newObject, arguments);</span><br><span class="line">  // 判断返回对象</span><br><span class="line">  let flag = result &amp;&amp; (typeof result === &quot;object&quot; || typeof result === &quot;function&quot;);</span><br><span class="line">  // 判断返回结果</span><br><span class="line">  return flag ? result : newObject;</span><br><span class="line">&#125;</span><br><span class="line">// 使用方法</span><br><span class="line">objectFactory(构造函数, 初始化参数);</span><br></pre></td></tr></table></figure>
<h1 id="map和Object的区别"><a href="#map和Object的区别" class="headerlink" title="map和Object的区别"></a>map和Object的区别</h1><table>
<thead>
<tr>
<th></th>
<th>Map</th>
<th>Object</th>
</tr>
</thead>
<tbody><tr>
<td>意外的键</td>
<td>Map默认情况不包含任何键，只包含显式插入的键</td>
<td>Object 有一个原型, 原型链上的键名有可能和自己在对象上的设置的键名产生冲突。</td>
</tr>
<tr>
<td>键的类型</td>
<td>Map的键可以是任意值，包括函数、对象或任意基本类型。</td>
<td>Object 的键必须是 String 或是Symbol。</td>
</tr>
<tr>
<td>键的顺序</td>
<td>Map 中的 key 是有序的。因此，当迭代的时候， Map 对象以插入的顺序返回键值。</td>
<td>Object 的键是无序的</td>
</tr>
<tr>
<td>Size</td>
<td>Map 的键值对个数可以轻易地通过size 属性获取</td>
<td>Object 的键值对个数只能手动计算</td>
</tr>
<tr>
<td>迭代</td>
<td>Map 是 iterable 的，所以可以直接被迭代。</td>
<td>迭代Object需要以某种方式获取它的键然后才能迭代。</td>
</tr>
<tr>
<td>性能</td>
<td>在频繁增删键值对的场景下表现更好。</td>
<td>在频繁添加和删除键值对的场景下未作出优化。</td>
</tr>
</tbody></table>
<h1 id="map和weakMap的区别"><a href="#map和weakMap的区别" class="headerlink" title="map和weakMap的区别"></a>map和weakMap的区别</h1><p>（1）Map<br>map本质上就是键值对的集合，但是普通的Object中的键值对中的键只能是字符串。而ES6提供的Map数据结构类似于对象，但是它的键不限制范围，可以是任意类型，是一种更加完善的Hash结构。如果Map的键是一个原始数据类型，只要两个键严格相同，就视为是同一个键。<br>实际上Map是一个数组，它的每一个数据也都是一个数组，其形式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const map = [</span><br><span class="line">     [&quot;name&quot;,&quot;张三&quot;],</span><br><span class="line">     [&quot;age&quot;,18],</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>Map数据结构有以下操作方法：</p>
<ul>
<li>size： map.size 返回Map结构的成员总数。</li>
<li>set(key,value)：设置键名key对应的键值value，然后返回整个Map结构，如果key已经有值，则键值会被更新，否则就新生成该键。（因为返回的是当前Map对象，所以可以链式调用）</li>
<li>get(key)：该方法读取key对应的键值，如果找不到key，返回undefined。</li>
<li>has(key)：该方法返回一个布尔值，表示某个键是否在当前Map对象中。</li>
<li>delete(key)：该方法删除某个键，返回true，如果删除失败，返回false。</li>
<li>clear()：map.clear()清除所有成员，没有返回值。</li>
</ul>
<p>Map结构原生提供是三个遍历器生成函数和一个遍历方法</p>
<ul>
<li>keys()：返回键名的遍历器。</li>
<li>values()：返回键值的遍历器。</li>
<li>entries()：返回所有成员的遍历器。</li>
<li>forEach()：遍历Map的所有成员。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const map = new Map([</span><br><span class="line">     [&quot;foo&quot;,1],</span><br><span class="line">     [&quot;bar&quot;,2],</span><br><span class="line">])</span><br><span class="line">for(let key of map.keys())&#123;</span><br><span class="line">    console.log(key);  // foo bar</span><br><span class="line">&#125;</span><br><span class="line">for(let value of map.values())&#123;</span><br><span class="line">     console.log(value); // 1 2</span><br><span class="line">&#125;</span><br><span class="line">for(let items of map.entries())&#123;</span><br><span class="line">    console.log(items);  // [&quot;foo&quot;,1]  [&quot;bar&quot;,2]</span><br><span class="line">&#125;</span><br><span class="line">map.forEach( (value,key,map) =&gt; &#123;</span><br><span class="line">     console.log(key,value); // foo 1    bar 2</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>（2）WeakMap<br>WeakMap 对象也是一组键值对的集合，其中的键是弱引用的。其键必须是对象，原始数据类型不能作为key值，而值可以是任意的。<br>该对象也有以下几种方法：</p>
<ul>
<li>set(key,value)：设置键名key对应的键值value，然后返回整个Map结构，如果key已经有值，则键值会被更新，否则就新生成该键。（因为返回的是当前Map对象，所以可以链式调用）</li>
<li>get(key)：该方法读取key对应的键值，如果找不到key，返回undefined。</li>
<li>has(key)：该方法返回一个布尔值，表示某个键是否在当前Map对象中。</li>
<li>delete(key)：该方法删除某个键，返回true，如果删除失败，返回false。</li>
</ul>
<p>其clear()方法已经被弃用，所以可以通过创建一个空的WeakMap并替换原对象来实现清除。<br>WeakMap的设计目的在于，有时想在某个对象上面存放一些数据，但是这会形成对于这个对象的引用。一旦不再需要这两个对象，就必须手动删除这个引用，否则垃圾回收机制就不会释放对象占用的内存。<br>而WeakMap的键名所引用的对象都是弱引用，即垃圾回收机制不将该引用考虑在内。因此，只要所引用的对象的其他引用都被清除，垃圾回收机制就会释放该对象所占用的内存。也就是说，一旦不再需要，WeakMap 里面的键名对象和所对应的键值对会自动消失，不用手动删除引用。<br>总结：</p>
<ul>
<li>Map 数据结构。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。</li>
<li>WeakMap 结构与 Map 结构类似，也是用于生成键值对的集合。但是 WeakMap 只接受对象作为键名（ null 除外），不接受其他类型的值作为键名。而且 WeakMap 的键名所指向的对象，不计入垃圾回收机制。</li>
</ul>
<h1 id="JavaScript有哪些内置对象"><a href="#JavaScript有哪些内置对象" class="headerlink" title="JavaScript有哪些内置对象"></a>JavaScript有哪些内置对象</h1><p>全局的对象（ global objects ）或称标准内置对象，不要和 “全局对象（global object）” 混淆。这里说的全局的对象是说在<br>全局作用域里的对象。全局作用域中的其他对象可以由用户的脚本创建或由宿主程序提供。<br>标准内置对象的分类：</p>
<ol>
<li>值属性，这些全局属性返回一个简单值，这些值没有自己的属性和方法。例如 Infinity、NaN、undefined、null 字面量</li>
<li>函数属性，全局函数可以直接调用，不需要在调用时指定所属对象，执行结束后会将结果直接返回给调用者。例如 eval()、parseFloat()、parseInt() 等</li>
<li>基本对象，基本对象是定义或使用其他对象的基础。基本对象包括一般对象、函数对象和错误对象。例如 Object、Function、Boolean、Symbol、Error 等</li>
<li>数字和日期对象，用来表示数字、日期和执行数学计算的对象。例如 Number、Math、Date</li>
<li>字符串，用来表示和操作字符串的对象。例如 String、RegExp</li>
<li>可索引的集合对象，这些对象表示按照索引值来排序的数据集合，包括数组和类型数组，以及类数组结构的对象。例如 Array</li>
<li>使用键的集合对象，这些集合对象在存储数据时会使用到键，支持按照插入顺序来迭代元素。<br>例如 Map、Set、WeakMap、WeakSet</li>
<li>矢量集合，SIMD 矢量集合中的数据会被组织为一个数据序列。<br>例如 SIMD 等</li>
<li>结构化数据，这些对象用来表示和操作结构化的缓冲区数据，或使用 JSON 编码的数据。例如 JSON 等</li>
<li>控制抽象对象<br>例如 Promise、Generator 等</li>
<li>反射。例如 Reflect、Proxy</li>
<li>国际化，为了支持多语言处理而加入 ECMAScript 的对象。例如 Intl、Intl.Collator 等</li>
<li>WebAssembly</li>
<li>其他。例如 arguments</li>
</ol>
<p>总结：<br>js 中的内置对象主要指的是在程序执行前存在全局作用域里的由 js 定义的一些全局值属性、函数和用来实例化其他对象的构造函数对象。一般经常用到的如全局变量值 NaN、undefined，全局函数如 parseInt()、parseFloat() 用来实例化对象的构造函数如 Date、Object 等，还有提供数学计算的单体内置对象如 Math 对象。</p>
<h1 id="常用的正则表达式有哪些？"><a href="#常用的正则表达式有哪些？" class="headerlink" title="常用的正则表达式有哪些？"></a>常用的正则表达式有哪些？</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// （1）匹配 16 进制颜色值</span><br><span class="line">var regex = /#([0-9a-fA-F]&#123;6&#125;|[0-9a-fA-F]&#123;3&#125;)/g;</span><br><span class="line"></span><br><span class="line">// （2）匹配日期，如 yyyy-mm-dd 格式</span><br><span class="line">var regex = /^[0-9]&#123;4&#125;-(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])$/;</span><br><span class="line"></span><br><span class="line">// （3）匹配 qq 号</span><br><span class="line">var regex = /^[1-9][0-9]&#123;4,10&#125;$/g;</span><br><span class="line"></span><br><span class="line">// （4）手机号码正则</span><br><span class="line">var regex = /^1[34578]\d&#123;9&#125;$/g;</span><br><span class="line"></span><br><span class="line">// （5）用户名正则</span><br><span class="line">var regex = /^[a-zA-Z\$][a-zA-Z0-9_\$]&#123;4,16&#125;$/;</span><br></pre></td></tr></table></figure>
<h1 id="对JSON的理解"><a href="#对JSON的理解" class="headerlink" title="对JSON的理解"></a>对JSON的理解</h1><p>JSON 是一种基于文本的轻量级的数据交换格式。它可以被任何的编程语言读取和作为数据格式来传递。<br>在项目开发中，使用 JSON 作为前后端数据交换的方式。在前端通过将一个符合 JSON 格式的数据结构序列化为<br>JSON 字符串，然后将它传递到后端，后端通过 JSON 格式的字符串解析后生成对应的数据结构，以此来实现前后端数据的一个传递。<br>因为 JSON 的语法是基于 js 的，因此很容易将 JSON 和 js 中的对象弄混，但是应该注意的是 JSON 和 js 中的对象不是一回事，JSON 中对象格式更加严格，比如说在 JSON 中属性值不能为函数，不能出现 NaN 这样的属性值等，因此大多数的 js 对象是不符合 JSON 对象的格式的。<br>在 js 中提供了两个函数来实现 js 数据结构和 JSON 格式的转换处理，</p>
<ul>
<li>JSON.stringify 函数，通过传入一个符合 JSON 格式的数据结构，将其转换为一个 JSON 字符串。如果传入的数据结构不符合 JSON 格式，那么在序列化的时候会对这些值进行对应的特殊处理，使其符合规范。在前端向后端发送数据时，可以调用这个函数将数据对象转化为 JSON 格式的字符串。</li>
<li>JSON.parse() 函数，这个函数用来将 JSON 格式的字符串转换为一个 js 数据结构，如果传入的字符串不是标准的 JSON 格式的字符串的话，将会抛出错误。当从后端接收到 JSON 格式的字符串时，可以通过这个方法来将其解析为一个 js 数据结构，以此来进行数据的访问。</li>
</ul>
<h1 id="JavaScript脚本延迟加载的方式有哪些？"><a href="#JavaScript脚本延迟加载的方式有哪些？" class="headerlink" title="JavaScript脚本延迟加载的方式有哪些？"></a>JavaScript脚本延迟加载的方式有哪些？</h1><p>延迟加载就是等页面加载完成之后再加载 JavaScript 文件。 js 延迟加载有助于提高页面加载速度。<br>一般有以下几种方式：</p>
<ul>
<li>defer 属性： 给 js 脚本添加 defer 属性，这个属性会让脚本的加载与文档的解析同步解析，然后在文档解析完成后再执行这个脚本文件，这样的话就能使页面的渲染不被阻塞。多个设置了 defer 属性的脚本按规范来说最后是顺序执行的，但是在一些浏览器中可能不是这样。</li>
<li>async 属性： 给 js 脚本添加 async 属性，这个属性会使脚本异步加载，不会阻塞页面的解析过程，但是当脚本加载完成后立即执行 js 脚本，这个时候如果文档没有解析完成的话同样会阻塞。多个 async 属性的脚本的执行顺序是不可预测的，一般不会按照代码的顺序依次执行。</li>
<li>动态创建 DOM 方式： 动态创建 DOM 标签的方式，可以对文档的加载事件进行监听，当文档加载完成后再动态的创建 script 标签来引入 js 脚本。</li>
<li>使用 setTimeout 延迟方法： 设置一个定时器来延迟加载js脚本文件</li>
<li>让 JS 最后加载： 将 js 脚本放在文档的底部，来使 js 脚本尽可能的在最后来加载执行。</li>
</ul>
<h1 id="JavaScript-类数组对象的定义？"><a href="#JavaScript-类数组对象的定义？" class="headerlink" title="JavaScript 类数组对象的定义？"></a>JavaScript 类数组对象的定义？</h1><p>一个拥有 length 属性和若干索引属性的对象就可以被称为类数组对象，类数组对象和数组类似，但是不能调用数组的方法。常见的类数组对象有 arguments 和 DOM 方法的返回结果，还有一个函数也可以被看作是类数组对象，因为它含有 length 属性值，代表可接收的参数个数。<br>常见的类数组转换为数组的方法有这样几种：<br>（1）通过 call 调用数组的 slice 方法来实现转换</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Array.prototype.slice.call(arrayLike);</span><br></pre></td></tr></table></figure>
<p>（2）通过 call 调用数组的 splice 方法来实现转换</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Array.prototype.splice.call(arrayLike, 0);</span><br></pre></td></tr></table></figure>
<p>（3）通过 apply 调用数组的 concat 方法来实现转换</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Array.prototype.concat.apply([], arrayLike);</span><br></pre></td></tr></table></figure>
<p>（4）通过 Array.from 方法来实现转换</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Array.from(arrayLike);</span><br></pre></td></tr></table></figure>
<h1 id="数组有哪些原生方法？"><a href="#数组有哪些原生方法？" class="headerlink" title="数组有哪些原生方法？"></a>数组有哪些原生方法？</h1><ul>
<li>数组和字符串的转换方法：toString()、toLocalString()、join() 其中 join() 方法可以指定转换为字符串时的分隔符。</li>
<li>数组尾部操作的方法 pop() 和 push()，push 方法可以传入多个参数。</li>
<li>数组首部操作的方法 shift() 和 unshift() 重排序的方法 reverse() 和 sort()，sort() 方法可以传入一个函数来进行比较，传入前后两个值，如果返回值为正数，则交换两个参数的位置。</li>
<li>数组连接的方法 concat() ，返回的是拼接好的数组，不影响原数组。</li>
<li>数组截取办法 slice()，用于截取数组中的一部分返回，不影响原数组。</li>
<li>数组插入方法 splice()，影响原数组查找特定项的索引的方法，indexOf() 和 lastIndexOf() 迭代方法 every()、some()、filter()、map() 和 forEach() 方法</li>
<li>数组归并方法 reduce() 和 reduceRight() 方法</li>
</ul>
<h1 id="Unicode、UTF-8、UTF-16、UTF-32的区别？"><a href="#Unicode、UTF-8、UTF-16、UTF-32的区别？" class="headerlink" title="Unicode、UTF-8、UTF-16、UTF-32的区别？"></a>Unicode、UTF-8、UTF-16、UTF-32的区别？</h1><h2 id="（1）Unicode"><a href="#（1）Unicode" class="headerlink" title="（1）Unicode"></a>（1）Unicode</h2><p>在说Unicode之前需要先了解一下ASCII码：ASCII 码（American Standard Code for Information Interchange）称为美国标准信息交换码。</p>
<p>它是基于拉丁字母的一套电脑编码系统。<br>它定义了一个用于代表常见字符的字典。<br>它包含了”A-Z”(包含大小写)，数据”0-9” 以及一些常见的符号。<br>它是专门为英语而设计的，有128个编码，对其他语言无能为力</p>
<p>ASCII码可以表示的编码有限，要想表示其他语言的编码，还是要使用Unicode来表示，可以说Unicode是ASCII 的超集。<br>Unicode全称 Unicode Translation Format，又叫做统一码、万国码、单一码。Unicode 是为了解决传统的字符编码方案的局限而产生的，它为每种语言中的每个字符设定了统一并且唯一的二进制编码，以满足跨语言、跨平台进行文本转换、处理的要求。<br>Unicode的实现方式（也就是编码方式）有很多种，常见的是UTF-8、UTF-16、UTF-32和USC-2。</p>
<h2 id="（2）UTF-8"><a href="#（2）UTF-8" class="headerlink" title="（2）UTF-8"></a>（2）UTF-8</h2><p>UTF-8是使用最广泛的Unicode编码方式，它是一种可变长的编码方式，可以是1—4个字节不等，它可以完全兼容ASCII码的128个字符。<br>注意： UTF-8 是一种编码方式，Unicode是一个字符集合。<br>UTF-8的编码规则：</p>
<p>对于单字节的符号，字节的第一位为0，后面的7位为这个字符的Unicode编码，因此对于英文字母，它的Unicode编码和ACSII编码一样。<br>对于n字节的符号，第一个字节的前n位都是1，第n+1位设为0，后面字节的前两位一律设为10，剩下的没有提及的二进制位，全部为这个符号的Unicode码 。</p>
<p>来看一下具体的Unicode编号范围与对应的UTF-8二进制格式 ：</p>
<p>编码范围（编号对应的十进制数）二进制格式0x00—0x7F （0-127）0xxxxxxx0x80—0x7FF （128-2047）110xxxxx 10xxxxxx0x800—0xFFFF  （2048-65535）1110xxxx 10xxxxxx 10xxxxxx0x10000—0x10FFFF  （65536以上）11110xxx 10xxxxxx 10xxxxxx 10xxxxxx<br>那该如何通过具体的Unicode编码，进行具体的UTF-8编码呢？步骤如下：</p>
<p>找到该Unicode编码的所在的编号范围，进而找到与之对应的二进制格式<br>将Unicode编码转换为二进制数（去掉最高位的0）<br>将二进制数从右往左一次填入二进制格式的X中，如果有X未填，就设为0</p>
<p>来看一个实际的例子：<br>“马” 字的Unicode编码是：0x9A6C，整数编号是39532<br>（1）首选确定了该字符在第三个范围内，它的格式是 1110xxxx 10xxxxxx 10xxxxxx<br>（2）39532对应的二进制数为1001 1010 0110 1100<br>（3）将二进制数填入X中，结果是：11101001 10101001 10101100</p>
<h2 id="（3）UTF-16"><a href="#（3）UTF-16" class="headerlink" title="（3）UTF-16"></a>（3）UTF-16</h2><ol>
<li>平面的概念<br>在了解UTF-16之前，先看一下平面的概念：<br>Unicode编码中有很多很多的字符，它并不是一次性定义的，而是分区进行定义的，每个区存放65536（216）个字符，这称为一个平面，目前总共有17 个平面。<br>最前面的一个平面称为基本平面，它的码点从0 — 216-1，写成16进制就是U+0000 — U+FFFF，那剩下的16个平面就是辅助平面，码点范围是 U+10000—U+10FFFF。</li>
<li>UTF-16 概念：<br>UTF-16也是Unicode编码集的一种编码形式，把Unicode字符集的抽象码位映射为16位长的整数（即码元）的序列，用于数据存储或传递。Unicode字符的码位需要1个或者2个16位长的码元来表示，因此UTF-16也是用变长字节表示的。</li>
<li>UTF-16 编码规则：</li>
</ol>
<p>编号在 U+0000—U+FFFF 的字符（常用字符集），直接用两个字节表示。<br>编号在 U+10000—U+10FFFF 之间的字符，需要用四个字节表示。</p>
<ol start="4">
<li>编码识别<br>那么问题来了，当遇到两个字节时，怎么知道是把它当做一个字符还是和后面的两个字节一起当做一个字符呢？<br>UTF-16 编码肯定也考虑到了这个问题，在基本平面内，从 U+D800 — U+DFFF 是一个空段，也就是说这个区间的码点不对应任何的字符，因此这些空段就可以用来映射辅助平面的字符。<br>辅助平面共有 220 个字符位，因此表示这些字符至少需要 20 个二进制位。UTF-16 将这 20 个二进制位分成两半，前 10 位映射在 U+D800 — U+DBFF，称为高位（H），后 10 位映射在 U+DC00 — U+DFFF，称为低位（L）。这就相当于，将一个辅助平面的字符拆成了两个基本平面的字符来表示。<br>因此，当遇到两个字节时，发现它的码点在 U+D800 —U+DBFF之间，就可以知道，它后面的两个字节的码点应该在 U+DC00 — U+DFFF 之间，这四个字节必须放在一起进行解读。</li>
<li>举例说明<br>以 “𡠀” 字为例，它的 Unicode 码点为 0x21800，该码点超出了基本平面的范围，因此需要用四个字节来表示，步骤如下：</li>
</ol>
<p>首先计算超出部分的结果：0x21800 - 0x10000<br>将上面的计算结果转为20位的二进制数，不足20位就在前面补0，结果为：0001000110 0000000000<br>将得到的两个10位二进制数分别对应到两个区间中<br>U+D800 对应的二进制数为 1101100000000000， 将0001000110填充在它的后10 个二进制位，得到 1101100001000110，转成 16 进制数为 0xD846。同理，低位为 0xDC00，所以这个字的UTF-16 编码为 0xD846 0xDC00</p>
<h2 id="（4）-UTF-32"><a href="#（4）-UTF-32" class="headerlink" title="（4） UTF-32"></a>（4） UTF-32</h2><p>UTF-32 就是字符所对应编号的整数二进制形式，每个字符占四个字节，这个是直接进行转换的。该编码方式占用的储存空间较多，所以使用较少。<br>比如“马” 字的Unicode编号是：U+9A6C，整数编号是39532，直接转化为二进制：1001 1010 0110 1100，这就是它的UTF-32编码。</p>
<h2 id="（5）总结"><a href="#（5）总结" class="headerlink" title="（5）总结"></a>（5）总结</h2><p>Unicode、UTF-8、UTF-16、UTF-32有什么区别？</p>
<p>Unicode 是编码字符集（字符集），而UTF-8、UTF-16、UTF-32是字符集编码（编码规则）；<br>UTF-16 使用变长码元序列的编码方式，相较于定长码元序列的UTF-32算法更复杂，甚至比同样是变长码元序列的UTF-8也更为复杂，因为其引入了独特的代理对这样的代理机制；<br>UTF-8需要判断每个字节中的开头标志信息，所以如果某个字节在传送过程中出错了，就会导致后面的字节也会解析出错；而UTF-16不会判断开头标志，即使错也只会错一个字符，所以容错能力教强；<br>如果字符内容全部英文或英文与其他文字混合，但英文占绝大部分，那么用UTF-8就比UTF-16节省了很多空间；而如果字符内容全部是中文这样类似的字符或者混合字符中中文占绝大多数，那么UTF-16就占优势了，可以节省很多空间；</p>
<h1 id="常见的位运算符有哪些？其计算规则是什么？"><a href="#常见的位运算符有哪些？其计算规则是什么？" class="headerlink" title="常见的位运算符有哪些？其计算规则是什么？"></a>常见的位运算符有哪些？其计算规则是什么？</h1><p>现代计算机中数据都是以二进制的形式存储的，即0、1两种状态，计算机对二进制数据进行的运算加减乘除等都是叫位运算，即将符号位共同参与运算的运算。<br>常见的位运算有以下几种：<br>|  运算符   | 描述      | 运算规则  |<br>|  —-  | —-  | —-  |<br>| &amp;      | 与 | 两个位都为1时，结果才为1 |<br>| ^ | 异或 | 两个位相同为0，相异为1 |<br>| ~    | 取反 | 0变1，1变0 |<br>| &lt;&lt;| 左移 | 各二进制位全部左移若干位，高位丢弃，低位补0  |<br>| &gt;&gt; | 右移 | 各二进制位全部右移若干位，正数左补0，负数左补1，右边丢弃 |</p>
<ol>
<li>按位与运算符（&amp;）<br>定义： 参加运算的两个数据按二进制位进行“与”运算。<br>运算规则：<br>0 &amp; 0 = 0<br>0 &amp; 1 = 0<br>1 &amp; 0 = 0<br>1 &amp; 1 = 1<br>总结：两位同时为1，结果才为1，否则结果为0。<br>例如：3&amp;5 即：<br>0000 0011<br>0000 0101<br>= 0000 0001<br>因此 3&amp;5 的值为1。<br>注意：负数按补码形式参加按位与运算。<br>用途：<br>（1）判断奇偶<br>只要根据最未位是0还是1来决定，为0就是偶数，为1就是奇数。因此可以用if ((i &amp; 1) == 0)代替if (i % 2 == 0)来判断a是不是偶数。<br>（2）清零<br>如果想将一个单元清零，即使其全部二进制位为0，只要与一个各位都为零的数值相与，结果为零。</li>
<li>按位或运算符（|）<br>定义： 参加运算的两个对象按二进制位进行“或”运算。<br>运算规则：<br>0 | 0 = 0<br>0 | 1 = 1<br>1 | 0 = 1<br>1 | 1 = 1<br>总结：参加运算的两个对象只要有一个为1，其值为1。<br>例如：3|5即：<br>0000 0011<br>0000 0101<br>= 0000 0111<br>因此，3|5的值为7。<br>注意：负数按补码形式参加按位或运算。</li>
<li>异或运算符（^）<br>定义： 参加运算的两个数据按二进制位进行“异或”运算。<br>运算规则：<br>0 ^ 0 = 0<br>0 ^ 1 = 1<br>1 ^ 0 = 1<br>1 ^ 1 = 0<br>总结：参加运算的两个对象，如果两个相应位相同为0，相异为1。<br>例如：3|5即：<br>0000 0011<br>0000 0101<br>= 0000 0110<br>因此，3^5的值为6。<br>异或运算的性质:</li>
</ol>
<p>交换律：(a^b)^c == a^(b^c)<br>结合律：(a + b)^c == a^b + b^c<br>对于任何数x，都有 x^x=0，x^0=x<br>自反性: a^b^b=a^0=a;</p>
<ol start="4">
<li>取反运算符 (<del>)<br>定义： 参加运算的一个数据按二进制进行“取反”运算。<br>运算规则：<br>~ 1 = 0</del> 0 = 1<br>总结：对一个二进制数按位取反，即将0变1，1变0。<br>例如：<del>6 即：<br>0000 0110= 1111 1001<br>在计算机中，正数用原码表示，负数使用补码存储，首先看最高位，最高位1表示负数，0表示正数。此计算机二进制码为负数，最高位为符号位。<br>当发现按位取反为负数时，就直接取其补码，变为十进制：<br>0000 0110   = 1111 1001反码：1000 0110补码：1000 0111<br>因此，</del>6的值为-7。</li>
<li>左移运算符（&lt;&lt;）<br>定义： 将一个运算对象的各二进制位全部左移若干位，左边的二进制位丢弃，右边补0。<br>设 a=1010 1110，a = a&lt;&lt; 2 将a的二进制位左移2位、右补0，即得a=1011 1000。<br>若左移时舍弃的高位不包含1，则每左移一位，相当于该数乘以2。</li>
<li>右移运算符（&gt;&gt;）<br>定义： 将一个数的各二进制位全部右移若干位，正数左补0，负数左补1，右边丢弃。<br>例如：a=a&gt;&gt;2 将a的二进制位右移2位，左补0 或者 左补1得看被移数是正还是负。<br>操作数每右移一位，相当于该数除以2。</li>
<li>原码、补码、反码<br>上面提到了补码、反码等知识，这里就补充一下。<br>计算机中的有符号数有三种表示方法，即原码、反码和补码。三种表示方法均有符号位和数值位两部分，符号位都是用0表示“正”，用1表示“负”，而数值位，三种表示方法各不相同。<br>（1）原码<br>原码就是一个数的二进制数。例如：10的原码为0000 1010<br>（2）反码</li>
</ol>
<p>正数的反码与原码相同，如：10 反码为 0000 1010<br>负数的反码为除符号位，按位取反，即0变1，1变0。</p>
<p>例如：-10<br>原码：1000 1010<br>反码：1111 0101<br>（3）补码</p>
<p>正数的补码与原码相同，如：10 补码为 0000 1010<br>负数的补码是原码除符号位外的所有位取反即0变1，1变0，然后加1，也就是反码加1。</p>
<p>例如：-10<br>原码：1000 1010<br>反码：1111 0101<br>补码：1111 0110</p>
<h1 id="为什么函数的-arguments-参数是类数组而不是数组？如何遍历类数组"><a href="#为什么函数的-arguments-参数是类数组而不是数组？如何遍历类数组" class="headerlink" title="为什么函数的 arguments 参数是类数组而不是数组？如何遍历类数组?"></a>为什么函数的 arguments 参数是类数组而不是数组？如何遍历类数组?</h1><p>arguments是一个对象，它的属性是从 0 开始依次递增的数字，还有callee和length等属性，与数组相似；但是它却没有数组常见的方法属性，如forEach, reduce等，所以叫它们类数组。<br>要遍历类数组，有三个方法：<br>（1）将数组的方法应用到类数组上，这时候就可以使用call和apply方法，如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function foo()&#123; </span><br><span class="line">  Array.prototype.forEach.call(arguments, a =&gt; console.log(a))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（2）使用Array.from方法将类数组转化成数组：‌</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function foo()&#123; </span><br><span class="line">  const arrArgs = Array.from(arguments) </span><br><span class="line">  arrArgs.forEach(a =&gt; console.log(a))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（3）使用展开运算符将类数组转化成数组</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function foo()&#123; </span><br><span class="line">    const arrArgs = [...arguments] </span><br><span class="line">    arrArgs.forEach(a =&gt; console.log(a)) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="什么是-DOM-和-BOM？"><a href="#什么是-DOM-和-BOM？" class="headerlink" title="什么是 DOM 和 BOM？"></a>什么是 DOM 和 BOM？</h1><ul>
<li>DOM 指的是文档对象模型，它指的是把文档当做一个对象，这个对象主要定义了处理网页内容的方法和接口。</li>
<li>BOM 指的是浏览器对象模型，它指的是把浏览器当做一个对象来对待，这个对象主要定义了与浏览器进行交互的法和接口。BOM的核心是 window，而 window 对象具有双重角色，它既是通过 js 访问浏览器窗口的一个接口，又是一个 Global（全局）对象。这意味着在网页中定义的任何对象，变量和函数，都作为全局对象的一个属性或者方法存在。window 对象含有 location 对象、navigator 对象、screen 对象等子对象，并且 DOM 的最根本的对象 document 对象也是 BOM 的 window 对象的子对象。</li>
</ul>
<h1 id="对类数组对象的理解，如何转化为数组"><a href="#对类数组对象的理解，如何转化为数组" class="headerlink" title="对类数组对象的理解，如何转化为数组"></a>对类数组对象的理解，如何转化为数组</h1><p>一个拥有 length 属性和若干索引属性的对象就可以被称为类数组对象，类数组对象和数组类似，但是不能调用数组的方法。常见的类数组对象有 arguments 和 DOM 方法的返回结果，函数参数也可以被看作是类数组对象，因为它含有 length属性值，代表可接收的参数个数。<br>常见的类数组转换为数组的方法有这样几种：</p>
<ul>
<li>通过 call 调用数组的 slice 方法来实现转换</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Array.prototype.slice.call(arrayLike);</span><br></pre></td></tr></table></figure>

<ul>
<li>通过 call 调用数组的 splice 方法来实现转换</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Array.prototype.splice.call(arrayLike, 0);</span><br></pre></td></tr></table></figure>

<ul>
<li>通过 apply 调用数组的 concat 方法来实现转换</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Array.prototype.concat.apply([], arrayLike);</span><br></pre></td></tr></table></figure>

<ul>
<li>通过 Array.from 方法来实现转换</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Array.from(arrayLike);</span><br></pre></td></tr></table></figure>
<h1 id="escape、encodeURI、encodeURIComponent-的区别"><a href="#escape、encodeURI、encodeURIComponent-的区别" class="headerlink" title="escape、encodeURI、encodeURIComponent 的区别"></a>escape、encodeURI、encodeURIComponent 的区别</h1><ul>
<li>encodeURI 是对整个 URI 进行转义，将 URI 中的非法字符转换为合法字符，所以对于一些在 URI 中有特殊意义的字符不会进行转义。</li>
<li>encodeURIComponent 是对 URI 的组成部分进行转义，所以一些特殊字符也会得到转义。</li>
<li>escape 和 encodeURI 的作用相同，不过它们对于 unicode 编码为 0xff 之外字符的时候会有区别，escape 是直接在字符的 unicode 编码前加上 %u，而 encodeURI 首先会将字符转换为 UTF-8 的格式，再在每个字节前加上 %。</li>
</ul>
<h1 id="对AJAX的理解，实现一个AJAX请求"><a href="#对AJAX的理解，实现一个AJAX请求" class="headerlink" title="对AJAX的理解，实现一个AJAX请求"></a>对AJAX的理解，实现一个AJAX请求</h1><p>AJAX是 Asynchronous JavaScript and XML 的缩写，指的是通过 JavaScript 的 异步通信，从服务器获取 XML 文档从中提取数据，再更新当前网页的对应部分，而不用刷新整个网页。<br>创建AJAX请求的步骤：</p>
<ul>
<li>创建一个 XMLHttpRequest 对象。</li>
<li>在这个对象上使用 open 方法创建一个 HTTP 请求，open 方法所需要的参数是请求的方法、请求的地址、是否异步和用户的认证信息。<br>在发起请求前，可以为这个对象添加一些信息和监听函数。比如说可以通过 setRequestHeader 方法来为请求添加头信息。还可以为这个对象添加一个状态监听函数。一个 XMLHttpRequest 对象一共有 5 个状态，当它的状态变化时会触发onreadystatechange 事件，可以通过设置监听函数，来处理请求成功后的结果。当对象的 readyState 变为 4 的时候，代表服务器返回的数据接收完成，这个时候可以通过判断请求的状态，如果状态是 2xx 或者 304 的话则代表返回正常。这个时候就可以通过 response 中的数据来对页面进行更新了。</li>
<li>当对象的属性和监听函数设置完成后，最后调用 sent 方法来向服务器发起请求，可以传入参数作为发送的数据体。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const SERVER_URL = &quot;/server&quot;;</span><br><span class="line">let xhr = new XMLHttpRequest();</span><br><span class="line">// 创建 Http 请求</span><br><span class="line">xhr.open(&quot;GET&quot;, url, true);</span><br><span class="line">// 设置状态监听函数</span><br><span class="line">xhr.onreadystatechange = function() &#123;</span><br><span class="line">  if (this.readyState !== 4) return;</span><br><span class="line">  // 当请求成功时</span><br><span class="line">  if (this.status === 200) &#123;</span><br><span class="line">    handle(this.response);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    console.error(this.statusText);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">// 设置请求失败时的监听函数</span><br><span class="line">xhr.onerror = function() &#123;</span><br><span class="line">  console.error(this.statusText);</span><br><span class="line">&#125;;</span><br><span class="line">// 设置请求头信息</span><br><span class="line">xhr.responseType = &quot;json&quot;;</span><br><span class="line">xhr.setRequestHeader(&quot;Accept&quot;, &quot;application/json&quot;);</span><br><span class="line">// 发送 Http 请求</span><br><span class="line">xhr.send(null);</span><br><span class="line">使用Promise封装AJAX：</span><br><span class="line">// promise 封装实现：</span><br><span class="line">function getJSON(url) &#123;</span><br><span class="line">  // 创建一个 promise 对象</span><br><span class="line">  let promise = new Promise(function(resolve, reject) &#123;</span><br><span class="line">    let xhr = new XMLHttpRequest();</span><br><span class="line">    // 新建一个 http 请求</span><br><span class="line">    xhr.open(&quot;GET&quot;, url, true);</span><br><span class="line">    // 设置状态的监听函数</span><br><span class="line">    xhr.onreadystatechange = function() &#123;</span><br><span class="line">      if (this.readyState !== 4) return;</span><br><span class="line">      // 当请求成功或失败时，改变 promise 的状态</span><br><span class="line">      if (this.status === 200) &#123;</span><br><span class="line">        resolve(this.response);</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        reject(new Error(this.statusText));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    // 设置错误监听函数</span><br><span class="line">    xhr.onerror = function() &#123;</span><br><span class="line">      reject(new Error(this.statusText));</span><br><span class="line">    &#125;;</span><br><span class="line">    // 设置响应的数据类型</span><br><span class="line">    xhr.responseType = &quot;json&quot;;</span><br><span class="line">    // 设置请求头信息</span><br><span class="line">    xhr.setRequestHeader(&quot;Accept&quot;, &quot;application/json&quot;);</span><br><span class="line">    // 发送 http 请求</span><br><span class="line">    xhr.send(null);</span><br><span class="line">  &#125;);</span><br><span class="line">  return promise;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="JavaScript为什么要进行变量提升，它导致了什么问题？"><a href="#JavaScript为什么要进行变量提升，它导致了什么问题？" class="headerlink" title="JavaScript为什么要进行变量提升，它导致了什么问题？"></a>JavaScript为什么要进行变量提升，它导致了什么问题？</h1><p>变量提升的表现是，无论在函数中何处位置声明的变量，好像都被提升到了函数的首部，可以在变量声明前访问到而不会报错。<br>造成变量声明提升的本质原因是 js 引擎在代码执行前有一个解析的过程，创建了执行上下文，初始化了一些代码执行时需要用到的对象。当访问一个变量时，会到当前执行上下文中的作用域链中去查找，而作用域链的首端指向的是当前执行上下文的变量对象，这个变量对象是执行上下文的一个属性，它包含了函数的形参、所有的函数和变量声明，这个对象的是在代码解析的时候创建的。<br>首先要知道，JS在拿到一个变量或者一个函数的时候，会有两步操作，即解析和执行。</p>
<ul>
<li>在解析阶段，JS会检查语法，并对函数进行预编译。解析的时候会先创建一个全局执行上下文环境，先把代码中即将执行的变量、函数声明都拿出来，变量先赋值为undefined，函数先声明好可使用。在一个函数执行之前，也会创建一个函数执行上下文环境，跟全局执行上下文类似，不过函数执行上下文会多出this、arguments和函数的参数。</li>
</ul>
<p>全局上下文：变量定义，函数声明<br>函数上下文：变量定义，函数声明，this，arguments</p>
<ul>
<li>在执行阶段，就是按照代码的顺序依次执行。</li>
</ul>
<p>那为什么会进行变量提升呢？主要有以下两个原因：</p>
<pre><code>- 提高性能
- 容错性更好
</code></pre>
<p>（1）提高性能<br>在JS代码执行之前，会进行语法检查和预编译，并且这一操作只进行一次。这么做就是为了提高性能，如果没有这一步，那么每次执行代码前都必须重新解析一遍该变量（函数），而这是没有必要的，因为变量（函数）的代码并不会改变，解析一遍就够了。<br>在解析的过程中，还会为函数生成预编译代码。在预编译时，会统计声明了哪些变量、创建了哪些函数，并对函数的代码进行压缩，去除注释、不必要的空白等。这样做的好处就是每次执行函数时都可以直接为该函数分配栈空间（不需要再解析一遍去获取代码中声明了哪些变量，创建了哪些函数），并且因为代码压缩的原因，代码执行也更快了。<br>（2）容错性更好<br>变量提升可以在一定程度上提高JS的容错性，看下面的代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a = 1;var a;console.log(a);</span><br></pre></td></tr></table></figure>
<p>如果没有变量提升，这两行代码就会报错，但是因为有了变量提升，这段代码就可以正常执行。<br>虽然，在可以开发过程中，可以完全避免这样写，但是有时代码很复杂的时候。可能因为疏忽而先使用后定义了，这样也不会影响正常使用。由于变量提升的存在，而会正常运行。<br>总结：</p>
<ul>
<li>解析和预编译过程中的声明提升可以提高性能，让函数可以在执行时预先为变量分配栈空间</li>
<li>声明提升还可以提高JS代码的容错性，使一些不规范的代码也可以正常执行</li>
</ul>
<p>变量提升虽然有一些优点，但是他也会造成一定的问题，在ES6中提出了let、const来定义变量，它们就没有变量提升的机制。下面看一下变量提升可能会导致的问题：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var tmp = new Date();</span><br><span class="line"></span><br><span class="line">function fn()&#123;</span><br><span class="line">	console.log(tmp);</span><br><span class="line">	if(false)&#123;</span><br><span class="line">		var tmp = &#x27;hello world&#x27;;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn();  // undefined</span><br></pre></td></tr></table></figure>
<p>在这个函数中，原本是要打印出外层的tmp变量，但是因为变量提升的问题，内层定义的tmp被提到函数内部的最顶部，相当于覆盖了外层的tmp，所以打印结果为undefined。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var tmp = &#x27;hello world&#x27;;</span><br><span class="line"></span><br><span class="line">for (var i = 0; i &lt; tmp.length; i++) &#123;</span><br><span class="line">	console.log(tmp[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(i); // 11</span><br></pre></td></tr></table></figure>
<p>由于遍历时定义的i会变量提升成为一个全局变量，在函数结束之后不会被销毁，所以打印出来11。</p>
<h1 id="什么是尾调用，使用尾调用有什么好处？"><a href="#什么是尾调用，使用尾调用有什么好处？" class="headerlink" title="什么是尾调用，使用尾调用有什么好处？"></a>什么是尾调用，使用尾调用有什么好处？</h1><p>尾调用指的是函数的最后一步调用另一个函数。代码执行是基于执行栈的，所以当在一个函数里调用另一个函数时，会保留当前的执行上下文，然后再新建另外一个执行上下文加入栈中。使用尾调用的话，因为已经是函数的最后一步，所以这时可以不必再保留当前的执行上下文，从而节省了内存，这就是尾调用优化。但是 ES6 的尾调用优化只在严格模式下开启，正常模式是无效的。</p>
<h1 id="ES6模块与CommonJS模块有什么异同？"><a href="#ES6模块与CommonJS模块有什么异同？" class="headerlink" title="ES6模块与CommonJS模块有什么异同？"></a>ES6模块与CommonJS模块有什么异同？</h1><ol>
<li><p>CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。</p>
<ul>
<li>CommonJS 模块输出的是值的拷贝，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。</li>
<li>ES6 模块的运行机制与 CommonJS 不一样。JS 引擎对脚本静态分析的时候，遇到模块加载命令import，就会生成一个只读引用。等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里面去取值。换句话说，ES6 的import有点像 Unix 系统的“符号连接”，原始值变了，import加载的值也会跟着变。因此，ES6 模块是动态引用，并且不会缓存值，模块里面的变量绑定其所在的模块。</li>
</ul>
</li>
<li><p>CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。</p>
<ul>
<li>运行时加载: CommonJS 模块就是对象；即在输入时是先加载整个模块，生成一个对象，然后再从这个对象上面读取方法，这种加载称为“运行时加载”。</li>
<li>编译时加载: ES6 模块不是对象，而是通过 export 命令显式指定输出的代码，import时采用静态命令的形式。即在import时可以指定加载某个输出值，而不是加载整个模块，这种加载称为“编译时加载”。</li>
</ul>
</li>
</ol>
<h1 id="常见的DOM操作有哪些"><a href="#常见的DOM操作有哪些" class="headerlink" title="常见的DOM操作有哪些"></a>常见的DOM操作有哪些</h1><p>1）DOM 节点的获取</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DOM 节点的获取的API及使用：</span><br><span class="line">getElementById // 按照 id 查询</span><br><span class="line">getElementsByTagName // 按照标签名查询</span><br><span class="line">getElementsByClassName // 按照类名查询</span><br><span class="line">querySelectorAll // 按照 css 选择器查询</span><br><span class="line"></span><br><span class="line">// 按照 id 查询</span><br><span class="line">var imooc = document.getElementById(&#x27;imooc&#x27;) // 查询到 id 为 imooc 的元素</span><br><span class="line">// 按照标签名查询</span><br><span class="line">var pList = document.getElementsByTagName(&#x27;p&#x27;)  // 查询到标签为 p 的集合</span><br><span class="line">console.log(divList.length)</span><br><span class="line">console.log(divList[0])</span><br><span class="line">// 按照类名查询</span><br><span class="line">var moocList = document.getElementsByClassName(&#x27;mooc&#x27;) // 查询到类名为 mooc 的集合</span><br><span class="line">// 按照 css 选择器查询</span><br><span class="line">var pList = document.querySelectorAll(&#x27;.mooc&#x27;) // 查询到类名为 mooc 的集合</span><br></pre></td></tr></table></figure>
<p>2）DOM 节点的创建<br>创建一个新节点，并把它添加到指定节点的后面。 已知的 HTML 结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;title&gt;DEMO&lt;/title&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;div id=&quot;container&quot;&gt; </span><br><span class="line">      &lt;h1 id=&quot;title&quot;&gt;我是标题&lt;/h1&gt;</span><br><span class="line">    &lt;/div&gt;   </span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<p>要求添加一个有内容的 span 节点到 id 为 title 的节点后面，做法就是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 首先获取父节点</span><br><span class="line">var container = document.getElementById(&#x27;container&#x27;)</span><br><span class="line">// 创建新节点</span><br><span class="line">var targetSpan = document.createElement(&#x27;span&#x27;)</span><br><span class="line">// 设置 span 节点的内容</span><br><span class="line">targetSpan.innerHTML = &#x27;hello world&#x27;</span><br><span class="line">// 把新创建的元素塞进父节点里去</span><br><span class="line">container.appendChild(targetSpan)</span><br></pre></td></tr></table></figure>
<p>3）DOM 节点的删除<br>删除指定的 DOM 节点， 已知的 HTML 结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;title&gt;DEMO&lt;/title&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;div id=&quot;container&quot;&gt; </span><br><span class="line">      &lt;h1 id=&quot;title&quot;&gt;我是标题&lt;/h1&gt;</span><br><span class="line">    &lt;/div&gt;   </span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<p>需要删除 id 为 title 的元素，做法是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 获取目标元素的父元素</span><br><span class="line">var container = document.getElementById(&#x27;container&#x27;)</span><br><span class="line">// 获取目标元素</span><br><span class="line">var targetNode = document.getElementById(&#x27;title&#x27;)</span><br><span class="line">// 删除目标元素</span><br><span class="line">container.removeChild(targetNode)</span><br><span class="line">或者通过子节点数组来完成删除：</span><br><span class="line">// 获取目标元素的父元素var container = document.getElementById(&#x27;container&#x27;)// 获取目标元素var targetNode = container.childNodes[1]// 删除目标元素container.removeChild(targetNode)</span><br></pre></td></tr></table></figure>
<p>4）修改 DOM 元素<br>修改 DOM 元素这个动作可以分很多维度，比如说移动 DOM 元素的位置，修改 DOM 元素的属性等。<br>将指定的两个 DOM 元素交换位置， 已知的 HTML 结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;title&gt;DEMO&lt;/title&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;div id=&quot;container&quot;&gt; </span><br><span class="line">      &lt;h1 id=&quot;title&quot;&gt;我是标题&lt;/h1&gt;</span><br><span class="line">      &lt;p id=&quot;content&quot;&gt;我是内容&lt;/p&gt;</span><br><span class="line">    &lt;/div&gt;   </span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<p>现在需要调换 title 和 content 的位置，可以考虑 insertBefore 或者 appendChild：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 获取父元素</span><br><span class="line">var container = document.getElementById(&#x27;container&#x27;)   </span><br><span class="line"> </span><br><span class="line">// 获取两个需要被交换的元素</span><br><span class="line">var title = document.getElementById(&#x27;title&#x27;)</span><br><span class="line">var content = document.getElementById(&#x27;content&#x27;)</span><br><span class="line">// 交换两个元素，把 content 置于 title 前面</span><br><span class="line">container.insertBefore(content, title)</span><br></pre></td></tr></table></figure>
<h1 id="use-strict是什么意思-使用它区别是什么？"><a href="#use-strict是什么意思-使用它区别是什么？" class="headerlink" title="use strict是什么意思 ? 使用它区别是什么？"></a>use strict是什么意思 ? 使用它区别是什么？</h1><p>use strict 是一种 ECMAscript5 添加的（严格模式）运行模式，这种模式使得 Javascript 在更严格的条件下运行。设立严格模式的目的如下：</p>
<ul>
<li>消除 Javascript 语法的不合理、不严谨之处，减少怪异行为;</li>
<li>消除代码运行的不安全之处，保证代码运行的安全；</li>
<li>提高编译器效率，增加运行速度；</li>
<li>为未来新版本的 Javascript 做好铺垫。</li>
</ul>
<p>区别：</p>
<ul>
<li>禁止使用 with 语句。</li>
<li>禁止 this 关键字指向全局对象。</li>
<li>对象不能有重名的属性。</li>
</ul>
<h1 id="如何判断一个对象是否属于某个类？"><a href="#如何判断一个对象是否属于某个类？" class="headerlink" title="如何判断一个对象是否属于某个类？"></a>如何判断一个对象是否属于某个类？</h1><ul>
<li>第一种方式，使用 instanceof 运算符来判断构造函数的 prototype 属性是否出现在对象的原型链中的任何位置。</li>
<li>第二种方式，通过对象的 constructor 属性来判断，对象的 constructor 属性指向该对象的构造函数，但是这种方式不是很安全，因为 constructor 属性可以被改写。</li>
<li>第三种方式，如果需要判断的是某个内置的引用类型的话，可以使用 Object.prototype.toString() 方法来打印对象的[[Class]] 属性来进行判断。</li>
</ul>
<h1 id="强类型语言和弱类型语言的区别"><a href="#强类型语言和弱类型语言的区别" class="headerlink" title="强类型语言和弱类型语言的区别"></a>强类型语言和弱类型语言的区别</h1><ul>
<li>强类型语言：强类型语言也称为强类型定义语言，是一种总是强制类型定义的语言，要求变量的使用要严格符合定义，所有变量都必须先定义后使用。Java和C++等语言都是强制类型定义的，也就是说，一旦一个变量被指定了某个数据类型，如果不经过强制转换，那么它就永远是这个数据类型了。例如你有一个整数，如果不显式地进行转换，你不能将其视为一个字符串。</li>
<li>弱类型语言：弱类型语言也称为弱类型定义语言，与强类型定义相反。JavaScript语言就属于弱类型语言。简单理解就是一种变量类型可以被忽略的语言。比如JavaScript是弱类型定义的，在JavaScript中就可以将字符串’12’和整数3进行连接得到字符串’123’，在相加的时候会进行强制类型转换。</li>
</ul>
<p>两者对比：强类型语言在速度上可能略逊色于弱类型语言，但是强类型语言带来的严谨性可以有效地帮助避免许多错误。</p>
<h1 id="解释性语言和编译型语言的区别"><a href="#解释性语言和编译型语言的区别" class="headerlink" title="解释性语言和编译型语言的区别"></a>解释性语言和编译型语言的区别</h1><ul>
<li>（1）解释型语言<br>使用专门的解释器对源程序逐行解释成特定平台的机器码并立即执行。是代码在执行时才被解释器一行行动态翻译和执行，而不是在执行之前就完成翻译。解释型语言不需要事先编译，其直接将源代码解释成机器码并立即执行，所以只要某一平台提供了相应的解释器即可运行该程序。其特点总结如下</li>
</ul>
<p>解释型语言每次运行都需要将源代码解释称机器码并执行，效率较低；<br>只要平台提供相应的解释器，就可以运行源代码，所以可以方便源程序移植；<br>JavaScript、Python等属于解释型语言。</p>
<ul>
<li><p>（2）编译型语言<br>使用专门的编译器，针对特定的平台，将高级语言源代码一次性的编译成可被该平台硬件执行的机器码，并包装成该平台所能识别的可执行性程序的格式。在编译型语言写的程序执行之前，需要一个专门的编译过程，把源代码编译成机器语言的文件，如exe格式的文件，以后要再运行时，直接使用编译结果即可，如直接运行exe文件。因为只需编译一次，以后运行时不需要编译，所以编译型语言执行效率高。其特点总结如下：</p>
<ol>
<li>一次性的编译成平台相关的机器语言文件，运行时脱离开发环境，运行效率高；</li>
<li>与特定平台相关，一般无法移植到其他平台；</li>
<li>C、C++等属于编译型语言。</li>
</ol>
</li>
</ul>
<p>两者主要区别在于： 前者源程序编译后即可在该平台运行，后者是在运行期间才编译。所以前者运行速度快，后者跨平台性好。</p>
<h1 id="for…in和for…of的区别"><a href="#for…in和for…of的区别" class="headerlink" title="for…in和for…of的区别"></a>for…in和for…of的区别</h1><p>for…of 是ES6新增的遍历方式，允许遍历一个含有iterator接口的数据结构（数组、对象等）并且返回各项的值，和ES3中的for…in的区别如下</p>
<ul>
<li>for…of 遍历获取的是对象的键值，for…in 获取的是对象的键名；</li>
<li>for… in 会遍历对象的整个原型链，性能非常差不推荐使用，而 for … of 只遍历当前对象不会遍历原型链；</li>
<li>对于数组的遍历，for…in 会返回数组中所有可枚举的属性(包括原型链上可枚举的属性)，for…of 只返回数组的下标对应的属性值；</li>
</ul>
<p>总结： for…in 循环主要是为了遍历对象而生，不适用于遍历数组；for…of 循环可以用来遍历数组、类数组对象，字符串、Set、Map 以及 Generator 对象。</p>
<h1 id="如何使用for…of遍历对象"><a href="#如何使用for…of遍历对象" class="headerlink" title="如何使用for…of遍历对象"></a>如何使用for…of遍历对象</h1><p>for…of是作为ES6新增的遍历方式，允许遍历一个含有iterator接口的数据结构（数组、对象等）并且返回各项的值，普通的对象用for..of遍历是会报错的。<br>如果需要遍历的对象是类数组对象，用Array.from转成数组即可。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line">    0:&#x27;one&#x27;,</span><br><span class="line">    1:&#x27;two&#x27;,</span><br><span class="line">    length: 2</span><br><span class="line">&#125;;</span><br><span class="line">obj = Array.from(obj);</span><br><span class="line">for(var k of obj)&#123;</span><br><span class="line">    console.log(k)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果不是类数组对象，就给对象添加一个[Symbol.iterator]属性，并指向一个迭代器即可。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//方法一：</span><br><span class="line">var obj = &#123;</span><br><span class="line">    a:1,</span><br><span class="line">    b:2,</span><br><span class="line">    c:3</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj[Symbol.iterator] = function()&#123;</span><br><span class="line">	var keys = Object.keys(this);</span><br><span class="line">	var count = 0;</span><br><span class="line">	return &#123;</span><br><span class="line">		next()&#123;</span><br><span class="line">			if(count&lt;keys.length)&#123;</span><br><span class="line">				return &#123;value: obj[keys[count++]],done:false&#125;;</span><br><span class="line">			&#125;else&#123;</span><br><span class="line">				return &#123;value:undefined,done:true&#125;;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">for(var k of obj)&#123;</span><br><span class="line">	console.log(k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 方法二</span><br><span class="line">var obj = &#123;</span><br><span class="line">    a:1,</span><br><span class="line">    b:2,</span><br><span class="line">    c:3</span><br><span class="line">&#125;;</span><br><span class="line">obj[Symbol.iterator] = function*()&#123;</span><br><span class="line">    var keys = Object.keys(obj);</span><br><span class="line">    for(var k of keys)&#123;</span><br><span class="line">        yield [k,obj[k]]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">for(var [k,v] of obj)&#123;</span><br><span class="line">    console.log(k,v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="ajax、axios、fetch的区别"><a href="#ajax、axios、fetch的区别" class="headerlink" title="ajax、axios、fetch的区别"></a>ajax、axios、fetch的区别</h1><ul>
<li><p>（1）AJAX<br>Ajax 即“AsynchronousJavascriptAndXML”（异步 JavaScript 和 XML），是指一种创建交互式网页应用的网页开发技术。它是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术。通过在后台与服务器进行少量数据交换，Ajax 可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。传统的网页（不使用 Ajax）如果需要更新内容，必须重载整个网页页面。其缺点如下：</p>
<ul>
<li>本身是针对MVC编程，不符合前端MVVM的浪潮</li>
<li>基于原生XHR开发，XHR本身的架构不清晰</li>
<li>不符合关注分离（Separation of Concerns）的原则</li>
<li>配置和调用方式非常混乱，而且基于事件的异步模型不友好。</li>
</ul>
</li>
<li><p>（2）Fetch<br>fetch号称是AJAX的替代品，是在ES6出现的，使用了ES6中的promise对象。Fetch是基于promise设计的。Fetch的代码结构比起ajax简单多。fetch不是ajax的进一步封装，而是原生js，没有使用XMLHttpRequest对象。<br>fetch的优点：</p>
<ul>
<li>语法简洁，更加语义化</li>
<li>基于标准 Promise 实现，支持 async/await</li>
<li>更加底层，提供的API丰富（request, response）</li>
<li>脱离了XHR，是ES规范里新的实现方式</li>
</ul>
</li>
</ul>
<p>fetch的缺点：</p>
<pre><code>- fetch只对网络请求报错，对400，500都当做成功的请求，服务器返回 400，500 错误码时并不会 reject，只有网络错误这些导致请求不能完成时，fetch 才会被 reject。
- fetch默认不会带cookie，需要添加配置项： fetch(url, &#123;credentials: &#39;include&#39;&#125;)
- fetch不支持abort，不支持超时控制，使用setTimeout及Promise.reject的实现的超时控制并不能阻止请求过程继续在后台运行，造成了流量的浪费
- fetch没有办法原生监测请求的进度，而XHR可以
</code></pre>
<ul>
<li><p>（3）Axios<br>Axios 是一种基于Promise封装的HTTP客户端，其特点如下：</p>
<ul>
<li>浏览器端发起XMLHttpRequests请求</li>
<li>node端发起http请求</li>
<li>支持Promise API</li>
<li>监听请求和返回</li>
<li>对请求和返回进行转化</li>
<li>取消请求</li>
<li>自动转换json数据</li>
<li>客户端支持抵御XSRF攻击</li>
</ul>
</li>
</ul>
<h1 id="数组的遍历方法有哪些"><a href="#数组的遍历方法有哪些" class="headerlink" title="数组的遍历方法有哪些"></a>数组的遍历方法有哪些</h1><table>
<thead>
<tr>
<th>方法</th>
<th>是否改变原数组</th>
<th>特点</th>
</tr>
</thead>
<tbody><tr>
<td>forEach()</td>
<td>否</td>
<td>数组方法，不改变原数组，没有返回值</td>
</tr>
<tr>
<td>map()</td>
<td>否</td>
<td>数组方法，不改变原数组，有返回值，可链式调用</td>
</tr>
<tr>
<td>filter()</td>
<td>否</td>
<td>数组方法，过滤数组，返回包含符合条件的元素的数组，可链式调用</td>
</tr>
<tr>
<td>for…of()</td>
<td>否</td>
<td>for…of遍历具有Iterator迭代器的对象的属性，返回的是数组的元素、对象的属性值，不能遍历普通的obj对象，将异步循环变成同步循环</td>
</tr>
<tr>
<td>every() 和 some()</td>
<td>否</td>
<td>数组方法，some()只要有一个是true，便返回true；而every()只要有一个是false，便返回false.</td>
</tr>
<tr>
<td>find() 和 findIndex()</td>
<td>否</td>
<td>数组方法，find()返回的是第一个符合条件的值；findIndex()返回的是第一个返回条件的值的索引值</td>
</tr>
<tr>
<td>reduce() 和 reduceRight()</td>
<td>否</td>
<td>数组方法，reduce()对数组正序操作；reduceRight()对数组逆序操作</td>
</tr>
</tbody></table>
<h1 id="forEach和map方法有什么区别"><a href="#forEach和map方法有什么区别" class="headerlink" title="forEach和map方法有什么区别"></a>forEach和map方法有什么区别</h1><p>这方法都是用来遍历数组的，两者区别如下：</p>
<ul>
<li>forEach()方法会针对每一个元素执行提供的函数，对数据的操作会改变原数组，该方法没有返回值；</li>
<li>map()方法不会改变原数组的值，返回一个新数组，新数组中的值为原数组调用函数处理之后的值；</li>
</ul>
<h1 id="什么是事件循环、宏任务、微任务"><a href="#什么是事件循环、宏任务、微任务" class="headerlink" title="什么是事件循环、宏任务、微任务"></a>什么是事件循环、宏任务、微任务</h1><h2 id="事件循环（event-loop）"><a href="#事件循环（event-loop）" class="headerlink" title="事件循环（event loop）"></a>事件循环（event loop）</h2><p>首先，所有的语言都拥有并发模型的概念，也就是说多个任务如何同时执行，大部分语言支持多线程执行，JS拥有所有语言中最简单的并发模型——JS使用单线程的”事件循环(Event Loop)”来处理多个任务的执行。</p>
<p>js的事件循环，每次读取一个任务，然后执行这个任务，执行完再继续获取下一个，如果暂时没有任务，就暂停执行，等待下一个任务到来；如果在执行任务的过程中有新的任务到达，也不会中断现有任务的执行，而是添加到队列的尾部等待</p>
<p>JS使用基于事件循环的单线程执行方式，而且是非抢断执行的（也就是说，无论发生什么，都会把当前任务执行完，不会出现执行到一半就去执行别的任务的情况）。<br><img src="/.io//duibi.png" alt="优缺点"></p>
<p><img src="/.io//eventloop1.png" alt="event-loop"></p>
<h2 id="任务队列的概念"><a href="#任务队列的概念" class="headerlink" title="任务队列的概念"></a>任务队列的概念</h2><p>任务队列，其实就是保存待处理任务的一个数组<br><img src="/.io//%E9%98%9F%E5%88%97.png" alt="队列"></p>
<p>每当我们要执行一个新的任务（例如：定时器），我们就会在队列尾部添加一个task，等到当前任务完成，事件循环会去队列头部寻找下一个可执行任务，我们用一个例子来更好的理解这一点</p>
<h2 id="任务队列与定时器"><a href="#任务队列与定时器" class="headerlink" title="任务队列与定时器"></a>任务队列与定时器</h2><ul>
<li>正在执行的任务（比如上面的console.log aaa和bbb）永远不会被打断，所有异步代码会被添加到队列等待执行</li>
<li>定时器不论时间多短（哪怕是0）也不会立刻执行，而是被放到任务队列尾部</li>
</ul>
<h2 id="定时器为什么总是不准？"><a href="#定时器为什么总是不准？" class="headerlink" title="定时器为什么总是不准？"></a>定时器为什么总是不准？</h2><ul>
<li>定时器的时间，并不是函数执行的时间，而是”最短x毫秒后，将任务添加到队列中”</li>
<li>也就是说，除非队列完全是空的，否则定时器的时间到了，它仅仅是开始排队罢了</li>
<li>那么，队列有可能永远是空的吗？显然不可能，就算没有你的任务，浏览器也有很多它的工作——渲染、重排、清理内存什么的</li>
</ul>
<h2 id="宏任务-微任务"><a href="#宏任务-微任务" class="headerlink" title="宏任务/微任务"></a>宏任务/微任务</h2><p>其实js里任务队列不只有一条，而是有两条.</p>
<ul>
<li>宏任务（macroTask或简称Task）：普通的任务，正常执行</li>
<li>微任务（microTask）：SVIP年费白金会员任务，优先于宏任务执行（但依然是非抢断的）</li>
</ul>
<p><img src="/.io//weirenwu.png" alt="微任务"></p>
<ol>
<li>获取下一个任务，如果没有就进入等待</li>
<li>当执行完一个任务之后，会执行所有排队的微任务</li>
<li>然后再次获取下一个任务</li>
</ol>
<h2 id="哪些操作属于宏任务？哪些属于微任务？"><a href="#哪些操作属于宏任务？哪些属于微任务？" class="headerlink" title="哪些操作属于宏任务？哪些属于微任务？"></a>哪些操作属于宏任务？哪些属于微任务？</h2><ul>
<li>宏任务：正常的异步任务都是宏任务，最常见的就是定时器（setInterval, setImmediate, setTimeout）、IO任务</li>
<li>微任务：微任务出现比较晚，queueMicrotask、Promise和async属于微任务（当然，async就是promise）</li>
</ul>
<h2 id="为什么要有微任务？"><a href="#为什么要有微任务？" class="headerlink" title="为什么要有微任务？"></a>为什么要有微任务？</h2><p>按照官方的设想，任务之间是不平等的，有些任务对用户体验影响大，就应该优先执行，而有些任务属于背景任务（比如定时器），晚点执行没有什么问题，所以设计了这种优先级队列的方式</p>
<h2 id="注意：async的坑"><a href="#注意：async的坑" class="headerlink" title="注意：async的坑"></a>注意：async的坑</h2><p>上面我们说到Promise也是微任务，而且async就是promise的一种语法包装（所谓语法糖），那async是不是一定是按照微任务的方式执行呢？”不全是”</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">console.log(&#x27;aaa&#x27;);</span><br><span class="line"></span><br><span class="line">(async ()=&gt;&#123;</span><br><span class="line">  console.log(111);  //在async里面</span><br><span class="line">&#125;)().then(()=&gt;&#123;</span><br><span class="line">  console.log(222);  //在async的then里面</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">console.log(&#x27;bbb&#x27;);</span><br><span class="line">aaa 111 bbb 222</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>事件循环：JS采用单线程的事件循环方式管理异步任务，优点是简化编程模型，缺点是无法发挥CPU的全部性能（但对前端其实没影响）</li>
<li>任务队列：JS采用非抢断式运行，当前任务不会被打断，有新的异步任务时，会放入任务队列</li>
<li>宏任务、微任务：宏任务就是普通异步任务，是最早出现的，微任务更关乎用户体验，所以得到优先执行</li>
<li>常见宏任务：定时器、IO任务</li>
<li>常见微任务：queueMicrotask、await、then</li>
</ul>
]]></content>
      <categories>
        <category>面试</category>
        <category>js</category>
      </categories>
  </entry>
  <entry>
    <title>html面试</title>
    <url>/2021/08/19/html%E9%9D%A2%E8%AF%95/</url>
    <content><![CDATA[<h1 id="html基础"><a href="#html基础" class="headerlink" title="html基础"></a>html基础</h1><h2 id="什么是HTML5以及和HTML的区别是什么"><a href="#什么是HTML5以及和HTML的区别是什么" class="headerlink" title="什么是HTML5以及和HTML的区别是什么"></a>什么是HTML5以及和HTML的区别是什么</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>HTML5是HTML的新标准，其主要目标是无需任何额外的插件如Flash、Silverlight等，就可以传输所有内容。它囊括了动画、视频、丰富的图形用户界面等。<br>HTML5是由万维网联盟（W3C）和Web Hypertext Application Technology Working Group 合作创建的HTML新版本。</p>
<h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><p>从文档声明类型上看：</p>
<p>HTML是很长的一段代码，很难记住。如下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;</span><br><span class="line">http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;</span><br><span class="line">&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;</span><br></pre></td></tr></table></figure>
<p>HTML5却只有简简单单的声明，方便记忆。如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br></pre></td></tr></table></figure>
<p>从语义结构上看：</p>
<p>HTML4.0：没有体现结构语义化的标签，通常都是这样来命名的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;header&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<p>这样表示网站的头部。<br>HTML5：在语义上却有很大的优势。提供了一些新的标签，比如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;header&gt;&lt;article&gt;&lt;footer&gt;</span><br></pre></td></tr></table></figure>

<p>拓展： 不输入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE HTML&gt;</span><br></pre></td></tr></table></figure>
<p>，浏览器将无法识别html文件，因此html将无法正常工作。</p>
<h2 id="HTML、XHTML和HTML5区别以及有什么联系"><a href="#HTML、XHTML和HTML5区别以及有什么联系" class="headerlink" title="HTML、XHTML和HTML5区别以及有什么联系"></a>HTML、XHTML和HTML5区别以及有什么联系</h2><p>XHTML与HTML的区别</p>
<ol>
<li>XHTML标签名必须小写；</li>
<li>XHTML元素必须被关闭；</li>
<li>XHTML元素必须被正确的嵌套；</li>
<li>XHTML元素必须要有根元素。</li>
</ol>
<p>XHTML与HTML5的区别</p>
<ol>
<li>HTML5新增了canvas绘画元素；</li>
<li>HTML5新增了用于绘媒介回放的video和audio元素；</li>
<li>更具语义化的标签，便于浏览器识别；</li>
<li>对本地离线存储有更好的支持；</li>
<li>MATHML，SVG等，可以更好的render；</li>
<li>添加了新的表单控件：calendar、date、time、email等。</li>
</ol>
<p>HTML、XHTML、HTML5之间联系</p>
<ol>
<li>XHTML是HTML规范版本；</li>
<li>HTML5是HTML、XHTML以及HTML DOM的新标准。</li>
</ol>
<h2 id="HTML5-为什么只需要写-lt-doctype-html-gt"><a href="#HTML5-为什么只需要写-lt-doctype-html-gt" class="headerlink" title="HTML5 为什么只需要写 &lt;!doctype html&gt;"></a>HTML5 为什么只需要写 &lt;!doctype html&gt;</h2><p>这是因为HTML5不基于SGML，因此不需要对DTD进行引用，但是需要DOCTYPE来规范浏览器的行为（让浏览器按照他们应该的方式来运行）而HTML4.01基于SGML，所以需要对DTD进行引用，才能告知浏览器文档所使用的文档类型。</p>
<h2 id="行内元素有哪些？块级元素有哪些？-空-void-元素有那些？"><a href="#行内元素有哪些？块级元素有哪些？-空-void-元素有那些？" class="headerlink" title="行内元素有哪些？块级元素有哪些？ 空(void)元素有那些？"></a>行内元素有哪些？块级元素有哪些？ 空(void)元素有那些？</h2><ol>
<li>行内元素： a, b, span, img, input, select, strong;</li>
<li>块级元素： div, ul, li, dl, dt, dd, h1-5, p等；</li>
<li>空元素： br, hr, img, link, meta;</li>
</ol>
<h2 id="Html5-有哪些新特性、移除了哪些元素"><a href="#Html5-有哪些新特性、移除了哪些元素" class="headerlink" title="Html5 有哪些新特性、移除了哪些元素"></a>Html5 有哪些新特性、移除了哪些元素</h2><p>（1）新增元素</p>
<p>绘画 canvas<br>用于媒介回放的 video 和 audio 元素<br>本地离线存储 localStorage 长期存储数据，浏览器关闭后数据不丢失<br>sessionStorage 的数据在浏览器关闭后会自动删除<br>语义化更好的内容元素，比如 article 、footer、header、nav、section<br>表单控件 ， calendar 、 date 、 time 、 email 、 url 、 search<br>新的技术 webworker 、 websocket 、 Geolocation</p>
<p>（2）移除的元素</p>
<p>纯表现的元素： basefont 、 big 、 center 、 font 、 s 、 strike 、 tt 、 u<br>对可用性产生负面影响的元素： frame 、 frameset 、 noframes</p>
<p>（3）支持 HTML5 新标签</p>
<p>IE8/IE7/IE6 支持通过 document.createElement 方法产生的标签。<br>可以利用这一特性让这些浏览器支持 HTML5 新标签。<br>浏览器支持新标签后，还需要添加标签默认的样式。</p>
<h2 id="HTML5有哪些更新"><a href="#HTML5有哪些更新" class="headerlink" title="HTML5有哪些更新"></a>HTML5有哪些更新</h2><ol>
<li>语义化标签</li>
</ol>
<p>· header：定义文档的页眉（头部）；<br>· nav：定义导航链接的部分；<br>· footer：定义文档或节的页脚（底部）；<br>· article：定义文章内容；<br>· section：定义文档中的节（section、区段）；<br>· aside：定义其所处内容之外的内容（侧边）；</p>
<ol start="2">
<li>媒体标签<br>（1） audio：音频<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;audio src=&#x27;&#x27; controls autoplay loop=&#x27;true&#x27;&gt;&lt;/audio&gt;</span><br></pre></td></tr></table></figure>
属性：</li>
</ol>
<p>· controls 控制面板<br>· autoplay 自动播放<br>· loop=‘true’ 循环播放</p>
<p>（2）video视频</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;video src=&#x27;&#x27; poster=&#x27;imgs/aa.jpg&#x27; controls&gt;&lt;/video&gt;</span><br></pre></td></tr></table></figure>
<p>属性：<br>· poster：指定视频还没有完全下载完毕，或者用户还没有点击播放前显示的封面。默认显示当前视频文件的第一针画面，当然通过poster也可以自己指定。<br>· controls 控制面板<br>· width<br>· height</p>
<p>（3）source标签<br>因为浏览器对视频格式支持程度不一样，为了能够兼容不同的浏览器，可以通过source来指定视频源。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;video&gt;</span><br><span class="line"> 	&lt;source src=&#x27;aa.flv&#x27; type=&#x27;video/flv&#x27;&gt;&lt;/source&gt;</span><br><span class="line"> 	&lt;source src=&#x27;aa.mp4&#x27; type=&#x27;video/mp4&#x27;&gt;&lt;/source&gt;</span><br><span class="line">&lt;/video&gt;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>表单<br>表单类型：</li>
</ol>
<p>· email ：能够验证当前输入的邮箱地址是否合法<br>· url ： 验证URL<br>· number ： 只能输入数字，其他输入不了，而且自带上下增大减小箭头，max属性可以设置为最大值，min可以设置为最小值，value为默认值。<br>· search ： 输入框后面会给提供一个小叉，可以删除输入的内容，更加人性化。<br>· range ： 可以提供给一个范围，其中可以设置max和min以及value，其中value属性可以设置为默认值<br>· color ： 提供了一个颜色拾取器<br>· time ： 时分秒<br>· data ： 日期选择年月日<br>· datatime ： 时间和日期(目前只有Safari支持)<br>· datatime-local ：日期时间控件<br>· week ：周控件<br>· month：月控件</p>
<p>表单属性：</p>
<p>· placeholder ：提示信息<br>· autofocus ：自动获取焦点<br>· autocomplete=“on” 或者 autocomplete=“off” 使用这个属性需要有两个前提：</p>
<pre><code>· 表单必须提交过
· 必须有name属性。
</code></pre>
<p>· required：要求输入框不能为空，必须有值才能够提交。<br>· pattern=” “ 里面写入想要的正则模式，例如手机号patte=”^(+86)?\d{10}$”<br>· multiple：可以选择多个文件或者多个邮箱<br>· form=” form表单的ID”</p>
<p>表单事件：</p>
<p>· oninput 每当input里的输入框内容发生变化都会触发此事件。<br>· oninvalid 当验证不通过时触发此事件。</p>
<ol start="4">
<li>进度条、度量器</li>
</ol>
<p>· progress标签：用来表示任务的进度（IE、Safari不支持），max用来表示任务的进度，value表示已完成多少<br>· meter属性：用来显示剩余容量或剩余库存（IE、Safari不支持）</p>
<pre><code>· high/low：规定被视作高/低的范围
· max/min：规定最大/小值
· value：规定当前度量值
</code></pre>
<p>设置规则：min &lt; low &lt; high &lt; max<br>5.DOM查询操作</p>
<p>· document.querySelector()<br>· document.querySelectorAll()</p>
<p>它们选择的对象可以是标签，可以是类(需要加点)，可以是ID(需要加#)<br>6. Web存储<br>HTML5 提供了两种在客户端存储数据的新方法：</p>
<p>· localStorage - 没有时间限制的数据存储<br>· sessionStorage - 针对一个 session 的数据存储</p>
<ol start="7">
<li>其他</li>
</ol>
<p>拖放：拖放是一种常见的特性，即抓取对象以后拖到另一个位置。设置元素可拖放：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;img draggable=&quot;true&quot; /&gt;</span><br></pre></td></tr></table></figure>

<p>画布（canvas ）： canvas 元素使用 JavaScript 在网页上绘制图像。画布是一个矩形区域，可以控制其每一像素。canvas 拥有多种绘制路径、矩形、圆形、字符以及添加图像的方法。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;canvas id=&quot;myCanvas&quot; width=&quot;200&quot; height=&quot;100&quot;&gt;&lt;/canvas&gt;</span><br></pre></td></tr></table></figure>

<p>SVG：SVG 指可伸缩矢量图形，用于定义用于网络的基于矢量的图形，使用 XML 格式定义图形，图像在放大或改变尺寸的情况下其图形质量不会有损失，它是万维网联盟的标准<br>地理定位：Geolocation（地理定位）用于定位用户的位置。‘</p>
<p>总结：<br>（1）新增语义化标签：nav、header、footer、aside、section、article<br>（2）音频、视频标签：audio、video<br>（3）数据存储：localStorage、sessionStorage<br>（4）canvas（画布）、Geolocation（地理定位）、websocket（通信协议）<br>（5）input标签新增属性：placeholder、autocomplete、autofocus、required<br>（6）history API：go、forward、back、pushstate<br>移除的元素有：</p>
<p>纯表现的元素：basefont，big，center，font, s，strike，tt，u;<br>对可用性产生负面影响的元素：frame，frameset，noframes；</p>
<h2 id="src和href的区别"><a href="#src和href的区别" class="headerlink" title="src和href的区别"></a>src和href的区别</h2><p>src和href都是用来引用外部的资源，它们的区别如下：</p>
<ol>
<li>src： 表示对资源的引用，它指向的内容会嵌入到当前标签所在的位置。src会将其指向的资源下载并应⽤到⽂档内，如请求js脚本。当浏览器解析到该元素时，会暂停其他资源的下载和处理，直到将该资源加载、编译、执⾏完毕，所以⼀般js脚本会放在页面底部。</li>
<li>href： 表示超文本引用，它指向一些网络资源，建立和当前元素或本文档的链接关系。当浏览器识别到它他指向的⽂件时，就会并⾏下载资源，不会停⽌对当前⽂档的处理。 常用在a、link等标签上。</li>
</ol>
<h2 id="Webp"><a href="#Webp" class="headerlink" title="Webp"></a>Webp</h2><p>WebP 格式，谷歌（google）开发的一种旨在加快图片加载速度的图片格式。图片压缩体积大约只有 JPEG 的 2/3 ，并能节省大量的服务器带宽资源和数据空间。Facebook 、 Ebay 等知名网站已经开始测试并使用 WebP 格式。<br>在质量相同的情况下， WebP 格式图像的体积要比 JPEG 格式图像小40%</p>
<h2 id="WebP-相对于-PNG、JPG-有什么优势？"><a href="#WebP-相对于-PNG、JPG-有什么优势？" class="headerlink" title="WebP 相对于 PNG、JPG 有什么优势？"></a>WebP 相对于 PNG、JPG 有什么优势？</h2><ol>
<li>PNG 转 WebP 的压缩率要高于 PNG 原图压缩率，同样支持有损与无损压缩</li>
<li>转换后的 WebP 体积大幅减少，图片质量也得到保障（同时肉眼几乎无法看出差异）</li>
<li>转换后的 WebP 支持 Alpha 透明和 24-bit 颜色数，不存在 PNG8 色彩不够丰富和在浏览器中可能会出现毛边的问题</li>
</ol>
<h2 id="HTML全局属性-global-attribute-有"><a href="#HTML全局属性-global-attribute-有" class="headerlink" title="HTML全局属性(global attribute)有"></a>HTML全局属性(global attribute)有</h2><ol>
<li>accesskey    规定激活元素的快捷键。</li>
<li>class    规定元素的一个或多个类名（引用样式表中的类）。</li>
<li>contenteditable    规定元素内容是否可编辑。</li>
<li>contextmenu    规定元素的上下文菜单。上下文菜单在用户点击元素时显示。</li>
<li>data-*    用于存储页面或应用程序的私有定制数据。</li>
<li>dir    规定元素中内容的文本方向。</li>
<li>draggable    规定元素是否可拖动。</li>
<li>dropzone    规定在拖动被拖动数据时是否进行复制、移动或链接。</li>
<li>hidden    规定元素仍未或不再相关。</li>
<li>id    规定元素的唯一 id。</li>
<li>lang    规定元素内容的语言。</li>
<li>spellcheck    规定是否对元素进行拼写和语法检查。</li>
<li>style    规定元素的行内 CSS 样式。</li>
<li>tabindex    规定元素的 tab 键次序。</li>
<li>title    规定有关元素的额外信息。</li>
<li>translate    规定是否应该翻译元素内容。</li>
</ol>
<h2 id="对HTML语义化的理解"><a href="#对HTML语义化的理解" class="headerlink" title="对HTML语义化的理解"></a>对HTML语义化的理解</h2><p>语义化是指根据内容的结构化（内容语义化），选择合适的标签（代码语义化）。通俗来讲就是用正确的标签做正确的事情。<br>语义化的优点如下：</p>
<p>对机器友好，带有语义的文字表现力丰富，更适合搜索引擎的爬虫爬取有效信息，有利于SEO。除此之外，语义类还支持读屏软件，根据文章可以自动生成目录；<br>对开发者友好，使用语义类标签增强了可读性，结构更加清晰，开发者能清晰的看出网页的结构，便于团队的开发与维护。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;header&gt;&lt;/header&gt;  头部</span><br><span class="line"></span><br><span class="line">&lt;nav&gt;&lt;/nav&gt;  导航栏</span><br><span class="line"></span><br><span class="line">&lt;section&gt;&lt;/section&gt;  区块（有语义化的div）</span><br><span class="line"></span><br><span class="line">&lt;main&gt;&lt;/main&gt;  主要区域</span><br><span class="line"></span><br><span class="line">&lt;article&gt;&lt;/article&gt;  主要内容</span><br><span class="line"></span><br><span class="line">&lt;aside&gt;&lt;/aside&gt;  侧边栏</span><br><span class="line"></span><br><span class="line">&lt;footer&gt;&lt;/footer&gt;  底部</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="DOCTYPE-⽂档类型-的作⽤"><a href="#DOCTYPE-⽂档类型-的作⽤" class="headerlink" title="DOCTYPE(⽂档类型) 的作⽤"></a>DOCTYPE(⽂档类型) 的作⽤</h2><p>DOCTYPE是HTML5中一种标准通用标记语言的文档类型声明，它的目的是告诉浏览器（解析器）应该以什么样（html或xhtml）的文档类型定义来解析文档，不同的渲染模式会影响浏览器对 CSS 代码甚⾄ JavaScript 脚本的解析。它必须声明在HTML⽂档的第⼀⾏。<br>浏览器渲染页面的两种模式（可通过document.compatMode获取，比如，语雀官网的文档类型是CSS1Compat）：</p>
<ol>
<li>CSS1Compat：标准模式（Strick mode），默认模式，浏览器使用W3C的标准解析渲染页面。在标准模式中，浏览器以其支持的最高标准呈现页面。</li>
<li>BackCompat：怪异模式(混杂模式)(Quick mode)，浏览器使用自己的怪异模式解析渲染页面。在怪异模式中，页面以一种比较宽松的向后兼容的方式显示。</li>
</ol>
<h2 id="viewport的content属性作用"><a href="#viewport的content属性作用" class="headerlink" title="viewport的content属性作用"></a>viewport的content属性作用</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;meta name=&quot;viewport&quot; content=&quot;&quot; /&gt; </span><br><span class="line">	width – viewport的宽度[device-width | pixel_value]width如果直接设置pixel_value数值，大部分的安卓手机不支持，但是ios支持；</span><br><span class="line">	height – viewport 的高度 （范围从 223 到 10,000 ）</span><br><span class="line">	user-scalable [yes | no]是否允许缩放</span><br><span class="line">	initial-scale [数值] 初始化比例（范围从 &gt; 0 到 10）</span><br><span class="line">	minimum-scale [数值] 允许缩放的最小比例</span><br><span class="line">	maximum-scale [数值] 允许缩放的最大比例</span><br><span class="line">	target-densitydpi 值有以下（一般推荐设置中等响度密度或者低像素密度，后者设置具体的值 dpi_value，另外webkit内核已不准备再支持此属性） </span><br><span class="line">	-- dpi_value 一般是70-400//没英寸像素点的个数</span><br><span class="line">	-- device-dpi设备默认像素密度</span><br><span class="line">	-- high-dpi 高像素密度</span><br><span class="line">	-- medium-dpi 中等像素密度</span><br><span class="line">	-- low-dpi 低像素密度</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="常⽤的meta标签有哪些"><a href="#常⽤的meta标签有哪些" class="headerlink" title="常⽤的meta标签有哪些"></a>常⽤的meta标签有哪些</h2><p>meta 标签由 name 和 content 属性定义，用来描述网页文档的属性，比如网页的作者，网页描述，关键词等，除了HTTP标准固定了一些name作为大家使用的共识，开发者还可以自定义name。<br>常用的meta标签：<br>（1）charset，用来描述HTML文档的编码类型：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;meta charset=&quot;UTF-8&quot; &gt;</span><br></pre></td></tr></table></figure>
<p>（2） keywords，页面关键词：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;meta name=&quot;keywords&quot; content=&quot;关键词&quot; /&gt;</span><br></pre></td></tr></table></figure>
<p>（3）description，页面描述：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;meta name=&quot;description&quot; content=&quot;页面描述内容&quot; /&gt;</span><br></pre></td></tr></table></figure>
<p>（4）refresh，页面重定向和刷新：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;meta http-equiv=&quot;refresh&quot; content=&quot;0;url=&quot; /&gt;</span><br></pre></td></tr></table></figure>
<p>（5）viewport，适配移动端，可以控制视口的大小和比例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, maximum-scale=1&quot;&gt;</span><br></pre></td></tr></table></figure>
<p>其中，content 参数有以下几种：</p>
<ol>
<li>width viewport ：宽度(数值/device-width)</li>
<li>height viewport ：高度(数值/device-height)</li>
<li>initial-scale ：初始缩放比例</li>
<li>maximum-scale ：最大缩放比例</li>
<li>minimum-scale ：最小缩放比例</li>
<li>user-scalable ：是否允许用户缩放(yes/no）</li>
</ol>
<p>（6）搜索引擎索引方式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;meta name=&quot;robots&quot; content=&quot;index,follow&quot; /&gt;</span><br></pre></td></tr></table></figure>
<p>其中，content 参数有以下几种：</p>
<ol>
<li>all：文件将被检索，且页面上的链接可以被查询；</li>
<li>none：文件将不被检索，且页面上的链接不可以被查询；</li>
<li>index：文件将被检索；</li>
<li>follow：页面上的链接可以被查询；</li>
<li>noindex：文件将不被检索；</li>
<li>nofollow：页面上的链接不可以被查询。</li>
</ol>
<h2 id="meta-相关"><a href="#meta-相关" class="headerlink" title="meta 相关"></a>meta 相关</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt; &lt;!--H5标准声明，使用 HTML5 doctype，不区分大小写--&gt; </span><br><span class="line">&lt;head lang=”en”&gt; &lt;!--标准的 lang 属性写法--&gt; </span><br><span class="line">&lt;meta charset=’utf-8ʹ&gt; &lt;!--声明文档使用的字符编码--&gt; </span><br><span class="line">&lt;meta http-equiv=”X-UA-Compatible” content=”IE=edge,chrome=1″/&gt; &lt;!--优先使用指定浏 览器使用特定的文档模式--&gt; </span><br><span class="line">&lt;meta name=”description” content=”不超过150个字符”/&gt; &lt;!--页面描述--&gt; </span><br><span class="line">&lt;meta name=”keywords” content=””/&gt; &lt;!-- 页面关键词--&gt; </span><br><span class="line">&lt;meta name=”author” content=”name, email@gmail.com”/&gt; &lt;!--网页作者--&gt; </span><br><span class="line">&lt;meta name=”robots” content=”index,follow”/&gt; &lt;!--搜索引擎抓取--&gt; </span><br><span class="line">&lt;meta name=”viewport” content=”initial-scale=1, maximum-scale=3, minimum-sc </span><br><span class="line">&lt;meta name=”apple-mobile-web-app-title” content=”标题”&gt; &lt;!--iOS 设备 begin--&gt; </span><br><span class="line">&lt;meta name=”apple-mobile-web-app-capable” content=”yes”/&gt; &lt;!--添加到主屏后的标 是否启用 WebApp 全屏模式，删除苹果默认的工具栏和菜单栏--&gt; &lt;meta name=”apple-mobile-web-app-status-bar-style” content=”black”/&gt; </span><br><span class="line">&lt;meta name=”renderer” content=”webkit”&gt; &lt;!-- 启用360浏览器的极速模式(webkit)--&gt; </span><br><span class="line">&lt;meta http-equiv=”X-UA-Compatible” content=”IE=edge”&gt; &lt;!--避免IE使用兼容模式--&gt; </span><br><span class="line">&lt;meta http-equiv=”Cache-Control” content=”no-siteapp” /&gt; &lt;!--不让百度转码--&gt; </span><br><span class="line">&lt;meta name=”HandheldFriendly” content=”true”&gt; &lt;!--针对手持设备优化，主要是针对一些老的 不识别viewport的浏览器--&gt; </span><br><span class="line">&lt;meta name=”MobileOptimized” content=”320″&gt; &lt;!--微软的老式浏览器--&gt; </span><br><span class="line">&lt;meta name=”screen-orientation” content=”portrait”&gt; &lt;!--uc强制竖屏--&gt; </span><br><span class="line">&lt;meta name=”x5-orientation” content=”portrait”&gt; &lt;!--QQ强制竖屏--&gt; </span><br><span class="line">&lt;meta name=”full-screen” content=”yes”&gt; &lt;!--UC强制全屏--&gt; </span><br><span class="line">&lt;meta name=”x5-fullscreen” content=”true”&gt; &lt;!--QQ强制全屏--&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="script标签中defer和async的区别"><a href="#script标签中defer和async的区别" class="headerlink" title="script标签中defer和async的区别"></a>script标签中defer和async的区别</h2><p>如果没有defer或async属性，浏览器会立即加载并执行相应的脚本。它不会等待后续加载的文档元素，读取到就会开始加载和执行，这样就阻塞了后续文档的加载。</p>
<p>defer 和 async属性都是去异步加载外部的JS脚本文件，它们都不会阻塞页面的解析，其区别如下：</p>
<ol>
<li>执行顺序： 多个带async属性的标签，不能保证加载的顺序；多个带defer属性的标签，按照加载顺序执行；</li>
<li>脚本是否并行执行：async属性，表示后续文档的加载和执行与js脚本的加载和执行是并行进行的，即异步执行；defer属性，加载后续文档的过程和js脚本的加载(此时仅加载不执行)是并行进行的(异步)，js脚本需要等到文档所有元素解析完成之后才执行，DOMContentLoaded事件触发执行之前。</li>
<li>async异步，defer是延迟</li>
</ol>
<h2 id="em-与-i-的区别"><a href="#em-与-i-的区别" class="headerlink" title="em 与 i 的区别"></a>em 与 i 的区别</h2><ol>
<li>效果都是斜体</li>
<li>em 是语义化标签，表强调</li>
<li>i 是样式标签， 表斜体</li>
</ol>
<h2 id="HTML-和-DOM-的关系"><a href="#HTML-和-DOM-的关系" class="headerlink" title="HTML 和 DOM 的关系"></a>HTML 和 DOM 的关系</h2><ol>
<li>HTML 只是一个字符串</li>
<li>DOM 由 HTML 解析而来</li>
<li>JS 可以维护 DOM</li>
</ol>
<h2 id="HTML5新增了哪些内容或API，使用过哪些"><a href="#HTML5新增了哪些内容或API，使用过哪些" class="headerlink" title="HTML5新增了哪些内容或API，使用过哪些"></a>HTML5新增了哪些内容或API，使用过哪些</h2><ol>
<li>document.querySelector()和document.querySelectorAll()</li>
</ol>
<p>document.querySelector()：根据css选择器返回第一个匹配的元素，如果没有匹配返回null；</p>
<p>document.querySelectorAll(“selector”)：querySelectorAll和querySelector作用一样的，只是querySelectorAll返回的是元素数组，querySelector返回的是一个元素。如果querySelectorAll没有匹配的内容返回的是一个空数组。</p>
<ol start="2">
<li>document.getElementsByClassName()<br>getElementsByClassName()方法接收一个参数，即一个包含一或多个类名的字符串，返回带有指定类的所有元素的NodeList。传入多个类名时，类名的先后顺序不重要。</li>
</ol>
<ol start="3">
<li><p>classList属性<br>add(value)：将给定的字符串值添加到列表中。如果值已经存在，就不添加了。<br>contains(value)：表示列表中是否存在给定的值，如果存在则返回true，否则返回false。<br>remove(value)：从列表中删除给定的字符串。<br>toggle(value)：如果列表中已经存在给定的值，删除它；如果列表中没有给定的值，添加它</p>
</li>
<li><p>自定义数据属性<br>HTML5 规定可以为元素添加非标准的属性，但要添加前缀data-，目的是为元素提供与渲染无关的信息，或者提供语义信息。这些属性可以任意添加、随便命名，只要以data-开头即可。来看一个例子。</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;myDiv&quot; data-myname=&quot;mike&quot;&gt;&lt;/div&gt;</span><br><span class="line">var div=document.getElementById(&#x27;myDiv&#x27;);</span><br><span class="line">if(div.dataset.myname)&#123;alert(div.dataset.myname);&#125;</span><br></pre></td></tr></table></figure>
<ol start="5">
<li>insertAdjacentHtml(),insertAdjacentText(),insertAdjacentElement()<br>插入标记的最后一个新增方式是insertAdjacentHTML()方法。它接收两个参数：插入位置和要插入的HTML 文本。第一个参数必须是下列值之一：</li>
</ol>
<p>“beforebegin”，在当前元素之前插入一个紧邻的同辈元素；<br>“afterbegin”，在当前元素之下插入一个新的子元素或在第一个子元素之前再插入新的子元素；<br>“beforeend”，在当前元素之下插入一个新的子元素或在最后一个子元素之后再插入新的子元素；<br>“afterend”，在当前元素之后插入一个紧邻的同辈元素。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">element.insertAdjacentHTML(&#x27;beforebegin&#x27;,&#x27;&lt;p&gt;hello world&lt;/p&gt;&#x27;);</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>FullScreen API…</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line"></span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">  &lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">  &lt;style&gt;</span><br><span class="line">    html:-moz-full-screen &#123;</span><br><span class="line">      background: red;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    html:-webkit-full-screen &#123;</span><br><span class="line">      background: red;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    html:fullscreen &#123;</span><br><span class="line">      background: red;</span><br><span class="line">    &#125;</span><br><span class="line">  &lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;ul class=&quot;class1 class2 class3 &quot;&gt;</span><br><span class="line">    &lt;li onclick=&quot;launchFullScreen()&quot;&gt;全屏&lt;/li&gt;</span><br><span class="line">    &lt;input type=&quot;text&quot;&gt;</span><br><span class="line">  &lt;/ul&gt;</span><br><span class="line">  &lt;button onclick=&quot;exitFullscreen()&quot;&gt;click me&lt;/button&gt;</span><br><span class="line">  &lt;script&gt;</span><br><span class="line">    // 找到支持的方法, 使用需要全屏的 element 调用</span><br><span class="line">    function launchFullScreen(element) &#123;</span><br><span class="line"></span><br><span class="line">      var element = element || document.documentElement;</span><br><span class="line">      console.log(element);</span><br><span class="line">      if (element.requestFullscreen) &#123;</span><br><span class="line">        element.requestFullscreen();</span><br><span class="line">      &#125; else if (element.mozRequestFullScreen) &#123;</span><br><span class="line">        element.mozRequestFullScreen();</span><br><span class="line">      &#125; else if (element.webkitRequestFullscreen) &#123;</span><br><span class="line">        element.webkitRequestFullscreen();</span><br><span class="line">      &#125; else if (element.msRequestFullscreen) &#123;</span><br><span class="line">        element.msRequestFullscreen();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //请注意: exitFullscreen 只能通过 document 对象调用 —— 而不是使用普通的 DOM element.</span><br><span class="line">    function exitFullscreen() &#123;</span><br><span class="line">      if (document.exitFullscreen) &#123;</span><br><span class="line">        document.exitFullscreen();</span><br><span class="line">      &#125; else if (document.mozExitFullScreen) &#123;</span><br><span class="line">        document.mozExitFullScreen();</span><br><span class="line">      &#125; else if (document.webkitExitFullscreen) &#123;</span><br><span class="line">        document.webkitExitFullscreen();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    element.webkitRequestFullScreen(Element.ALLOW_KEYBOARD_INPUT);//全屏状态允许键盘输入</span><br><span class="line"></span><br><span class="line">    /*有的时候为了用户友好体验，在进入全屏或者退出全屏的时候，需要给用户提示，</span><br><span class="line">    这个时候我们可以使用FullScreen的screenchange事件进行监控。事件监听没作用？？？？？*/</span><br><span class="line">    document.addEventListener(&quot;fullscreenchange&quot;, function () &#123;</span><br><span class="line">      fullscreenState.innerHTML = (document.fullscreen) ? &quot;&quot; : &quot;not &quot;;</span><br><span class="line">    &#125;, false);</span><br><span class="line"></span><br><span class="line">    document.addEventListener(&quot;mozfullscreenchange&quot;, function () &#123;</span><br><span class="line">      fullscreenState.innerHTML = (document.mozFullScreen) ? &quot;&quot; : &quot;not &quot;;</span><br><span class="line">    &#125;, false);</span><br><span class="line"></span><br><span class="line">    document.addEventListener(&quot;webkitfullscreenchange&quot;, function () &#123;</span><br><span class="line">      fullscreenState.innerHTML = (document.webkitIsFullScreen) ? &quot;&quot; : &quot;not &quot;;</span><br><span class="line">    &#125;, false);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<ol start="7">
<li>页面可见性（Page Visibility）…<br>所谓页面可见性就是当前页面是处于显示状态还是隐藏状态，页面可见性对于网站的统计非常有用。有的时候我们会统计用户停留在每个页面的时间，这个时间就是：用户打开网页到网页关闭或者最小化之间的时间。</li>
</ol>
<p>有的时候在视频播放的时候，当用户离开视频播放页面自动暂停视频播放，我们有时候也对那些定期刷新内容的页面进行控制，当该页面不可见则不刷新，可见则刷新。这些都是页面可见性的具体应用。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">  &lt;title&gt;Title&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;ul class=&quot;class1 class2 class3 &quot;&gt;</span><br><span class="line">  &lt;li&gt;1&lt;/li&gt;</span><br><span class="line">  &lt;li&gt;2&lt;/li&gt;</span><br><span class="line">  &lt;li&gt;3&lt;/li&gt;</span><br><span class="line">  &lt;li&gt;4&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  (function () &#123;</span><br><span class="line">    var hidden = &quot;hidden&quot;;</span><br><span class="line">    // Standards:</span><br><span class="line">    if (hidden in document)</span><br><span class="line">      document.addEventListener(&quot;visibilitychange&quot;, onchange);</span><br><span class="line">    else if ((hidden = &quot;mozHidden&quot;) in document)</span><br><span class="line">      document.addEventListener(&quot;mozvisibilitychange&quot;, onchange);</span><br><span class="line">    else if ((hidden = &quot;webkitHidden&quot;) in document)</span><br><span class="line">      document.addEventListener(&quot;webkitvisibilitychange&quot;, onchange);</span><br><span class="line">    else if ((hidden = &quot;msHidden&quot;) in document)</span><br><span class="line">      document.addEventListener(&quot;msvisibilitychange&quot;, onchange);</span><br><span class="line">    // IE 9 and lower:</span><br><span class="line">    else if (&quot;onfocusin&quot; in document)</span><br><span class="line">      document.onfocusin = document.onfocusout = onchange;</span><br><span class="line">    // All others:</span><br><span class="line">    else</span><br><span class="line">      window.onpageshow = window.onpagehide</span><br><span class="line">        = window.onfocus = window.onblur = onchange;</span><br><span class="line">    function onchange(evt) &#123;</span><br><span class="line">      var v = &quot;visible&quot;, h = &quot;hidden&quot;,</span><br><span class="line">        evtMap = &#123;</span><br><span class="line">          focus: v, focusin: v, pageshow: v, blur: h, focusout: h, pagehide: h</span><br><span class="line">        &#125;;</span><br><span class="line">      evt = evt || window.event;</span><br><span class="line">      if (evt.type in evtMap)</span><br><span class="line">        document.body.className = evtMap[evt.type];</span><br><span class="line">      else</span><br><span class="line">        document.body.className = this[hidden] ? &quot;hidden&quot; : &quot;visible&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    // set the initial state (but only if browser supports the Page Visibility API)</span><br><span class="line">    if (document[hidden] !== undefined)</span><br><span class="line">      onchange(&#123;type: document[hidden] ? &quot;blur&quot; : &quot;focus&quot;&#125;);</span><br><span class="line">  &#125;)();</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<ol start="8">
<li>预加载（prefetch）<br>网站优化一直是项目开发中的重点之中，常用的优化方式主要有：图片懒加载、图片sprite、css合并、js合并、数据本地存储、数据网络缓存等。这些都是项目中经常使用的，HTML5考虑到了这一点，提出了链接预加载的方法，其实，这个方案是FireFox提出的，所以它对链接预加载绝对的支持。什么是链接预加载那？我们看一下mdn的描述：<br>预加载是一种浏览器机制，使用浏览器空闲时间来预先下载/加载用户接下来很可能会浏览的页面/资源。页面提供给浏览器需要预加载的集合。 浏览器载入当前页面完成后，将会在后台下载需要预加载的页面并添加到缓存中。当用户访问某个预加载的链接时，如果从缓存命中, 页面就得以快速呈现。<br>说的直接一些就是让浏览器在后台提前下载一些文件</li>
</ol>
<p>关于链接预加载，有如下注意事项：<br>预加载可以跨域进行，当然，请求时cookie等信息也会被发送。<br>预加载可能破坏网站统计数据，而用户并没有实际访问。<br>浏览器兼容性不是很好</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;link rel=&#x27;prefetch&#x27; href=&#x27;page1.html&#x27;&gt;</span><br><span class="line">&lt;link rel=&#x27;dns-prefetch&#x27; href=&#x27;flower.png&#x27;&gt;</span><br></pre></td></tr></table></figure>

<ol start="9">
<li>图形元素（The Figure Element）<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;figure&gt;</span><br><span class="line">     &lt;img src=&quot;path/to/image&quot; alt=&quot;About image&quot; /&gt;</span><br><span class="line">     &lt;figcaption&gt;</span><br><span class="line">        &lt;p&gt;This is an image of something interesting. &lt;/p&gt;</span><br><span class="line">     &lt;/figcaption&gt;</span><br><span class="line"> &lt;/figure&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li>内容可编辑（contenteditable）<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;ul contenteditable=true&gt;</span><br><span class="line">    &lt;li&gt;i am editable&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;i am editable too&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;i am editable too too&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure></li>
<li>本地存储（Local Storage）</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">//localStorage方法</span><br><span class="line">if (localStorage.pagecount)</span><br><span class="line">    &#123;</span><br><span class="line">    localStorage.pagecount=Number(localStorage.pagecount) +1;</span><br><span class="line">    &#125;</span><br><span class="line">else</span><br><span class="line">    &#123;</span><br><span class="line">    localStorage.pagecount=1;</span><br><span class="line">    &#125;</span><br><span class="line">document.write(&quot;Visits: &quot; + localStorage.pagecount + &quot; time(s).&quot;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//sessionStorage方法</span><br><span class="line">if (sessionStorage.pagecount)</span><br><span class="line">  &#123;</span><br><span class="line">  sessionStorage.pagecount=Number(sessionStorage.pagecount) +1;</span><br><span class="line">  &#125;</span><br><span class="line">else</span><br><span class="line">  &#123;</span><br><span class="line">  sessionStorage.pagecount=1;</span><br><span class="line">  &#125;</span><br><span class="line">document.write(&quot;Visits &quot;+sessionStorage.pagecount+&quot; time(s) this session.&quot;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<ol start="12">
<li>自定义数据属性<br>HTML5 规定可以为元素添加非标准的属性，但要添加前缀data-，目的是为元素提供与渲染无关的信息，或者提供语义信息。这些属性可以任意添加、随便命名，只要以data-开头即可。</li>
</ol>
<h2 id="img的srcset属性的作⽤？"><a href="#img的srcset属性的作⽤？" class="headerlink" title="img的srcset属性的作⽤？"></a>img的srcset属性的作⽤？</h2><p>响应式页面中经常用到根据屏幕密度设置不同的图片。这时就用到了 img 标签的srcset属性。srcset属性用于设置不同屏幕密度下，img 会自动加载不同的图片。用法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;img src=&quot;image-128.png&quot; srcset=&quot;image-256.png 2x&quot; /&gt;</span><br></pre></td></tr></table></figure>
<p>使用上面的代码，就能实现在屏幕密度为1x的情况下加载image-128.png, 屏幕密度为2x时加载image-256.png。<br>按照上面的实现，不同的屏幕密度都要设置图片地址，目前的屏幕密度有1x,2x,3x,4x四种，如果每一个图片都设置4张图片，加载就会很慢。所以就有了新的srcset标准。代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;img src=&quot;image-128.png&quot;</span><br><span class="line">     srcset=&quot;image-128.png 128w, image-256.png 256w, image-512.png 512w&quot;</span><br><span class="line">     sizes=&quot;(max-width: 360px) 340px, 128px&quot; /&gt;</span><br></pre></td></tr></table></figure>
<p>其中srcset指定图片的地址和对应的图片质量。sizes用来设置图片的尺寸零界点。对于 srcset 中的 w 单位，可以理解成图片质量。如果可视区域小于这个质量的值，就可以使用。浏览器会自动选择一个最小的可用图片。<br>sizes语法如下：<br>sizes=”[media query] [length], [media query] [length] … “</p>
<p>sizes就是指默认显示128px, 如果视区宽度大于360px, 则显示340px。</p>
<h2 id="说一下-web-worker"><a href="#说一下-web-worker" class="headerlink" title="说一下 web worker"></a>说一下 web worker</h2><p>在 HTML 页面中，如果在执行脚本时，页面的状态是不可相应的，直到脚本执行完成后，页面才变成可相应。web worker 是运行在后台的 js，独立于其他脚本，不会影响页面的性能。 并且通过 postMessage 将结果回传到主线程。这样在进行复杂操作的时候，就不会阻塞主线程了。</p>
<p>web worker特点：<br>（1）同源限制</p>
<p>分配给 Worker 线程运行的脚本文件，必须与主线程的脚本文件同源。</p>
<p>（2）DOM 限制</p>
<p>Worker 线程所在的全局对象，与主线程不一样，无法读取主线程所在网页的 DOM 对象，也无法使用document、window、parent这些对象。但是，Worker 线程可以navigator对象和location对象。</p>
<p>（3）通信联系</p>
<p>Worker 线程和主线程不在同一个上下文环境，它们不能直接通信，必须通过消息完成。</p>
<p>（4）脚本限制</p>
<p>Worker 线程不能执行alert()方法和confirm()方法，但可以使用 XMLHttpRequest 对象发出 AJAX 请求。</p>
<p>（5）文件限制</p>
<p>Worker 线程无法读取本地文件，即不能打开本机的文件系统（file://），它所加载的脚本，必须来自网络。</p>
<p>如何创建 web worker：</p>
<ol>
<li>检测浏览器对于 web worker 的支持性</li>
<li>创建 web worker 文件（js，回传函数等）</li>
<li>创建 web worker 对象</li>
</ol>
<h2 id="HTML5的离线储存怎么使用，它的工作原理是什么"><a href="#HTML5的离线储存怎么使用，它的工作原理是什么" class="headerlink" title="HTML5的离线储存怎么使用，它的工作原理是什么"></a>HTML5的离线储存怎么使用，它的工作原理是什么</h2><p>离线存储指的是：在用户没有与因特网连接时，可以正常访问站点或应用，在用户与因特网连接时，更新用户机器上的缓存文件。<br><strong>原理：</strong>HTML5的离线存储是基于一个新建的 .appcache 文件的缓存机制(不是存储技术)，通过这个文件上的解析清单离线存储资源，这些资源就会像cookie一样被存储了下来。之后当网络在处于离线状态下时，浏览器会通过被离线存储的数据进行页面展示<br>使用方法：<br>（1）创建一个和 html 同名的 manifest 文件，然后在页面头部加入 manifest 属性：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;html lang=&quot;en&quot; manifest=&quot;index.manifest&quot;&gt;</span><br></pre></td></tr></table></figure>
<p>（2）在 cache.manifest 文件中编写需要离线存储的资源：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CACHE MANIFEST</span><br><span class="line">    #v0.11</span><br><span class="line">    CACHE:</span><br><span class="line">    js/app.js</span><br><span class="line">    css/style.css</span><br><span class="line">    NETWORK:</span><br><span class="line">    resourse/logo.png</span><br><span class="line">    FALLBACK:</span><br><span class="line">    / /offline.html</span><br></pre></td></tr></table></figure>

<ol>
<li>CACHE: 表示需要离线存储的资源列表，由于包含 manifest 文件的页面将被自动离线存储，所以不需要把页面自身也列出来。</li>
<li>NETWORK: 表示在它下面列出来的资源只有在在线的情况下才能访问，他们不会被离线存储，所以在离线情况下无法使用这些资源。不过，如果在 CACHE 和 NETWORK 中有一个相同的资源，那么这个资源还是会被离线存储，也就是说 CACHE 的优先级更高。<br>FALLBACK: 表示如果访问第一个资源失败，那么就使用第二个资源来替换他，比如上面这个文件表示的就是如果访问根目录下任何一个资源失败了，那么就去访问 offline.html 。</li>
</ol>
<p>（3）在离线状态时，操作 window.applicationCache 进行离线缓存的操作。<br>如何更新缓存：<br>（1）更新 manifest 文件<br>（2）通过 javascript 操作<br>（3）清除浏览器缓存<br>注意事项：<br>（1）浏览器对缓存数据的容量限制可能不太一样（某些浏览器设置的限制是每个站点 5MB）。<br>（2）如果 manifest 文件，或者内部列举的某一个文件不能正常下载，整个更新过程都将失败，浏览器继续全部使用老的缓存。<br>（3）引用 manifest 的 html 必须与 manifest 文件同源，在同一个域下。<br>（4）FALLBACK 中的资源必须和 manifest 文件同源。<br>（5）当一个资源被缓存后，该浏览器直接请求这个绝对路径也会访问缓存中的资源。<br>（6）站点中的其他页面即使没有设置 manifest 属性，请求的资源如果在缓存中也从缓存中访问。<br>（7）当 manifest 文件发生改变时，资源请求本身也会触发更新。</p>
<h2 id="浏览器是如何对-HTML5-的离线储存资源进行管理和加载？"><a href="#浏览器是如何对-HTML5-的离线储存资源进行管理和加载？" class="headerlink" title="浏览器是如何对 HTML5 的离线储存资源进行管理和加载？"></a>浏览器是如何对 HTML5 的离线储存资源进行管理和加载？</h2><ol>
<li>在线的情况下，浏览器发现 html 头部有 manifest 属性，它会请求 manifest 文件，如果是第一次访问页面 ，那么浏览器就会根据 manifest 文件的内容下载相应的资源并且进行离线存储。如果已经访问过页面并且资源已经进行离线存储了，那么浏览器就会使用离线的资源加载页面，然后浏览器会对比新的 manifest 文件与旧的 manifest 文件，如果文件没有发生改变，就不做任何操作，如果文件改变了，就会重新下载文件中的资源并进行离线存储。</li>
<li>离线的情况下，浏览器会直接使用离线存储的资源。</li>
</ol>
<h2 id="title与h1的区别、b与strong的区别、i与em的区别？"><a href="#title与h1的区别、b与strong的区别、i与em的区别？" class="headerlink" title="title与h1的区别、b与strong的区别、i与em的区别？"></a>title与h1的区别、b与strong的区别、i与em的区别？</h2><ol>
<li>strong标签有语义，是起到加重语气的效果，而b标签是没有的，b标签只是一个简单加粗标签。b标签之间的字符都设为粗体，strong标签加强字符的语气都是通过粗体来实现的，而搜索引擎更侧重strong标签。</li>
<li>title属性没有明确意义只表示是个标题，H1则表示层次明确的标题，对页面信息的抓取有很大的影响</li>
<li>i内容展示为斜体，em表示强调的文本</li>
</ol>
<h2 id="iframe-有那些优点和缺点？"><a href="#iframe-有那些优点和缺点？" class="headerlink" title="iframe 有那些优点和缺点？"></a>iframe 有那些优点和缺点？</h2><p>iframe 元素会创建包含另外一个文档的内联框架（即行内框架）。<br>优点：</p>
<ol>
<li>用来加载速度较慢的内容（如广告）</li>
<li>可以使脚本可以并行下载</li>
<li>可以实现跨子域通信</li>
</ol>
<p>缺点：</p>
<ol>
<li>iframe 会阻塞主页面的 onload 事件</li>
<li>无法被一些搜索引擎索识别</li>
<li>会产生很多页面，不容易管理</li>
</ol>
<h2 id="页面可见性（Page-Visibility）API-可以有哪些用途"><a href="#页面可见性（Page-Visibility）API-可以有哪些用途" class="headerlink" title="页面可见性（Page Visibility）API 可以有哪些用途"></a>页面可见性（Page Visibility）API 可以有哪些用途</h2><p>在页面被切换到其他后台进程的时候，自动暂停音乐或视频的播放。</p>
<h2 id="script标签为什么要放在body标签的底部，【defer-async】"><a href="#script标签为什么要放在body标签的底部，【defer-async】" class="headerlink" title="script标签为什么要放在body标签的底部，【defer async】"></a>script标签为什么要放在body标签的底部，【defer async】</h2><p>因为浏览器在渲染html的时候，从上到下依次执行，遇到js文件就会停止当前页面的渲染，转而去下载js文件，如果将script标签放在头部，如果文件又很大的情况下，首屏时间就会延长，影响用户体验。<br>解决方法：</p>
<p>将script标签放到body的底部<br>通过defer\async属性将js文件转为异步下载</p>
<p>defer\async的区别<br>首先都是让js文件能够异步下载，不阻塞页面的渲染<br>区别就是defer必须等待整个文档渲染完成后才执行<br>而async在下载完成后，会暂停html的解析，转去执行js</p>
<p>也就是说 下载的处理二者是相同的，主要是执行的时间不同，async执行的时候还是要阻塞html的解析，defer就是安排到最后才执行。 另外如果两个属性同时设置，以async为准。</p>
<h2 id="HTML5的form如何关闭自动完成功能"><a href="#HTML5的form如何关闭自动完成功能" class="headerlink" title="HTML5的form如何关闭自动完成功能"></a>HTML5的form如何关闭自动完成功能</h2><p>给不想要提示的input是设置autocomplete=off即可。</p>
<h2 id="处理兼容问题有两种方式"><a href="#处理兼容问题有两种方式" class="headerlink" title="处理兼容问题有两种方式"></a>处理兼容问题有两种方式</h2><p>IE6/IE7/IE8支持通过document方法产生的标签，利用这一特性让这些浏览器支持HTML5新标签；<br>使用是html5shim框架 另外，DOCTYPE声明的方式是区分HTML和HTML5标志的一个重要因素，此外，还可以根据新增的结构，功能元素来加以区分。</p>
<h2 id="说说-title-和-alt-属性"><a href="#说说-title-和-alt-属性" class="headerlink" title="说说 title 和 alt 属性"></a>说说 title 和 alt 属性</h2><ol>
<li>两个属性都是当鼠标滑动到元素上的时候显示。</li>
<li>alt 是 img 的特有属性，是图片内容的等价描述，图片无法正常显示时候的替代文字。</li>
<li>title 属性可以用在除了base，basefont，head，html，meta，param，script和title 之外的所有标签，是对dom元素的一种类似注释说明。</li>
</ol>
<h2 id="div-css的布局较table布局有什么优点"><a href="#div-css的布局较table布局有什么优点" class="headerlink" title="div+css的布局较table布局有什么优点"></a>div+css的布局较table布局有什么优点</h2><ol>
<li>改版的时候更方便，只需要修改 css 文件。</li>
<li>页面加载速度更快、结构化清晰、页面显示简洁。</li>
<li>表现与结构相分离。</li>
<li>易于优化 seo ，搜索引擎更友好，排名更容易靠前。</li>
</ol>
<h2 id="label-的作用是什么？如何使用？"><a href="#label-的作用是什么？如何使用？" class="headerlink" title="label 的作用是什么？如何使用？"></a>label 的作用是什么？如何使用？</h2><p>label标签来定义表单控件的关系：当用户选择label标签时，浏览器会自动将焦点转到和label标签相关的表单控件上。</p>
<p>使用方法1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;label for=&quot;mobile&quot;&gt;Number:&lt;/label&gt;</span><br><span class="line">&lt;input type=&quot;text&quot; id=&quot;mobile&quot;/&gt;</span><br></pre></td></tr></table></figure>

<p>使用方法2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&lt;label&gt;Date:&lt;input type=&quot;text&quot;/&gt;&lt;/label&gt;</span><br></pre></td></tr></table></figure>

<h2 id="Canvas和SVG的区别"><a href="#Canvas和SVG的区别" class="headerlink" title="Canvas和SVG的区别"></a>Canvas和SVG的区别</h2><p>（1）SVG：<br>SVG可缩放矢量图形（Scalable Vector Graphics）是基于可扩展标记语言XML描述的2D图形的语言，SVG基于XML就意味着SVG DOM中的每个元素都是可用的，可以为某个元素附加Javascript事件处理器。在 SVG 中，每个被绘制的图形均被视为对象。如果 SVG 对象的属性发生变化，那么浏览器能够自动重现图形。<br>其特点如下：</p>
<ol>
<li>不依赖分辨率</li>
<li>支持事件处理器</li>
<li>最适合带有大型渲染区域的应用程序（比如谷歌地图）</li>
<li>复杂度高会减慢渲染速度（任何过度使用 DOM 的应用都不快）</li>
<li>不适合游戏应用</li>
</ol>
<p>（2）Canvas：<br>Canvas是画布，通过Javascript来绘制2D图形，是逐像素进行渲染的。其位置发生改变，就会重新进行绘制。<br>其特点如下：</p>
<ol>
<li>依赖分辨率</li>
<li>不支持事件处理器</li>
<li>弱的文本渲染能力</li>
<li>能够以 .png 或 .jpg 格式保存结果图像</li>
<li>最适合图像密集型的游戏，其中的许多对象会被频繁重绘</li>
</ol>
<p>注：矢量图，也称为面向对象的图像或绘图图像，在数学上定义为一系列由线连接的点。矢量文件中的图形元素称为对象。每个对象都是一个自成一体的实体，它具有颜色、形状、轮廓、大小和屏幕位置等属性。</p>
<h2 id="head-标签有什么作用，其中什么标签必不可少？"><a href="#head-标签有什么作用，其中什么标签必不可少？" class="headerlink" title="head 标签有什么作用，其中什么标签必不可少？"></a>head 标签有什么作用，其中什么标签必不可少？</h2><p> 标签用于定义文档的头部，它是所有头部元素的容器。 中的元素可以引用脚本、指示浏览器在哪里找到样式表、提供元信息等。<br>文档的头部描述了文档的各种属性和信息，包括文档的标题、在 Web 中的位置以及和其他文档的关系等。绝大多数文档头部包含的数据都不会真正作为内容显示给读者。<br>下面这些标签可用在 head 部分：base, link, meta, script, style, title。<br>其中 title 定义文档的标题，它是 head 部分中唯一必需的元素。</p>
<h2 id="文档声明（Doctype）和-lt-Doctype-html-gt-有何作用-严格模式与混杂模式如何区分？它们有何意义"><a href="#文档声明（Doctype）和-lt-Doctype-html-gt-有何作用-严格模式与混杂模式如何区分？它们有何意义" class="headerlink" title="文档声明（Doctype）和&lt;!Doctype html&gt;有何作用? 严格模式与混杂模式如何区分？它们有何意义?"></a>文档声明（Doctype）和&lt;!Doctype html&gt;有何作用? 严格模式与混杂模式如何区分？它们有何意义?</h2><p>文档声明的作用： 文档声明是为了告诉浏览器，当前HTML文档使用什么版本的HTML来写的，这样浏览器才能按照声明的版本来正确的解析。<br>作用：&lt;!Doctype html&gt; 的作用就是让浏览器进入标准模式，使用最新的 HTML5 标准来解析渲染页面；如果不写，浏览器就会进入混杂模式，我们需要避免此类情况发生。<br>严格模式与混杂模式的区分：</p>
<ol>
<li>严格模式： 又称为标准模式，指浏览器按照W3C标准解析代码；</li>
<li>混杂模式： 又称怪异模式、兼容模式，是指浏览器用自己的方式解析代码。混杂模式通常模拟老式浏览器的行为，以防止老站点无法工作；</li>
</ol>
<p>区分：网页中的DTD，直接影响到使用的是严格模式还是浏览模式，可以说DTD的使用与这两种方式的区别息息相关。</p>
<ol>
<li>如果文档包含严格的DOCTYPE ，那么它一般以严格模式呈现（严格 DTD ——严格模式）；<br>包含过渡 DTD 和 URI 的 DOCTYPE ，也以严格模式呈现，但有过渡 DTD 而没有 URI （统一资源标识符，就是声明最后的地址）会导致页面以混杂模式呈现（有 URI 的过渡 DTD ——严格模式；没有 URI 的过渡 DTD ——混杂模式）；</li>
<li>DOCTYPE 不存在或形式不正确会导致文档以混杂模式呈现（DTD不存在或者格式不正确——混杂模式）；</li>
<li>HTML5 没有 DTD ，因此也就没有严格模式与混杂模式的区别，HTML5 有相对宽松的 法，实现时，已经尽可能大的实现了向后兼容(HTML5 没有严格和混杂之分)。</li>
</ol>
<p>总之，严格模式让各个浏览器统一执行一套规范兼容模式保证了旧网站的正常运行。</p>
<h2 id="几种Doctype文档类型"><a href="#几种Doctype文档类型" class="headerlink" title="几种Doctype文档类型"></a>几种Doctype文档类型</h2><p>标签可声明三种 DTD 类型，分别表示严格版本、过渡版本以及基于框架的 HTML 文档。</p>
<ol>
<li>HTML 4.01 规定了三种文档类型：分别是Strict、Transitional 以及 Frameset；</li>
<li>XHTML 1.0 规定了三种 XML 文档类型：分别是Strict、Transitional 以及 Frameset；</li>
<li>Standards （标准）模式（也就是严格呈现模式）用于呈现遵循最新标准的网页；</li>
<li>Quirks（包容）模式（也就是松散呈现模式或者兼容模式）用于呈现为传统浏览器而设计的网页。</li>
</ol>
<h2 id="Quirks模式是什么？它和Standards模式有什么区别？"><a href="#Quirks模式是什么？它和Standards模式有什么区别？" class="headerlink" title="Quirks模式是什么？它和Standards模式有什么区别？"></a>Quirks模式是什么？它和Standards模式有什么区别？</h2><p>Quirks模式<br>Quirks模式，又称怪癖模式、诡异模式、怪异模式。<br>Quirks和Standards模式的区别<br>当我们在写程序时，遇到新旧功能不兼容的时候，如何做才能保证原来的接口不变，又可以提供强大的功能？<br>一般情况下可以通过增加参数和分支来解决。也就是当某个参数为true时，使用新功能，为false时使用旧功能，这样就能不破坏原有的程序，又能提供新功能。<br>IE6也是类似这样做的，它将DTD当成了这个“参数”，因为以前的页面大家都不会去写DTD，第一IE6就假定，如果写了DTD就意味这个页面将采用对CSS支持更好的布局，而如果没有就采用兼容之前的布局方式，这就是Quirks模式（怪癖，诡异，怪异模式）。<br>其与Standards的区别总体会有布局、样式解析、和脚本执行三个方面的区别：</p>
<ol>
<li>盒模型：在W3C标准中，如果设置一个元素的宽度和高度，指的是元素内容的宽度和高度，而在Quirks 模式下，IE的宽度和高度还包含了padding和border；</li>
<li>设置行内元素的高宽：在Standards模式下，给等行内元素设置wdith和height都不会生效，而在2.quirks模式下，则会生效；</li>
<li>设置百分比的高度：在standards模式下，一个元素的高度是由其包含的内容来决定的，如果父元素没有设置百分比的高度，子元素设置一个百分比的高度是无效的用；</li>
<li>设置水平居中：使用margin:0 auto在standards模式下可以使元素水平居中，但在quirks模式下却会失效。</li>
</ol>
<h2 id="什么是前端的结构，样式和行为相分离？以及分离的好处是什么？"><a href="#什么是前端的结构，样式和行为相分离？以及分离的好处是什么？" class="headerlink" title="什么是前端的结构，样式和行为相分离？以及分离的好处是什么？"></a>什么是前端的结构，样式和行为相分离？以及分离的好处是什么？</h2><p>结构，样式和行为分离<br>小编的理解是： 若是将前端比作一个人来举例子，结构（HTML）就相当于是人体的“骨架”，样式就相当于人体的“装饰”，例如衣服，首饰等；行为就相当于人做出的一系列“动作”。<br>在结构，样式和行为分离，就是将三者分离开，各自负责各自的内容，各部分可以通过引用进行使用。<br>在分离的基础上，我们需要做到代码的：精简， 重用， 有序。<br>分离的好处</p>
<ol>
<li>代码分离，利于团队的开发和后期的维护；</li>
<li>减少维护成本，提高可读性和更好的兼容性；</li>
</ol>
<h2 id="如何对网站的文件和资源进行优化"><a href="#如何对网站的文件和资源进行优化" class="headerlink" title="如何对网站的文件和资源进行优化"></a>如何对网站的文件和资源进行优化</h2><ol>
<li>文件合并（目的是减少http请求）；</li>
<li>文件压缩 （目的是直接减少文件下载的体积）；</li>
<li>使用缓存；</li>
<li>使用cdn托管资源；</li>
<li>gizp压缩需要的js和css文件；</li>
<li>反向链接，网站外链接优化；</li>
<li>meta标签优化（title, description, keywords）,heading标签的优化,alt优化；</li>
</ol>
<h2 id="Html5中datalist是什么"><a href="#Html5中datalist是什么" class="headerlink" title="Html5中datalist是什么"></a>Html5中datalist是什么</h2><p>datalist标签，用来定义选项列表，与input元素配合使用该元素，来定义input可能的值。</p>
<p>datalist及其选项不会被显示出来，他仅仅是合法的输入列表值。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;input id=&quot;fruits&quot; list=&quot;fruit&quot; /&gt;</span><br><span class="line">&lt;datalist id=&quot;fruit&quot;&gt;</span><br><span class="line">    &lt;option value=&quot;apple&quot;&gt;</span><br><span class="line">    &lt;option value=&quot;orange&quot;&gt;</span><br><span class="line">    &lt;option value=&quot;banana&quot;&gt;</span><br><span class="line">&lt;/datalist&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="LocalStorage本地存储在HTML5中有什么用途"><a href="#LocalStorage本地存储在HTML5中有什么用途" class="headerlink" title="LocalStorage本地存储在HTML5中有什么用途"></a>LocalStorage本地存储在HTML5中有什么用途</h2><p>localStorage本地存储相当于一个轻量级的数据库，可以在本地永久的储存数据（除非人为删除）。此外，还可以在断网情况下读取本地缓存的cookies。</p>
<ol>
<li>使用localStorage保存数据： localStorage.setItem(key, value);</li>
<li>使用localStorage获取保存的数据: localStorage.getItem(key);</li>
<li>清除localStorage保存的数据： localStorage.removeItem(key);</li>
<li>清除全部localStorage对象保存的数据: localStorage.clear( );</li>
</ol>
<h2 id="新的HTML5文档类型和字符集是什么"><a href="#新的HTML5文档类型和字符集是什么" class="headerlink" title="新的HTML5文档类型和字符集是什么"></a>新的HTML5文档类型和字符集是什么</h2><p>HTML5文档类型：&lt;!doctype html&gt;<br>字符集：HTML5使用的编码&lt;meta charset=”UTF-8”&gt;</p>
<h2 id="为什么HTML5里面我们不需要DTD"><a href="#为什么HTML5里面我们不需要DTD" class="headerlink" title="为什么HTML5里面我们不需要DTD"></a>为什么HTML5里面我们不需要DTD</h2><p>HTML5没有使用SGML或者XHTML，HTML5是一个全新的东西，因此不需要参考DTD，对于HTML5，仅需放置下面的文档类型代码告诉浏览器识别这是HTML5文档就行。</p>
<h2 id="自身对网页标准和标准制定机构重要性有何理解"><a href="#自身对网页标准和标准制定机构重要性有何理解" class="headerlink" title="自身对网页标准和标准制定机构重要性有何理解"></a>自身对网页标准和标准制定机构重要性有何理解</h2><p>网页标准和标准制定机构是让web更加规范，更加标准，健康的发展所必不可少的东西。</p>
<p>于开发者而言： 开发者可以遵循统一的开发标准，大大降低了开发难度，开发成本，从而也提高了代码的可阅读性以及易于后期维护；<br>于SEO而言： 对SEO更加友好，提升了搜索效率。</p>
<p>使用网页标准和标准制定机构，对于提高网站的易用性起着非常大的作用。</p>
<h2 id="对于web标准以及w3c有何理解与认识"><a href="#对于web标准以及w3c有何理解与认识" class="headerlink" title="对于web标准以及w3c有何理解与认识"></a>对于web标准以及w3c有何理解与认识</h2><p>于WEB而言：web标准简单来说可以分为结构、表现和行为。web标准一般是将该三部分独立分开，使其更具有模块化。但一般产生行为时，就会有结构或者表现的变化，也使这三者的界限并不那么清晰；<br>于W3C而言： W3C对web标准提出了规范化的要求，也就是在实际编程中的一些代码规范，如下：<br>结构上的要求：</p>
<ol>
<li>标签必须闭合、标签小写、不乱嵌套，可以提高搜索机器人对网页内容的搜索几率；</li>
</ol>
<p>对于css和js来说：</p>
<ol>
<li>建议使用外链css和js脚本，从而达到结构与行为、结构与表现的分离，提高页面的渲染速度，能更快地显示页面的内容；</li>
<li>样式与标签的分离，更合理的语义化标签，使内容能被更多的用户所访问、内容能被更广泛的设备所访问、更少的代码和组件， 从而降低维护成本、改版更方便；</li>
<li>不需要变动页面内容，便可提供打印版本而不需要复制内容，提高网站易用性；</li>
</ol>
<p>总之，遵循w3c制定的web标准，能够使用户浏览者更方便的阅读，使网页开发者之间更好的交流。</p>
<h2 id="Html5应用程序缓存和HTML浏览器缓存有什么区别"><a href="#Html5应用程序缓存和HTML浏览器缓存有什么区别" class="headerlink" title="Html5应用程序缓存和HTML浏览器缓存有什么区别"></a>Html5应用程序缓存和HTML浏览器缓存有什么区别</h2><p>新的HTML5规范的应用缓存最关键的就是支持离线应用，允许浏览器在链接客户端时预取一些或全部网站资产，如HTML文件，图像，CSS以及JS等，预取文件加速了站点的性能。换句话说，应用程序缓存可以预取完全未被访问的页面，从而在常规的浏览器缓存中不可用。与传统的浏览器缓存比较，该特性并不强制要求用户访问网站。</p>
<h2 id="HTML元素如何体现其嵌套关系"><a href="#HTML元素如何体现其嵌套关系" class="headerlink" title="HTML元素如何体现其嵌套关系"></a>HTML元素如何体现其嵌套关系</h2><ol>
<li>块级元素可以包含行内元素；</li>
<li>块级元素不一定能包含块级元素；</li>
<li>行内元素一般不能包含块级元素（a元素例外）</li>
</ol>
<h2 id="property和attribute的区别是什么"><a href="#property和attribute的区别是什么" class="headerlink" title="property和attribute的区别是什么"></a>property和attribute的区别是什么</h2><p>property是DOM中的属性，是JavaScript里的对象;<br>attribute是HTML标签上的特性，它的值只能够是字符串;</p>
<p>简单的理解就是：Attribute就是DOM节点自带的属性，例如html中常用的id、class、title、align等；而Property是这个DOM元素作为对象，其附加的内容，例如childNodes、firstChild等。</p>
<h2 id="form-作用"><a href="#form-作用" class="headerlink" title="form 作用"></a>form 作用</h2><ol>
<li>直接提交表单</li>
<li>使用 submit / reset 按钮</li>
<li>便于浏览器保存表单</li>
<li>第三方库可以整体取值</li>
<li>第三方库可以进行表单验证</li>
</ol>
<h2 id="请描述一下-cookies，sessionStorage-和-localStorage-的区别？"><a href="#请描述一下-cookies，sessionStorage-和-localStorage-的区别？" class="headerlink" title="请描述一下 cookies，sessionStorage 和 localStorage 的区别？"></a>请描述一下 cookies，sessionStorage 和 localStorage 的区别？</h2><ol>
<li>cookie 是网站为了标示用户身份而储存在用户本地终端（Client Side）上的数据（通常经过加密）</li>
<li>cookie 数据始终在同源的 http 请求中携带（即使不需要），记会在浏览器和服务器间来回传递。</li>
<li>sessionStorage 和 localStorage 不会自动把数据发给服务器，仅在本地保存。</li>
<li>存储大小：<br>· cookie 数据大小不能超过 4k。<br>·sessionStorage 和 localStorage 虽然也有存储大小的限制，但比 cookie 大得多，可以达到 5M 或更大。</li>
<li>有效期（生命周期）：<br>· localStorage: 存储持久数据，浏览器关闭后数据不丢失除非主动删除数据；<br>· sessionStorage: 数据在当前浏览器窗口关闭后自动删除。<br>· cookie: 设置的 cookie 过期时间之前一直有效，即使窗口或浏览器关闭</li>
<li>共享<br>· sessionStorage 不能共享，localStorage 在同源文档之间共享，cookie 在同源且符合 path 规则的文档之间共享</li>
</ol>
<h2 id="浏览器乱码的原因是什么？如何解决？"><a href="#浏览器乱码的原因是什么？如何解决？" class="headerlink" title="浏览器乱码的原因是什么？如何解决？"></a>浏览器乱码的原因是什么？如何解决？</h2><p>产生乱码的原因：</p>
<ol>
<li>网页源代码是gbk的编码，而内容中的中文字是utf-8编码的，这样浏览器打开即会出现html乱码，反之也会出现乱码；</li>
<li>html网页编码是gbk，而程序从数据库中调出呈现是utf-8编码的内容也会造成编码乱码；</li>
<li>浏览器不能自动检测网页编码，造成网页乱码。</li>
</ol>
<p>解决办法：</p>
<ol>
<li>使用软件编辑HTML网页内容；</li>
<li>如果网页设置编码是gbk，而数据库储存数据编码格式是UTF-8，此时需要程序查询数据库数据显示数据前进程序转码；</li>
<li>如果浏览器浏览时候出现网页乱码，在浏览器中找到转换编码的菜单进行转换。</li>
</ol>
<h2 id="渐进增强和优雅降级之间的区别"><a href="#渐进增强和优雅降级之间的区别" class="headerlink" title="渐进增强和优雅降级之间的区别"></a>渐进增强和优雅降级之间的区别</h2><p>（1）渐进增强（progressive enhancement）：主要是针对低版本的浏览器进行页面重构，保证基本的功能情况下，再针对高级浏览器进行效果、交互等方面的改进和追加功能，以达到更好的用户体验。<br>（2）优雅降级 graceful degradation： 一开始就构建完整的功能，然后再针对低版本的浏览器进行兼容。<br>两者区别：</p>
<ol>
<li>优雅降级是从复杂的现状开始的，并试图减少用户体验的供给；而渐进增强是从一个非常基础的，能够起作用的版本开始的，并在此基础上不断扩充，以适应未来环境的需要；</li>
<li>降级（功能衰竭）意味着往回看，而渐进增强则意味着往前看，同时保证其根基处于安全地带。</li>
</ol>
<p>“优雅降级”观点认为应该针对那些最高级、最完善的浏览器来设计网站。而将那些被认为“过时”或有功能缺失的浏览器下的测试工作安排在开发周期的最后阶段，并把测试对象限定为主流浏览器（如 IE、Mozilla 等）的前一个版本。 在这种设计范例下，旧版的浏览器被认为仅能提供“简陋却无妨 (poor, but passable)” 的浏览体验。可以做一些小的调整来适应某个特定的浏览器。但由于它们并非我们所关注的焦点，因此除了修复较大的错误之外，其它的差异将被直接忽略。<br>“渐进增强”观点则认为应关注于内容本身。内容是建立网站的诱因，有的网站展示它，有的则收集它，有的寻求，有的操作，还有的网站甚至会包含以上的种种，但相同点是它们全都涉及到内容。这使得“渐进增强”成为一种更为合理的设计范例。这也是它立即被 Yahoo 所采纳并用以构建其“分级式浏览器支持 (Graded Browser Support)”策略的原因所在。</p>
<h2 id="说一下-HTML5-drag-API"><a href="#说一下-HTML5-drag-API" class="headerlink" title="说一下 HTML5 drag API"></a>说一下 HTML5 drag API</h2><ol>
<li>dragstart：事件主体是被拖放元素，在开始拖放被拖放元素时触发。</li>
<li>darg：事件主体是被拖放元素，在正在拖放被拖放元素时触发。</li>
<li>dragenter：事件主体是目标元素，在被拖放元素进入某元素时触发。</li>
<li>dragover：事件主体是目标元素，在被拖放在某元素内移动时触发。</li>
<li>dragleave：事件主体是目标元素，在被拖放元素移出目标元素是触发。</li>
<li>drop：事件主体是目标元素，在目标元素完全接受被拖放元素时触发。</li>
<li>dragend：事件主体是被拖放元素，在整个拖放操作结束时触发。</li>
</ol>
<h2 id="table的作用以及其优缺点"><a href="#table的作用以及其优缺点" class="headerlink" title="table的作用以及其优缺点"></a>table的作用以及其优缺点</h2><p>作用</p>
<p>可用于布局（已过时）；<br>用于显示批量数据；</p>
<p>优点<br>在某些场合，使用Table是100%的适合、恰当和正确。比如，用table做表格是完全正确的<br>缺点</p>
<ol>
<li>Table要比其它html标记占更多的字节，会导致延迟下载时间，占用服务器更多的流量资源；</li>
<li>Table会阻挡浏览器渲染引擎的渲染顺序，这会导致延迟页面的生成速度，让用户等待更久的时间；</li>
<li>灵活性差，比如要通多td才能设置tr的border属性；</li>
<li>代码臃肿，当在table中套用table的时候，阅读代码会显得异常混乱；</li>
<li>混乱的colspan与rowspan，用来布局时，频繁使用他们会造成整个文档顺序混乱；</li>
<li>深层的嵌套，导致搜索引擎读取困难，同时还很大程度上增加了代码冗余；<br>不够语义。</li>
</ol>
<h2 id="HTML-中的-input-标签有哪些-type"><a href="#HTML-中的-input-标签有哪些-type" class="headerlink" title="HTML 中的 input 标签有哪些 type"></a>HTML 中的 input 标签有哪些 type</h2><h3 id="button"><a href="#button" class="headerlink" title="button"></a>button</h3><p>没有默认行为的按钮，上面显示 value 属性的值，默认为空。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;input type=&quot;button&quot; name=&quot;button&quot; /&gt;</span><br></pre></td></tr></table></figure>
<h3 id="checkbox"><a href="#checkbox" class="headerlink" title="checkbox"></a>checkbox</h3><p>复选框，可设为选中或未选中。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;input type=&quot;checkbox&quot; name=&quot;checkbox&quot; /&gt;</span><br></pre></td></tr></table></figure>
<h3 id="color"><a href="#color" class="headerlink" title="color"></a>color</h3><p>用于指定颜色的控件；在支持的浏览器中，激活时会打开取色器。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;input type=&quot;color&quot; name=&quot;color&quot; /&gt;</span><br></pre></td></tr></table></figure>
<h3 id="date"><a href="#date" class="headerlink" title="date"></a>date</h3><p>输入日期的控件（年、月、日，不包括时间）。在支持的浏览器激活时打开日期选择器或年月日的数字滚轮。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;input type=&quot;date&quot; name=&quot;date&quot; /&gt;</span><br></pre></td></tr></table></figure>
<h3 id="datetime-local"><a href="#datetime-local" class="headerlink" title="datetime-local"></a>datetime-local</h3><p>输入日期和时间的控件，不包括时区。在支持的浏览器激活时打开日期选择器或年月日的数字滚轮。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;input type=&quot;datetime-local&quot; name=&quot;datetime-local&quot; /&gt;</span><br></pre></td></tr></table></figure>
<h3 id="email"><a href="#email" class="headerlink" title="email"></a>email</h3><p>编辑邮箱地址的区域。类似  text  输入，但在支持的浏览器和带有动态键盘的设备上会有确认参数和相应的键盘。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;input type=&quot;email&quot; name=&quot;email&quot; /&gt;</span><br></pre></td></tr></table></figure>
<h3 id="file"><a href="#file" class="headerlink" title="file"></a>file</h3><p>让用户选择文件的控件。使用 accept 属性规定控件能选择的文件类型。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;input type=&quot;file&quot; accept=&quot;image/*, text/*&quot; name=&quot;file&quot; /&gt;</span><br></pre></td></tr></table></figure>
<h3 id="hidden"><a href="#hidden" class="headerlink" title="hidden"></a>hidden</h3><p>不显示的控件，其值仍会提交到服务器。举个例子，右边就是一个隐形的控件。</p>
<h3 id="image"><a href="#image" class="headerlink" title="image"></a>image</h3><p>带图像的  submit 按钮。显示的图像由 src  属性规定。如果 src 缺失，alt 属性就会显示。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;input type=&quot;image&quot; name=&quot;image&quot; src=&quot;&quot; alt=&quot;image input&quot; /&gt;</span><br></pre></td></tr></table></figure>
<h3 id="month"><a href="#month" class="headerlink" title="month"></a>month</h3><p>输入年和月的控件，没有时区。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;input type=&quot;month&quot; name=&quot;month&quot; /&gt;</span><br></pre></td></tr></table></figure>
<h3 id="number"><a href="#number" class="headerlink" title="number"></a>number</h3><p>用于输入数字的控件。如果支持的话，会显示滚动按钮并提供缺省验证（即只能输入数字）。拥有动态键盘的设备上会显示数字键盘。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;input type=&quot;number&quot; name=&quot;number&quot; /&gt;</span><br></pre></td></tr></table></figure>
<h3 id="password"><a href="#password" class="headerlink" title="password"></a>password</h3><p>单行的文本区域，其值会被遮盖。如果站点不安全，会警告用户。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;input type=&quot;password&quot; name=&quot;password&quot; /&gt;</span><br></pre></td></tr></table></figure>
<h3 id="radio"><a href="#radio" class="headerlink" title="radio"></a>radio</h3><p>单选按钮，允许在多个拥有相同 name 值的选项中选中其中一个。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;input type=&quot;radio&quot; name=&quot;radio&quot; /&gt;</span><br></pre></td></tr></table></figure>
<h3 id="range"><a href="#range" class="headerlink" title="range"></a>range</h3><p>此控件用于输入不需要精确的数字。控件是一个范围组件，默认值为正中间的值。同时使用 htmlattrdefmin    和 htmlattrdefmax 来规定值的范围。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;input type=&quot;range&quot; name=&quot;range&quot; min=&quot;0&quot; max=&quot;25&quot; /&gt;</span><br></pre></td></tr></table></figure>
<h3 id="reset"><a href="#reset" class="headerlink" title="reset"></a>reset</h3><p>此按钮将表单的所有内容重置为默认值。不推荐。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;input type=&quot;reset&quot; name=&quot;reset&quot; /&gt;</span><br></pre></td></tr></table></figure>
<h3 id="search"><a href="#search" class="headerlink" title="search"></a>search</h3><p>用于搜索字符串的单行文字区域。输入文本中的换行会被自动去除。在支持的浏览器中可能有一个删除按钮，用于清除整个区域。拥有动态键盘的设备上的回车图标会变成搜索图标。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;input type=&quot;search&quot; name=&quot;search&quot; /&gt;</span><br></pre></td></tr></table></figure>
<h3 id="submit"><a href="#submit" class="headerlink" title="submit"></a>submit</h3><p>用于提交表单的按钮。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;input type=&quot;submit&quot; name=&quot;submit&quot; /&gt;</span><br></pre></td></tr></table></figure>
<h3 id="tel"><a href="#tel" class="headerlink" title="tel"></a>tel</h3><p>用于输入电话号码的控件。拥有动态键盘的设备上会显示电话数字键盘。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;input type=&quot;tel&quot; name=&quot;tel&quot; /&gt;</span><br></pre></td></tr></table></figure>
<h3 id="text"><a href="#text" class="headerlink" title="text"></a>text</h3><p>默认值。单行的文本区域，输入中的换行会被自动去除。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;input type=&quot;text&quot; name=&quot;text&quot; /&gt;</span><br></pre></td></tr></table></figure>
<h3 id="time"><a href="#time" class="headerlink" title="time"></a>time</h3><p>用于输入时间的控件，不包括时区。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;input type=&quot;time&quot; name=&quot;time&quot; /&gt;</span><br></pre></td></tr></table></figure>
<h3 id="url"><a href="#url" class="headerlink" title="url"></a>url</h3><p>用于输入 URL 的控件。类似 text  输入，但有验证参数，在支持动态键盘的设备上有相应的键盘。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;input type=&quot;url&quot; name=&quot;url&quot; /&gt;</span><br></pre></td></tr></table></figure>
<h3 id="week"><a href="#week" class="headerlink" title="week"></a>week</h3><p>用于输入以年和周数组成的日期，不带时区。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;input type=&quot;week&quot; name=&quot;week&quot; /&gt;</span><br></pre></td></tr></table></figure>
<h3 id="什么是-Data-URL"><a href="#什么是-Data-URL" class="headerlink" title="什么是 Data URL"></a>什么是 Data URL</h3><p>Data URL 是将图片转换为 base64 直接嵌入到了网页中，使用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;img src=&quot;data:[MIME type];base64&quot;/&gt;</span><br></pre></td></tr></table></figure>
<p>这种方式引用图片，不需要再发请求获取图片。 使用 Data URL 也有一些缺点：</p>
<ol>
<li>base64 编码后的图片会比原来的体积大三分之一左右。</li>
<li>Data URL 形式的图片不会缓存下来，每次访问页面都要被下载一次。可以将 Data URL 写入到 CSS 文件中随着 CSS 被缓存下来。</li>
</ol>
<h2 id="你做的页面在哪些流览器测试过？这些浏览器的内核分别是什么"><a href="#你做的页面在哪些流览器测试过？这些浏览器的内核分别是什么" class="headerlink" title="你做的页面在哪些流览器测试过？这些浏览器的内核分别是什么?"></a>你做的页面在哪些流览器测试过？这些浏览器的内核分别是什么?</h2><ol>
<li>IE: trident内核</li>
<li>Firefox：gecko内核</li>
<li>Safari:webkit内核</li>
<li>Opera:以前是presto内核，Opera现已改用GoogleChrome的Blink内核</li>
<li>Chrome:Blink(基于webkit，Google与Opera Software共同开发)</li>
</ol>
<h2 id="介绍一下你对浏览器内核的理解？"><a href="#介绍一下你对浏览器内核的理解？" class="headerlink" title="介绍一下你对浏览器内核的理解？"></a>介绍一下你对浏览器内核的理解？</h2><p>主要分成两部分：渲染引擎(layout engineer或Rendering Engine)和JS引擎<br>渲染引擎：负责取得网页的内容（HTML、XML、图像等等）、整理讯息（例如加入CSS等），以及计算网页的显示方式，然后会输出至显示器或打印机。浏览器的内核的不同对于网页的语法解释会有不同，所以渲染的效果也不相同。所有网页浏览器</p>
<h2 id="渲染优化"><a href="#渲染优化" class="headerlink" title="渲染优化"></a>渲染优化</h2><ol>
<li>使用CSS3代码代替JS动画（尽可能避免重绘重排以及回流）</li>
<li>页面中空的href和 src会阻塞页面其他资源的加载 (阻塞下载进程)</li>
<li>用innerHTML代替DOM操作，减少DOM操作次数，优化javascript性能</li>
<li>当需要设置的样式很多时设置className而不是直接操作style</li>
<li>少用全局变量、缓存DOM节点查找的结果。减少IO读取操作</li>
<li>图片预加载，将样式表放在顶部，将脚本放在底部 加上时间戳</li>
</ol>
<h2 id="如何进行网站性能优化"><a href="#如何进行网站性能优化" class="headerlink" title="如何进行网站性能优化"></a>如何进行网站性能优化</h2><p>1、减少HTTP请求：合并文件、CSS精灵、inline Image<br>2、将样式表放到页面顶部<br>3、不使用CSS表达式<br>4、使用link不使用@import<br>5、将脚本放到页面底部<br>6、将javascript和css从外部引入<br>7、压缩javascript和css</p>
<h3 id="什么是-HTML-的实体编码-HTML-Entity-Encode"><a href="#什么是-HTML-的实体编码-HTML-Entity-Encode" class="headerlink" title="什么是 HTML 的实体编码 (HTML Entity Encode)"></a>什么是 HTML 的实体编码 (HTML Entity Encode)</h3><p>HTML 实体是一段以连字号（&amp;）开头、以分号（;）结尾的字符串。用以显示不可见字符及保留字符 (如 HTML 标签)</p>
<p>在前端，一般为了避免 XSS 攻击，会将 &lt;&gt; 编码为 &lt; 与 &gt;，这些就是 HTML 实体编码。</p>
<p>在 whatwg (opens new window)中可查看实体编码数据。</p>
<p>在 HTML 转义时，仅仅只需要对六个字符进行编码: &amp;, &lt;, &gt;, “, ‘, ```。可使用 he (opens new window)这个库进行编码及转义</p>
<ol>
<li>不可分的空格:＆nbsp;</li>
<li>&lt;(小于符号):＆lt;</li>
<li>(大于符号):＆gt;</li>
<li>＆(与符号):＆amp;</li>
<li>″(双引号):＆quot;</li>
<li>‘(单引号):’＆apos;</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 实体编码</span><br><span class="line">&gt; he.encode(&#x27;&lt;img src=&quot;&quot;&gt;&lt;/img&gt;&#x27;)</span><br><span class="line">&lt; &quot;&amp;#x3C;img src=&amp;#x22;&amp;#x22;&amp;#x3E;&amp;#x3C;/img&amp;#x3E;&quot;</span><br><span class="line"></span><br><span class="line">// 转义</span><br><span class="line">&gt; he.escape(&#x27;&lt;img src=&quot;&quot;&gt;&lt;/img&gt;&#x27;)</span><br><span class="line">&lt; &quot;&amp;lt;img src=&amp;quot;&amp;quot;&amp;gt;&amp;lt;/img&amp;gt;&quot;</span><br></pre></td></tr></table></figure>
<h2 id="input和textarea的区别"><a href="#input和textarea的区别" class="headerlink" title="input和textarea的区别"></a>input和textarea的区别</h2><p>input是单行文本框，不会换行。<br>通过size属性指定显示字符的长度，注意：当使用css限定了宽高，那么size属性就不再起作用。<br>value属性指定初始值，Maxlength属性指定文本框可以输入的最长长度。<br>可以通过width和height设置宽高，但是也不会增加行数。<br>textarea是多行文本输入框，文本区中可容纳无限数量的文本，无value属性，其中的文本的默认字体是等宽字体（通常是Courier） ，可以通 过 cols 和 rows 属性来规定 textarea 的尺寸，不过更好的办法是使用 CSS 的 height 和 width 属性。</p>
<h2 id="用一个div模拟textarea的实现"><a href="#用一个div模拟textarea的实现" class="headerlink" title="用一个div模拟textarea的实现"></a>用一个div模拟textarea的实现</h2><p>作为多行文本域功能来讲，textarea满足了我们大部分的需求。然而，textarea有一个不足就是不能像普通div标签一样高度可以跟随内容自适应。textarea总是很自信地显摆它的滚动条，高度固执地岿然不动。</p>
<p>要解决这个问题很简单，一个普通的block元素上加个contenteditable=”true”就ok了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div contenteditable=&quot;true&quot;&gt;&lt;/div&gt; </span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">	&lt;style&gt;</span><br><span class="line">		.textarea&#123;</span><br><span class="line">			min-height: 100px;</span><br><span class="line">			border: 1px solid #a0b3d6; </span><br><span class="line">			width: 300px;</span><br><span class="line">			font-size: 14px;</span><br><span class="line">			max-height: 300px;</span><br><span class="line">			overflow-y: auto;</span><br><span class="line">		&#125;</span><br><span class="line">	&lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">	&lt;!--用div模拟textarea--&gt;</span><br><span class="line">	&lt;div class=&quot;textarea&quot; contenteditable=&quot;true&quot;&gt;</span><br><span class="line">		</span><br><span class="line">	&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure>
<p>给div设置了一个最小高度，当超过最小高度但不超过最大高度时，div的高度根据文本自适应，当超过最大高度时，出现滚动条。</p>
<h2 id="textarea-如何禁止拉伸"><a href="#textarea-如何禁止拉伸" class="headerlink" title="textarea 如何禁止拉伸"></a>textarea 如何禁止拉伸</h2><p>使用 CSS 样式可以避免拉伸</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">textarea &#123;</span><br><span class="line">  resize: none;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="移动设备忽略将页面中的数字识别为电话号码的方法"><a href="#移动设备忽略将页面中的数字识别为电话号码的方法" class="headerlink" title="移动设备忽略将页面中的数字识别为电话号码的方法"></a>移动设备忽略将页面中的数字识别为电话号码的方法</h2><p>在做移动端l的web开发的时候； IOS 上的Safari总会把长串数字识别为电话号码，文字变成蓝色，点击还会弹出菜单添加到通讯录。<br>解决方法：<br>只要加上 ：<br> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;meta name = &quot;format-detection&quot; content = &quot;telephone=no&quot;&gt;  </span><br></pre></td></tr></table></figure><br>meta标签中format-detection翻译成中文的意思是“格式检测”，是用来检测html里的文本格式的，还包括：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;meta name=&quot;format-detection&quot; content=&quot;telephone=no&quot;&gt;  //禁止把数字转化为拨号链接</span><br><span class="line">&lt;meta name=&quot;format-detection&quot; content=&quot;email=no&quot;&gt;  //禁止邮箱,禁止发送邮件</span><br><span class="line">&lt;meta name=&quot;format-detection&quot; content=&quot;adress=no&quot;&gt;  //禁止地址跳转至地图</span><br><span class="line">&lt;meta name=&quot;format-detection&quot; content=&quot;telephone=no,email=no,adress=no&quot;&gt;  //合并写法</span><br></pre></td></tr></table></figure>
<h2 id="在-Canvas-中如何处理跨域的图片"><a href="#在-Canvas-中如何处理跨域的图片" class="headerlink" title="在 Canvas 中如何处理跨域的图片"></a>在 Canvas 中如何处理跨域的图片</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">img.setAttribute(&quot;crossOrigin&quot;, &quot;anonymous&quot;);</span><br></pre></td></tr></table></figure>

<h2 id="什么是-URL-编码-URL-Encode"><a href="#什么是-URL-编码-URL-Encode" class="headerlink" title="什么是 URL 编码 (URL Encode)"></a>什么是 URL 编码 (URL Encode)</h2><ol>
<li><p>encodeURI 用来编码URI，其不会编码保留字符：;,/?😡&amp;=+$</p>
</li>
<li><p>encodeURIComponent 用来编码 URI参数，除了字符：A-Z a-z 0-9 - _ . ! ~ * ‘ ( )，都将会转义</p>
</li>
</ol>
<h2 id="head-元素"><a href="#head-元素" class="headerlink" title="head 元素"></a>head 元素</h2><p>head 子元素大概分为三类，分别是：</p>
<ol>
<li>描述网页基本信息的</li>
<li>指向渲染网页需要其他文件链接的</li>
<li>各大厂商根据自己需要定制的</li>
</ol>
<h2 id="网页基本信息"><a href="#网页基本信息" class="headerlink" title="网页基本信息"></a>网页基本信息</h2><p>一个网页，首先得有个标题，就跟人有名字一样。除此之外，还可以根据实际需要补充一些基本信息。</p>
<ol>
<li>文档标题（浏览器标签中显示的文本）：深入了解 head 元素</li>
<li>编码格式： 如果你的页面出现乱码，那一般就是编码格式不对</li>
<li>视窗设置：</li>
<li>搜索引擎优化相关内容： </li>
<li>IE 浏览器版本渲染设置</li>
</ol>
<h2 id="厂商定制"><a href="#厂商定制" class="headerlink" title="厂商定制"></a>厂商定制</h2><p>同样分享页面到 QQ 的聊天窗口，有些页面直接就是一个链接，但是有些页面有标题，图片，还有文字介绍。为什么区别这么明显呢？其实就是看有没有设置下面这三个内容</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;meta itemprop=&quot;name&quot; content=&quot;这是分享的标题&quot; /&gt;</span><br><span class="line">&lt;meta</span><br><span class="line">  itemprop=&quot;image&quot;</span><br><span class="line">  content=&quot;http://imgcache.qq.com/qqshow/ac/v4/global/logo.png&quot;</span><br><span class="line">/&gt;</span><br><span class="line">&lt;meta name=&quot;description&quot; itemprop=&quot;description&quot; content=&quot;这是要分享的内容&quot; /&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="300-毫秒点击延迟问题"><a href="#300-毫秒点击延迟问题" class="headerlink" title="300 毫秒点击延迟问题"></a>300 毫秒点击延迟问题</h2><ol>
<li>原因<br>移动端浏览器会有一些默认的行为，比如双击缩放、双击滚动，尤其是双击缩放，这也是300 毫秒延迟的主要原因。</li>
<li>解决反感<br>方案一：禁用缩放(不推荐)<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;meta name=&quot;viewport&quot; content=&quot;user-scalable=no&quot;&gt;</span><br><span class="line">&lt;meta name=&quot;viewport&quot; content=&quot;initial-scale=1,maximum-scale=1&quot;&gt;</span><br></pre></td></tr></table></figure>
方案二：更改默认的视口宽度(不推荐)<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width&quot;&gt;</span><br></pre></td></tr></table></figure>
方案三：CSS touch-action(不推荐)<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">touch-action: none</span><br></pre></td></tr></table></figure>
方案四：FastClick（推荐）<br>FastClick的实现原理是在检测到touchend事件的时候，会通过DOM自定义事件立即出发模拟一个click事件，并把浏览器在300ms之后的click事件阻止掉。<br>在移动端开发中，某些机型上使用 click 事件会延迟 300ms 才执行，这样影响了用户体验。 解决方法： 引入fastclick.js。<h1 id="html深入"><a href="#html深入" class="headerlink" title="html深入"></a>html深入</h1><h2 id="网站开发中，如何实现图片的懒加载"><a href="#网站开发中，如何实现图片的懒加载" class="headerlink" title="网站开发中，如何实现图片的懒加载"></a>网站开发中，如何实现图片的懒加载</h2></li>
</ol>
<p>懒加载，顾名思义，在当前网页，滑动页面到能看到图片的时候再加载图片</p>
<p>故问题拆分成两个：</p>
<ol>
<li>如何判断图片出现在了当前视口 （即如何判断我们能够看到图片）</li>
<li>如何控制图片的加载</li>
</ol>
<h3 id="方案一-位置计算-滚动事件-Scroll-DataSet-API"><a href="#方案一-位置计算-滚动事件-Scroll-DataSet-API" class="headerlink" title="方案一: 位置计算 + 滚动事件 (Scroll) + DataSet API"></a>方案一: 位置计算 + 滚动事件 (Scroll) + DataSet API</h3><h4 id="如何判断图片出现在了当前视口"><a href="#如何判断图片出现在了当前视口" class="headerlink" title="如何判断图片出现在了当前视口"></a>如何判断图片出现在了当前视口</h4><p>clientTop，offsetTop，clientHeight 以及 scrollTop 各种关于图片的高度作比对</p>
<p>这些高度都代表了什么意思？</p>
<p>这我以前有可能是知道的，那时候我比较单纯，喜欢死磕。我现在想通了，背不过的东西就不要背了</p>
<p>所以它有一个问题：复杂琐碎不好理解！</p>
<p>仅仅知道它静态的高度还不够，我们还需要知道动态的</p>
<p>如何动态？监听 window.scroll 事件</p>
<h4 id="如何控制图片的加载"><a href="#如何控制图片的加载" class="headerlink" title="如何控制图片的加载"></a>如何控制图片的加载</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;img data-src=&quot;shanyue.jpg&quot; /&gt;</span><br></pre></td></tr></table></figure>
<p>首先设置一个临时 Data 属性 data-src，控制加载时使用 src 代替 data-src，可利用 DataSet API 实现</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">img.src = img.datset.src</span><br></pre></td></tr></table></figure>

<h3 id="方案二-getBoundingClientRect-API-Scroll-with-Throttle-DataSet-API"><a href="#方案二-getBoundingClientRect-API-Scroll-with-Throttle-DataSet-API" class="headerlink" title="方案二: getBoundingClientRect API + Scroll with Throttle + DataSet API"></a>方案二: getBoundingClientRect API + Scroll with Throttle + DataSet API</h3><p>改进一下</p>
<p>#如何判断图片出现在了当前视口<br>引入一个新的 API， Element.getBoundingClientRect() 方法返回元素的大小及其相对于视口的位置。</p>
<p>那如何</p>
<p>判断图片出现在了当前视口呢，根据示例图示意，代码如下，这个就比较好理解了，就可以很容易地背会(就可以愉快地去面试了)。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// clientHeight 代表当前视口的高度</span><br><span class="line">img.getBoundingClientRect().top &lt; document.documentElement.clientHeight;</span><br></pre></td></tr></table></figure>

<p>监听 window.scroll 事件也优化一下</p>
<p>加个节流器，提高性能。工作中一般使用 lodash.throttle 就可以了，万能的 lodash 啊！</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">_.throttle(func, [(wait = 0)], [(options = &#123;&#125;)]);</span><br></pre></td></tr></table></figure>

<h3 id="方案三-IntersectionObserver-API-DataSet-API"><a href="#方案三-IntersectionObserver-API-DataSet-API" class="headerlink" title="方案三: IntersectionObserver API + DataSet API"></a>方案三: IntersectionObserver API + DataSet API</h3><p>再改进一下</p>
<h4 id="如何判断图片出现在了当前视口-1"><a href="#如何判断图片出现在了当前视口-1" class="headerlink" title="如何判断图片出现在了当前视口"></a>如何判断图片出现在了当前视口</h4><p>方案二使用的方法是: window.scroll 监听 Element.getBoundingClientRect() 并使用 _.throttle 节流</p>
<p>一系列组合动作太复杂了，于是浏览器出了一个三合一事件: IntersectionObserver API，一个能够监听元素是否到了当前视口的事件，一步到位！</p>
<p>事件回调的参数是 IntersectionObserverEntry (opens new window)的集合，代表关于是否在可见视口的一系列值</p>
<p>其中，entry.isIntersecting 代表目标元素可见</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const observer = new IntersectionObserver(changes =&gt; &#123;</span><br><span class="line">  // changes: 目标元素集合</span><br><span class="line">  changes.forEach(change =&gt; &#123;</span><br><span class="line">    // intersectionRatio</span><br><span class="line">    if (change.isIntersecting) &#123;</span><br><span class="line">      const img = change.target;</span><br><span class="line">      img.src = img.dataset.src;</span><br><span class="line">      observer.unobserve(img);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>observer.observe(img);<br>当然，IntersectionObserver 除了给图片做懒加载外，还可以对单页应用资源做预加载。</p>
<p>如在 next.js v9 中，会对视口内的资源做预加载，可以参考 next 9 production optimizations(opens new window)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;Link href=&quot;/about&quot;&gt;</span><br><span class="line">  &lt;a&gt;关于山月&lt;/a&gt;</span><br><span class="line">&lt;/Link&gt;</span><br></pre></td></tr></table></figure>

<h3 id="方案四-LazyLoading-属性"><a href="#方案四-LazyLoading-属性" class="headerlink" title="方案四: LazyLoading 属性"></a>方案四: LazyLoading 属性</h3><p>浏览器觉得懒加载这事可以交给自己做，你们开发者加个属性就好了。实在是…！</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;img src=&quot;shanyue.jpg&quot; loading=&quot;lazy&quot; /&gt;</span><br></pre></td></tr></table></figure>
<p>不过目前浏览器兼容性不太好</p>
<h2 id="浏览器中如何实现剪切板复制内容的功能"><a href="#浏览器中如何实现剪切板复制内容的功能" class="headerlink" title="浏览器中如何实现剪切板复制内容的功能"></a>浏览器中如何实现剪切板复制内容的功能</h2><p>它一般可以使用第三方库 clipboard-copy (opens new window)来实现，源码很简单，可以读一读</p>
<p>目前最为推荐的方式是使用 Clipboard API 进行实现</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">navigator.clipboard.writeText(text);</span><br></pre></td></tr></table></figure>
<p>而对于一些不支持 Clipboard API 的浏览器，使用以下 API 进行复制</p>
<p>选中: Selection API<br>复制: document.execCommand (已被废弃)</p>
<h3 id="选中-Selection-API-Range-API"><a href="#选中-Selection-API-Range-API" class="headerlink" title="选中: Selection API/Range API"></a>选中: Selection API/Range API</h3><p>选中主要利用了 Selection API (opens new window)与 Range API</p>
<p>选中的代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const selection = window.getSelection();</span><br><span class="line">const range = document.createRange();</span><br><span class="line"></span><br><span class="line">// RangeAPI: 制造区域</span><br><span class="line">range.selectNodeContents(element);</span><br><span class="line"></span><br><span class="line">// Selection: 选中区域</span><br><span class="line">selection.addRange(range);</span><br><span class="line"></span><br><span class="line">selectedText = selection.toString();</span><br></pre></td></tr></table></figure>
<p>取消选中的代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">window.getSelection().removeAllRanges();</span><br></pre></td></tr></table></figure>

<h2 id="在浏览器中如何监听剪切板中内容"><a href="#在浏览器中如何监听剪切板中内容" class="headerlink" title="在浏览器中如何监听剪切板中内容"></a>在浏览器中如何监听剪切板中内容</h2><p>通过 Clipboard API 可以获取剪切板中内容，但需要获取到 clipboard-read 的权限，以下是关于读取剪贴板内容的代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 是否能够有读取剪贴板的权限</span><br><span class="line">// result.state == &quot;granted&quot; || result.state == &quot;prompt&quot;</span><br><span class="line">const result = await navigator.permissions.query(&#123; name: &quot;clipboard-read&quot; &#125;);</span><br><span class="line"></span><br><span class="line">// 获取剪贴板内容</span><br><span class="line">const text = await navigator.clipboard.readText();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>它有现成的第三方库可以使用: select.js(opens new window)</p>
<h4 id="复制-execCommand"><a href="#复制-execCommand" class="headerlink" title="复制: execCommand"></a>复制: execCommand</h4><p>复制就比较简单了，execCommand</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">document.execCommand(&quot;copy&quot;);</span><br></pre></td></tr></table></figure>

<h2 id="localhost-3000-与-localhost-5000-的-cookie-信息是否共享"><a href="#localhost-3000-与-localhost-5000-的-cookie-信息是否共享" class="headerlink" title="localhost:3000 与 localhost:5000 的 cookie 信息是否共享"></a>localhost:3000 与 localhost:5000 的 cookie 信息是否共享</h2><p>根据同源策略，cookie 是区分端口的，但是浏览器实现来说，“cookie 区分域，而不区分端口，也就是说，同一个 ip 下的多个端口下的 cookie 是共享的！<br>不考虑 domian 设置 path 默认为/的话</p>
<p><a href="https://xxxx.com/">https://xxxx.com</a> 和<a href="http://xxxx.com/">http://xxxx.com</a> 协议不同其他相同的 cookie 也是共享的</p>
<p>默认 domain 为 localhost path 为/ 存储的 cookie 没有端口信息 共享</p>
<h2 id="什么是-CSRF-攻击"><a href="#什么是-CSRF-攻击" class="headerlink" title="什么是 CSRF 攻击"></a>什么是 CSRF 攻击</h2><p>跨站请求伪造（英语：Cross-site request forgery），也被称为 one-click attack 或者 session riding，通常缩写为 CSRF 或者 XSRF， 是一种挟制用户在当前已登录的 Web 应用程序上执行非本意的操作的攻击方法。跟跨网站脚本（XSS）相比，XSS 利用的是用户对指定网站的信任，CSRF 利用的是网站对用户网页浏览器的信任。</p>
<p>CSRF (Cross-site request forgery)，跨站请求伪造，又称为 one-click attack，顾名思义，通过恶意引导用户一次点击劫持 cookie 进行攻击。</p>
<p>使用 JSON API。当进行 CSRF 攻击时，请求体通过 &lt;form&gt; 构建，请求头为 application/www-form-urlencoded。它难以发送 JSON 数据被服务器所理解。<br>CSRF Token。生成一个随机的 token，切勿放在 cookie 中，每次请求手动携带该 token 进行校验。<br>SameSite Cookie。设置为 Lax 或者 Strict，禁止发送第三方 Cookie。</p>
<h2 id="如何把-json-数据转化为-demo-json-并下载文件"><a href="#如何把-json-数据转化为-demo-json-并下载文件" class="headerlink" title="如何把 json 数据转化为 demo.json 并下载文件"></a>如何把 json 数据转化为 demo.json 并下载文件</h2><p>json 视为字符串，可以利用 DataURL 进行下载</p>
<p>Text -&gt; DataURL</p>
<p>除了使用 DataURL，还可以转化为 Object URL 进行下载</p>
<p>Text -&gt; Blob -&gt; Object URL</p>
<p>可以把以下代码直接粘贴到控制台下载文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">function download(url, name) &#123;</span><br><span class="line">  const a = document.createElement(&quot;a&quot;);</span><br><span class="line">  a.download = name;</span><br><span class="line">  a.rel = &quot;noopener&quot;;</span><br><span class="line">  a.href = url;</span><br><span class="line">  // 触发模拟点击</span><br><span class="line">  a.dispatchEvent(new MouseEvent(&quot;click&quot;));</span><br><span class="line">  // 或者 a.click()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const json = &#123;</span><br><span class="line">  a: 3,</span><br><span class="line">  b: 4,</span><br><span class="line">  c: 5</span><br><span class="line">&#125;;</span><br><span class="line">const str = JSON.stringify(json, null, 2);</span><br><span class="line"></span><br><span class="line">// 方案一：Text -&gt; DataURL</span><br><span class="line">const dataUrl = `data:,$&#123;str&#125;`;</span><br><span class="line">download(dataUrl, &quot;demo.json&quot;);</span><br><span class="line"></span><br><span class="line">// 方案二：Text -&gt; Blob -&gt; ObjectURL</span><br><span class="line">const url = URL.createObjectURL(new Blob(str.split(&quot;&quot;)));</span><br><span class="line">download(url, &quot;demo1.json&quot;);</span><br></pre></td></tr></table></figure>
<p>#总结<br>模拟下载，可以通过新建一个 &lt;a href=”url” download&gt;&lt;a&gt; 标签并设置 url 及 download 属性来下载<br>可以通过把 json 转化为 dataurl 来构造 URL<br>可以通过把 json 转换为 Blob 再转化为 ObjectURL 来构造 URL</p>
<h2 id="简单介绍-requestIdleCallback-及使用场景"><a href="#简单介绍-requestIdleCallback-及使用场景" class="headerlink" title="简单介绍 requestIdleCallback 及使用场景"></a>简单介绍 requestIdleCallback 及使用场景</h2><p>requestIdleCallback 维护一个队列，将在浏览器空闲时间内执行。它属于 Background Tasks API (opens new window)，你可以使用 setTimeout 来模拟实现</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">window.requestIdleCallback =</span><br><span class="line">  window.requestIdleCallback ||</span><br><span class="line">  function(handler) &#123;</span><br><span class="line">    let startTime = Date.now();</span><br><span class="line"></span><br><span class="line">    return setTimeout(function() &#123;</span><br><span class="line">      handler(&#123;</span><br><span class="line">        didTimeout: false,</span><br><span class="line">        timeRemaining: function() &#123;</span><br><span class="line">          return Math.max(0, 50.0 - (Date.now() - startTime));</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;, 1);</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const rIC = window[&quot;requestIdleCallback&quot;] || (f =&gt; setTimeout(f, 1));</span><br></pre></td></tr></table></figure>
<p>在 rIC 中执行任务时需要注意以下几点：</p>
<p>执行重计算而非紧急任务<br>空闲回调执行时间应该小于 50ms，最好更少<br>空闲回调中不要操作 DOM，因为它本来就是利用的重排重绘后的间隙空闲时间，重新操作 DOM 又会造成重排重绘<br>React 的时间分片便是基于类似 rIC 而实现，然而因为 rIC 的兼容性及 50ms 流畅问题，React 自制了一个实现: scheduler(opens new window)</p>
<p>use-swr (opens new window)中进行资源的 revalidate 时，也是通过 rIC 来提高性能</p>
<h2 id="如何计算白屏时间和首屏时间"><a href="#如何计算白屏时间和首屏时间" class="headerlink" title="如何计算白屏时间和首屏时间"></a>如何计算白屏时间和首屏时间</h2><p>白屏时间:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">window.performance.timing.domLoading - window.performance.timing.navigationStart</span><br></pre></td></tr></table></figure>

<p>首屏时间:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">window.performance.timing.domInteractive - window.performace.timing.navigationStart</span><br></pre></td></tr></table></figure>
<h2 id="从浏览器地址栏输入url到显示页面的步骤"><a href="#从浏览器地址栏输入url到显示页面的步骤" class="headerlink" title="从浏览器地址栏输入url到显示页面的步骤"></a>从浏览器地址栏输入url到显示页面的步骤</h2><p>浏览器根据请求的URL交给DNS域名解析，找到真实IP，向服务器发起请求；<br>服务器交给后台处理完成后返回数据，浏览器接收文件（HTML、JS、CSS、图象等）；<br>浏览器对加载到的资源（HTML、JS、CSS等）进行语法解析，建立相应的内部数据结构（如HTML的DOM）；<br>载入解析到的资源文件，渲染页面，完成。</p>
<ol>
<li>为什么url要解析（也就是编码)<br>因为网络标准规定了URL只能使用英文字母、阿拉伯数字和某些标点符号（-_.~ ! * ‘ ( ) ; : @ &amp; = + $ , / ? # [ ]，比较常见的就是不包括百分号和双引号），如果URL中有汉字，就必须编码后使用（一般由应用程序决定），如果不转义会出现歧义，比如http:<a href="http://www.baidu.com/?key=value,%E5%81%87%E5%A6%82%E6%88%91%E7%9A%84key%E6%9C%AC%E8%BA%AB%E5%B0%B1%E5%8C%85%E6%8B%AC%E7%AD%89%E4%BA%8E=%E7%AC%A6%E5%8F%B7%EF%BC%8C%E6%AF%94%E5%A6%82ke=y=value%EF%BC%8C%E5%B0%B1%E4%BC%9A%E5%87%BA%E7%8E%B0%E6%AD%A7%E4%B9%89%EF%BC%8C%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93=%E5%88%B0%E5%BA%95%E6%98%AF%E8%BF%9E%E6%8E%A5key%E5%92%8Cvalue%E7%9A%84%E7%AC%A6%E5%8F%B7%EF%BC%8C%E8%BF%98%E6%98%AF%E8%AF%B4%E6%9C%AC%E8%BA%ABkey%E9%87%8C%E9%9D%A2%E5%B0%B1%E6%9C%89=">www.baidu.com?key=value,假如我的key本身就包括等于=符号，比如ke=y=value，就会出现歧义，你不知道=到底是连接key和value的符号，还是说本身key里面就有=</a></li>
<li>url编码的规则是什么？<br> （1）情况1:网址路径中包含汉字，网址路径的编码，用的是utf-8编码<br> （2）情况2:查询字符串包含汉字，查询字符串的编码，用的是操作系统的默认编码。<br> （3）情况3:Get/Post方法生成的URL包含汉字，GET和POST方法的编码，用的是网页的编码。<br> （4）情况4:Ajax调用的URL包含汉字，，IE总是采用GB2312编码（操作系统的默认编码），而Firefox总是采用utf-8编码，也就是说不通浏览器有不同的编码规则</li>
</ol>
<h2 id="什么是关键渲染路径"><a href="#什么是关键渲染路径" class="headerlink" title="什么是关键渲染路径"></a>什么是关键渲染路径</h2><p>从收到 HTML、CSS 和 JavaScript 字节到对其进行必需的处理，从而将它们转变成渲染的像素这一过程中有一些中间步骤，优化性能其实就是了解这些步骤中发生了什么， 即关键渲染路径</p>
<ol>
<li>创建DOM树(Constructing the DOM Tree)</li>
<li>创建CSSOM树(Constructing the CSSOM Tree)</li>
<li>执行脚本(Running JavaScript)</li>
<li>生成渲染树(Creating the Render Tree)</li>
<li>生成布局(Generating the Layout)</li>
<li>绘制(Painting)</li>
</ol>
<h2 id="什么是重排重绘，如何减少重拍重绘"><a href="#什么是重排重绘，如何减少重拍重绘" class="headerlink" title="什么是重排重绘，如何减少重拍重绘"></a>什么是重排重绘，如何减少重拍重绘</h2><p>重排和重绘是关键渲染路径中的两步，可以参考另一个问题: 什么是关键渲染路径(opens new window)</p>
<p>重排(Reflow)：元素的位置发生变动时发生重排，也叫回流。此时在关键渲染路径中的 Layout 阶段，计算每一个元素在设备视口内的确切位置和大小。当一个元素位置发生变化时，其父元素及其后边的元素位置都可能发生变化，代价极高</p>
<p>重绘(Repaint): 元素的样式发生变动，但是位置没有改变。此时在关键渲染路径中的 Paint 阶段，将渲染树中的每个节点转换成屏幕上的实际像素，这一步通常称为绘制或栅格化</p>
<p>另外，重排必定会造成重绘。以下是避免过多重拍重绘的方法</p>
<ol>
<li>使用 DocumentFragment 进行 DOM 操作，不过现在原生操作很少也基本上用不到</li>
<li>CSS 样式尽量批量修改</li>
<li>避免使用 table 布局</li>
<li>为元素提前设置好高宽，不因多次渲染改变位置</li>
</ol>
<h2 id="如何取消请求的发送"><a href="#如何取消请求的发送" class="headerlink" title="如何取消请求的发送"></a>如何取消请求的发送</h2><p>根据发送网络请求的 API 不同，取消方法不同</p>
<p>xhr<br>fetch<br>axios<br>如果使用XMLHttpRequest发送请求可以使用XMLHttpRequest.abort()</p>
<p>如果使用fetch发送请求可以使用AbortController</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const controller = new AbortController();</span><br><span class="line">const signal = controller.signal;</span><br><span class="line">fetch(&#x27;https://somewhere&#x27;, &#123; signal &#125;)</span><br><span class="line">controller.abort()</span><br></pre></td></tr></table></figure>
<p>如果使用axios，取消原理同 fetch</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var CancelToken = axios.CancelToken;</span><br><span class="line">var source = CancelToken.source();</span><br><span class="line"></span><br><span class="line">axios.get(&#x27;/https://somewhere&#x27;, &#123;</span><br><span class="line">  cancelToken: source.token</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">source.cancel()</span><br></pre></td></tr></table></figure>

<p>XHR 使用 xhr.abort()</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const xhr = new XMLHttpRequest(),</span><br><span class="line">  method = &quot;GET&quot;,</span><br><span class="line">  url = &quot;https://developer.mozilla.org/&quot;;</span><br><span class="line">xhr.open(method, url, true);</span><br><span class="line"></span><br><span class="line">xhr.send();</span><br><span class="line"></span><br><span class="line">// 取消发送请求</span><br><span class="line">xhr.abort();</span><br></pre></td></tr></table></figure>

<p>而其中的原理可分为两部分</p>
<p>浏览器端: 基于 XHR，xhr.abort()，见源码axios/lib/adapters/xhr.js(opens new window)<br>Node 端: 基于 http/https/follow-redirects，使用 request.abort()，见源码axios/lib/adapters/http.js</p>
<h2 id="如何实现浏览器内多个标签页之间的通信？"><a href="#如何实现浏览器内多个标签页之间的通信？" class="headerlink" title="如何实现浏览器内多个标签页之间的通信？"></a>如何实现浏览器内多个标签页之间的通信？</h2><h3 id="第一种——调用localStorage"><a href="#第一种——调用localStorage" class="headerlink" title="第一种——调用localStorage"></a>第一种——调用localStorage</h3><p>在一个标签页里面使用 localStorage.setItem(key,value)添加（修改、删除）内容；<br>在另一个标签页里面监听 storage 事件。<br>即可得到 localstorge 存储的值，实现不同标签页之间的通信。</p>
<p>标签页1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;input id=&quot;name&quot;&gt;  </span><br><span class="line">&lt;input type=&quot;button&quot; id=&quot;btn&quot; value=&quot;提交&quot;&gt;  </span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;  </span><br><span class="line">    $(function()&#123;    </span><br><span class="line">        $(&quot;#btn&quot;).click(function()&#123;    </span><br><span class="line">            var name=$(&quot;#name&quot;).val();    </span><br><span class="line">            localStorage.setItem(&quot;name&quot;, name);   </span><br><span class="line">        &#125;);    </span><br><span class="line">    &#125;);    </span><br><span class="line">&lt;/script&gt;  </span><br></pre></td></tr></table></figure>

<p>标签页2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">    $(function()&#123;</span><br><span class="line">        window.addEventListener(&quot;storage&quot;, function(event)&#123;</span><br><span class="line">            console.log(event.key + &quot;=&quot; + event.newValue);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h3 id="第二种——调用cookie-setInterval"><a href="#第二种——调用cookie-setInterval" class="headerlink" title="第二种——调用cookie+setInterval()"></a>第二种——调用cookie+setInterval()</h3><p>将要传递的信息存储在cookie中，每隔一定时间读取cookie信息，即可随时获取要传递的信息。</p>
<p>页面1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;input id=&quot;name&quot;&gt;</span><br><span class="line">&lt;input type=&quot;button&quot; id=&quot;btn&quot; value=&quot;提交&quot;&gt;</span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">    $(function()&#123;</span><br><span class="line">        $(&quot;#btn&quot;).click(function()&#123;</span><br><span class="line">            var name=$(&quot;#name&quot;).val();</span><br><span class="line">            document.cookie=&quot;name=&quot;+name;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>页面2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">    $(function()&#123;</span><br><span class="line">        function getCookie(key) &#123;</span><br><span class="line">            return JSON.parse(&quot;&#123;\&quot;&quot; + document.cookie.replace(/;\s+/gim,&quot;\&quot;,\&quot;&quot;).replace(/=/gim, &quot;\&quot;:\&quot;&quot;) + &quot;\&quot;&#125;&quot;)[key];</span><br><span class="line">        &#125;</span><br><span class="line">        setInterval(function()&#123;</span><br><span class="line">            console.log(&quot;name=&quot; + getCookie(&quot;name&quot;));</span><br><span class="line">        &#125;, 10000);</span><br><span class="line">    &#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h3 id="第三种-websocket通讯"><a href="#第三种-websocket通讯" class="headerlink" title="第三种 websocket通讯"></a>第三种 websocket通讯</h3><h3 id="第四种-html5浏览器的新特性SharedWorker"><a href="#第四种-html5浏览器的新特性SharedWorker" class="headerlink" title="第四种 html5浏览器的新特性SharedWorker"></a>第四种 html5浏览器的新特性SharedWorker</h3><p>普通的webworker直接使用new Worker()即可创建，这种webworker是当前页面专有的。然后还有种共享worker(SharedWorker)，这种是可以多个标签页、iframe共同使用的。</p>
<p>SharedWorker可以被多个window共同使用，但必须保证这些标签页都是同源的(相同的协议，主机和端口号)</p>
<p>首先新建一个js文件worker.js，具体代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// sharedWorker所要用到的js文件，不必打包到项目中，直接放到服务器即可let data = &#x27;&#x27;onconnect = function (e) &#123;  let port = e.ports[0]  port.onmessage = function (e) &#123;    if (e.data === &#x27;get&#x27;) &#123;      port.postMessage(data)    &#125; else &#123;      data = e.data    &#125;  &#125;&#125;</span><br></pre></td></tr></table></figure>

<p>webworker端(暂且这样称呼)的代码就如上，只需注册一个onmessage监听信息的事件，客户端(即使用sharedWorker的标签页)发送message时就会触发。</p>
<p>注意webworker无法在本地使用，出于浏览器本身的安全机制，所以我这次的示例也是放在服务器上的，worker.js和index.html在同一目录。</p>
<p>因为客户端和webworker端的通信不像websocket那样是全双工的，所以客户端发送数据和接收数据要分成两步来处理。示例中会有两个按钮，分别对应的向sharedWorker发送数据的请求以及获取数据的请求，但他们本质上都是相同的事件–发送消息。</p>
<p>webworker端会进行判断，传递的数据为’get’时，就把变量data的值回传给客户端，其他情况，则把客户端传递过来的数据存储到data变量中。下面是客户端的代码：</p>
<p>// 这段代码是必须的，打开页面后注册SharedWorker，显示指定worker.port.start()方法建立与worker间的连接</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (typeof Worker === &quot;undefined&quot;) &#123;</span><br><span class="line"></span><br><span class="line">      alert(&#x27;当前浏览器不支持webworker&#x27;)</span><br><span class="line"></span><br><span class="line">    &#125; else &#123;</span><br><span class="line"></span><br><span class="line">      let worker = new SharedWorker(&#x27;worker.js&#x27;)</span><br><span class="line"></span><br><span class="line">      worker.port.addEventListener(&#x27;message&#x27;, (e) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">        console.log(&#x27;来自worker的数据：&#x27;, e.data)</span><br><span class="line"></span><br><span class="line">      &#125;, false)</span><br><span class="line"></span><br><span class="line">      worker.port.start()</span><br><span class="line"></span><br><span class="line">      window.worker = worker</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>// 获取和发送消息都是调用postMessage方法，我这里约定的是传递’get’表示获取数据。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">window.worker.port.postMessage(&#x27;get&#x27;)</span><br><span class="line"></span><br><span class="line">window.worker.port.postMessage(&#x27;发送信息给worker&#x27;)</span><br></pre></td></tr></table></figure>

<p>页面A发送数据给worker，然后打开页面B，调用window.worker.port.postMessage(‘get’)，即可收到页面A发送给worker的数据。</p>
<h2 id="webSocket如何兼容低浏览器"><a href="#webSocket如何兼容低浏览器" class="headerlink" title="webSocket如何兼容低浏览器"></a>webSocket如何兼容低浏览器</h2><ol>
<li><p>使用轮询或长连接的方式实现伪websocket的通信</p>
</li>
<li><p>使用flash或其他方法实现一个websocket客户端 Adobe Flash Socket；</p>
</li>
<li><p>ActiveX HTMLFile (IE) ；</p>
</li>
<li><p>基于 multipart 编码发送 XHR；</p>
</li>
</ol>
<h2 id="canvas-和-svg-的区别"><a href="#canvas-和-svg-的区别" class="headerlink" title="canvas 和 svg 的区别"></a>canvas 和 svg 的区别</h2><p>canvas 是 html5 提供的新元素，而 svg 存在的历史要比 canvas 久远，已经有十几年了。svg 并不是 html5 专有的标签，最初 svg 是用 xml 技术（超文本扩展语言，可以自定义标签或属性）描述二维图形的语言。在 H5 中看似 canvas 与 svg 很像，但是，他们有巨大的差别。<br>首先，从它们的功能上来讲，canvas 可以看做是一个画布。，其绘制出来的图形为标量图，因此，可以在 canvas 中引入 jpg 或 png 这类格式的图片，在实际开发中，大型的网络游戏都是用 canvas 画布做出来的，并且 canvas 的技术现在已经相当的成熟。另外，我们喜欢用 canvas 来做一些统计用的图表，如柱状图曲线图或饼状图等。 而 svg，所绘制的图形为矢量图，所以其用法上受到了限制。因为只能绘制矢量图，所以 svg 中不能引入普通的图片，因为矢量图的不会失真的效果，在项目中我们会用来做小图标。但是由于其本质为矢量图，可以被无限放大而不会失真，这很适合被用来做地图，而百度地图就是用 svg 技术做出来的。<br>另外从技术发面来讲 canvas 里面绘制的图形不能被引擎抓取，如我们要让 canvas 里面的一个图片跟随鼠标事件: canvas.onmouseover=function(){}。 而 svg 里面的图形可以被引擎抓取，支持事件的绑定。另外 canvas 中我们绘制图形通常是通过 javascript 来实现，svg 更多的是通过标签来来实现，如在 svg 中绘制正矩形形就要用，这里我们不能用属性 style=”width:XXX;height:XXX;”来定义。</p>
]]></content>
      <categories>
        <category>面试</category>
        <category>html</category>
      </categories>
  </entry>
  <entry>
    <title>css面试</title>
    <url>/2021/08/19/css%E9%9D%A2%E8%AF%95/</url>
    <content><![CDATA[<h2 id="介绍一下标准的CSS的盒子模型？与低版本IE的盒子模型有什么不同？"><a href="#介绍一下标准的CSS的盒子模型？与低版本IE的盒子模型有什么不同？" class="headerlink" title="介绍一下标准的CSS的盒子模型？与低版本IE的盒子模型有什么不同？"></a>介绍一下标准的CSS的盒子模型？与低版本IE的盒子模型有什么不同？</h2><p>相关知识点：<br>（1）有两种盒子模型：IE盒模型（border-box）、W3C标准盒模型（content-box）</p>
<p>（2）盒模型：分为内容（content）、填充（padding）、边界（margin）、边框（border）四个部分</p>
<p>IE盒模型和W3C标准盒模型的区别：</p>
<p>（1）W3C标准盒模型：属性width，height只包含内容content，不包含border和padding<br>（2）IE盒模型：属性width，height包含content、border和padding，指的是content +padding+border。</p>
<p>在 IE8+ 浏览器中使用哪个盒模型可以由box-sizing（CSS新增的属性）控制，默认值为content-box，即标准盒模型；</p>
<p>如果将box-sizing设为border-box则用的是IE盒模型。如果在 IE6/7/8中DOCTYPE缺失会将盒子模型解释为IE盒子模型。若在页面中声明了DOCTYPE类型，所有的浏览器都会把盒模型解释为W3C盒模型。</p>
<p>回答：<br>盒模型都是由四个部分组成的，分别是margin、border、padding和content。</p>
<p>标准盒模型和IE盒模型的区别在于设置width和height时，所对应的范围不同。标准盒模型的width和height属性的范围只包含了content，而IE盒模型的width和height属性的范围包含了border、padding和content。</p>
<p>一般来说，我们可以通过修改元素的box-sizing属性来改变元素的盒模型。</p>
<h2 id="box-sizing属性？"><a href="#box-sizing属性？" class="headerlink" title="box-sizing属性？"></a>box-sizing属性？</h2><p>用来控制元素的盒子模型的解析模式，默认为content-box</p>
<p>content-box：w3c标准盒子模型，设置元素的width/height属性指的是content部分的宽高</p>
<p>border-box：IE传统盒子模型。设置元素的height/width属性指的是border+padding+content<br>部分的宽/高</p>
<h2 id="css选择器有哪些？"><a href="#css选择器有哪些？" class="headerlink" title="css选择器有哪些？"></a>css选择器有哪些？</h2><p>（1）id选择器（#myid）</p>
<p>（2）类选择器（.myclassname）</p>
<p>（3）标签选择器（div,h1,p）</p>
<p>（4）后代选择器（h1 p）</p>
<p>（5）相邻后代选择器（子）选择器（ul&gt;li）</p>
<p>（6）兄弟选择器（li~a）</p>
<p>（7）相邻兄弟选择器（li+a）</p>
<p>（8）属性选择器（a[rel=”external”]）</p>
<p>（9）伪类选择器（a:hover,li:nth-child）</p>
<p>（10）伪元素选择器（::before、::after）</p>
<p>（11）通配符选择器（*）</p>
<h2 id="CSS中可继承与不可继承属性有哪些"><a href="#CSS中可继承与不可继承属性有哪些" class="headerlink" title="CSS中可继承与不可继承属性有哪些"></a>CSS中可继承与不可继承属性有哪些</h2><p>一、无继承性的属性</p>
<ol>
<li>display：规定元素应该生成的框的类型</li>
<li>文本属性：<br>· vertical-align：垂直文本对齐<br>· text-decoration：规定添加到文本的装饰<br>· text-shadow：文本阴影效果<br>· white-space：空白符的处理<br>· unicode-bidi：设置文本的方向</li>
<li>盒子模型的属性：width、height、margin、border、padding</li>
<li>背景属性：background、background-color、background-image</li>
<li>background-repeat、background-position、background-attachment<br>定位属性：float、clear、position、top、right、bottom、left、min-width、min-height、max-width、max-height、overflow、clip、z-index</li>
<li>生成内容属性：content、counter-reset、counter-increment</li>
<li>轮廓样式属性：outline-style、outline-width、outline-color、outline</li>
<li>页面样式属性：size、page-break-before、page-break-after</li>
<li>声音样式属性：pause-before、pause-after、pause、cue-before、cue-after、cue、play-during</li>
</ol>
<p>二、有继承性的属性<br>1.字体系列属性<br>font-family：字体系列<br>font-weight：字体的粗细<br>font-size：字体的大小<br>font-style：字体的风格<br>2. 文本系列属性<br>text-indent：文本缩进<br>text-align：文本水平对齐<br>line-height：行高<br>word-spacing：单词之间的间距<br>letter-spacing：中文或者字母之间的间距<br>text-transform：控制文本大小写（就是uppercase、lowercase、capitalize这三个）<br>color：文本颜色<br>3. 元素可见性<br>visibility：控制元素显示隐藏<br>列表布局属性<br>list-style：列表风格，包括list-style-type、list-style-image等<br>光标属性<br>cursor：光标显示为何种形态</p>
<h2 id="关于伪类-LVHA-的解释"><a href="#关于伪类-LVHA-的解释" class="headerlink" title="关于伪类 LVHA 的解释?"></a>关于伪类 LVHA 的解释?</h2><p>a标签有四种状态：链接访问前、链接访问后、鼠标滑过、激活，分别对应四种伪类:link、:visited、:hover、:active；</p>
<p>当链接未访问过时：</p>
<p>（1）当鼠标滑过a链接时，满足:link和:hover两种状态，要改变a标签的颜色，就必须将:hover伪类在:link伪<br>类后面声明；<br>（2）当鼠标点击激活a链接时，同时满足:link、:hover、:active三种状态，要显示a标签激活时的样式（:active），<br>必须将:active声明放到:link和:hover之后。因此得出LVHA这个顺序。</p>
<p>当链接访问过时，情况基本同上，只不过需要将:link换成:visited。</p>
<p>这个顺序能不能变？可以，但也只有:link和:visited可以交换位置，因为一个链接要么访问过要么没访问过，不可能同时满足，<br>也就不存在覆盖的问题。</p>
<h2 id="伪类与伪元素有什么区别"><a href="#伪类与伪元素有什么区别" class="headerlink" title="## 伪类与伪元素有什么区别"></a>## 伪类与伪元素有什么区别</h2><p>css引入伪类和伪元素概念是为了格式化文档树以外的信息。也就是说，伪类和伪元素是用来修饰不在文档树中的部分，比如，一句话中的第一个字母，或者是列表中的第一个元素。</p>
<p>伪类用于当已有的元素处于某个状态时，为其添加对应的样式，这个状态是根据用户行为而动态变化的。比如说，当用户悬停在指定的元素时，我们可以通过:hover来描述这个元素的状态。</p>
<p>伪元素用于创建一些不在文档树中的元素，并为其添加样式。它们允许我们为元素的某些部分设置样式。比如说，我们可以通过::before来在一个元素前增加一些文本，并为这些文本添加样式。虽然用户可以看到这些文本，但是这些文本实际上不在文档树中。</p>
<p>有时你会发现伪元素使用了两个冒号（::）而不是一个冒号（:）。这是CSS3的一部分，并尝试区分伪类和伪元素。大多数浏览器都支持这两个值。按照规则应该使用（::）而不是（:），从而区分伪类和伪元素。但是，由于在旧版本的W3C规范并未对此进行特别区分，因此目前绝大多数的浏览器都支持使用这两种方式表示伪元素。</p>
<h2 id="CSS3-新增伪类有那些？"><a href="#CSS3-新增伪类有那些？" class="headerlink" title="CSS3 新增伪类有那些？"></a>CSS3 新增伪类有那些？</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">（1）elem:nth-child(n)选中父元素下的第n个子元素，并且这个子元素的标签名为elem，n可以接受具体的数</span><br><span class="line">值，也可以接受函数。</span><br><span class="line"></span><br><span class="line">（2）elem:nth-last-child(n)作用同上，不过是从后开始查找。</span><br><span class="line"></span><br><span class="line">（3）elem:last-child选中最后一个子元素。</span><br><span class="line"></span><br><span class="line">（4）elem:only-child如果elem是父元素下唯一的子元素，则选中之。</span><br><span class="line"></span><br><span class="line">（5）elem:nth-of-type(n)选中父元素下第n个elem类型元素，n可以接受具体的数值，也可以接受函数。</span><br><span class="line"></span><br><span class="line">（6）elem:first-of-type选中父元素下第一个elem类型元素。</span><br><span class="line"></span><br><span class="line">（7）elem:last-of-type选中父元素下最后一个elem类型元素。</span><br><span class="line"></span><br><span class="line">（8）elem:only-of-type如果父元素下的子元素只有一个elem类型元素，则选中该元素。</span><br><span class="line"></span><br><span class="line">（9）elem:empty选中不包含子元素和内容的elem类型元素。</span><br><span class="line"></span><br><span class="line">（10）elem:target选择当前活动的elem元素。</span><br><span class="line"></span><br><span class="line">（11）:not(elem)选择非elem元素的每个元素。</span><br><span class="line"></span><br><span class="line">（12）:enabled 控制表单控件的禁用状态。</span><br><span class="line"></span><br><span class="line">（13）:disabled	控制表单控件的禁用状态。</span><br><span class="line"></span><br><span class="line">(14):checked单选框或复选框被选中。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="before-和-after-中双冒号和单冒号有什么区别？解释一下这-2-个伪元素的作用。"><a href="#before-和-after-中双冒号和单冒号有什么区别？解释一下这-2-个伪元素的作用。" class="headerlink" title="::before 和:after 中双冒号和单冒号有什么区别？解释一下这 2 个伪元素的作用。"></a>::before 和:after 中双冒号和单冒号有什么区别？解释一下这 2 个伪元素的作用。</h2><p>相关知识点：<br>单冒号（:）用于CSS3伪类，双冒号（::）用于CSS3伪元素。（伪元素由双冒号和伪元素名称组成）双冒号是在当前规范中引入的，用于区分伪类和伪元素。不过浏览器需要同时支持旧的已经存在的伪元素写法，比如:first-line、:first-letter、:before、:after等，而新的在CSS3中引入的伪元素则不允许再支持旧的单冒号的写法。</p>
<p>想让插入的内容出现在其它内容前，使用::before，否者，使用::after；<br>在代码顺序上，::after生成的内容也比::before生成的内容靠后。如果按堆栈视角，::after生成的内容会在::before生成的内容之上。</p>
<p>回答：<br>在css3中使用单冒号来表示伪类，用双冒号来表示伪元素。但是为了兼容已有的伪元素的写法，在一些浏览器中也可以使用单冒号来表示伪元素。</p>
<p>伪类一般匹配的是元素的一些特殊状态，如hover、link等，而伪元素一般匹配的特殊的位置，比如after、before等。</p>
<h2 id="css优先级算法如何计算"><a href="#css优先级算法如何计算" class="headerlink" title="css优先级算法如何计算"></a>css优先级算法如何计算</h2><p>相关知识点：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CSS的优先级是根据样式声明的特殊性值来判断的。</span><br><span class="line"></span><br><span class="line">选择器的特殊性值分为四个等级，如下：</span><br><span class="line"></span><br><span class="line">（1）标签内选择符x,0,0,0</span><br><span class="line">（2）ID选择符0,x,0,0</span><br><span class="line">（3）class选择符/属性选择符/伪类选择符	0,0,x,0</span><br><span class="line">（4）元素和伪元素选择符0,0,0,x</span><br><span class="line"></span><br><span class="line">计算方法：</span><br><span class="line"></span><br><span class="line">（1）每个等级的初始值为0</span><br><span class="line">（2）每个等级的叠加为选择器出现的次数相加</span><br><span class="line">（3）不可进位，比如0,99,99,99</span><br><span class="line">（4）依次表示为：0,0,0,0</span><br><span class="line">（5）每个等级计数之间没关联</span><br><span class="line">（6）等级判断从左向右，如果某一位数值相同，则判断下一位数值</span><br><span class="line">（7）如果两个优先级相同，则最后出现的优先级高，!important也适用</span><br><span class="line">（8）通配符选择器的特殊性值为：0,0,0,0</span><br><span class="line">（9）继承样式优先级最低，通配符样式优先级高于继承样式</span><br><span class="line">（10）!important（权重），它没有特殊性值，但它的优先级是最高的，为了方便记忆，可以认为它的特殊性值为1,0,0,0,0。</span><br><span class="line"></span><br><span class="line">计算实例：</span><br><span class="line"></span><br><span class="line">（1）#demo a&#123;color: orange;&#125;/*特殊性值：0,1,0,1*/</span><br><span class="line">（2）div#demo a&#123;color: red;&#125;/*特殊性值：0,1,0,2*/</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">注意：</span><br><span class="line">（1）样式应用时，css会先查看规则的权重（!important），加了权重的优先级最高，当权重相同的时候，会比较规则的特殊性。</span><br><span class="line"></span><br><span class="line">（2）特殊性值越大的声明优先级越高。</span><br><span class="line"></span><br><span class="line">（3）相同特殊性值的声明，根据样式引入的顺序，后声明的规则优先级高（距离元素出现最近的）</span><br><span class="line"></span><br><span class="line"> (4) 部分浏览器由于字节溢出问题出现的进位表现不做考虑</span><br></pre></td></tr></table></figure>

<p>判断优先级时，首先我们会判断一条属性声明是否有权重，也就是是否在声明后面加上了!important。一条声明如果加上了权重，<br>那么它的优先级就是最高的，前提是它之后不再出现相同权重的声明。如果权重相同，我们则需要去比较匹配规则的特殊性。一条匹配规则一般由多个选择器组成，一条规则的特殊性由组成它的选择器的特殊性累加而成。选择器的特殊性可以分为四个等级，第一个等级是行内样式，为1000，第二个等级是id选择器，为0100，第三个等级是类选择器、伪类选择器和属性选择器，为0010，第四个等级是元素选择器和伪元素选择器，为0001。规则中每出现一个选择器，就将它的特殊性进行叠加，这个叠加只限于对应的等级的叠加，不会产生进位。选择器特殊性值的比较是从左向右排序的，也就是说以1开头的特殊性值比所有以0开头的特殊性值要大。比如说特殊性值为1000的的规则优先级就要比特殊性值为0999的规则高。如果两个规则的特殊性值相等的时候，那么就会根据它们引入的顺序，后出现的规则的优先级最高。</p>
<h2 id="如何居中div？如何居中一个浮动元素？如何让绝对定位的div居中？"><a href="#如何居中div？如何居中一个浮动元素？如何让绝对定位的div居中？" class="headerlink" title="如何居中div？如何居中一个浮动元素？如何让绝对定位的div居中？"></a>如何居中div？如何居中一个浮动元素？如何让绝对定位的div居中？</h2><p>div:</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">border</span>: <span class="number">1px</span> solid red;</span><br><span class="line"><span class="attribute">margin</span>:<span class="number">0</span> auto;</span><br><span class="line"><span class="attribute">height</span>:<span class="number">50px</span>;</span><br><span class="line"><span class="attribute">width</span>: <span class="number">50px</span>;</span><br></pre></td></tr></table></figure>

<p>浮动元素的上下左右居中：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">border</span>: <span class="number">1px</span> solid red;</span><br><span class="line"><span class="attribute">float</span>: left;</span><br><span class="line"><span class="attribute">position</span>: absolute;</span><br><span class="line"><span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line"><span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line"><span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line"><span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line"><span class="attribute">margin</span>: -<span class="number">50px</span> <span class="number">0</span> <span class="number">0</span> -<span class="number">100px</span>;</span><br></pre></td></tr></table></figure>

<p>绝对定位的左右居中：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">border</span>: <span class="number">1px</span> solid black;</span><br><span class="line"><span class="attribute">position</span>: absolute;</span><br><span class="line"><span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line"><span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line"><span class="attribute">margin</span>: <span class="number">0</span> auto;</span><br><span class="line"><span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line"><span class="attribute">right</span>: <span class="number">0</span>; </span><br></pre></td></tr></table></figure>

<p>flex居中：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">display</span>: flex;</span><br><span class="line"><span class="attribute">align-items</span>: center;</span><br><span class="line"><span class="attribute">justify-content</span>: center;</span><br></pre></td></tr></table></figure>

<h2 id="display有哪些值？说明他们的作用？"><a href="#display有哪些值？说明他们的作用？" class="headerlink" title="display有哪些值？说明他们的作用？"></a>display有哪些值？说明他们的作用？</h2><p>inline(默认)-内联<br>none-隐藏<br>block-块显示<br>table-表格显示<br>list-item -项目列表<br>inline-block（内联块显示）</p>
<h2 id="position的值？"><a href="#position的值？" class="headerlink" title="position的值？"></a>position的值？</h2><p>static（默认）按照正常文档流进行排列</p>
<p>relative（相对定位）：不脱离文档流，参考自身静态位置通过 top,bottom,left,right定位</p>
<p>absolute（绝对定位）：参考距其最近的一个不为 static的福元素通过top,bottom,left,right定位</p>
<p>fixed（固定定位）：所固定的参照对象是可视窗口</p>
<h2 id="css3新特性？"><a href="#css3新特性？" class="headerlink" title="css3新特性？"></a>css3新特性？</h2><ol>
<li>RGBA和透明度</li>
<li>background-image、background-origin background-size background-repeat</li>
<li>word-wrap(对长的不可分割单词换行) work- wrap:break-word</li>
<li>文字阴影  text-shadom:5px 5px 5px #000(水平阴影，垂直阴影，模糊距离，颜色)</li>
<li>font-face属性：定义自己的字体</li>
<li>圆角 border-radius</li>
<li>边框图片 border-image:url() 30 30 round</li>
<li>盒阴影：box-shadom:10px 10px 5px #000(水平阴影，垂直阴影，模糊距离，颜色)</li>
<li>媒体查询@media</li>
</ol>
<h2 id="请解释一下css3的flexbox（弹性盒布局模型），以及适用场景"><a href="#请解释一下css3的flexbox（弹性盒布局模型），以及适用场景" class="headerlink" title="请解释一下css3的flexbox（弹性盒布局模型），以及适用场景"></a>请解释一下css3的flexbox（弹性盒布局模型），以及适用场景</h2><p>该布局模型的目的是提供一种更加高效的方式来对容器中的条目进行布局、对齐和分配空间。在传统的布局方式中，block 布局是把块在垂直方向从上到下依次排列的；而 inline 布局则是在水平方向来排列。弹性盒布局并没有这样内在的方向限制，可以由开发人员自由操作。试用场景：弹性布局适合于移动前端开发，在Android和ios上也完美支持。</p>
<h2 id="用纯CSS创建一个三角形的原理是什么？"><a href="#用纯CSS创建一个三角形的原理是什么？" class="headerlink" title="用纯CSS创建一个三角形的原理是什么？"></a>用纯CSS创建一个三角形的原理是什么？</h2><p>采用的是均分原理,把矩形分为4等份,这4等份其实都是边框</p>
<p>首先，需要把元素的宽度、高度设为0。然后设置边框样式。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line"><span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line"><span class="attribute">border-top</span>: <span class="number">40px</span> solid transparent;</span><br><span class="line"><span class="attribute">border-left</span>: <span class="number">40px</span> solid transparent;</span><br><span class="line"><span class="attribute">border-right</span>: <span class="number">40px</span> solid transparent;</span><br><span class="line"><span class="attribute">border-bottom</span>: <span class="number">40px</span> solid <span class="number">#ff0000</span>;</span><br></pre></td></tr></table></figure>

<h2 id="一个满屏品字布局如何设计？"><a href="#一个满屏品字布局如何设计？" class="headerlink" title="一个满屏品字布局如何设计？"></a>一个满屏品字布局如何设计？</h2><p>第一种真正的品字：</p>
<ol>
<li>三块高宽是确定的；</li>
<li>上面那块用margin: 0 auto;居中；</li>
<li>下面两块用float或者inline-block不换行；</li>
<li>用margin调整位置使他们居中。</li>
</ol>
<p>第二种全屏的品字布局:上面的div设置成100%，下面的div分别宽50%，然后使用float或者inline使其不换行。</p>
<h2 id="常见的兼容性问题？"><a href="#常见的兼容性问题？" class="headerlink" title="常见的兼容性问题？"></a>常见的兼容性问题？</h2><ol>
<li>不同浏览器的标签默认的margin和padding不一样。*{margin:0;padding:0}</li>
<li>IE6双边距bug:块属性标签float后，又有横行的margin情况下，在IE6显示的margin比较大。解决方案： display：inline；将其转化为行内属性。</li>
<li>渐进识别的方式，从总体中逐渐排出局部。首先，巧妙的使用“9”这一标记，将IE浏览器从所有情况中分离出来。接着，再次使用“+”将IE8和IE7、IE6分离开来，这样IE8已经独立识别。<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attribute">background-color</span>:<span class="number">#f1ee18</span>;<span class="comment">/*所有识别*/</span></span><br><span class="line">    <span class="selector-class">.background-color</span>:<span class="number">#00deff</span>\<span class="number">9</span>; <span class="comment">/*IE6、7、8识别*/</span></span><br><span class="line">    +<span class="attribute">background-color</span>:<span class="number">#a200ff</span>;<span class="comment">/*IE6、7识别*/</span></span><br><span class="line">    _background-<span class="attribute">color</span>:<span class="number">#1e0bd1</span>;<span class="comment">/*IE6识别*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>设置较小高度标签（一般小于10px），在IE6，IE7中高度超出自己设置高度。hack：给超出高度的标签设置overflow：hidden；或者设置行高line- height小于你设置的高度。</li>
<li>IE下，可以使用获取常规属性的方法来获取自定义属性,也可以使用getAttribute()获取自定义属性；Firefox下，只能使用getAttribute()获取自定义属性。解决方法:统一通过getAttribute()获取自定义属性。</li>
<li>Chrome 中文界面下默认会将小于 12px 的文本强制按照 12px 显示,可通过加入 CSS 属性 -webkit-text-size-adjust: none; 解决。</li>
<li>超链接访问过后hover样式就不出现了，被点击访问过的超链接样式不再具有hover和active了。解决方法是改变CSS属性的排列顺序:L-V-H-A ( love hate ): a:link {} a:visited {} a:hover {} a:active {}</li>
</ol>
<h2 id="为什么要初始化CSS样式"><a href="#为什么要初始化CSS样式" class="headerlink" title="为什么要初始化CSS样式"></a>为什么要初始化CSS样式</h2><p>因为浏览器的兼容问题，不同浏览器对有些标签的默认值是不同的，如果没对CSS初始化往往会出现浏览器之间的页面显示差异。</p>
<h2 id="absolute的containing-block计算方式跟正常流有什么不同"><a href="#absolute的containing-block计算方式跟正常流有什么不同" class="headerlink" title="absolute的containing block计算方式跟正常流有什么不同"></a>absolute的containing block计算方式跟正常流有什么不同</h2><p>（1）内联元素也可以作为“包含块”所在的元素；</p>
<p>（2）“包含块”所在的元素不是父块级元素，而是最近的position不为static的祖先元素或根元素；</p>
<p>（3）边界是padding box而不是content box。</p>
<h2 id="CSS里的visibility属性有个collapse属性值？在不同浏览器下有什么区别？"><a href="#CSS里的visibility属性有个collapse属性值？在不同浏览器下有什么区别？" class="headerlink" title="CSS里的visibility属性有个collapse属性值？在不同浏览器下有什么区别？"></a>CSS里的visibility属性有个collapse属性值？在不同浏览器下有什么区别？</h2><p>当一个元素的visibility属性被设置成collapse值后，对于一般的元素，它的表现跟hidden是一样的。但例外的是，如果这个元素是table相关的元素，例如table行，table group，table列，table column group，它的表现却跟display:none一样，也就是说，它们占用的空间也会释放。</p>
<ol>
<li>chrome中，使用collapse值和使用hidden没有区别。</li>
<li>firefox，opera和IE，使用collapse值和使用display：none没有什么区别。</li>
</ol>
<h2 id="display-none与visibility：hidden的区别？"><a href="#display-none与visibility：hidden的区别？" class="headerlink" title="display:none与visibility：hidden的区别？"></a>display:none与visibility：hidden的区别？</h2><p>这两个属性都是让元素隐藏，不可见。两者区别如下：<br>（1）在渲染树中</p>
<p>· display:none会让元素完全从渲染树中消失，渲染时不会占据任何空间；<br>· visibility:hidden不会让元素从渲染树中消失，渲染的元素还会占据相应的空间，只是内容不可见。</p>
<p>（2）是否是继承属性</p>
<p>· display:none是非继承属性，子孙节点会随着父节点从渲染树消失，通过修改子孙节点的属性也无法显示；<br>· visibility:hidden是继承属性，子孙节点消失是由于继承了hidden，通过设置visibility:visible可以让子孙节点显示；</p>
<p>（3）修改常规文档流中元素的 display 通常会造成文档的重排，但是修改visibility属性只会造成本元素的重绘；<br>（4）如果使用读屏器，设置为display:none的内容不会被读取，设置为visibility:hidden的内容会被读取。</p>
<h2 id="对BFC规范-块级格式化上下文：block-formatting-context-的理解？"><a href="#对BFC规范-块级格式化上下文：block-formatting-context-的理解？" class="headerlink" title="对BFC规范(块级格式化上下文：block formatting context)的理解？"></a>对BFC规范(块级格式化上下文：block formatting context)的理解？</h2><p>BFC规定了内部的Block Box如何布局。定位方案：</p>
<ol>
<li>内部的Box会在垂直方向上一个接一个放置。</li>
<li>Box垂直方向的距离由margin决定，属于同一个BFC的两个相邻Box的margin会发生重叠。</li>
<li>每个元素的margin box 的左边，与包含块border box的左边相接触。</li>
<li>BFC的区域不会与float box重叠。</li>
<li>BFC是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。</li>
<li>计算BFC的高度时，浮动元素也会参与计算。</li>
</ol>
<p>满足下列条件之一就可触发BFC:</p>
<ol>
<li>根元素，即html</li>
<li>float的值不为none（默认）</li>
<li>overflow的值不为visible（默认）</li>
<li>display的值为inline-block、table-cell、table-caption</li>
<li>position的值为absolute或fixed</li>
</ol>
<h2 id="为什么会出现浮动和什么时候需要清除浮动？清除浮动的方式？你认为最好的是哪一种？为什么？"><a href="#为什么会出现浮动和什么时候需要清除浮动？清除浮动的方式？你认为最好的是哪一种？为什么？" class="headerlink" title="为什么会出现浮动和什么时候需要清除浮动？清除浮动的方式？你认为最好的是哪一种？为什么？"></a>为什么会出现浮动和什么时候需要清除浮动？清除浮动的方式？你认为最好的是哪一种？为什么？</h2><p>浮动元素碰到包含它的边框或者浮动元素的边框停留。在CSS规范中，浮动定位不属于正常的页面流，而是独立定位的，所以文档流的块框表现得就像浮动框不存在一样。浮动元素会漂浮在文档流的块框上。<br>关于css的定位机制：普通流，浮动，绝对定位（position：fixed是position：absolute的一个子类）。浮动的框可以左右移动，直到它的外边缘遇到包含框或者另一个浮动框的边缘，所以才说浮动定位不属于正常的页面流。文档中的普通流就会表现得和浮动框不存在一样，当浮动框高度超出包含框的时候，就会出现包含框不会自动伸缩高度类笔盒浮动元素。所以，只含有浮动元素的父容器在显示时不需要考虑子元素的位置，就造成显示父容器像空容器一样。</p>
<p>浮动元素会漂浮在文档流的块框上。浮动带来的问题：</p>
<ol>
<li>父元素的高度无法被撑开，影响与父元素同级的元素</li>
<li>与浮动元素同级的非浮动元素（内联元素）会跟随其后</li>
<li>若非第一个元素浮动，则该元素之前的元素也需要浮动，否则会影响页面显示的结构。</li>
</ol>
<p>清除浮动的方式：</p>
<ol>
<li>父级div定义height</li>
<li>最后一个浮动元素后加空div标签 并添加样式clear:both。</li>
<li>包含浮动元素的父标签添加样式overflow为hidden或auto。</li>
<li>父级div定义zoom</li>
</ol>
<p>1<strong>、父级div定义height</strong><br>原理：父级div手动定义height，就解决了父级div无法自动获取到高度的问题<br>优点：简单，代码少，容易掌握<br>缺点：只适合高度固定的布局，要给出精确的高度，如果高度和父级div不一样时，会产生问题<br>建议：不推荐使用，只建议高度固定的布局时使用</p>
<p>2<strong>、结尾处加空 div 标签 clear:both</strong><br>原理：添加一个空div，利用css提高的clear:both清除浮动，让父级div能自动获取到高度<br>优点：简单，代码少，浏览器支持好，不容易出现怪问题<br>缺点：不少初学者不理解原理；如果页面浮动布局多，就要增加很多空div，让人感觉很不爽<br>建议：不推荐使用，但此方法是以前主要使用的一种清除浮动方法</p>
<p>3<strong>、父级 div 定义 overflow:hidden</strong><br>原理：必须定义width或zoom:1，同时不能定义height，使用overflow:hidden时，浏览器会自动检查浮动区域的高度<br>优点：简单，代码少，浏览器支持好<br>缺点：不能和position配合使用，因为超出的尺寸的会被隐藏<br>建议：只推荐没有使用position或对overflow:hidden理解比较深的朋友使用</p>
<p>4<strong>、父级div定义伪类 :after 和 zoom</strong><br>原理：IE8以上和非IE浏览器才支持:after，原理和方法2有点类似，zoom(IE转有属性)可解决ie6,ie7浮动问题<br>优点：浏览器支持好，不容易出现怪问题（目前：大型网站都有使用，如：腾迅，网易，新浪等等）<br>缺点：代码多，不少初学者不理解原理，要两句代码结合使用，才能让主流浏览器都支持<br>建议：推荐使用，建议定义公共类，以减少CSS代码<br>(1) 在子元素后添加一个空div div{clear:both;}<br>(2) 在父元素中{overflow:hidden|auto;zoom:1}<br>(3) :after伪选择符，在父容器的尾部自动创建一个子元素</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.clearfix:after &#123;</span><br><span class="line">    content: &quot;\0020&quot;;display: block;height: 0;clear: both;</span><br><span class="line">&#125;</span><br><span class="line">.clearfix &#123;</span><br><span class="line">    zoom: 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>“clearfix”是父容器的class名称，”content:”020”;”是在父容器的结尾处放一个空白符，<br>“height: 0;”是让这个这个空白字符不显示出来，”display: block; clear: both;”是确保这个空白字符是非浮动的独立区块。:after选择符IE 6不支持,添加一条IE 6的独有命令”zoom:1;”就行了.</p>
<h2 id="zoom-1-的清除浮动原理"><a href="#zoom-1-的清除浮动原理" class="headerlink" title="zoom:1 的清除浮动原理?"></a>zoom:1 的清除浮动原理?</h2><p>清除浮动，触发hasLayout；<br>zoom属性是IE浏览器的专有属性，它可以设置或检索对象的缩放比例。解决ie下比较奇葩的bug。譬如外边距（margin）<br>的重叠，浮动清除，触发ie的haslayout属性等。</p>
<p>来龙去脉大概如下：<br>当设置了zoom的值之后，所设置的元素就会就会扩大或者缩小，高度宽度就会重新计算了，这里一旦改变zoom值时其实也会发<br>生重新渲染，运用这个原理，也就解决了ie下子元素浮动时候父元素不随着自动扩大的问题。</p>
<p>zoom属性是IE浏览器的专有属性，火狐和老版本的webkit核心的浏览器都不支持这个属性。然而，zoom现在已经被逐步标<br>准化，出现在CSS3.0规范草案中。</p>
<p>目前非ie由于不支持这个属性，它们又是通过什么属性来实现元素的缩放呢？可以通过css3里面的动画属性scale进行缩放。</p>
<h2 id="使用-clear-属性清除浮动的原理？"><a href="#使用-clear-属性清除浮动的原理？" class="headerlink" title="使用 clear 属性清除浮动的原理？"></a>使用 clear 属性清除浮动的原理？</h2><p>使用clear属性清除浮动，其语法如下：</p>
<p>clear:none|left|right|both</p>
<p>如果单看字面意思，clear:left应该是“清除左浮动”，clear:right应该是“清除右浮动”的意思，实际上，这种解释是有问<br>题的，因为浮动一直还在，并没有清除。</p>
<p>官方对clear属性的解释是：“元素盒子的边不能和前面的浮动元素相邻。”，我们对元素设置clear属性是为了避免浮动元素<br>对该元素的影响，而不是清除掉浮动。</p>
<p>还需要注意的一点是clear属性指的是元素盒子的边不能和前面的浮动元素相邻，注意这里“前面的”3个字，也就是clear属<br>性对“后面的”浮动元素是不闻不问的。考虑到float属性要么是left，要么是right，不可能同时存在，同时由于clear<br>属性对“后面的”浮动元素不闻不问，因此，当clear:left有效的时候，clear:right必定无效，也就是此时clear:left<br>等同于设置clear:both；同样地，clear:right如果有效也是等同于设置clear:both。由此可见，clear:left和cle<br>ar:right这两个声明就没有任何使用的价值，至少在CSS世界中是如此，直接使用clear:both吧。</p>
<p>一般使用伪元素的方式清除浮动</p>
<p>.clear::after{<br>content:’’;<br>display:table;//也可以是’block’，或者是’list-item’<br>clear:both;<br>}</p>
<p>clear属性只有块级元素才有效的，而::after等伪元素默认都是内联水平，这就是借助伪元素清除浮动影响时需要设置disp<br>lay属性值的原因。</p>
<h2 id="上下margin重合的问题"><a href="#上下margin重合的问题" class="headerlink" title="上下margin重合的问题"></a>上下margin重合的问题</h2><p>在重合元素外包裹一层容器，并触发该容器生成一个BFC。</p>
<p>例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div class=&quot;aside&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;div class=&quot;text&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;main&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;!--下面是css代码--&gt;</span><br><span class="line"> .aside &#123;</span><br><span class="line">            margin-bottom: 100px;  </span><br><span class="line">            width: 100px;</span><br><span class="line">            height: 150px;</span><br><span class="line">            background: #f66;</span><br><span class="line">        &#125;</span><br><span class="line">        .main &#123;</span><br><span class="line">            margin-top: 100px;</span><br><span class="line">            height: 200px;</span><br><span class="line">            background: #fcc;</span><br><span class="line">        &#125;</span><br><span class="line">         .text&#123;</span><br><span class="line">            /*盒子main的外面包一个div，通过改变此div的属性使两个盒子分属于两个不同的BFC，以此来阻止margin重叠*/</span><br><span class="line">            overflow: hidden;  //此时已经触发了BFC属性。</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<h2 id="设置元素浮动后，该元素的display值是多少？"><a href="#设置元素浮动后，该元素的display值是多少？" class="headerlink" title="设置元素浮动后，该元素的display值是多少？"></a>设置元素浮动后，该元素的display值是多少？</h2><p>自动变成display:block</p>
<h2 id="移动端的布局用过媒体查询吗？"><a href="#移动端的布局用过媒体查询吗？" class="headerlink" title="移动端的布局用过媒体查询吗？"></a>移动端的布局用过媒体查询吗？</h2><p>媒体查询由⼀个可选的媒体类型和零个或多个使⽤媒体功能的限制了样式表范围的表达式组成，例如宽度、⾼度和颜⾊。媒体查询，添加⾃CSS3，允许内容的呈现针对⼀个特定范围的输出设备⽽进⾏裁剪，⽽不必改变内容本身，适合web⽹⻚应对不同型号的设备⽽做出对应的响应适配。<br>媒体查询包含⼀个可选的媒体类型和满⾜CSS3规范的条件下，包含零个或多个表达式，这些表达式描述了媒体特征，最终会被解析为true或false。如果媒体查询中指定的媒体类型匹配展示⽂档所使⽤的设备类型，并且所有的表达式的值都是true，那么该媒体查询的结果为true。那么媒体查询内的样式将会⽣效。</p>
<p>通过媒体查询可以为不同大小和尺寸的媒体定义不同的css，适应相应的设备的显示。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. &lt;head&gt;里边&lt;link rel=”stylesheet” type=”text/css” href=”xxx.css” media=”only screen and (max-device-width:480px)”&gt;</span><br><span class="line"></span><br><span class="line">2. CSS : @media only screen and (max-device-width:480px) &#123;/css样式/&#125;</span><br></pre></td></tr></table></figure>

<h2 id="使用-CSS-预处理器吗？"><a href="#使用-CSS-预处理器吗？" class="headerlink" title="使用 CSS 预处理器吗？"></a>使用 CSS 预处理器吗？</h2><p>Less sass</p>
<h2 id="CSS优化、提高性能的方法有哪些？"><a href="#CSS优化、提高性能的方法有哪些？" class="headerlink" title="CSS优化、提高性能的方法有哪些？"></a>CSS优化、提高性能的方法有哪些？</h2><p>加载性能：</p>
<p>（1）css压缩：将写好的css进行打包压缩，可以减少很多的体积。<br>（2）css单一样式：当需要下边距和左边距的时候，很多时候选择:margin:top 0 bottom 0;但margin-bottom:bottom;margin-left:left;执行的效率更高。<br>（3）减少使用@import,而建议使用link，因为后者在页面加载时一起加载，前者是等待页面加载完成之后再进行加载。</p>
<p>选择器性能：</p>
<p>（1）关键选择器（key selector）。选择器的最后面的部分为关键选择器（即用来匹配目标元素的部分）。CSS选择符是从右到<br>左进行匹配的。当使用后代选择器的时候，浏览器会遍历所有子元素来确定是否是指定的元素等等；</p>
<p>（2）如果规则拥有ID选择器作为其关键选择器，则不要为规则增加标签。过滤掉无关的规则（这样样式系统就不会浪费时间去匹<br>配它们了）。</p>
<p>（3）避免使用通配规则，如*{}计算次数惊人！只对需要用到的元素进行选择。</p>
<p>（4）尽量少的去对标签进行选择，而是用class。</p>
<p>（5）尽量少的去使用后代选择器，降低选择器的权重值。后代选择器的开销是最高的，尽量将选择器的深度降到最低，最高不要超过<br>三层，更多的使用类来关联每一个标签元素。</p>
<p>（6）了解哪些属性是可以通过继承而来的，然后避免对这些属性重复指定规则。</p>
<p>渲染性能：</p>
<p>（1）慎重使用高性能属性：浮动、定位。</p>
<p>（2）尽量减少页面重排、重绘。</p>
<p>（3）去除空规则：｛｝。空规则的产生原因一般来说是为了预留样式。去除这些空规则无疑能减少css文档体积。</p>
<p>（4）属性值为0时，不加单位。</p>
<p>（5）属性值为浮动小数0.**，可以省略小数点之前的0。</p>
<p>（6）标准化各种浏览器前缀：带浏览器前缀的在前。标准属性在后。</p>
<p>（7）不使用@import前缀，它会影响css的加载速度。</p>
<p>（8）选择器优化嵌套，尽量避免层级过深。</p>
<p>（9）css雪碧图，同一页面相近部分的小图标，方便使用，减少页面的请求次数，但是同时图片本身会变大，使用时，优劣考虑清<br>楚，再使用。</p>
<p>（10）正确使用display的属性，由于display的作用，某些样式组合会无效，徒增样式体积的同时也影响解析性能。</p>
<p>（11）不滥用web字体。对于中文网站来说WebFonts可能很陌生，国外却很流行。web fonts通常体积庞大，而且一些浏<br>览器在下载web fonts时会阻塞页面渲染损伤性能。</p>
<p>可维护性、健壮性：</p>
<p>（1）将具有相同属性的样式抽离出来，整合并通过class在页面中进行使用，提高css的可维护性。<br>（2）样式与内容分离：将css代码定义到外部css中。</p>
<h2 id="浏览器是怎样解析CSS选择器的？"><a href="#浏览器是怎样解析CSS选择器的？" class="headerlink" title="浏览器是怎样解析CSS选择器的？"></a>浏览器是怎样解析CSS选择器的？</h2><p>样式系统从关键选择器开始匹配，然后左移查找规则选择器的祖先元素。只要选择器的子树一直在工作，样式系统就会持续左移，直<br>到和规则匹配，或者是因为不匹配而放弃该规则。</p>
<p>CSS选择器的解析是从右向左解析的。若从左向右的匹配，发现不符合规则，需要进行回溯，会损失很多性能。若从右向左匹配，先找到所有的最右节点，对于每一个节点，向上寻找其父节点直到找到根元素或满足条件的匹配规则，则结束这个分支的遍历。两种匹配规则的性能差别很大，是因为从右向左的匹配在第一步就筛选掉了大量的不符合条件的最右节点（叶子节点），而从左向右的匹配规则的性能都浪费在了失败的查找上面。</p>
<p>而在 CSS 解析完毕后，需要将解析的结果与 DOM Tree 的内容一起进行分析建立一棵 Render Tree，最终用来进行绘图。在建立 Render Tree 时（WebKit 中的「Attachment」过程），浏览器就要为每个 DOM Tree 中的元素根据 CSS 的解析结果（Style Rules）来确定生成怎样的 Render Tree。</p>
<h2 id="在网页中的应该使用奇数还是偶数的字体？为什么呢？"><a href="#在网页中的应该使用奇数还是偶数的字体？为什么呢？" class="headerlink" title="在网页中的应该使用奇数还是偶数的字体？为什么呢？"></a>在网页中的应该使用奇数还是偶数的字体？为什么呢？</h2><p>（1）偶数字号相对更容易和web设计的其他部分构成比例关系。比如：当我用了14px的正文字号，我可能会在一些地方用14<br>×0.5=7px的margin，在另一些地方用14×1.5=21px的标题字号。<br>（2）浏览器缘故，低版本的浏览器ie6会把奇数字体强制转化为偶数，即13px渲染为14px。<br>（3）系统差别，早期的Windows里，中易宋体点阵只有12和14、15、16px，唯独缺少13px。</p>
<h2 id="margin和padding分别适合什么场景使用？"><a href="#margin和padding分别适合什么场景使用？" class="headerlink" title="margin和padding分别适合什么场景使用？"></a>margin和padding分别适合什么场景使用？</h2><p>margin是用来隔开元素与元素的间距；padding是用来隔开元素与内容的间隔。<br>margin用于布局分开元素使元素与元素互不相干。<br>padding用于元素与内容之间的间隔，让内容（文字）与（包裹）元素之间有一段距离。</p>
<p>何时使用margin：</p>
<ol>
<li>需要在border外侧添加空白</li>
<li>空白处不需要背景色</li>
<li>上下相连的两个盒子之间的空白，需要相互抵消时。</li>
</ol>
<p>何时使用padding：</p>
<ol>
<li>需要在border内侧添加空白</li>
<li>空白处需要背景颜色</li>
<li>上下相连的两个盒子的空白，希望为两者之和。</li>
</ol>
<p>兼容性的问题：在IE5 IE6中，为float的盒子指定margin时，左侧的margin可能会变成两倍的宽度。通过改变padding或者指定盒子的display：inline解决。</p>
<h2 id="元素竖向的百分比设定是相对于容器的高度吗？"><a href="#元素竖向的百分比设定是相对于容器的高度吗？" class="headerlink" title="元素竖向的百分比设定是相对于容器的高度吗？"></a>元素竖向的百分比设定是相对于容器的高度吗？</h2><p>当按百分比设定一个元素的宽度时，它是相对于父容器的宽度计算的，但是，对于一些表示竖向距离的属性，例如 padding-top , padding-bottom , margin-top , margin-bottom 等，当按百分比设定它们时，依据的也是父容器的宽度，而不是高度。</p>
<h2 id="全屏滚动的原理是什么？用到了CSS的哪些属性？"><a href="#全屏滚动的原理是什么？用到了CSS的哪些属性？" class="headerlink" title="全屏滚动的原理是什么？用到了CSS的哪些属性？"></a>全屏滚动的原理是什么？用到了CSS的哪些属性？</h2><p>原理：有点类似于轮播，整体的元素一直排列下去，假设有5个需要展示的全屏页面，那么高度是500%，只是展示100%，剩下的可以通过transform进行y轴定位，也可以通过margin-top实现</p>
<p>overflow：hidden；transition：all 1000ms ease；</p>
<h2 id="什么是响应式设计？响应式设计的基本原理是什么？如何兼容低版本的IE？"><a href="#什么是响应式设计？响应式设计的基本原理是什么？如何兼容低版本的IE？" class="headerlink" title="什么是响应式设计？响应式设计的基本原理是什么？如何兼容低版本的IE？"></a>什么是响应式设计？响应式设计的基本原理是什么？如何兼容低版本的IE？</h2><p>响应式网站设计(Responsive Web design)是一个网站能够兼容多个终端，而不是为每一个终端做一个特定的版本。基本原理是通过媒体查询检测不同的设备屏幕尺寸做处理。页面头部必须有meta声明的viewport。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;meta name=&quot;’viewport’&quot; content=&quot;”width=device-width,&quot; initial-scale=&quot;1.&quot; maximum-scale=&quot;1,user-scalable=no”&quot;/&gt;</span><br></pre></td></tr></table></figure>

<h2 id="视差滚动效果？"><a href="#视差滚动效果？" class="headerlink" title="视差滚动效果？"></a>视差滚动效果？</h2><p>视差滚动（Parallax Scrolling）通过在网页向下滚动的时候，控制背景的移动速度比前景的移动速度慢来创建出令人惊叹的3D效果。</p>
<ol>
<li>CSS3实现优点：开发时间短、性能和开发效率比较好，缺点是不能兼容到低版本的浏览器</li>
<li>jQuery实现通过控制不同层滚动速度，计算每一层的时间，控制滚动效果。优点：能兼容到各个版本的，效果可控性好缺点：开发起来对制作者要求高</li>
<li>插件实现方式例如：parallax-scrolling，兼容性十分好</li>
</ol>
<h2 id="before-和-after中双冒号和单冒号有什么区别？解释一下这2个伪元素的作用"><a href="#before-和-after中双冒号和单冒号有什么区别？解释一下这2个伪元素的作用" class="headerlink" title="::before 和 :after中双冒号和单冒号有什么区别？解释一下这2个伪元素的作用"></a>::before 和 :after中双冒号和单冒号有什么区别？解释一下这2个伪元素的作用</h2><ol>
<li>单冒号(:)用于CSS3伪类，双冒号(::)用于CSS3伪元素。</li>
<li>::before就是以一个子元素的存在，定义在元素主体内容之前的一个伪元素。并不存在于dom之中，只存在在页面之中。</li>
</ol>
<p>:before 和 :after 这两个伪元素，是在CSS2.1里新出现的。起初，伪元素的前缀使用的是单冒号语法，但随着Web的进化，在CSS3的规范里，伪元素的语法被修改成使用双冒号，成为::before ::after</p>
<h2 id="你对line-height是如何理解的？"><a href="#你对line-height是如何理解的？" class="headerlink" title="你对line-height是如何理解的？"></a>你对line-height是如何理解的？</h2><p>行高是指一行文字的高度，具体说是两行文字间基线的距离。CSS中起高度作用的是height和line-height，没有定义height属性，最终其表现作用一定是line-height。单行文本垂直居中：把line-height值设置为height一样大小的值可以实现单行文字的垂直居中，其实也可以把height删除。多行文本垂直居中：需要设置display属性为inline-block。</p>
<h2 id="怎么让Chrome支持小于12px-的文字？"><a href="#怎么让Chrome支持小于12px-的文字？" class="headerlink" title="怎么让Chrome支持小于12px 的文字？"></a>怎么让Chrome支持小于12px 的文字？</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在谷歌下css设置字体大小为12px及以下时，显示都是一样大小，都是默认12px。</span><br><span class="line"></span><br><span class="line">解决办法：</span><br><span class="line"></span><br><span class="line">（1）可以使用Webkit的内核的-webkit-text-size-adjust的私有CSS属性来解决，只要加了-webkit-text-size</span><br><span class="line">-adjust:none;字体大小就不受限制了。但是chrome更新到27版本之后就不可以用了。所以高版本chrome谷歌浏览器</span><br><span class="line">已经不再支持-webkit-text-size-adjust样式，所以要使用时候慎用。</span><br><span class="line"></span><br><span class="line">（2）还可以使用css3的transform缩放属性-webkit-transform:scale(0.5);注意-webkit-transform:scale(0.</span><br><span class="line">75);收缩的是整个元素的大小，这时候，如果是内联元素，必须要将内联元素转换成块元素，可以使用display：block/</span><br><span class="line">inline-block/...；</span><br><span class="line"></span><br><span class="line">（3）使用图片：如果是内容固定不变情况下，使用将小于12px文字内容切出做图片，这样不影响兼容也不影响美观。</span><br></pre></td></tr></table></figure>

<h2 id="让页面里的字体变清晰，变细用CSS怎么做？"><a href="#让页面里的字体变清晰，变细用CSS怎么做？" class="headerlink" title="让页面里的字体变清晰，变细用CSS怎么做？"></a>让页面里的字体变清晰，变细用CSS怎么做？</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">webkit内核的私有属性：-webkit-font-smoothing，用于字体抗锯齿，使用后字体看起来会更清晰舒服。</span><br><span class="line">在MacOS测试环境下面设置-webkit-font-smoothing:antialiased;但是这个属性仅仅是面向MacOS，其他操作系统设</span><br><span class="line">置后无效。</span><br></pre></td></tr></table></figure>

<h2 id="position-跟-display、overflow、float-这些特性相互叠加后会怎么样？"><a href="#position-跟-display、overflow、float-这些特性相互叠加后会怎么样？" class="headerlink" title="position 跟 display、overflow、float 这些特性相互叠加后会怎么样？"></a>position 跟 display、overflow、float 这些特性相互叠加后会怎么样？</h2><p>display 属性规定元素应该生成的框的类型；position属性规定元素的定位类型；float属性是一种布局方式，定义元素在哪个方向浮动。<br>类似于优先级机制：position：absolute/fixed优先级最高，有他们在时，float不起作用，display值需要调整。float 或者absolute定位的元素，只能是块元素或表格。</p>
<h2 id="position-fixed-在android下无效怎么处理？"><a href="#position-fixed-在android下无效怎么处理？" class="headerlink" title="position:fixed;在android下无效怎么处理？"></a>position:fixed;在android下无效怎么处理？</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">因为移动端浏览器默认的viewport叫做layout viewport。在移动端显示时，因为layout viewport的宽度大于移动端屏幕</span><br><span class="line">的宽度，所以页面会出现滚动条左右移动，fixed的元素是相对layout viewport来固定位置的，而不是移动端屏幕来固定位置的</span><br><span class="line">，所以会出现感觉fixed无效的情况。</span><br><span class="line"></span><br><span class="line">如果想实现fixed相对于屏幕的固定效果，我们需要改变的是viewport的大小为ideal viewport，可以如下设置：</span><br><span class="line"></span><br><span class="line">&lt;metaname=&quot;viewport&quot;content=&quot;width=device-width,initial-scale=1.0,maximum-scale=1.0,minimum-sca</span><br><span class="line">le=1.0,user-scalable=no&quot;/&gt;</span><br></pre></td></tr></table></figure>

<h2 id="如果需要手动写动画，你认为最小时间间隔是多久，为什么？"><a href="#如果需要手动写动画，你认为最小时间间隔是多久，为什么？" class="headerlink" title="如果需要手动写动画，你认为最小时间间隔是多久，为什么？"></a>如果需要手动写动画，你认为最小时间间隔是多久，为什么？</h2><p>多数显示器默认频率是60Hz，即1秒刷新60次，所以理论上最小间隔为1/60＊1000ms ＝ 16.7ms。</p>
<h2 id="li与li之间有看不见的空白间隔是什么原因引起的？有什么解决办法？"><a href="#li与li之间有看不见的空白间隔是什么原因引起的？有什么解决办法？" class="headerlink" title="li与li之间有看不见的空白间隔是什么原因引起的？有什么解决办法？"></a>li与li之间有看不见的空白间隔是什么原因引起的？有什么解决办法？</h2><p>浏览器会把inline元素间的空白字符（空格、换行、Tab等）渲染成一个空格。而为了美观。我们通常是一个li放在一行，<br>这导致li换行后产生换行字符，它变成一个空格，占用了一个字符的宽度。</p>
<p>解决办法：</p>
<p>（1）为li设置float:left。不足：有些容器是不能设置浮动，如左右切换的焦点图等。</p>
<p>（2）将所有li写在同一行。不足：代码不美观。</p>
<p>（3）将ul内的字符尺寸直接设为0，即font-size:0。不足：ul中的其他字符尺寸也被设为0，需要额外重新设定其他<br>字符尺寸，且在Safari浏览器依然会出现空白间隔。</p>
<p>（4）消除ul的字符间隔letter-spacing:-8px，不足：这也设置了li内的字符间隔，因此需要将li内的字符<br>间隔设为默认letter-spacing:normal。</p>
<h2 id="display-inline-block-什么时候会显示间隙？"><a href="#display-inline-block-什么时候会显示间隙？" class="headerlink" title="display:inline-block 什么时候会显示间隙？"></a>display:inline-block 什么时候会显示间隙？</h2><ol>
<li>有空格时候会有间隙 解决：移除空格</li>
<li>margin正值的时候 解决：margin使用负值</li>
<li>使用font-size时候 解决：font-size:0、letter-spacing、word-spacing</li>
</ol>
<h2 id="有一个高度自适应的div，里面有两个div，一个高度100px，希望另一个填满剩下的高度"><a href="#有一个高度自适应的div，里面有两个div，一个高度100px，希望另一个填满剩下的高度" class="headerlink" title="有一个高度自适应的div，里面有两个div，一个高度100px，希望另一个填满剩下的高度"></a>有一个高度自适应的div，里面有两个div，一个高度100px，希望另一个填满剩下的高度</h2><p>外层div使用position：relative；高度要求自适应的div使用position: absolute; top: 100px; bottom: 0; left: 0</p>
<h2 id="png、jpg、gif-这些图片格式解释一下，分别什么时候用。有没有了解过webp？"><a href="#png、jpg、gif-这些图片格式解释一下，分别什么时候用。有没有了解过webp？" class="headerlink" title="png、jpg、gif 这些图片格式解释一下，分别什么时候用。有没有了解过webp？"></a>png、jpg、gif 这些图片格式解释一下，分别什么时候用。有没有了解过webp？</h2><ol>
<li>png是便携式网络图片（Portable Network Graphics）是一种无损数据压缩位图文件格式.优点是：压缩比高，色彩好。 大多数地方都可以用。</li>
<li>jpg是一种针对相片使用的一种失真压缩方法，是一种破坏性的压缩，在色调及颜色平滑变化做的不错。在www上，被用来储存和传输照片的格式。</li>
<li>gif是一种位图文件格式，以8位色重现真色彩的图像。可以实现动画效果.</li>
<li>webp格式是谷歌在2010年推出的图片格式，压缩率只有jpg的2/3，大小比png小了45%。缺点是压缩的时间更久了，兼容性不好，目前谷歌和opera支持。</li>
</ol>
<h2 id="style标签写在body后与body前有什么区别？"><a href="#style标签写在body后与body前有什么区别？" class="headerlink" title="style标签写在body后与body前有什么区别？"></a>style标签写在body后与body前有什么区别？</h2><p>页面加载自上而下 当然是先加载样式。写在body标签后由于浏览器以逐行方式对HTML文档进行解析，当解析到写在尾部的样式表（外联或写在style标签）会导致浏览器停止之前的渲染，等待加载且解析样式表完成之后重新渲染，在windows的IE下可能会出现FOUC现象（即样式失效导致的页面闪烁问题）</p>
<h2 id="CSS属性overflow属性定义溢出元素内容区的内容会如何处理"><a href="#CSS属性overflow属性定义溢出元素内容区的内容会如何处理" class="headerlink" title="CSS属性overflow属性定义溢出元素内容区的内容会如何处理?"></a>CSS属性overflow属性定义溢出元素内容区的内容会如何处理?</h2><p>参数是scroll时候，必会出现滚动条。<br>参数是auto时候，子元素内容大于父元素时出现滚动条。<br>参数是visible时候，溢出的内容出现在父元素之外。<br>参数是hidden时候，溢出隐藏。</p>
<h2 id="你知道-CSS-中不同属性设置为百分比-x-时对应的计算基准？"><a href="#你知道-CSS-中不同属性设置为百分比-x-时对应的计算基准？" class="headerlink" title="你知道 CSS 中不同属性设置为百分比\x 时对应的计算基准？"></a>你知道 CSS 中不同属性设置为百分比\x 时对应的计算基准？</h2><ol>
<li>基于包含块</li>
</ol>
<p>以下的关于包含块（含块）的概念，不能简单地理解成是父元素。</p>
<p>如果是静态定位和相对定位，包含块一般就是其父元素。但是对于绝对定位的元素，包含块应该是离它最近的 position 不是static的父元素，比如为absolute，relative，或者 fixed 的父元素。而对于固定定位的元素，它的包含块是视口（viewport）。</p>
<ol start="2">
<li><p>基于包含块的宽度（width，min-width，max-width，margin，padding，left，right，text-indent）</p>
</li>
<li><p>百分比是基于包含块的宽度的属性：width，min-width，max-width，margin，padding，left，right，text-indent</p>
</li>
<li><p>基于包含块的高度（height，max-height，min-height，top，bottom）</p>
</li>
</ol>
<p>百分比是基于包含块的高度的属性：height，max-height，min-height，top，bottom</p>
<ol start="5">
<li>基于元素的字体大小（line-height ）</li>
</ol>
<p>line-height 的百分比基于该元素本身的字体大小</p>
<ol start="6">
<li>基于元素的行高（vertical-align）</li>
</ol>
<p>vertical-align 的百分比基于元素的行高 line-height</p>
<p>（vertical-align 主要是设置行内元素的属性，该属性值设置行内元素相对于该元素所在的基线的垂直对齐位置。如果该行内元素是表格的单元格的话，该属性设置的是单元格内的内容的垂直方向的对齐位置）</p>
<ol start="7">
<li>font-size 的百分比<br>字体大小font-size 中的百分比是基于该元素所继承的字体大小的，也就是父元素的字体大小。</li>
</ol>
<p>其他答案：<br>公式：当前元素某CSS属性值 = 基准 * 对应的百分比<br>元素的 position 为 relative 和 absolute 时，top和bottom、left和right基准分别为包含块的 height、width<br>元素的 position 为 fixed 时，top和bottom、left和right基准分别为初始包含块（也就是视口）的 height、width，移动设备较为复杂，基准为 Layout viewport 的 height、width<br>元素的 height 和 width 设置为百分比时，基准分别为包含块的 height 和 width<br>元素的 margin 和 padding 设置为百分比时，基准为包含块的 width（易错）<br>元素的 border-width，不支持百分比<br>元素的 text-indent，基准为包含块的 width</p>
<p>元素的 border-radius，基准为分别为自身的height、width<br>元素的 background-size，基准为分别为自身的height、width<br>元素的 translateX、translateY，基准为分别为自身的height、width<br>元素的 line-height，基准为自身的 font-size</p>
<p>元素的 font-size，基准为父元素字体</p>
<h2 id="一个自适应矩形，水平垂直居中，且宽高比为-2-1"><a href="#一个自适应矩形，水平垂直居中，且宽高比为-2-1" class="headerlink" title="一个自适应矩形，水平垂直居中，且宽高比为 2:1"></a>一个自适应矩形，水平垂直居中，且宽高比为 2:1</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.box &#123;</span><br><span class="line">    position: absolute;</span><br><span class="line">    top: 0;</span><br><span class="line">    right: 0;</span><br><span class="line">    left: 0;</span><br><span class="line">    bottom: 0;</span><br><span class="line">    margin: auto;</span><br><span class="line"></span><br><span class="line">    width: 10%;</span><br><span class="line">    height: 0;</span><br><span class="line">    padding-top: 20%;</span><br><span class="line">    background: tomato;</span><br><span class="line">&#125;</span><br><span class="line">&lt;div class=&quot;box&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<h2 id="css-三栏布局的实现？"><a href="#css-三栏布局的实现？" class="headerlink" title="css 三栏布局的实现？"></a>css 三栏布局的实现？</h2><ol>
<li><p>网格（grid）布局</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.div&#123;</span><br><span class="line">    width: 100%;</span><br><span class="line">    display: grid;</span><br><span class="line">    grid-template-rows: 100px;</span><br><span class="line">    grid-template-columns: 300px auto 300px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>flex布局</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">display: flex;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>3.table布局</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.main&#123;</span><br><span class="line">    width: 100%;</span><br><span class="line">    display: table;</span><br><span class="line">&#125;</span><br><span class="line">.left,.center,.right&#123;</span><br><span class="line">    display: table-cell;</span><br><span class="line">&#125;</span><br><span class="line">.left&#123;</span><br><span class="line">    width: 300px;</span><br><span class="line">    background-color: red;</span><br><span class="line">&#125;</span><br><span class="line">.center&#123;</span><br><span class="line">    background-color: blue;</span><br><span class="line">&#125;</span><br><span class="line">.right&#123;</span><br><span class="line">    width: 300px;</span><br><span class="line">    background-color: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>浮动布局<br>float</li>
<li>position布局</li>
</ol>
<h2 id="css经典布局——头尾固定高度中间高度自适应布局"><a href="#css经典布局——头尾固定高度中间高度自适应布局" class="headerlink" title="css经典布局——头尾固定高度中间高度自适应布局"></a>css经典布局——头尾固定高度中间高度自适应布局</h2><h2 id="常见的元素隐藏方式？"><a href="#常见的元素隐藏方式？" class="headerlink" title="常见的元素隐藏方式？"></a>常见的元素隐藏方式？</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-（1）使用 display:none;隐藏元素，渲染树不会包含该渲染对象，因此该元素不会在页面中占据位置，也不会响应绑定的监听事件。</span><br><span class="line"></span><br><span class="line">-（2）使用 visibility:hidden;隐藏元素。元素在页面中仍占据空间，但是不会响应绑定的监听事件。</span><br><span class="line"></span><br><span class="line">-（3）使用 opacity:0;将元素的透明度设置为 0，以此来实现元素的隐藏。元素在页面中仍然占据空间，并且能够响应元素绑定的监听事件。</span><br><span class="line"></span><br><span class="line">-（4）通过使用绝对定位将元素移除可视区域内，以此来实现元素的隐藏。</span><br><span class="line"></span><br><span class="line">-（5）通过 z-index 负值，来使其他元素遮盖住该元素，以此来实现隐藏。</span><br><span class="line"></span><br><span class="line">-（6）通过 clip/clip-path 元素裁剪的方法来实现元素的隐藏，这种方法下，元素仍在页面中占据位置，但是不会响应绑定的监听事件。</span><br><span class="line"></span><br><span class="line">-（7）通过 transform:scale(0,0)来将元素缩放为 0，以此来实现元素的隐藏。这种方法下，元素仍在页面中占据位置，但是不会响应绑定的监听事件。</span><br></pre></td></tr></table></figure>

<h2 id="如何实现单行／多行文本溢出的省略（…）"><a href="#如何实现单行／多行文本溢出的省略（…）" class="headerlink" title="如何实现单行／多行文本溢出的省略（…）"></a>如何实现单行／多行文本溢出的省略（…）</h2><ol>
<li>单行<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">overflow: hidden;</span><br><span class="line">text-overflow: ellipsis;</span><br><span class="line">white-space: nowrap;</span><br></pre></td></tr></table></figure></li>
<li>多行</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">display:-webkit-box;//对象作为弹性伸缩盒子模型显示 </span><br><span class="line">-webkit-box-orient: vertical;//设置或检索伸缩盒对象的子元素的排列方式 </span><br><span class="line">-webkit-line-clamp: 2;//溢出省略的界限</span><br><span class="line">overflow:hidden;//设置隐藏溢出元素&#x27;</span><br></pre></td></tr></table></figure>

<h2 id="css隐藏元素的背景图到底加不加载"><a href="#css隐藏元素的背景图到底加不加载" class="headerlink" title="css隐藏元素的背景图到底加不加载"></a>css隐藏元素的背景图到底加不加载</h2><p>-（1）元素的背景图片</p>
<p>-元素本身设置 display:none，会请求图片 -父级元素设置 display:none，不会请求图片 -样式没有元素使用，不会请求<br>-:hover 样式下，触发时请求</p>
<p>-（2）img 标签图片任何情况下都会请求图片</p>
<h2 id="white-space-与换行和空格的控制？"><a href="#white-space-与换行和空格的控制？" class="headerlink" title="white-space 与换行和空格的控制？"></a>white-space 与换行和空格的控制？</h2><p>white-space属性声明了如何处理元素内的空白字符，这类空白字符包括Space（空格）键、Enter（回车）键、Tab（制表符）<br>键产生的空白。因此，white-space可以决定图文内容是否在一行显示（回车空格是否生效），是否显示大段连续空白（空格是否<br>生效）等。</p>
<p>其属性值包括下面这些。<br>•normal：合并空白字符和换行符。<br>•pre：空白字符不合并，并且内容只在有换行符的地方换行。<br>•nowrap：该值和normal一样会合并空白字符，但不允许文本环绕。<br>•pre-wrap：空白字符不合并，并且内容只在有换行符的地方换行，同时允许文本环绕。<br>•pre-line：合并空白字符，但只在有换行符的地方换行，允许文本环绕。</p>
<h2 id="word-spacing-单词间距-letter-spacing-字符间距？"><a href="#word-spacing-单词间距-letter-spacing-字符间距？" class="headerlink" title="word-spacing 单词间距 letter-spacing 字符间距？"></a>word-spacing 单词间距 letter-spacing 字符间距？</h2><p>letter-spacing : normal | length<br>word-spacing：normal | length<br>letter-spacing作用于所有字符，但word-spacing仅作用于空格字符。换句话说，word-spacing的作用就是增加空格的间隙宽度。</p>
<p>letter-spacing可以用来控制字符之间的间距，这里说的“字符”包括英文字母、汉字以及空格等。</p>
<p>letter-spacing具有以下一些特性。</p>
<p>（1）继承性。<br>（2）默认值是normal而不是0。虽然说正常情况下，normal的计算值就是0，但两者还是有差别的，在有些场景下，letter-spacing会调整normal的计算值以实现更好的版面布局。<br>（3）支持负值，且值足够大的时候，会让字符形成重叠，甚至反向排列。<br>（4）和text-indent属性一样，无论值多大或多小，第一行一定会保留至少一个字符。<br>（5）支持小数值，即使0.1px也是支持的。<br>（6）暂不支持百分比值。</p>
<h2 id="text-indent-的特殊性"><a href="#text-indent-的特殊性" class="headerlink" title="text-indent 的特殊性"></a>text-indent 的特殊性</h2><p>（1）text-indent仅对第一行内联盒子内容有效。</p>
<p>（2）非替换元素以外的display计算值为inline的内联元素设置text-indent值无效，如果计算值inline-block/inli<br>ne-table则会生效。</p>
<p>（3）input标签按钮text-indent值无效。</p>
<p>（4）button标签按钮text-indent值有效。</p>
<p>（5）text-indent的百分比值是相对于当前元素的“包含块”计算的，而不是当前元素。</p>
<h2 id="font-weight-的特殊性？"><a href="#font-weight-的特殊性？" class="headerlink" title="font-weight 的特殊性？"></a>font-weight 的特殊性？</h2><p>在上面我们已经提到，在很多情况下，字体并不是以九阶数值来划分的，并且其含有的字重数量是不一的，通常情况下为4-6个。</p>
<p>此时，就会出现样式指定的字重数值在字体中找不到直接对应的字重，那浏览器是如何解决的呢？</p>
<p>Bingo！</p>
<p>那就是要靠字体匹配算法来解决。其中关于font-weight部分是这么提及到的：</p>
<p>如果指定的font-weight数值，即所需的字重，能够在字体中找到对应的字重，那么就匹配为该对应的字重。否则，使用下面的规则来查找所需的字重并渲染：</p>
<p>·    如果所需的字重小于400，则首先降序检查小于所需字重的各个字重，如仍然没有，则升序检查大于所需字重的各字重，直到找到匹配的字重。</p>
<p>·    如果所需的字重大于500，则首先升序检查大于所需字重的各字重，之后降序检查小于所需字重的各字重，直到找到匹配的字重。</p>
<p>·    如果所需的字重是400，那么会优先匹配500对应的字重，如仍没有，那么执行第一条所需字重小于400的规则。</p>
<p>·    如果所需的字重是500，则优先匹配400对应的字重，如仍没有，那么执行第二条所需字重大于500的规则。</p>
<h2 id="层叠上下文、层叠水平和层叠顺序"><a href="#层叠上下文、层叠水平和层叠顺序" class="headerlink" title="层叠上下文、层叠水平和层叠顺序"></a>层叠上下文、层叠水平和层叠顺序</h2><ol>
<li>层叠上下文(stacking context)是一种三维概念，如果用户和电脑屏幕之间存在一条看不见的垂直线，假设一个元素含有层叠上下文的话，那么这个元素就会在这个垂直线上比其它元素“高人一等”。</li>
<li>层叠水平(stacking level)决定了同一个层叠上下文中元素在z轴上的显示顺序。所有的元素都有层叠水平，包括层叠上下文元素，普通元素的层叠水平优先由层叠上下文决定。注意不要把层叠水平和z-index属性混为一谈，z-index确实可以影响层叠水平，但是，只限于定位元素以及flex盒子的孩子元素；而层叠水平所有的元素都存在。</li>
<li>层叠顺序(stacking order)表示元素发生层叠时特定的垂直显示顺序。</li>
</ol>
<p>层叠上下文</p>
<p>网页上的元素其实是三维的，类似于高中学的左手坐标系，Z轴就是垂直于屏幕。层叠上下文跟“块状格式化上下文”（BFC）类似，只要元素拥有某些特定的css属性，就会表现出层叠上下文的特点。</p>
<p>层叠准则</p>
<p>(1) 谁大谁上：如生效的z-index属性值，大的就覆盖小的。</p>
<p>(2)后来居上：当元素的层叠顺序一致的时候，比较后面的元素就会覆盖前面的元素。</p>
<p>层叠上下文创建</p>
<p>普通元素可以添加overflow：hidden；使他成为BFC元素。而层叠上下文也可以添加某些css属性变成的。</p>
<ol>
<li>文档根元素（<html>）；</html></li>
<li>position 值为 absolute（绝对定位）或 relative（相对定位）且 z-index 值不为 auto 的元素；</li>
<li>position 值为 fixed（固定定位）或 sticky（粘滞定位）的元素（沾滞定位适配所有移动设备上的浏览器，但老的桌面浏览器不支持）；</li>
<li>flex (flexbox) 容器的子元素，且 z-index 值不为 auto；</li>
<li>grid (grid) 容器的子元素，且 z-index 值不为 auto；</li>
<li>opacity 属性值小于 1 的元素</li>
<li>mix-blend-mode 属性值不为 normal 的元素；</li>
<li>以下任意属性值不为 none 的元素：</li>
<li>transform</li>
<li>filter</li>
<li>perspective</li>
<li>clip-path</li>
<li> mask / mask-image / mask-border</li>
<li>isolation 属性值为 isolate 的元素；</li>
<li>-webkit-overflow-scrolling 属性值为 touch 的元素；</li>
<li>will-change 值设定了任一属性而该属性在 non-initial 值时会创建层叠上下文的元素</li>
<li>contain 属性值为 layout、paint 或包含它们其中之一的合成值（比如 contain: strict、contain: content）的元素。</li>
</ol>
<p>元素的层叠顺序？</p>
<p>层叠顺序</p>
<ol>
<li>background</li>
<li>border</li>
<li>块级</li>
<li>浮动</li>
<li>内联</li>
<li>z-index: 0</li>
<li>z-index: +</li>
</ol>
<p>综述：</p>
<ol>
<li><p>子元素在父元素之上。</p>
</li>
<li><p>Relative、absolute、fixed元素在static元素之上。</p>
</li>
<li><p>同级的元素z-index值高的元素在上。</p>
</li>
<li><p>后定义的元素在先定义的元素之上。</p>
</li>
<li><p>若父元素设定了z-index属性，则子元素受限于父元素的层叠位置；若没有，则子元素被当作与元素同等级的元素。</p>
</li>
</ol>
<p>总结</p>
<ol>
<li>在层叠上下文中，子元素也会发生层叠上下文，但是子元素的z-index的值只在其父元素内起作用。</li>
<li>在同一个层叠上下文中，层叠水平值大的那一个覆盖小的那一个。</li>
<li>当元素的层叠顺序和层叠水平一样时，后出现的元素会覆盖前面的元素。</li>
</ol>
<h2 id="clip-裁剪是什么？"><a href="#clip-裁剪是什么？" class="headerlink" title="clip 裁剪是什么？"></a>clip 裁剪是什么？</h2><p>所谓“可访问性隐藏”，指的是虽然内容肉眼看不见，但是其他辅助设备却能够进行识别和访问的隐藏。</p>
<p>clip剪裁被我称为“最佳可访问性隐藏”的另外一个原因就是，它具有更强的普遍适应性，任何元素、任何场景都可以无障碍使用。</p>
<h2 id="overflow与absolute的关系"><a href="#overflow与absolute的关系" class="headerlink" title="overflow与absolute的关系"></a>overflow与absolute的关系</h2><p>（1）如果overflow不是定位元素，同时绝对定位元素和overflow容器之间也没有定位元素，则overflow无法对absolute<br>元素进行剪裁。</p>
<p>（2）如果overflow的属性值不是hidden而是auto或者scroll，即使绝对定位元素高宽比overflow元素高宽还要大，也<br>都不会出现滚动条。</p>
<p>（3）overflow元素自身transform的时候，Chrome和Opera浏览器下的overflow剪裁是无效的。</p>
<h2 id="无依赖绝对定位的应用"><a href="#无依赖绝对定位的应用" class="headerlink" title="无依赖绝对定位的应用"></a>无依赖绝对定位的应用</h2><p>含义：<br>当绝对定位元素不使用top/right/bottom/left中任何一个属性时，或者上述四个偏移量都使用auto取值时，该绝对定位元素不受其参照物的限制，又可以称为无依赖的绝对定位元素。<br>特点：</p>
<ol>
<li>是一个无宽、高的浮动元素，因此会尽可能向上浮动</li>
<li>位置跟随性，即原来是block水平元素的换行显示行为，在绝对定位以后仍是换行显示，即原来在某个块级元素（普通文档流）之上或者之下，绝对定位以后依然在该元素的上方或者下方；原来是inline或者inline-block水平元素的同行显示行为在绝对定位以后仍是同行显示，也就是如果原来是跟在某个行内元素（普通文档流）后面或者前面，在无依赖绝对定位以后依然在该元素后面或者前面。</li>
<li>对于含有无依赖absolute元素的父级元素DOM结构的布局行为：首先确定当前的普通文档流DOM结构：将普通文档流中的元素按照在DOM结构中的先后顺序进行摆放，确定当前的布局。接着判断无依赖absolute元素，按照DOM结构以此判断，如果多个绝对定位元素相互遮挡，那么按照七层层叠顺序+后来居上+大者居上的准则判断。<br>应用：<br>应用主要是与margin结合、与text-align结合。注意：绝对定位元素无论是否设置偏移量，都可以使用margin。具体包括：</li>
</ol>
<p>图片的图标定位：左上角定位和右上角定位，可延伸到非图片的左上角、右上角定位</p>
<ol>
<li>下拉框：最佳实践</li>
<li>星号和文字的对齐</li>
<li>小图标和文字的对齐：这个图片可以是img，也可以是只含背景图片的空标签</li>
<li>文字溢出的处理</li>
<li>对齐或者居中：与text-align结合</li>
</ol>
<h2 id="overflow-的特殊性？"><a href="#overflow-的特殊性？" class="headerlink" title="overflow 的特殊性？"></a>overflow 的特殊性？</h2><p>（1）一个设置了overflow:hidden声明的元素，假设同时存在border属性和padding属性，则当子元素内容超出容器宽度<br>高度限制的时候，剪裁的边界是border box的内边缘，而非padding box的内边缘。</p>
<p>（2）HTML中有两个标签是默认可以产生滚动条的，一个是根元素html，另一个是文本域textarea。</p>
<p>（3）滚动条会占用容器的可用宽度或高度。</p>
<p>（4）元素设置了overflow:hidden声明，里面内容高度溢出的时候，滚动依然存在，仅仅滚动条不存在！</p>
<h2 id="vertical-align-的特殊性？"><a href="#vertical-align-的特殊性？" class="headerlink" title="vertical-align 的特殊性？"></a>vertical-align 的特殊性？</h2><p>（1）vertical-align的默认值是baseline，即基线对齐，而基线的定义是字母x的下边缘。因此，内联元素默认都是沿着字<br>母x的下边缘对齐的。对于图片等替换元素，往往使用元素本身的下边缘作为基线。：一个inline-block元素，如果里面<br>没有内联元素，或者overflow不是visible，则该元素的基线就是其margin底边缘；否则其基线就是元素里面最后一行<br>内联元素的基线。</p>
<p>（2）vertical-align:top就是垂直上边缘对齐，如果是内联元素，则和这一行位置最高的内联元素的顶部对齐；如果display<br>计算值是table-cell的元素，我们不妨脑补成<td>元素，则和</td><tr>元素上边缘对齐。</tr></p>
<p>（3）vertical-align:middle是中间对齐，对于内联元素，元素的垂直中心点和行框盒子基线往上1/2x-height处对齐。对<br>于table-cell元素，单元格填充盒子相对于外面的表格行居中对齐。</p>
<p>（4）vertical-align支持数值属性，根据数值的不同，相对于基线往上或往下偏移，如果是负值，往下偏移，如果是正值，往上<br>偏移。</p>
<p>（5）vertical-align属性的百分比值则是相对于line-height的计算值计算的。</p>
<p>（6）vertical-align起作用是有前提条件的，这个前提条件就是：只能应用于内联元素以及display值为table-cell的元<br>素。</p>
<p>（7）table-cell元素设置vertical-align垂直对齐的是子元素，但是其作用的并不是子元素，而是table-cell元素自身。</p>
<h2 id="line-height-的特殊性？"><a href="#line-height-的特殊性？" class="headerlink" title="line-height 的特殊性？"></a>line-height 的特殊性？</h2><p>（1）对于非替换元素的纯内联元素，其可视高度完全由line-height决定。对于文本这样的纯内联元素，line-height就是高<br>度计算的基石，用专业说法就是指定了用来计算行框盒子高度的基础高度。</p>
<p>（2）内联元素的高度由固定高度和不固定高度组成，这个不固定的部分就是这里的“行距”。换句话说，line-height之所以起作<br>用，就是通过改变“行距”来实现的。在CSS中，“行距”分散在当前文字的上方和下方，也就是即使是第一行文字，其上方也是<br>有“行距”的，只不过这个“行距”的高度仅仅是完整“行距”高度的一半，因此，也被称为“半行距”。</p>
<p>（3）行距=line-height-font-size。</p>
<p>（4）border以及line-height等传统CSS属性并没有小数像素的概念。如果标注的是文字上边距，则向下取整；如果是文字下<br>边距，则向上取整。</p>
<p>（5）对于纯文本元素，line-height直接决定了最终的高度。但是，如果同时有替换元素，则line-height只能决定最小高度。</p>
<p>（6）对于块级元素，line-height对其本身是没有任何作用的，我们平时改变line-height，块级元素的高度跟着变化实际上是<br>通过改变块级元素里面内联级别元素占据的高度实现的。</p>
<p>（7）line-height的默认值是normal，还支持数值、百分比值以及长度值。为数值类型时，其最终的计算值是和当前font-si<br>ze相乘后的值。为百分比值时，其最终的计算值是和当前font-size相乘后的值。为长度值时原意不变。</p>
<p>（8）如果使用数值作为line-height的属性值，那么所有的子元素继承的都是这个值；但是，如果使用百分比值或者长度值作为<br>属性值，那么所有的子元素继承的是最终的计算值。</p>
<p>（9）无论内联元素line-height如何设置，最终父级元素的高度都是由数值大的那个line-height决定的。</p>
<p>（10）只要有“内联盒子”在，就一定会有“行框盒子”，就是每一行内联元素外面包裹的一层看不见的盒子。然后，重点来了，在每个<br>“行框盒子”前面有一个宽度为0的具有该元素的字体和行高属性的看不见的“幽灵空白节点”。</p>
<h2 id="什么是基线和-x-height？"><a href="#什么是基线和-x-height？" class="headerlink" title="什么是基线和 x-height？"></a>什么是基线和 x-height？</h2><p>字母x的下边缘（线）就是我们的基线。</p>
<p>x-height指的就是小写字母x的高度，术语描述就是基线和等分线（meanline）（也称作中线，midline）之间的距离。在C<br>SS世界中，middle指的是基线往上1/2x-height高度。我们可以近似理解为字母x交叉点那个位置。</p>
<p>ex是CSS中的一个相对单位，指的是小写字母x的高度，没错，就是指x-height。ex的价值就在其副业上不受字体和字号影<br>响的内联元素的垂直居中对齐效果。内联元素默认是基线对齐的，而基线就是x的底部，而1ex就是一个x的高度。</p>
<h2 id="border-的特殊性？"><a href="#border-的特殊性？" class="headerlink" title="border 的特殊性？"></a>border 的特殊性？</h2><p>（1）border-width却不支持百分比。</p>
<p>（2）border-style的默认值是none，有一部分人可能会误以为是solid。这也是单纯设置border-width或border-col<br>or没有边框显示的原因。</p>
<p>（3）border-style:double的表现规则：双线宽度永远相等，中间间隔±1。</p>
<p>（4）border-color默认颜色就是color色值。</p>
<p>（5）默认background背景图片是相对于padding box定位的。</p>
<h2 id="margin-无效的情形"><a href="#margin-无效的情形" class="headerlink" title="margin 无效的情形"></a>margin 无效的情形</h2><p>（1）display计算值inline的非替换元素的垂直margin是无效的。对于内联替换元素，垂直margin有效，并且没有ma<br>rgin合并的问题。</p>
<p>（2）表格中的tr和td元素或者设置display计算值是table-cell或table-row的元素的margin都是无效的。</p>
<p>（3）绝对定位元素非定位方位的margin值“无效”。</p>
<p>（4）定高容器的子元素的margin-bottom或者宽度定死的子元素的margin-right的定位“失效”。</p>
<h2 id="margin-auto-的填充规则？"><a href="#margin-auto-的填充规则？" class="headerlink" title="margin:auto 的填充规则？"></a>margin:auto 的填充规则？</h2><p>margin的’auto’可不是摆设，是具有强烈的计算意味的关键字，用来计算元素对应方向应该获得的剩余间距大小。但是触发mar<br>gin:auto计算有一个前提条件，就是width或height为auto时，元素是具有对应方向的自动填充特性的。</p>
<p>（1）如果一侧定值，一侧auto，则auto为剩余空间大小。<br>（2）如果两侧均是auto，则平分剩余空间。</p>
<h2 id="content-与替换元素的关系？"><a href="#content-与替换元素的关系？" class="headerlink" title="content 与替换元素的关系？"></a>content 与替换元素的关系？</h2><p>content属性生成的对象称为“匿名替换元素”。</p>
<p>（1）我们使用content生成的文本是无法选中、无法复制的，好像设置了user select:none声明一般，但是普通元素的文本<br>却可以被轻松选中。同时，content生成的文本无法被屏幕阅读设备读取，也无法被搜索引擎抓取，因此，千万不要自以为是<br>地把重要的文本信息使用content属性生成，因为这对可访问性和SEO都很不友好。</p>
<p>（2）content生成的内容不能左右:empty伪类。</p>
<p>（3）content动态生成值无法获取。</p>
<h2 id="替换元素的计算规则？"><a href="#替换元素的计算规则？" class="headerlink" title="替换元素的计算规则？"></a>替换元素的计算规则？</h2><p>替换元素的尺寸从内而外分为3类：固有尺寸、HTML尺寸和CSS尺寸。</p>
<p>（1）固有尺寸指的是替换内容原本的尺寸。例如，图片、视频作为一个独立文件存在的时候，都是有着自己的宽度和高度的。</p>
<p>（2）HTML尺寸只能通过HTML原生属性改变，这些HTML原生属性包括img的width和height属性、input的size属性、textarea的cols和rows属性等。</p>
<p>（3）CSS尺寸特指可以通过CSS的width和height或者max-width/min-width和max-height/min-height设置的<br>尺寸，对应盒尺寸中的content box。</p>
<p>这3层结构的计算规则具体如下</p>
<p>（1）如果没有CSS尺寸和HTML尺寸，则使用固有尺寸作为最终的宽高。</p>
<p>（2）如果没有CSS尺寸，则使用HTML尺寸作为最终的宽高。</p>
<p>（3）如果有CSS尺寸，则最终尺寸由CSS属性决定。</p>
<p>（4）如果“固有尺寸”含有固有的宽高比例，同时仅设置了宽度或仅设置了高度，则元素依然按照固有的宽高比例显示。</p>
<p>（5）如果上面的条件都不符合，则最终宽度表现为300像素，高度为150像素。</p>
<p>（6）内联替换元素和块级替换元素使用上面同一套尺寸计算规则。</p>
<h2 id="什么是替换元素？"><a href="#什么是替换元素？" class="headerlink" title="什么是替换元素？"></a>什么是替换元素？</h2><p>通过修改某个属性值呈现的内容就可以被替换的元素就称为“替换元素”。因此，img、object、video、iframe或者表<br>单元素textarea和input和select都是典型的替换元素。</p>
<p>替换元素除了内容可替换这一特性以外，还有以下一些特性。</p>
<p>（1）内容的外观不受页面上的CSS的影响。用专业的话讲就是在样式表现在CSS作用域之外。如何更改替换元素本身的外观需要<br>类似appearance属性，或者浏览器自身暴露的一些样式接口，</p>
<p>（2）有自己的尺寸。在Web中，很多替换元素在没有明确尺寸设定的情况下，其默认的尺寸（不包括边框）是300像素×150像<br>素，如video、iframe或者canvas等，也有少部分替换元素为0像素，如img图片，而表单元素的替换元素<br>的尺寸则和浏览器有关，没有明显的规律。</p>
<p>（3）在很多CSS属性上有自己的一套表现规则。比较具有代表性的就是vertical-align属性，对于替换元素和非替换元素，ve<br>rtical-align属性值的解释是不一样的。比方说vertical-align的默认值的baseline，很简单的属性值，基线之意，<br>被定义为字符x的下边缘，而替换元素的基线却被硬生生定义成了元素的下边缘。</p>
<p>（4）所有的替换元素都是内联水平元素，也就是替换元素和替换元素、替换元素和文字都是可以在一行显示的。但是，替换元素默认<br>的display值却是不一样的，有的是inline，有的是inline-block。</p>
<h2 id="什么是幽灵空白节点？"><a href="#什么是幽灵空白节点？" class="headerlink" title="什么是幽灵空白节点？"></a>什么是幽灵空白节点？</h2><p>“幽灵空白节点”是内联盒模型中非常重要的一个概念，具体指的是：在HTML5文档声明中，内联元素的所有解析和渲染表现就如同<br>每个行框盒子的前面有一个“空白节点”一样。这个“空白节点”永远透明，不占据任何宽度，看不见也无法通过脚本获取，就好像幽灵<br>一样，但又确确实实地存在，表现如同文本节点一样，因此，我称之为“幽灵空白节点”。</p>
<h2 id="内联盒模型基本概念"><a href="#内联盒模型基本概念" class="headerlink" title="内联盒模型基本概念"></a>内联盒模型基本概念</h2><p>（1）内容区域（content area）。内容区域指一种围绕文字看不见的盒子，其大小仅受字符本身特性控制，本质上是一个字符盒子<br>（character box）；但是有些元素，如图片这样的替换元素，其内容显然不是文字，不存在字符盒子之类的，因此，对于这些<br>元素，内容区域可以看成元素自身。</p>
<p>（2）内联盒子（inline box）。“内联盒子”不会让内容成块显示，而是排成一行，这里的“内联盒子”实际指的就是元素的“外在盒<br>子”，用来决定元素是内联还是块级。该盒子又可以细分为“内联盒子”和“匿名内联盒子”两类。</p>
<p>（3）行框盒子（line box），每一行就是一个“行框盒子”（实线框标注），每个“行框盒子”又是由一个一个“内联盒子”组成的。</p>
<p>（4）包含块（containing box），由一行一行的“行框盒子”组成。</p>
<h2 id="min-width-max-width-和-min-height-max-height-属性间的覆盖规则？"><a href="#min-width-max-width-和-min-height-max-height-属性间的覆盖规则？" class="headerlink" title="min-width/max-width 和 min-height/max-height 属性间的覆盖规则？"></a>min-width/max-width 和 min-height/max-height 属性间的覆盖规则？</h2><p>（1）max-width会覆盖width，即使width是行类样式或者设置了!important。</p>
<p>（2）min-width会覆盖max-width，此规则发生在min-width和max-width冲突的时候。</p>
<h2 id="为什么-height-100-会无效？"><a href="#为什么-height-100-会无效？" class="headerlink" title="为什么 height:100%会无效？"></a>为什么 height:100%会无效？</h2><p>对于普通文档流中的元素，百分比高度值要想起作用，其父级必须有一个可以生效的高度值。</p>
<p>原因是如果包含块的高度没有显式指定（即高度由内容决定），并且该元素不是绝对定位，则计算值为auto，因为解释成了auto，<br>所以无法参与计算。</p>
<p>使用绝对定位的元素会有计算值，即使祖先元素的height计算为auto也是如此。</p>
<h2 id="什么是首选最小宽度？"><a href="#什么是首选最小宽度？" class="headerlink" title="什么是首选最小宽度？"></a>什么是首选最小宽度？</h2><p>“首选最小宽度”，指的是元素最适合的最小宽度。</p>
<p>东亚文字（如中文）最小宽度为每个汉字的宽度。</p>
<p>西方文字最小宽度由特定的连续的英文字符单元决定。并不是所有的英文字符都会组成连续单元，一般会终止于空格（普通空格）、短<br>横线、问号以及其他非英文字符等。</p>
<p>如果想让英文字符和中文一样，每一个字符都用最小宽度单元，可以试试使用CSS中的word-break:break-all。</p>
<h2 id="transition-和-animation-的区别"><a href="#transition-和-animation-的区别" class="headerlink" title="transition 和 animation 的区别"></a>transition 和 animation 的区别</h2><p>transition关注的是CSS property的变化，property值和时间的关系是一个三次贝塞尔曲线。</p>
<p>animation作用于元素本身而不是样式属性，可以使用关键帧的概念，应该说可以实现更自由的动画效果。</p>
<h2 id="画一条-0-5px-的线"><a href="#画一条-0-5px-的线" class="headerlink" title="画一条 0.5px 的线"></a>画一条 0.5px 的线</h2><p>采用meta viewport的方式<br>meta name=”viewport” content=”width=device-width,initial-sacle=0.5”<br>采用border-image的方式</p>
<p>采用transform:scale()的方式<br>transform: scaleY(0.5);<br>transform-origin: 50% 100%;</p>
<h2 id="几种常见的CSS布局"><a href="#几种常见的CSS布局" class="headerlink" title="几种常见的CSS布局"></a>几种常见的CSS布局</h2><p>[<a href="https://juejin.cn/post/6844903710070407182#heading-12]">https://juejin.cn/post/6844903710070407182#heading-12]</a></p>
<h2 id="使用-rem-布局的优缺点？"><a href="#使用-rem-布局的优缺点？" class="headerlink" title="使用 rem 布局的优缺点？"></a>使用 rem 布局的优缺点？</h2><p>优点：<br>在屏幕分辨率千差万别的时代，只要将rem与屏幕分辨率关联起来就可以实现页面的整体缩放，使得在设备上的展现都统一起来了。<br>而且现在浏览器基本都已经支持rem了，兼容性也非常的好。</p>
<p>缺点：<br>（1）在奇葩的dpr设备上表现效果不太好，比如一些华为的高端机型用rem布局会出现错乱。<br>（2）使用iframe引用也会出现问题。<br>（3）rem在多屏幕尺寸适配上与当前两大平台的设计哲学不一致。即大屏的出现到底是为了看得又大又清楚，还是为了看的更多的问<br>题。</p>
<h2 id="阐述一下-CSSSprites"><a href="#阐述一下-CSSSprites" class="headerlink" title="阐述一下 CSSSprites"></a>阐述一下 CSSSprites</h2><p>将一个页面涉及到的所有图片都包含到一张大图中去，然后利用CSS的background-image，background-repeat，background<br>-position的组合进行背景定位。利用CSSSprites能很好地减少网页的http请求，从而很好的提高页面的性能；CSSSprites<br>能减少图片的字节。</p>
<p>优点：</p>
<p>减少HTTP请求数，极大地提高页面加载速度<br>增加图片信息重复度，提高压缩比，减少图片大小<br>解决了网页设计师在图片命名上的困扰<br>更换风格方便，只需在一张或几张图片上修改颜色或样式即可实现</p>
<p>缺点：</p>
<p>图片合并麻烦<br>图片合并时需预留好足够空间，宽屏、高分辨率的屏幕下易出现背景断裂<br>开发较麻烦，测量繁琐；<br>维护麻烦，修改一个图片可能需要重新布局整个图片，样式</p>
<h2 id="什么是-CSS-预处理器-后处理器？为什么要使用它们？"><a href="#什么是-CSS-预处理器-后处理器？为什么要使用它们？" class="headerlink" title="什么是 CSS 预处理器/后处理器？为什么要使用它们？"></a>什么是 CSS 预处理器/后处理器？为什么要使用它们？</h2><p>CSS预处理器定义了一种新的语言，其基本思想是，用一种专门的编程语言，为CSS增加了一些编程的特性，将CSS作为目标生成<br>文件，然后开发者就只要使用这种语言进行编码工作。通俗的说，CSS预处理器用一种专门的编程语言，进行Web页面样式设计，然<br>后再编译成正常的CSS文件。</p>
<p>预处理器例如：LESS、Sass、Stylus，用来预编译Sass或less csssprite，增强了css代码的复用性，还有层级、mixin、<br>变量、循环、函数等，具有很方便的UI组件模块化开发能力，极大的提高工作效率。</p>
<p>CSS后处理器是对CSS进行处理，并最终生成CSS的预处理器，它属于广义上的CSS预处理器。我们很久以前就在用CSS后<br>处理器了，最典型的例子是CSS压缩工具（如clean-css），只不过以前没单独拿出来说过。还有最近比较火的Autoprefixer，<br>以CanIUse上的浏览器支持数据为基础，自动处理兼容性问题。</p>
<p>后处理器例如：PostCSS，通常被视为在完成的样式表中根据CSS规范处理CSS，让其更有效；目前最常做的是给CSS属性添加浏<br>览器私有前缀，实现跨浏览器兼容性的问题。</p>
<p>为什么要使用它们？<br>结构清晰，便于扩展。<br>可以方便地屏蔽浏览器私有语法差异。这个不用多说，封装对浏览器语法差异的重复处理，减少无意义的机械劳动。<br>可以轻松实现多重继承。<br>完全兼容 CSS 代码，可以方便地应用到老项目中。LESS 只是在 CSS 语法上做了扩展，所以老的 CSS 代码也可以与 LESS 代码一同编译。</p>
<h2 id="style-标签写在-body-后与-body-前有什么区别？"><a href="#style-标签写在-body-后与-body-前有什么区别？" class="headerlink" title="style 标签写在 body 后与 body 前有什么区别？"></a>style 标签写在 body 后与 body 前有什么区别？</h2><p>页面加载自上而下当然是先加载样式。写在body标签后由于浏览器以逐行方式对HTML文档进行解析，当解析到写在尾部的样式<br>表（外联或写在style标签）会导致浏览器停止之前的渲染，等待加载且解析样式表完成之后重新渲染，在windows的IE下可<br>能会出现FOUC现象（即样式失效导致的页面闪烁问题）</p>
<h2 id="什么是-Cookie-隔离？（或者说：请求资源的时候不要让它带-cookie-怎么做）"><a href="#什么是-Cookie-隔离？（或者说：请求资源的时候不要让它带-cookie-怎么做）" class="headerlink" title="什么是 Cookie 隔离？（或者说：请求资源的时候不要让它带 cookie 怎么做）"></a>什么是 Cookie 隔离？（或者说：请求资源的时候不要让它带 cookie 怎么做）</h2><p>网站向服务器请求的时候，会自动带上cookie这样增加表头信息量，使请求变慢。</p>
<p>如果静态文件都放在主域名下，那静态文件请求的时候都带有的cookie的数据提交给server的，非常浪费流量，所以不如隔离开<br>，静态资源放CDN。</p>
<p>因为cookie有域的限制，因此不能跨域提交请求，故使用非主要域名的时候，请求头中就不会带有cookie数据，这样可以降低请<br>求头的大小，降低请求时间，从而达到降低整体请求延时的目的。</p>
<p>同时这种方式不会将cookie传入WebServer，也减少了WebServer对cookie的处理分析环节，提高了webserver的<br>http请求的解析速度。</p>
<h2 id="浏览器如何判断是否支持-webp-格式图片"><a href="#浏览器如何判断是否支持-webp-格式图片" class="headerlink" title="浏览器如何判断是否支持 webp 格式图片"></a>浏览器如何判断是否支持 webp 格式图片</h2><p>（1）宽高判断法。通过创建image对象，将其src属性设置为webp格式的图片，然后在onload事件中获取图片的宽高，如<br>果能够获取，则说明浏览器支持webp格式图片。如果不能获取或者触发了onerror函数，那么就说明浏览器不支持webp格<br>式的图片。</p>
<p>（2）canvas判断方法。我们可以动态的创建一个canvas对象，通过canvas的toDataURL将设置为webp格式，然后判断<br>返回值中是否含有image/webp字段，如果包含则说明支持WebP，反之则不支持。</p>
<h2 id="png、jpg、gif-这些图片格式解释一下，分别什么时候用。有没有了解过-webp？"><a href="#png、jpg、gif-这些图片格式解释一下，分别什么时候用。有没有了解过-webp？" class="headerlink" title="png、jpg、gif 这些图片格式解释一下，分别什么时候用。有没有了解过 webp？"></a>png、jpg、gif 这些图片格式解释一下，分别什么时候用。有没有了解过 webp？</h2><p>我了解到的一共有七种常见的图片的格式。</p>
<p>（1）第一种是BMP格式，它是无损压缩的，支持索引色和直接色的点阵图。由于它基本上没有进行压缩，因此它的文件体积一般比<br>较大。</p>
<p>（2）第二种是GIF格式，它是无损压缩的使用索引色的点阵图。由于使用了LZW压缩方法，因此文件的体积很小。并且GIF还<br>支持动画和透明度。但因为它使用的是索引色，所以它适用于一些对颜色要求不高且需要文件体积小的场景。</p>
<p>（3）第三种是JPEG格式，它是有损压缩的使用直接色的点阵图。由于使用了直接色，色彩较为丰富，一般适用于来存储照片。但<br>由于使用的是直接色，可能文件的体积相对于GIF格式来说更大。</p>
<p>（4）第四种是PNG-8格式，它是无损压缩的使用索引色的点阵图。它是GIF的一种很好的替代格式，它也支持透明度的调整，并<br>且文件的体积相对于GIF格式更小。一般来说如果不是需要动画的情况，我们都可以使用PNG-8格式代替GIF格式。</p>
<p>（5）第五种是PNG-24格式，它是无损压缩的使用直接色的点阵图。PNG-24的优点是它使用了压缩算法，所以它的体积比BMP<br>格式的文件要小得多，但是相对于其他的几种格式，还是要大一些。</p>
<p>（6）第六种格式是svg格式，它是矢量图，它记录的图片的绘制方式，因此对矢量图进行放大和缩小不会产生锯齿和失真。它一般<br>适合于用来制作一些网站logo或者图标之类的图片。</p>
<p>（7）第七种格式是webp格式，它是支持有损和无损两种压缩方式的使用直接色的点阵图。使用webp格式的最大的优点是，在相<br>同质量的文件下，它拥有更小的文件体积。因此它非常适合于网络图片的传输，因为图片体积的减少，意味着请求时间的减小，<br>这样会提高用户的体验。这是谷歌开发的一种新的图片格式，目前在兼容性上还不是太好。</p>
<h2 id="overflow-scroll-时不能平滑滚动的问题怎么处理？"><a href="#overflow-scroll-时不能平滑滚动的问题怎么处理？" class="headerlink" title="overflow:scroll 时不能平滑滚动的问题怎么处理？"></a>overflow:scroll 时不能平滑滚动的问题怎么处理？</h2><p>以下代码可解决这种卡顿的问题：-webkit-overflow-scrolling:touch;是因为这行代码启用了硬件加速特性，所以滑动很流<br>畅。</p>
<h2 id="如何让去除-inline-block-元素间间距？"><a href="#如何让去除-inline-block-元素间间距？" class="headerlink" title="如何让去除 inline-block 元素间间距？"></a>如何让去除 inline-block 元素间间距？</h2><p>移除空格、使用margin负值、使用font-size:0、letter-spacing、word-spacing</p>
<h2 id="如果需要手动写动画，你认为最小时间间隔是多久，为什么？-1"><a href="#如果需要手动写动画，你认为最小时间间隔是多久，为什么？-1" class="headerlink" title="如果需要手动写动画，你认为最小时间间隔是多久，为什么？"></a>如果需要手动写动画，你认为最小时间间隔是多久，为什么？</h2><p>多数显示器默认频率是60Hz，即1秒刷新60次，所以理论上最小间隔为1/60*1000ms＝16.7ms</p>
<h2 id="position-fixed-在-android-下无效怎么处理？"><a href="#position-fixed-在-android-下无效怎么处理？" class="headerlink" title="position:fixed;在 android 下无效怎么处理？"></a>position:fixed;在 android 下无效怎么处理？</h2><p>因为移动端浏览器默认的viewport叫做layout viewport。在移动端显示时，因为layout viewport的宽度大于移动端屏幕<br>的宽度，所以页面会出现滚动条左右移动，fixed的元素是相对layout viewport来固定位置的，而不是移动端屏幕来固定位置的<br>，所以会出现感觉fixed无效的情况。</p>
<p>如果想实现fixed相对于屏幕的固定效果，我们需要改变的是viewport的大小为ideal viewport，可以如下设置：</p>
<p>metaname=”viewport”content=”width=device-width,initial-scale=1.0,maximum-scale=1.0,minimum-sca<br>le=1.0,user-scalable=no”</p>
<h2 id="layout-viewport、visual-viewport-和-ideal-viewport-的区别？"><a href="#layout-viewport、visual-viewport-和-ideal-viewport-的区别？" class="headerlink" title="layout viewport、visual viewport 和 ideal viewport 的区别？"></a>layout viewport、visual viewport 和 ideal viewport 的区别？</h2><p>移动端一共需要理解三个viewport的概念的理解。</p>
<p>第一个视口是布局视口，在移动端显示网页时，由于移动端的屏幕尺寸比较小，如果网页使用移动端的屏幕尺寸进行布局的话，那么整<br>个页面的布局都会显示错乱。所以移动端浏览器提供了一个layout viewport布局视口的概念，使用这个视口来对页面进行布局展<br>示，一般layout viewport的大小为980px，因此页面布局不会有太大的变化，我们可以通过拖动和缩放来查看到这个页面。</p>
<p>第二个视口指的是视觉视口，visual viewport指的是移动设备上我们可见的区域的视口大小，一般为屏幕的分辨率的大小。visu<br>al viewport和layout viewport的关系，就像是我们通过窗户看外面的风景，视觉视口就是窗户，而外面的风景就是布局视口<br>中的网页内容。</p>
<p>第三个视口是理想视口，由于layout viewport一般比visual viewport要大，所以想要看到整个页面必须通过拖动和缩放才<br>能实现。所以又提出了ideal viewport的概念，ideal viewport下用户不用缩放和滚动条就能够查看到整个页面，并且页面在<br>不同分辨率下显示的内容大小相同。ideal viewport其实就是通过修改layout viewport的大小，让它等于设备的宽度，这个<br>宽度可以理解为是设备独立像素，因此根据ideal viewport设计的页面，在不同分辨率的屏幕下，显示应该相同。</p>
<h2 id="设备像素、css-像素、设备独立像素、dpr、ppi-之间的区别？"><a href="#设备像素、css-像素、设备独立像素、dpr、ppi-之间的区别？" class="headerlink" title="设备像素、css 像素、设备独立像素、dpr、ppi 之间的区别？"></a>设备像素、css 像素、设备独立像素、dpr、ppi 之间的区别？</h2><p>设备像素指的是物理像素，一般手机的分辨率指的就是设备像素，一个设备的设备像素是不可变的。</p>
<p>css像素和设备独立像素是等价的，不管在何种分辨率的设备上，css像素的大小应该是一致的，css像素是一个相对单位，它是相<br>对于设备像素的，一个css像素的大小取决于页面缩放程度和dpr的大小。</p>
<p>dpr指的是设备像素和设备独立像素的比值，一般的pc屏幕，dpr=1。在iphone4时，苹果推出了retina屏幕，它的dpr<br>为2。屏幕的缩放会改变dpr的值。</p>
<p>ppi指的是每英寸的物理像素的密度，ppi越大，屏幕的分辨率越大。</p>
<h2 id="font-style-属性中-italic-和-oblique-的区别？"><a href="#font-style-属性中-italic-和-oblique-的区别？" class="headerlink" title="font-style 属性中 italic 和 oblique 的区别？"></a>font-style 属性中 italic 和 oblique 的区别？</h2><p>italic和oblique这两个关键字都表示“斜体”的意思。</p>
<p>它们的区别在于，italic是使用当前字体的斜体字体，而oblique只是单纯地让文字倾斜。如果当前字体没有对应的斜体字体，<br>则退而求其次，解析为oblique，也就是单纯形状倾斜。</p>
<h2 id="如何修改-chrome-记住密码后自动填充表单的黄色背景？"><a href="#如何修改-chrome-记住密码后自动填充表单的黄色背景？" class="headerlink" title="如何修改 chrome 记住密码后自动填充表单的黄色背景？"></a>如何修改 chrome 记住密码后自动填充表单的黄色背景？</h2><p>chrome表单自动填充后，input文本框的背景会变成黄色的，通过审查元素可以看到这是由于chrome会默认给自动填充的in<br>put表单加上input:-webkit-autofill私有属性，然后对其赋予以下样式：</p>
<p>{<br>background-color:rgb(250,255,189)!important;<br>background-image:none!important;<br>color:rgb(0,0,0)!important;<br>}</p>
<p>对chrome默认定义的background-color，background-image，color使用important是不能提高其优先级的，但是<br>其他属性可使用。</p>
<p>使用足够大的纯色内阴影来覆盖input输入框的黄色背景，处理如下</p>
<p>input:-webkit-autofill,textarea:-webkit-autofill,select:-webkit-autofill{<br>-webkit-box-shadow:000px 1000px white inset;<br>border:1px solid #CCC !important;<br>}</p>
<h2 id="对于-hasLayout-的理解？"><a href="#对于-hasLayout-的理解？" class="headerlink" title="对于 hasLayout 的理解？"></a>对于 hasLayout 的理解？</h2><p>hasLayout是IE特有的一个属性。很多的IE下的css bug都与其息息相关。在IE中，一个元素要么自己对自身的内容进<br>行计算大小和组织，要么依赖于父元素来计算尺寸和组织内容。当一个元素的hasLayout属性值为true时，它负责对自己和可<br>能的子孙元素进行尺寸计算和定位。虽然这意味着这个元素需要花更多的代价来维护自身和里面的内容，而不是依赖于祖先元素来完<br>成这些工作。</p>
<h2 id="absolute-的-containingblock（包含块）计算方式跟正常流有什么不同？"><a href="#absolute-的-containingblock（包含块）计算方式跟正常流有什么不同？" class="headerlink" title="absolute 的 containingblock（包含块）计算方式跟正常流有什么不同？"></a>absolute 的 containingblock（包含块）计算方式跟正常流有什么不同？</h2><p>（1）内联元素也可以作为“包含块”所在的元素；</p>
<p>（2）“包含块”所在的元素不是父块级元素，而是最近的position不为static的祖先元素或根元素；</p>
<p>（3）边界是padding box而不是content box。</p>
<h2 id="为什么不建议使用统配符初始化-css-样式。"><a href="#为什么不建议使用统配符初始化-css-样式。" class="headerlink" title="为什么不建议使用统配符初始化 css 样式。"></a>为什么不建议使用统配符初始化 css 样式。</h2><p>采用*{padding:0;margin:0;}这样的写法好处是写起来很简单，但是是通配符，需要把所有的标签都遍历一遍，当网站较大时，<br>样式比较多，这样写就大大的加强了网站运行的负载，会使网站加载的时候需要很长一段时间，因此一般大型的网站都有分层次的一<br>套初始化样式。</p>
<p>出于性能的考虑，并不是所有标签都会有padding和margin，因此对常见的具有默认padding和margin的元素初始化即<br>可，并不需使用通配符*来初始化。</p>
<h2 id="简单说一下-css3-的-all-属性。"><a href="#简单说一下-css3-的-all-属性。" class="headerlink" title="简单说一下 css3 的 all 属性。"></a>简单说一下 css3 的 all 属性。</h2><p>all属性实际上是所有CSS属性的缩写，表示，所有的CSS属性都怎样怎样，但是，不包括unicode-bidi和direction<br>这两个CSS属性。支持三个CSS通用属性值，initial,inherit,unset。</p>
<p>initial是初始值的意思，也就是该元素元素都除了unicode-bidi和direction以外的CSS属性都使用属性的默认初始<br>值。</p>
<p>inherit是继承的意思，也就是该元素除了unicode-bidi和direction以外的CSS属性都继承父元素的属性值。</p>
<p>unset是取消设置的意思，也就是当前元素浏览器或用户设置的CSS忽略，然后如果是具有继承特性的CSS，如color，则<br>使用继承值；如果是没有继承特性的CSS属性，如background-color，则使用初始值。</p>
<h2 id="抽离样式模块怎么写，说出思路，有无实践经验？"><a href="#抽离样式模块怎么写，说出思路，有无实践经验？" class="headerlink" title="抽离样式模块怎么写，说出思路，有无实践经验？"></a>抽离样式模块怎么写，说出思路，有无实践经验？</h2><p>我的理解是把常用的css样式单独做成css文件……通用的和业务相关的分离出来，通用的做成样式模块儿共享，业务相关的，放<br>进业务相关的库里面做成对应功能的模块儿。</p>
<h2 id="IFC-是什么？"><a href="#IFC-是什么？" class="headerlink" title="IFC 是什么？"></a>IFC 是什么？</h2><p>IFC指的是行级格式化上下文，它有这样的一些布局规则：</p>
<p>（1）行级上下文内部的盒子会在水平方向，一个接一个地放置。<br>（2）当一行不够的时候会自动切换到下一行。<br>（3）行级上下文的高度由内部最高的内联盒子的高度决定。</p>
<h2 id="margin-重叠问题的理解。"><a href="#margin-重叠问题的理解。" class="headerlink" title="margin 重叠问题的理解。"></a>margin 重叠问题的理解。</h2><p>块级元素的上外边距（margin-top）与下外边距（margin-bottom）有时会合并为单个外边距，这样的现象称为“margin合<br>并”。</p>
<p>产生折叠的必备条件：margin必须是邻接的!</p>
<p>而根据w3c规范，两个margin是邻接的必须满足以下条件：</p>
<p>•必须是处于常规文档流（非float和绝对定位）的块级盒子，并且处于同一个BFC当中。<br>•没有线盒，没有空隙，没有padding和border将他们分隔开<br>•都属于垂直方向上相邻的外边距，可以是下面任意一种情况<br>•元素的margin-top与其第一个常规文档流的子元素的margin-top<br>•元素的margin-bottom与其下一个常规文档流的兄弟元素的margin-top<br>•height为auto的元素的margin-bottom与其最后一个常规文档流的子元素的margin-bottom<br>•高度为0并且最小高度也为0，不包含常规文档流的子元素，并且自身没有建立新的BFC的元素的margin-top<br>和margin-bottom</p>
<p>margin合并的3种场景：</p>
<p>（1）相邻兄弟元素margin合并。</p>
<p>解决办法：<br>•设置块状格式化上下文元素（BFC）</p>
<p>（2）父级和第一个/最后一个子元素的margin合并。</p>
<p>解决办法：</p>
<p>对于margin-top合并，可以进行如下操作（满足一个条件即可）：<br>•父元素设置为块状格式化上下文元素；<br>•父元素设置border-top值；<br>•父元素设置padding-top值；<br>•父元素和第一个子元素之间添加内联元素进行分隔。</p>
<p>对于margin-bottom合并，可以进行如下操作（满足一个条件即可）：<br>•父元素设置为块状格式化上下文元素；<br>•父元素设置border-bottom值；<br>•父元素设置padding-bottom值；<br>•父元素和最后一个子元素之间添加内联元素进行分隔；<br>•父元素设置height、min-height或max-height。</p>
<p>（3）空块级元素的margin合并。</p>
<p>解决办法：<br>•设置垂直方向的border；<br>•设置垂直方向的padding；<br>•里面添加内联元素（直接Space键空格是没用的）；<br>•设置height或者min-height。</p>
<p>margin重叠指的是在垂直方向上，两个相邻元素的margin发生重叠的情况。</p>
<p>一般来说可以分为四种情形：</p>
<p>第一种是相邻兄弟元素的marin-bottom和margin-top的值发生重叠。这种情况下我们可以通过设置其中一个元素为BFC<br>来解决。</p>
<p>第二种是父元素的margin-top和子元素的margin-top发生重叠。它们发生重叠是因为它们是相邻的，所以我们可以通过这<br>一点来解决这个问题。我们可以为父元素设置border-top、padding-top值来分隔它们，当然我们也可以将父元素设置为BFC<br>来解决。</p>
<p>第三种是高度为auto的父元素的margin-bottom和子元素的margin-bottom发生重叠。它们发生重叠一个是因为它们相<br>邻，一个是因为父元素的高度不固定。因此我们可以为父元素设置border-bottom、padding-bottom来分隔它们，也可以为<br>父元素设置一个高度，max-height和min-height也能解决这个问题。当然将父元素设置为BFC是最简单的方法。</p>
<p>第四种情况，是没有内容的元素，自身的margin-top和margin-bottom发生的重叠。我们可以通过为其设置border、pa<br>dding或者高度来解决这个问题。</p>
<h2 id="‘display’、’position’和’float’的相互关系？"><a href="#‘display’、’position’和’float’的相互关系？" class="headerlink" title="‘display’、’position’和’float’的相互关系？"></a>‘display’、’position’和’float’的相互关系？</h2><p>（1）首先我们判断display属性是否为none，如果为none，则position和float属性的值不影响元素最后的表现。</p>
<p>（2）然后判断position的值是否为absolute或者fixed，如果是，则float属性失效，并且display的值应该被<br>设置为table或者block，具体转换需要看初始转换值。</p>
<p>（3）如果position的值不为absolute或者fixed，则判断float属性的值是否为none，如果不是，则display<br>的值则按上面的规则转换。注意，如果position的值为relative并且float属性的值存在，则relative相对<br>于浮动后的最终位置定位。</p>
<p>（4）如果float的值为none，则判断元素是否为根元素，如果是根元素则display属性按照上面的规则转换，如果不是，<br>则保持指定的display属性值不变。</p>
<p>总的来说，可以把它看作是一个类似优先级的机制，”position:absolute”和”position:fixed”优先级最高，有它存在<br>的时候，浮动不起作用，’display’的值也需要调整；其次，元素的’float’特性的值不是”none”的时候或者它是根元素<br>的时候，调整’display’的值；最后，非根元素，并且非浮动元素，并且非绝对定位的元素，’display’特性值同设置值。</p>
<h2 id="简单介绍使用图片-base64-编码的优点和缺点。"><a href="#简单介绍使用图片-base64-编码的优点和缺点。" class="headerlink" title="简单介绍使用图片 base64 编码的优点和缺点。"></a>简单介绍使用图片 base64 编码的优点和缺点。</h2><p>base64编码是一种图片处理格式，通过特定的算法将图片编码成一长串字符串，在页面上显示的时候，可以用该字符串来代替图片的<br>url属性。</p>
<p>使用base64的优点是：</p>
<p>（1）减少一个图片的HTTP请求</p>
<p>使用base64的缺点是：</p>
<p>（1）根据base64的编码原理，编码后的大小会比原文件大小大1/3，如果把大图片编码到html/css中，不仅会造成文件体<br>积的增加，影响文件的加载速度，还会增加浏览器对html或css文件解析渲染的时间。</p>
<p>（2）使用base64无法直接缓存，要缓存只能缓存包含base64的文件，比如HTML或者CSS，这相比域直接缓存图片的效果要<br>差很多。</p>
<p>（3）兼容性的问题，ie8以前的浏览器不支持。</p>
<p>一般一些网站的小图标可以使用base64图片来引入。</p>
<h2 id="绝对定位元素与非绝对定位元素的百分比计算的区别"><a href="#绝对定位元素与非绝对定位元素的百分比计算的区别" class="headerlink" title="绝对定位元素与非绝对定位元素的百分比计算的区别"></a>绝对定位元素与非绝对定位元素的百分比计算的区别</h2><p>绝对定位元素的宽高百分比是相对于临近的position不为static的祖先元素的padding box来计算的。</p>
<p>非绝对定位元素的宽高百分比则是相对于父元素的content box来计算的。</p>
<h2 id="width-auto-和-width-100-的区别"><a href="#width-auto-和-width-100-的区别" class="headerlink" title="width:auto 和 width:100%的区别"></a>width:auto 和 width:100%的区别</h2><p>一般而言</p>
<p>width:100%会使元素box的宽度等于父元素的content box的宽度。</p>
<p>width:auto会使元素撑满整个父元素，margin、border、padding、content区域会自动分配水平空间。</p>
<h2 id="什么是包含块，对于包含块的理解"><a href="#什么是包含块，对于包含块的理解" class="headerlink" title="什么是包含块，对于包含块的理解?"></a>什么是包含块，对于包含块的理解?</h2><p>包含块（containing block）就是元素用来计算和定位的一个框。</p>
<p>（1）根元素（很多场景下可以看成是<html>）被称为“初始包含块”，其尺寸等同于浏览器可视窗口的大小。</html></p>
<p>（2）对于其他元素，如果该元素的position是relative或者static，则“包含块”由其最近的块容器祖先盒的content box<br>边界形成。</p>
<p>（3）如果元素position:fixed，则“包含块”是“初始包含块”。</p>
<p>（4）如果元素position:absolute，则“包含块”由最近的position不为static的祖先元素建立，具体方式如下：</p>
<p>如果该祖先元素是纯inline元素，则规则略复杂：<br>•假设给内联元素的前后各生成一个宽度为0的内联盒子（inline box），则这两个内联盒子的padding box外面的包<br>围盒就是内联元素的“包含块”；<br>•如果该内联元素被跨行分割了，那么“包含块”是未定义的，也就是CSS2.1规范并没有明确定义，浏览器自行发挥<br>否则，“包含块”由该祖先的padding box边界形成。</p>
<p>如果没有符合条件的祖先元素，则“包含块”是“初始包含块”。</p>
<h2 id="经常遇到的浏览器的兼容性有哪些？原因，解决方法是什么，常用-hack-的技巧？"><a href="#经常遇到的浏览器的兼容性有哪些？原因，解决方法是什么，常用-hack-的技巧？" class="headerlink" title="经常遇到的浏览器的兼容性有哪些？原因，解决方法是什么，常用 hack 的技巧？"></a>经常遇到的浏览器的兼容性有哪些？原因，解决方法是什么，常用 hack 的技巧？</h2><p>（1）png24位的图片在iE6浏览器上出现背景<br>解决方案：做成PNG8，也可以引用一段脚本处理。</p>
<p>（2）浏览器默认的margin和padding不同<br>解决方案：加一个全局的*{margin:0;padding:0;}来统一。</p>
<p>（3）IE6双边距bug：在IE6下，如果对元素设置了浮动，同时又设置了margin-left或<br>margin-right，margin值会加倍。</p>
<p>#box{float:left;width:10px;margin:0 0 0 10px;}</p>
<p>这种情况之下IE会产生20px的距离<br>解决方案：在float的标签样式控制中加入_display:inline;将其转化为行内属性。(_这个符号只有ie6会识别)</p>
<p>（4）渐进识别的方式，从总体中逐渐排除局部。<br>首先，巧妙的使用”\9”这一标记，将IE游览器从所有情况中分离出来。<br>接着，再次使用”+”将IE8和IE7、IE6分离开来，这样IE8已经独立识别。<br>.bb{<br>background-color:#f1ee18;/<em>所有识别</em>/<br>.background-color:#00deff\9;/<em>IE6、7、8识别</em>/<br>+background-color:#a200ff;/<em>IE6、7识别</em>/<br>_background-color:#1e0bd1;/<em>IE6识别</em>/<br>}</p>
<p>（5）IE下，可以使用获取常规属性的方法来获取自定义属性，也可以使用getAttribute()获取自定义<br>属性；Firefox下，只能使用getAttribute()获取自定义属性<br>解决方法：统一通过getAttribute()获取自定义属性。</p>
<p>（6）IE下，event对象有x、y属性，但是没有pageX、pageY属性;Firefox下，event对象有<br>pageX、pageY属性，但是没有x、y属性。<br>解决方法：（条件注释）缺点是在IE浏览器下可能会增加额外的HTTP请求数。</p>
<p>（7）Chrome中文界面下默认会将小于12px的文本强制按照12px显示<br>解决方法：</p>
<p>1.可通过加入CSS属性-webkit-text-size-adjust:none;解决。但是，在chrome<br>更新到27版本之后就不可以用了。</p>
<p>2.还可以使用-webkit-transform:scale(0.5);注意-webkit-transform:scale(0.75);<br>收缩的是整个span的大小，这时候，必须要将span转换成块元素，可以使用display：block/inline-block/…；</p>
<p>（8）超链接访问过后hover样式就不出现了，被点击访问过的超链接样式不再具有hover和active了<br>解决方法：改变CSS属性的排列顺序L-V-H-A</p>
<p>（9）怪异模式问题：漏写DTD声明，Firefox仍然会按照标准模式来解析网页，但在IE中会触发怪异模<br>式。为避免怪异模式给我们带来不必要的麻烦，最好养成书写DTD声明的好习惯。</p>
<h2 id="CSS-多列等高如何实现？"><a href="#CSS-多列等高如何实现？" class="headerlink" title="CSS 多列等高如何实现？"></a>CSS 多列等高如何实现？</h2><p>（1）利用padding-bottom|margin-bottom正负值相抵，不会影响页面布局的特点。设置父容器设置超出隐藏（overflow:<br>hidden），这样父容器的高度就还是它里面的列没有设定padding-bottom时的高度，当它里面的任一列高度增加了，则<br>父容器的高度被撑到里面最高那列的高度，其他比这列矮的列会用它们的padding-bottom补偿这部分高度差。</p>
<p>（2）利用table-cell所有单元格高度都相等的特性，来实现多列等高。</p>
<p>（3）利用flex布局中项目align-items属性默认为stretch，如果项目未设置高度或设为auto，将占满整个容器的高度<br>的特性，来实现多列等高。</p>
<h2 id="请解释一下-CSS3-的-Flex-box（弹性盒布局模型），以及适用场景？"><a href="#请解释一下-CSS3-的-Flex-box（弹性盒布局模型），以及适用场景？" class="headerlink" title="请解释一下 CSS3 的 Flex box（弹性盒布局模型），以及适用场景？"></a>请解释一下 CSS3 的 Flex box（弹性盒布局模型），以及适用场景？</h2><p>flex布局是CSS3新增的一种布局方式，我们可以通过将一个元素的display属性值设置为flex从而使它成为一个flex<br>容器，它的所有子元素都会成为它的项目。</p>
<p>一个容器默认有两条轴，一个是水平的主轴，一个是与主轴垂直的交叉轴。我们可以使用flex-direction来指定主轴的方向。<br>我们可以使用justify-content来指定元素在主轴上的排列方式，使用align-items来指定元素在交叉轴上的排列方式。还<br>可以使用flex-wrap来规定当一行排列不下时的换行方式。</p>
<p>对于容器中的项目，我们可以使用order属性来指定项目的排列顺序，还可以使用flex-grow来指定当排列空间有剩余的时候，<br>项目的放大比例。还可以使用flex-shrink来指定当排列空间不足时，项目的缩小比例。</p>
<h2 id="css-实现上下固定中间自适应布局？"><a href="#css-实现上下固定中间自适应布局？" class="headerlink" title="css 实现上下固定中间自适应布局？"></a>css 实现上下固定中间自适应布局？</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">利用绝对定位实现body &#123;</span><br><span class="line">  padding: 0;</span><br><span class="line">  margin: 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.header &#123;</span><br><span class="line">  position: absolute;</span><br><span class="line">  top: 0;</span><br><span class="line">  width: 100%;</span><br><span class="line">  height: 100px;</span><br><span class="line">  background: red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.container &#123;</span><br><span class="line">  position: absolute;</span><br><span class="line">  top: 100px;</span><br><span class="line">  bottom: 100px;</span><br><span class="line">  width: 100%;</span><br><span class="line">  background: green;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.footer &#123;</span><br><span class="line">  position: absolute;</span><br><span class="line">  bottom: 0;</span><br><span class="line">  height: 100px;</span><br><span class="line">  width: 100%;</span><br><span class="line">  background: red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">利用flex布局实现html,</span><br><span class="line">body &#123;</span><br><span class="line">  height: 100%;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">body &#123;</span><br><span class="line">  display: flex;</span><br><span class="line">  padding: 0;</span><br><span class="line">  margin: 0;</span><br><span class="line">  flex-direction: column;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.header &#123;</span><br><span class="line">  height: 100px;</span><br><span class="line">  background: red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.container &#123;</span><br><span class="line">  flex-grow: 1;</span><br><span class="line">  background: green;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.footer &#123;</span><br><span class="line">  height: 100px;</span><br><span class="line">  background: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="relative-的特殊性"><a href="#relative-的特殊性" class="headerlink" title="relative 的特殊性"></a>relative 的特殊性</h2><p>（1）相对定位元素的left/top/right/bottom的百分比值是相对于包含块计算的，而不是自身。注意，虽然定位位移是相对自身，但是百分比值的计算值不是。</p>
<p>（2）top和bottom这两个垂直方向的百分比值计算跟height的百分比值是一样的，都是相对高度计算的。同时，如果包含块的高度是auto，那么计算值是0，偏移无效，也就是说，如果父元素没有设定高度或者不是“格式化高度”，那么relative类似top:20%的代码等同于top:0。</p>
<p>（3）当相对定位元素同时应用对立方向定位值的时候，也就是top/bottom和left/right同时使用的时候，只有一个方向的定位属性会起作用。而谁起作用则是与文档流的顺序有关的，默认的文档流是自上而下、从左往右，因此top/bottom同时使用的时候，bottom失效；left/right同时使用的时候，right失效。</p>
<h2 id="CSS-怎么画一个大小为父元素宽度一半的正方形？"><a href="#CSS-怎么画一个大小为父元素宽度一半的正方形？" class="headerlink" title="CSS 怎么画一个大小为父元素宽度一半的正方形？"></a>CSS 怎么画一个大小为父元素宽度一半的正方形？</h2> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> &lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot; /&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;</span><br><span class="line">    &lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">      .outer &#123;</span><br><span class="line">        width: 400px;</span><br><span class="line">        height: 600px;</span><br><span class="line">        background: red;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      .inner &#123;</span><br><span class="line">        width: 50%;</span><br><span class="line">        padding-bottom: 50%;</span><br><span class="line">        background: blue;</span><br><span class="line">      &#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;div class=&quot;outer&quot;&gt;</span><br><span class="line">      &lt;div class=&quot;inner&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="CSS实现自适应正方形、等宽高比矩形"><a href="#CSS实现自适应正方形、等宽高比矩形" class="headerlink" title="CSS实现自适应正方形、等宽高比矩形"></a>CSS实现自适应正方形、等宽高比矩形</h2><ol>
<li><p>双重嵌套，外层 relative，内层 absolute</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> &lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot; /&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;</span><br><span class="line">    &lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">      .outer &#123;</span><br><span class="line">        padding-top: 50%;</span><br><span class="line">        height: 0;</span><br><span class="line">        background: #ccc;</span><br><span class="line">        width: 50%;</span><br><span class="line">        position: relative;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      .inner &#123;</span><br><span class="line">        position: absolute;</span><br><span class="line">        width: 100%;</span><br><span class="line">        height: 100%;</span><br><span class="line">        top: 0;</span><br><span class="line">        left: 0;</span><br><span class="line">        background: blue;</span><br><span class="line">      &#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;div class=&quot;outer&quot;&gt;</span><br><span class="line">      &lt;div class=&quot;inner&quot;&gt;hello&lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>padding 撑高画正方形</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> &lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot; /&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;</span><br><span class="line">    &lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">      .outer &#123;</span><br><span class="line">        width: 400px;</span><br><span class="line">        height: 600px;</span><br><span class="line">        background: blue;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      .inner &#123;</span><br><span class="line">        width: 100%;</span><br><span class="line">        height: 0;</span><br><span class="line">        padding-bottom: 100%;</span><br><span class="line">        background: red;</span><br><span class="line">      &#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;div class=&quot;outer&quot;&gt;</span><br><span class="line">      &lt;div class=&quot;inner&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>相对于视口 VW VH</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> &lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot; /&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;</span><br><span class="line">    &lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">      .inner &#123;</span><br><span class="line">        width: 1vw;</span><br><span class="line">        height: 1vw;</span><br><span class="line">        background: blue;</span><br><span class="line">      &#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;div class=&quot;outer&quot;&gt;</span><br><span class="line">      &lt;div class=&quot;inner&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
<p> 4、伪元素设置 margin-top</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot; /&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;</span><br><span class="line">    &lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">      .inner &#123;</span><br><span class="line">        width: 100px;</span><br><span class="line">        overflow: hidden;</span><br><span class="line">        background: blue;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      .inner::after &#123;</span><br><span class="line">        content: &quot;&quot;;</span><br><span class="line">        margin-top: 100%;</span><br><span class="line">        display: block;</span><br><span class="line">      &#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;div class=&quot;outer&quot;&gt;</span><br><span class="line">      &lt;div class=&quot;inner&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="CSS-动画有哪些？"><a href="#CSS-动画有哪些？" class="headerlink" title="CSS 动画有哪些？"></a>CSS 动画有哪些？</h2><p>animation：用于设置动画属性，他是一个简写的属性，包含6个属性<br>transition：用于设置元素的样式过度，和animation有着类似的效果，但细节上有很大的不同<br>transform：用于元素进行旋转、缩放、移动或倾斜，和设置样式的动画并没有什么关系<br>translate：translate只是transform的一个属性值，即移动，除此之外还有 scale 等</p>
<h2 id="visibility-和-display-的差别（还有opacity"><a href="#visibility-和-display-的差别（还有opacity" class="headerlink" title="visibility 和 display 的差别（还有opacity)"></a>visibility 和 display 的差别（还有opacity)</h2><ol>
<li>visibility 设置 hidden 会隐藏元素，但是其位置还存在与页面文档流中，不会被删除，所以会触发浏览器渲染引擎的重绘</li>
<li>display 设置了 none 属性会隐藏元素，且其位置也不会被保留下来，所以会触发浏览器渲染引擎的回流和重绘。</li>
<li>opacity 会将元素设置为透明，但是其位置也在页面文档流中，不会被删除，所以会触发浏览器渲染引擎的重绘</li>
</ol>
<h2 id="BFC会与float元素相互覆盖吗？为什么？举例说明"><a href="#BFC会与float元素相互覆盖吗？为什么？举例说明" class="headerlink" title="BFC会与float元素相互覆盖吗？为什么？举例说明"></a>BFC会与float元素相互覆盖吗？为什么？举例说明</h2><p>不会，因为 BFC 是页面中一个独立的隔离容器，其内部的元素不会与外部的元素相互影响，比如两个 div，上面的 div 设置了 float，那么如果下面的元素不是 BFC，也没有设置 float，会形成对上面的元素进行包裹内容的情况，如果设置了下面元素为 overflow：hidden；属性那么就能够实现经典的两列布局，左边内容固定宽度，右边因为是 BFC 所以会进行自适应。</p>
<h2 id="两个div上下排列，都设margin，有什么现象？"><a href="#两个div上下排列，都设margin，有什么现象？" class="headerlink" title="两个div上下排列，都设margin，有什么现象？"></a>两个div上下排列，都设margin，有什么现象？</h2><p>1）都正取大<br>2）一正一负相加</p>
<p>问：为什么会有这种现象？你能解释一下吗<br>是由块级格式上下文决定的，BFC，元素在 BFC 中会进行上下排列，然后垂直距离由 margin 决定，并且会发生重叠，具体表现为同正取最大的，同负取绝对值最大的，一正一负，相加<br>BFC 是页面中一个独立的隔离容器，内部的子元素不会影响到外部的元素。</p>
<h2 id="用css2和css3分别写一下垂直居中和水平居中"><a href="#用css2和css3分别写一下垂直居中和水平居中" class="headerlink" title="用css2和css3分别写一下垂直居中和水平居中"></a>用css2和css3分别写一下垂直居中和水平居中</h2><p>CSS2<br>水平居中：</p>
<ol>
<li>div + margin: auto;</li>
<li>span + text-align</li>
</ol>
<p>垂直居中</p>
<ol>
<li>使用 position 然后 left/top 和 margin 的方式垂直居中（已知宽高和未知宽高）</li>
<li>使用 position + margin</li>
<li>使用 display: table-cell;</li>
</ol>
<p>已知宽高，进行水平垂直居中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot; /&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;</span><br><span class="line">    &lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">      .outer &#123;</span><br><span class="line">        position: relative;</span><br><span class="line">        width: 400px;</span><br><span class="line">        height: 600px;</span><br><span class="line">        background: blue;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      .inner &#123;</span><br><span class="line">        position: absolute;</span><br><span class="line">        width: 200px;</span><br><span class="line">        height: 300px;</span><br><span class="line">        background: red;</span><br><span class="line">        left: 50%;</span><br><span class="line">        top: 50%;</span><br><span class="line">        margin: -150px 0 0 -100px;</span><br><span class="line">      &#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;div class=&quot;outer&quot;&gt;</span><br><span class="line">      &lt;div class=&quot;inner&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>宽高未知，比如 内联元素，进行水平垂直居中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot; /&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;</span><br><span class="line">    &lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">      .outer &#123;</span><br><span class="line">        width: 400px;</span><br><span class="line">        height: 600px;</span><br><span class="line">        /* background: blue; */</span><br><span class="line">        border: 1px solid red;</span><br><span class="line">        background-color: transparent;</span><br><span class="line">        position: relative;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      .inner &#123;</span><br><span class="line">        position: absolute;</span><br><span class="line">        background: red;</span><br><span class="line">        left: 50%;</span><br><span class="line">        top: 50%;</span><br><span class="line">        transform: translate(-50%, -50%);</span><br><span class="line">      &#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;div class=&quot;outer&quot;&gt;</span><br><span class="line">      &lt;span class=&quot;inner&quot;&gt;我想居中显示&lt;/span&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>绝对定位的 div 水平垂直居中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot; /&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;</span><br><span class="line">    &lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">      .outer &#123;</span><br><span class="line">        width: 400px;</span><br><span class="line">        height: 600px;</span><br><span class="line">        /* background: blue; */</span><br><span class="line">        border: 1px solid red;</span><br><span class="line">        background-color: transparent;</span><br><span class="line">        position: relative;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      .inner &#123;</span><br><span class="line">        position: absolute;</span><br><span class="line">        background: red;</span><br><span class="line">        left: 0;</span><br><span class="line">        right: 0;</span><br><span class="line">        bottom: 0;</span><br><span class="line">        top: 0;</span><br><span class="line">        width: 200px;</span><br><span class="line">        height: 300px;</span><br><span class="line">        margin: auto;</span><br><span class="line">        border: 1px solid blue;</span><br><span class="line">      &#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;div class=&quot;outer&quot;&gt;</span><br><span class="line">      &lt;div class=&quot;inner&quot;&gt;我想居中显示&lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>图片和其他元素使用 display: table-cell; 进行垂直居中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot; /&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;</span><br><span class="line">    &lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">      .outer &#123;</span><br><span class="line">        width: 400px;</span><br><span class="line">        height: 600px;</span><br><span class="line">        /* background: blue; */</span><br><span class="line">        border: 1px solid red;</span><br><span class="line">        background-color: transparent;</span><br><span class="line">        display: table-cell;</span><br><span class="line">        vertical-align: middle;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      .inner &#123;</span><br><span class="line">        background: red;</span><br><span class="line">        width: 200px;</span><br><span class="line">        height: 300px;</span><br><span class="line">        border: 1px solid blue;</span><br><span class="line">        margin: 0 auto;</span><br><span class="line">      &#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;div class=&quot;outer&quot;&gt;</span><br><span class="line">      &lt;div class=&quot;inner&quot;&gt;我想居中显示&lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>CSS3<br>垂直、水平居中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot; /&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;</span><br><span class="line">    &lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">      .outer &#123;</span><br><span class="line">        width: 400px;</span><br><span class="line">        height: 600px;</span><br><span class="line"></span><br><span class="line">        display: flex;</span><br><span class="line">        </span><br><span class="line">        /* 垂直居中 */</span><br><span class="line">        align-items: center;</span><br><span class="line">        </span><br><span class="line">        /* 水平居中 */</span><br><span class="line">        justify-content: center;</span><br><span class="line">        border: 1px solid red;</span><br><span class="line">        background-color: transparent;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      .inner &#123;</span><br><span class="line">        background: red;</span><br><span class="line">        width: 200px;</span><br><span class="line">        height: 300px;</span><br><span class="line">        border: 1px solid blue;</span><br><span class="line">      &#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;div class=&quot;outer&quot;&gt;</span><br><span class="line">      &lt;div class=&quot;inner&quot;&gt;我想居中显示&lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<h2 id="html-根元素的默认-display-为-block"><a href="#html-根元素的默认-display-为-block" class="headerlink" title="html 根元素的默认 display 为 block"></a>html 根元素的默认 display 为 block</h2><h2 id="‘-’-与-‘-’-选择器有什么不同"><a href="#‘-’-与-‘-’-选择器有什么不同" class="headerlink" title="‘+’ 与 ‘~’ 选择器有什么不同"></a>‘+’ 与 ‘~’ 选择器有什么不同</h2><ol>
<li><ul>
<li>选择器匹配紧邻的兄弟元素</li>
</ul>
</li>
<li>~ 选择器匹配随后的所有兄弟元素</li>
</ol>
<h2 id="css-动画与-js-动画哪个性能更好"><a href="#css-动画与-js-动画哪个性能更好" class="headerlink" title="css 动画与 js 动画哪个性能更好"></a>css 动画与 js 动画哪个性能更好</h2><p>CSS3 的动画：</p>
<ol>
<li>在性能上会稍微好一些，浏览器会对 CSS3 的动画做一些优化（比如专门新建一个图层用来跑动画）</li>
<li>代码相对简单</li>
<li>在动画控制上不够灵活</li>
<li>兼容性不好</li>
<li>部分动画功能无法实现（如滚动动画，视差滚动等）</li>
</ol>
<p>JavaScript 的动画：<br>正好弥补了 css 缺点，控制能力很强，可以单帧的控制、变换，同时写得好完全可以兼容 IE6，并且功能强大。<br>总结： 对于一些复杂控制的动画，使用 javascript 会比较好。而在实现一些小的交互动效的时候，可以多考虑 CSS</p>
<h2 id="css-如何匹配前-N-个子元素及最后-N-个子元素，偶数，奇数"><a href="#css-如何匹配前-N-个子元素及最后-N-个子元素，偶数，奇数" class="headerlink" title="css 如何匹配前 N 个子元素及最后 N 个子元素，偶数，奇数"></a>css 如何匹配前 N 个子元素及最后 N 个子元素，偶数，奇数</h2><ol>
<li>如何匹配最前三个子元素: :nth-child(-n+3)</li>
<li>如何匹配最后三个子元素: :nth-last-child(-n+3)</li>
<li>如何匹配双行样式: nth-child(2n)/nth-child(even)</li>
<li>如何匹配单行样式: nth-child(2n+1)/nth-child(odd)</li>
</ol>
<h2 id="如何使用-CSS-实现网站的暗黑模式-Dark-Mode"><a href="#如何使用-CSS-实现网站的暗黑模式-Dark-Mode" class="headerlink" title="如何使用 CSS 实现网站的暗黑模式 (Dark Mode)"></a>如何使用 CSS 实现网站的暗黑模式 (Dark Mode)</h2><p>prefers-color-scheme<br>@media (prefers-color-scheme: dark) {<br>  :root {<br>  }<br>}</p>
<h2 id="css-如何实现响应式布局大屏幕三等分、中屏幕二等分、小屏幕一等分"><a href="#css-如何实现响应式布局大屏幕三等分、中屏幕二等分、小屏幕一等分" class="headerlink" title="css 如何实现响应式布局大屏幕三等分、中屏幕二等分、小屏幕一等分"></a>css 如何实现响应式布局大屏幕三等分、中屏幕二等分、小屏幕一等分</h2><p>Grid 布局可以自动判断容器大小，无论大小屏幕自动撑满并均分，请看以下属性</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.container &#123;</span><br><span class="line">  grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>repeat: 用以 N 整分</li>
<li>auto-fill：表示自动填充</li>
<li>minmx: 即书面意思，最小宽度为 300px</li>
</ol>
<h2 id="前端开发中如何进行多主题配置"><a href="#前端开发中如何进行多主题配置" class="headerlink" title="前端开发中如何进行多主题配置"></a>前端开发中如何进行多主题配置</h2><h2 id="如何自定义滚动条的样式"><a href="#如何自定义滚动条的样式" class="headerlink" title="如何自定义滚动条的样式"></a>如何自定义滚动条的样式</h2><p>滚动条相关样式都是伪元素，以 scrollbar 打头，有以下伪元素，从 -webkit 中可见兼容性一般，不过无所谓，现在 Chrome 浏览器占大头</p>
<p>· ::-webkit-scrollbar — 整个滚动条.<br>· ::-webkit-scrollbar-button — 滚动条上的按钮 (上下箭头).<br>· ::-webkit-scrollbar-thumb — 滚动条上的滚动滑块.<br>· ::-webkit-scrollbar-track — 滚动条轨道.<br>· ::-webkit-scrollbar-track-piece — 滚动条没有滑块的轨道部分.<br>· ::-webkit-scrollbar-corner — 当同时有垂直滚动条和水平滚动条时交汇的部分.<br>· ::-webkit-resizer — 某些元素的 corner 部分的部分样式(例:textarea 的可拖动按钮).</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">::-webkit-scrollbar &#123;</span><br><span class="line">  width: 6px;</span><br><span class="line">  height: 6px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">::-webkit-scrollbar-track &#123;</span><br><span class="line">  border-radius: 3px;</span><br><span class="line">  background: rgba(0, 0, 0);</span><br><span class="line">  box-shadow: inset 0 0 5px rgba(0, 0, 0, 0.08);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">::-webkit-scrollbar-thumb &#123;</span><br><span class="line">  border-radius: 3px;</span><br><span class="line">  background: rgba(0, 0, 1);</span><br><span class="line">  box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="网站设置字体时，如何设置优先使用系统默认字体"><a href="#网站设置字体时，如何设置优先使用系统默认字体" class="headerlink" title="网站设置字体时，如何设置优先使用系统默认字体"></a>网站设置字体时，如何设置优先使用系统默认字体</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">font-family: system-ui;</span><br></pre></td></tr></table></figure>

<h2 id="写-CSS-时如何避免命名样式冲突"><a href="#写-CSS-时如何避免命名样式冲突" class="headerlink" title="写 CSS 时如何避免命名样式冲突"></a>写 CSS 时如何避免命名样式冲突</h2><ol>
<li><p>BEM 式: .home-page .home-page-btn</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.home-page &#123;</span><br><span class="line">  .home-page-btn &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>BEM 有一个缺点，就是有些太长，可适当简化，只包裹该页面组件的根类名，但有可能增加样式冲突的风险</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.home-page &#123;</span><br><span class="line">  .btn &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>CSS Scoped<br>scoped css 会对当前组件(scope)下所有元素生成唯一的属性或类名，对所有 CSS 规则将携带唯一属性实现作用域的命名保护</p>
</li>
<li><p>CSS Module<br>module css 会对类名进行 hash 化</p>
</li>
</ol>
<h2 id="CSS-如何设置方格背景"><a href="#CSS-如何设置方格背景" class="headerlink" title="CSS 如何设置方格背景"></a>CSS 如何设置方格背景</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">background: linear-gradient(90deg, rgba(200, 200, 200, 0.1) 3%, transparent 0),</span><br><span class="line">  linear-gradient(rgba(200, 200, 200, 0.1) 3%, transparent 0);</span><br><span class="line">background-size: 20px 20px;</span><br></pre></td></tr></table></figure>

<h2 id="aspect-ratio"><a href="#aspect-ratio" class="headerlink" title="aspect-ratio"></a>aspect-ratio</h2><p>aspect ratio翻译为中文就是宽高比（也称：纵横比）即x:y。</p>
<h2 id="normalize-css-与-reset-css-又何区别"><a href="#normalize-css-与-reset-css-又何区别" class="headerlink" title="normalize.css 与 reset.css 又何区别"></a>normalize.css 与 reset.css 又何区别</h2><p>· normalize.css (opens new window): 会保留有用的样式，比如 h1 的字体大小<br>· reset.css (opens new window): 把所有样式都重置，比如 h1、h2、h3 的字体大小都进行了重置，保持了无样式</p>
<h2 id="Grid-布局的优势在哪里"><a href="#Grid-布局的优势在哪里" class="headerlink" title="Grid 布局的优势在哪里"></a>Grid 布局的优势在哪里</h2><p>Flex 布局是轴线布局，只能指定”项目”针对轴线的位置，可以看作是一维布局。 Grid 布局则是将容器划分成”行”和”列”，产生单元格，然后指定”项目所在”的单元格，可以看作是二维布局。 Grid 布局远比 Flex 布局强大</p>
<h2 id="css-加载会阻塞-DOM-树的解析和渲染吗"><a href="#css-加载会阻塞-DOM-树的解析和渲染吗" class="headerlink" title="css 加载会阻塞 DOM 树的解析和渲染吗"></a>css 加载会阻塞 DOM 树的解析和渲染吗</h2><p>css 加载会直接影响网页的渲染，因为只有 css 加载完毕，构建完 CSSOM 后，渲染树(Render Tree)才会构建，然后渲染成位图</p>
<p>如果 html 中有加载 script 的话，还会间接影响 DOM 树的解析，因为 javascript 的下载、解析和执行和阻塞 DOM 树的解析，而 javascript 中有可能访问 CSSOM，比如 Element.getBoundingClientRect，因此 CSSOM 构建完毕以后才会开始 javascript 的执行，间接阻塞 dom 树的解析</p>
<h2 id="如何理解-CSS-的继承和重用？"><a href="#如何理解-CSS-的继承和重用？" class="headerlink" title="如何理解 CSS 的继承和重用？"></a>如何理解 CSS 的继承和重用？</h2><p>继承：在一个属性应用于一个特定标签之后，该标签的子标签也应该应用该属性。这一行为称为继承。但并不是所有的属性都会被继承。如文字样式一般都继承，盒图的宽高一般不 继承，总之该继承的都会继承，不该继承的都不继承。<br>重用：一个样式文件，可以多个页面使用，这对于一些公共样式的重构是很有用的。</p>
<h2 id="如何水平并且垂直居中一张背景图"><a href="#如何水平并且垂直居中一张背景图" class="headerlink" title="如何水平并且垂直居中一张背景图"></a>如何水平并且垂直居中一张背景图</h2><p>设置 background-position:center;</p>
<h2 id="font-style属性可以让它赋值为“oblique”是什么意思"><a href="#font-style属性可以让它赋值为“oblique”是什么意思" class="headerlink" title="font-style属性可以让它赋值为“oblique”是什么意思"></a>font-style属性可以让它赋值为“oblique”是什么意思</h2><p>让一种字体标识为斜体(oblique)，如果没有这种格式，就使用italic字体</p>
<h2 id="常见的浏览器内核有哪些？"><a href="#常见的浏览器内核有哪些？" class="headerlink" title="常见的浏览器内核有哪些？"></a>常见的浏览器内核有哪些？</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">**Trident内核**：IE,MaxThon,TT,The World,360,搜狗浏览器等。[又称MSHTML]</span><br><span class="line">**Gecko内核**：Netscape6及以上版本，FF,MozillaSuite/SeaMonkey等。</span><br><span class="line">**Presto内核**：Opera7及以上。[Opera内核原为：Presto，现为：Blink;]</span><br><span class="line">**Webkit内核**：Safari,Chrome等。[ Chrome的：Blink（WebKit的分支）]</span><br><span class="line">**EdgeHTML内核**：Microsoft Edge。[此内核其实是从MSHTML fork而来，删掉了几乎所有的</span><br></pre></td></tr></table></figure>

<h2 id="介绍一下你对浏览器内核的理解"><a href="#介绍一下你对浏览器内核的理解" class="headerlink" title="介绍一下你对浏览器内核的理解"></a>介绍一下你对浏览器内核的理解</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">主要分成两部分：渲染引擎（layout engineer或Rendering Engine）和 JS 引擎。</span><br><span class="line">（1）渲染引擎：负责取得网页的内容（HTML、XML、图像等等）、整理讯息（例如加入CSS等），以及计算网页的显示方式，然后会输出至显示器或打印机。浏览器的内核的不同对于网页的语法解释会有不同，所以渲染的效果也不相同。所有网页浏览器、电子邮件客户以及其他它所需要编辑、显示网络的应用程序都需要内核。</span><br><span class="line">（2）JS引擎则：解析和执行JavaScript 来实现网页的动态效果；</span><br><span class="line">最开始渲染引擎和 JS 并没有区分的很明确，后来JS引擎越来越独立，内核就倾向于只渲染引擎。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="CSS引入的方式有哪些？使用Link和-import有什么区别？"><a href="#CSS引入的方式有哪些？使用Link和-import有什么区别？" class="headerlink" title="CSS引入的方式有哪些？使用Link和@import有什么区别？"></a>CSS引入的方式有哪些？使用Link和@import有什么区别？</h2><p>答：内联，内嵌，外链，导入<br>（1）link 属于 XHTML 标签，除了加载 CSS 外，还能用于定义RSS，定义 rel 连接属性等作用，无兼容性，支持使用javascript改变样式；而@import是CSS提供的，只能用于加载CSS，不支持使用 javascript 改变样式；<br>（2）页面被加载的时，link 会被同时加载，而@import 引用的CSS会等到页面加载完再加载；<br>（3）import是CSS2.1 提出的，CSS2.1以下浏览器不支持，只在IE5以上才能被识别，而link是XHTML标签，无兼容问题。</p>
<h2 id="translate-方法能移动一个元素在z轴上的位置？"><a href="#translate-方法能移动一个元素在z轴上的位置？" class="headerlink" title="translate()方法能移动一个元素在z轴上的位置？"></a>translate()方法能移动一个元素在z轴上的位置？</h2><p>不能。它只能移动x,y轴的位置。translate3d可以。</p>
<h2 id="rgba-和-opacity-的透明效果有什么不同？"><a href="#rgba-和-opacity-的透明效果有什么不同？" class="headerlink" title="rgba() 和 opacity 的透明效果有什么不同？"></a>rgba() 和 opacity 的透明效果有什么不同？</h2><p>rgba()和opacity都能实现透明效果，但最大的不同是opacity作用于元素，以及元素内的所有内容的透明度，<br>而rgba()只作用于元素的颜色或其背景色。（设置rgba透明的元素的子元素不会继承透明效果！）</p>
<h2 id="CSS-伪类和伪元素的区别？"><a href="#CSS-伪类和伪元素的区别？" class="headerlink" title="CSS 伪类和伪元素的区别？"></a>CSS 伪类和伪元素的区别？</h2><p>伪类： :focus、:hover、:active<br>伪元素：:before、:after<br>伪类本质上是为了弥补常规CSS选择器的不足，以便获取到更多信息；<br>伪元素本质上是创建了一个有内容的虚拟容器；<br>CSS3中伪类和伪元素的语法不同；<br>可以同时使用多个伪类，而只能同时使用一个伪元素；</p>
<h2 id="transition和animation的区别"><a href="#transition和animation的区别" class="headerlink" title="transition和animation的区别"></a>transition和animation的区别</h2><p>· transition是过度属性，强调过度，它的实现需要触发一个事件（比如鼠标移动上去，焦点，点击等）才执行动画。它类似于flash的补间动画，设置一个开始关键帧，一个结束关键帧。</p>
<p>· animation是动画属性，它的实现不需要触发事件，设定好时间之后可以自己执行，且可以循环一个动画。它也类似于flash的补间动画，但是它可以设置多个关键帧（用@keyframe定义）完成动画。</p>
<h2 id="对requestAnimationframe的理解"><a href="#对requestAnimationframe的理解" class="headerlink" title="对requestAnimationframe的理解"></a>对requestAnimationframe的理解</h2><p>实现动画效果的方法比较多，Javascript 中可以通过定时器 setTimeout 来实现，CSS3 中可以使用 transition 和 animation 来实现，HTML5 中的 canvas 也可以实现。除此之外，HTML5 提供一个专门用于请求动画的API，那就是 requestAnimationFrame，顾名思义就是请求动画帧。</p>
<p>MDN对该方法的描述：<br>window.requestAnimationFrame() 告诉浏览器——你希望执行一个动画，并且要求浏览器在下次重绘之前调用指定的回调函数更新动画。该方法需要传入一个回调函数作为参数，该回调函数会在浏览器下一次重绘之前执行。</p>
<p>优势：</p>
<ol>
<li>CPU节能：使用SetTinterval 实现的动画，当页面被隐藏或最小化时，SetTinterval 仍然在后台执行动画任务，由于此时页面处于不可见或不可用状态，刷新动画是没有意义的，完全是浪费CPU资源。而RequestAnimationFrame则完全不同，当页面处理未激活的状态下，该页面的屏幕刷新任务也会被系统暂停，因此跟着系统走的RequestAnimationFrame也会停止渲染，当页面被激活时，动画就从上次停留的地方继续执行，有效节省了CPU开销。</li>
<li>函数节流：在高频率事件( resize, scroll 等)中，为了防止在一个刷新间隔内发生多次函数执行，RequestAnimationFrame可保证每个刷新间隔内，函数只被执行一次，这样既能保证流畅性，也能更好的节省函数执行的开销，一个刷新间隔内函数执行多次时没有意义的，因为多数显示器每16.7ms刷新一次，多次绘制并不会在屏幕上体现出来。</li>
<li>减少DOM操作：requestAnimationFrame 会把每一帧中的所有DOM操作集中起来，在一次重绘或回流中就完成，并且重绘或回流的时间间隔紧紧跟随浏览器的刷新频率，一般来说，这个频率为每秒60帧。</li>
</ol>
<h2 id="为什么有时候⽤translate来改变位置⽽不是定位"><a href="#为什么有时候⽤translate来改变位置⽽不是定位" class="headerlink" title="为什么有时候⽤translate来改变位置⽽不是定位"></a>为什么有时候⽤translate来改变位置⽽不是定位</h2><p>translate 是 transform 属性的⼀个值。改变transform或opacity不会触发浏览器重新布局（reflow）或重绘（repaint），只会触发复合（compositions）。⽽改变绝对定位会触发重新布局，进⽽触发重绘和复合。transform使浏览器为元素创建⼀个 GPU 图层，但改变绝对定位会使⽤到 CPU。 因此translate()更⾼效，可以缩短平滑动画的绘制时间。 ⽽translate改变位置时，元素依然会占据其原始空间，绝对定位就不会发⽣这种情况。</p>
<h2 id="替换元素的概念及计算规则"><a href="#替换元素的概念及计算规则" class="headerlink" title="替换元素的概念及计算规则"></a>替换元素的概念及计算规则</h2><p>通过修改某个属性值呈现的内容就可以被替换的元素就称为“替换元素”。<br>替换元素除了内容可替换这一特性以外，还有以下特性：</p>
<ol>
<li>内容的外观不受页面上的CSS的影响：用专业的话讲就是在样式表现在CSS作用域之外。如何更改替换元素本身的外观需要类似appearance属性，或者浏览器自身暴露的一些样式接口。</li>
<li>有自己的尺寸：在Web中，很多替换元素在没有明确尺寸设定的情况下，其默认的尺寸（不包括边框）是300像素×150像素，如</li>
<li>在很多CSS属性上有自己的一套表现规则：比较具有代表性的就是vertical-align属性，对于替换元素和非替换元素，vertical-align属性值的解释是不一样的。比方说vertical-align的默认值的baseline，很简单的属性值，基线之意，被定义为字符x的下边缘，而替换元素的基线却被硬生生定义成了元素的下边缘。</li>
<li>所有的替换元素都是内联水平元素：也就是替换元素和替换元素、替换元素和文字都是可以在一行显示的。但是，替换元素默认的display值却是不一样的，有的是inline，有的是inline-block。</li>
</ol>
<p>替换元素的尺寸从内而外分为三类：</p>
<ol>
<li>固有尺寸： 指的是替换内容原本的尺寸。例如，图片、视频作为一个独立文件存在的时候，都是有着自己的宽度和高度的。</li>
<li>HTML尺寸： 只能通过HTML原生属性改变，这些HTML原生属性包括的width和height属性、的size属性。</li>
<li>CSS尺寸： 特指可以通过CSS的width和height或者max-width/min-width和max-height/min-height设置的尺寸，对应盒尺寸中的content box。</li>
</ol>
<p>这三层结构的计算规则具体如下：<br>（1）如果没有CSS尺寸和HTML尺寸，则使用固有尺寸作为最终的宽高。<br>（2）如果没有CSS尺寸，则使用HTML尺寸作为最终的宽高。<br>（3）如果有CSS尺寸，则最终尺寸由CSS属性决定。<br>（4）如果“固有尺寸”含有固有的宽高比例，同时仅设置了宽度或仅设置了高度，则元素依然按照固有的宽高比例显示。<br>（5）如果上面的条件都不符合，则最终宽度表现为300像素，高度为150像素。<br>（6）内联替换元素和块级替换元素使用上面同一套尺寸计算规则。</p>
<h2 id="什么是物理像素，逻辑像素和像素密度，为什么在移动端开发时需要用到-3x-2x这种图片？"><a href="#什么是物理像素，逻辑像素和像素密度，为什么在移动端开发时需要用到-3x-2x这种图片？" class="headerlink" title="什么是物理像素，逻辑像素和像素密度，为什么在移动端开发时需要用到@3x, @2x这种图片？"></a>什么是物理像素，逻辑像素和像素密度，为什么在移动端开发时需要用到@3x, @2x这种图片？</h2><p>以 iPhone XS 为例，当写 CSS 代码时，针对于单位 px，其宽度为 414px &amp; 896px，也就是说当赋予一个 DIV元素宽度为 414px，这个 DIV 就会填满手机的宽度；</p>
<p>而如果有一把尺子来实际测量这部手机的物理像素，实际为 1242*2688 物理像素；经过计算可知，1242/414=3，也就是说，在单边上，一个逻辑像素=3个物理像素，就说这个屏幕的像素密度为 3，也就是常说的 3 倍屏。</p>
<p>对于图片来说，为了保证其不失真，1 个图片像素至少要对应一个物理像素，假如原始图片是 500300 像素，那么在 3 倍屏上就要放一个 1500900 像素的图片才能保证 1 个物理像素至少对应一个图片像素，才能不失真。</p>
<h2 id="对-CSS-工程化的理解"><a href="#对-CSS-工程化的理解" class="headerlink" title="对 CSS 工程化的理解"></a>对 CSS 工程化的理解</h2><p>CSS 工程化是为了解决以下问题：</p>
<ol>
<li>宏观设计：CSS 代码如何组织、如何拆分、模块结构怎样设计？</li>
<li>编码优化：怎样写出更好的 CSS？</li>
<li>构建：如何处理我的 CSS，才能让它的打包结果最优？</li>
<li>可维护性：代码写完了，如何最小化它后续的变更成本？如何确保任何一个同事都能轻松接手？</li>
</ol>
<p>以下三个方向都是时下比较流行的、普适性非常好的 CSS 工程化实践：</p>
<ol>
<li>预处理器：Less、 Sass 等；</li>
<li>重要的工程化插件： PostCss；</li>
<li>Webpack loader 等 。</li>
</ol>
<h2 id="PostCss：PostCss-是如何工作的？我们在什么场景下会使用-PostCss？"><a href="#PostCss：PostCss-是如何工作的？我们在什么场景下会使用-PostCss？" class="headerlink" title="PostCss：PostCss 是如何工作的？我们在什么场景下会使用 PostCss？"></a>PostCss：PostCss 是如何工作的？我们在什么场景下会使用 PostCss？</h2><p>它和预处理器的不同就在于，预处理器处理的是 类CSS，而 PostCss 处理的就是 CSS 本身。Babel 可以将高版本的 JS 代码转换为低版本的 JS 代码。PostCss 做的是类似的事情：它可以编译尚未被浏览器广泛支持的先进的 CSS 语法，还可以自动为一些需要额外兼容的语法增加前缀。更强的是，由于 PostCss 有着强大的插件机制，支持各种各样的扩展，极大地强化了 CSS 的能力。<br>PostCss 在业务中的使用场景非常多：</p>
<ol>
<li>提高 CSS 代码的可读性：PostCss 其实可以做类似预处理器能做的工作；</li>
<li>当我们的 CSS 代码需要适配低版本浏览器时，PostCss 的 Autoprefixer 插件可以帮助我们自动增加浏览器前缀；</li>
<li>允许我们编写面向未来的 CSS：PostCss 能够帮助我们编译 CSS next 代码；</li>
</ol>
<h2 id="Webpack-能处理-CSS-吗？如何实现？-Webpack-能处理-CSS-吗："><a href="#Webpack-能处理-CSS-吗？如何实现？-Webpack-能处理-CSS-吗：" class="headerlink" title="Webpack 能处理 CSS 吗？如何实现？ Webpack 能处理 CSS 吗："></a>Webpack 能处理 CSS 吗？如何实现？ Webpack 能处理 CSS 吗：</h2><p>· Webpack 在裸奔的状态下，是不能处理 CSS 的，Webpack 本身是一个面向 JavaScript 且只能处理 JavaScript 代码的模块化打包工具；<br>· Webpack 在 loader 的辅助下，是可以处理 CSS 的。</p>
<p>如何用 Webpack 实现对 CSS 的处理：</p>
<ol>
<li>Webpack 中操作 CSS 需要使用的两个关键的 loader：css-loader 和 style-loader</li>
<li>注意，答出“用什么”有时候可能还不够，面试官会怀疑你是不是在背答案，所以你还需要了解每个 loader 都做了什么事情：<br>· css-loader：导入 CSS 模块，对 CSS 代码进行编译处理；<br>· style-loader：创建style标签，把 CSS 内容写入标签。<br>在实际使用中，css-loader 的执行顺序一定要安排在 style-loader 的前面。因为只有完成了编译过程，才可以对 css 代码进行插入；若提前插入了未编译的代码，那么 webpack 是无法理解这坨东西的，它会无情报错。</li>
</ol>
<h2 id="z-index属性在什么情况下会失效"><a href="#z-index属性在什么情况下会失效" class="headerlink" title="z-index属性在什么情况下会失效"></a>z-index属性在什么情况下会失效</h2><p>通常 z-index 的使用是在有两个重叠的标签，在一定的情况下控制其中一个在另一个的上方或者下方出现。z-index值越大就越是在上层。z-index元素的position属性需要是relative，absolute或是fixed。<br>z-index属性在下列情况下会失效：</p>
<ol>
<li>父元素position为relative时，子元素的z-index失效。解决：父元素position改为absolute或static；</li>
<li>元素没有设置position属性为非static属性。解决：设置该元素的position属性为relative，absolute或是fixed中的一种；</li>
<li>元素在设置z-index的同时还设置了float浮动。解决：float去除，改为display：inline-block；</li>
</ol>
<h2 id="px、em、rem的区别及使用场景"><a href="#px、em、rem的区别及使用场景" class="headerlink" title="px、em、rem的区别及使用场景"></a>px、em、rem的区别及使用场景</h2><p>区别:</p>
<ol>
<li>px是固定的像素，一旦设置了就无法因为适应页面大小而改变。</li>
<li>em和rem相对于px更具有灵活性，他们是相对长度单位，其长度不是固定的，更适用于响应式布局。</li>
<li>em是相对于其父元素来设置字体大小，这样就会存在一个问题，进行任何元素设置，都有可能需要知道他父元素的大小。而rem是相对于根元素，这样就意味着，只需要在根元素确定一个参考值。<br>使用场景：</li>
<li>对于只需要适配少部分移动设备，且分辨率对页面影响不大的，使用px即可 。</li>
<li>对于需要适配各种移动设备，使用rem，例如需要适配iPhone和iPad等分辨率差别比较挺大的设备。</li>
</ol>
<h2 id="如何根据设计稿进行移动端适配？"><a href="#如何根据设计稿进行移动端适配？" class="headerlink" title="如何根据设计稿进行移动端适配？"></a>如何根据设计稿进行移动端适配？</h2><p>移动端适配主要有两个维度：</p>
<ol>
<li>适配不同像素密度， 针对不同的像素密度，使用 CSS 媒体查询，选择不同精度的图片，以保证图片不会失真；</li>
<li>适配不同屏幕大小， 由于不同的屏幕有着不同的逻辑像素大小，所以如果直接使用 px 作为开发单位，会使得开发的页面在某一款手机上可以准确显示，但是在另一款手机上就会失真。为了适配不同屏幕的大小，应按照比例来还原设计稿的内容。</li>
</ol>
<p>为了能让页面的尺寸自适应，可以使用 rem，em，vw，vh 等相对单位。</p>
<h2 id="absolute与fixed共同点与不同点"><a href="#absolute与fixed共同点与不同点" class="headerlink" title="absolute与fixed共同点与不同点"></a>absolute与fixed共同点与不同点</h2><p>共同点：</p>
<ol>
<li>改变行内元素的呈现方式，将display置为inline-block  </li>
<li>使元素脱离普通文档流，不再占据文档物理空间</li>
<li>覆盖非定位文档元素</li>
</ol>
<p>不同点：</p>
<ol>
<li>abuselute与fixed的根元素不同，abuselute的根元素可以设置，fixed根元素是浏览器。</li>
<li>在有滚动条的页面中，absolute会跟着父元素进行移动，fixed固定在页面的具体位置。</li>
</ol>
<h2 id="对-sticky-定位的理解"><a href="#对-sticky-定位的理解" class="headerlink" title="对 sticky 定位的理解"></a>对 sticky 定位的理解</h2><p>sticky 英文字面意思是粘贴，所以可以把它称之为粘性定位。语法：position: sticky; 基于用户的滚动位置来定位。<br>粘性定位的元素是依赖于用户的滚动，在 position:relative 与 position:fixed 定位之间切换。它的行为就像 position:relative; 而当页面滚动超出目标区域时，它的表现就像 position:fixed;，它会固定在目标位置。元素定位表现为在跨越特定阈值前为相对定位，之后为固定定位。这个特定阈值指的是 top, right, bottom 或 left 之一，换言之，指定 top, right, bottom 或 left 四个阈值其中之一，才可使粘性定位生效。否则其行为与相对定位相同。</p>
<h2 id="实现一个扇形"><a href="#实现一个扇形" class="headerlink" title="实现一个扇形"></a>实现一个扇形</h2><p>用CSS实现扇形的思路和三角形基本一致，就是多了一个圆角的样式，实现一个90°的扇形：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">div&#123;</span><br><span class="line">    border: 100px solid transparent;</span><br><span class="line">    width: 0;</span><br><span class="line">    heigt: 0;</span><br><span class="line">    border-radius: 100px;</span><br><span class="line">    border-top-color: red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="如何解决-1px-问题？"><a href="#如何解决-1px-问题？" class="headerlink" title="如何解决 1px 问题？"></a>如何解决 1px 问题？</h2><p>1px 问题指的是：在一些 Retina屏幕 的机型上，移动端页面的 1px 会变得很粗，呈现出不止 1px 的效果。原因很简单——CSS 中的 1px 并不能和移动设备上的 1px 划等号。它们之间的比例关系有一个专门的属性来描述：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">window.devicePixelRatio = 设备的物理像素 / CSS像素。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>打开 Chrome 浏览器，启动移动端调试模式，在控制台去输出这个 devicePixelRatio 的值。这里选中 iPhone6/7/8 这系列的机型，输出的结果就是2：<br>这就意味着设置的 1px CSS 像素，在这个设备上实际会用 2 个物理像素单元来进行渲染，所以实际看到的一定会比 1px 粗一些。 解决1px 问题的三种思路：</p>
<ol>
<li>思路一：直接写 0.5px<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">border:1px solid #333</span><br><span class="line"></span><br><span class="line">&lt;div id=&quot;container&quot; data-device=&#123;&#123;window.devicePixelRatio&#125;&#125;&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">#container[data-device=&quot;2&quot;] &#123;</span><br><span class="line">  border:0.5px solid #333</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>思路二：伪元素先放大后缩小<br>这个方法的可行性会更高，兼容性也更好。唯一的缺点是代码会变多。<br>思路是先放大、后缩小：在目标元素的后面追加一个 ::after 伪元素，让这个元素布局为 absolute 之后、整个伸展开铺在目标元素上，然后把它的宽和高都设置为目标元素的两倍，border值设为 1px。接着借助 CSS 动画特效中的放缩能力，把整个伪元素缩小为原来的 50%。此时，伪元素的宽高刚好可以和原有的目标元素对齐，而 border 也缩小为了 1px 的二分之一，间接地实现了 0.5px 的效果。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#container[data-device=&quot;2&quot;] &#123;</span><br><span class="line">    position: relative;</span><br><span class="line">&#125;</span><br><span class="line">#container[data-device=&quot;2&quot;]::after&#123;</span><br><span class="line">      position:absolute;</span><br><span class="line">      top: 0;</span><br><span class="line">      left: 0;</span><br><span class="line">      width: 200%;</span><br><span class="line">      height: 200%;</span><br><span class="line">      content:&quot;&quot;;</span><br><span class="line">      transform: scale(0.5);</span><br><span class="line">      transform-origin: left top;</span><br><span class="line">      box-sizing: border-box;</span><br><span class="line">      border: 1px solid #333;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>思路三：viewport 缩放来解决</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;meta name=&quot;viewport&quot; content=&quot;initial-scale=0.5, maximum-scale=0.5, minimum-scale=0.5, user-scalable=no&quot;&gt;</span><br><span class="line"></span><br><span class="line">const scale = 1 / window.devicePixelRatio;</span><br><span class="line">// 这里 metaEl 指的是 meta 标签对应的 Dom</span><br><span class="line">metaEl.setAttribute(&#x27;content&#x27;, `width=device-width,user-scalable=no,initial-scale=$&#123;scale&#125;,maximum-scale=$&#123;scale&#125;,minimum-scale=$&#123;scale&#125;`);</span><br><span class="line"></span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>面试</category>
        <category>css</category>
      </categories>
  </entry>
</search>
