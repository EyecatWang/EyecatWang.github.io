<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>call、 bind、apply区别</title>
    <url>/2021/08/19/call%E3%80%81apply%E5%92%8Cbind%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h1 id="call、-bind、apply区别"><a href="#call、-bind、apply区别" class="headerlink" title="call、 bind、apply区别"></a>call、 bind、apply区别</h1><p>我们都知道call apply bind都可以改变函数调用的this指向。那么它们三者有什么区别，什么时候该用哪个呢？</p>
<p>我们先来看MDN语法说明</p>
<h2 id="语法说明"><a href="#语法说明" class="headerlink" title="语法说明"></a>语法说明</h2><h3 id="1-call语法"><a href="#1-call语法" class="headerlink" title="1. call语法"></a>1. call语法</h3><ul>
<li>fun.call(thisArg, arg1, arg2, …)</li>
<li>thisArg: 在fun函数运行时指定的this值。需要注意的是，指定的this值并不一定是该函数执行时真正的this值，如果这个函数处于非严格模式下，则指定为null和undefined的this值会自动指向全局对象(浏览器中就是window对象)，同时值为原始值(数字，字符串，布尔值)的this会指向该原始值的自动包装对象。</li>
<li>arg1, arg2, … 指定的参数列表</li>
</ul>
<h3 id="2-apply语法"><a href="#2-apply语法" class="headerlink" title="2. apply语法"></a>2. apply语法</h3><ul>
<li>fun.apply(thisArg, [argsArray])</li>
<li>thisArg 在 fun 函数运行时指定的 this 值。需要注意的是，指定的 this 值并不一定是该函数执行时真正的 this 值，如果这个函数处于非严格模式下，则指定为 null 或 undefined 时会自动指向全局对象（浏览器中就是window对象），同时值为原始值（数字，字符串，布尔值）的 this 会指向该原始值的自动包装对象。</li>
<li>argsArray 一个数组或者类数组对象，其中的数组元素将作为单独的参数传给 fun 函数。如果该参数的值为null 或 undefined，则表示不需要传入任何参数。从ECMAScript 5 开始可以使用类数组对象。</li>
</ul>
<h3 id="3-bind语法"><a href="#3-bind语法" class="headerlink" title="3. bind语法"></a>3. bind语法</h3><ul>
<li>fun.bind(thisArg[, arg1[, arg2[, …]]])</li>
<li>thisArg 当绑定函数被调用时，该参数会作为原函数运行时的 this 指向。当使用new 操作符调用绑定函数时，该参数无效。</li>
<li>arg1, arg2, … 当绑定函数被调用时，这些参数将置于实参之前传递给被绑定的方法。</li>
</ul>
<h2 id="例子说明"><a href="#例子说明" class="headerlink" title="例子说明"></a>例子说明</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 有只猫叫小黑，小黑会吃鱼</span></span><br><span class="line"><span class="keyword">const</span> cat = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;小黑&#x27;</span>,</span><br><span class="line">    <span class="function"><span class="title">eatFish</span>(<span class="params">...args</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;this指向=&gt;&#x27;</span>, <span class="built_in">this</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;...args&#x27;</span>, args);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.name + <span class="string">&#x27;吃鱼&#x27;</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 有只狗叫大毛，大毛会吃骨头</span></span><br><span class="line"><span class="keyword">const</span> dog = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;大毛&#x27;</span>,</span><br><span class="line">    <span class="function"><span class="title">eatBone</span>(<span class="params">...args</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;this指向=&gt;&#x27;</span>, <span class="built_in">this</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;...args&#x27;</span>, args);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.name + <span class="string">&#x27;吃骨头&#x27;</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;=================== call =========================&#x27;</span>);</span><br><span class="line"><span class="comment">// 有一天大毛想吃鱼了，可是它不知道怎么吃。怎么办？小黑说我吃的时候喂你吃</span></span><br><span class="line">cat.eatFish.call(dog, <span class="string">&#x27;汪汪汪&#x27;</span>, <span class="string">&#x27;call&#x27;</span>)</span><br><span class="line"><span class="comment">// 大毛为了表示感谢，决定下次吃骨头的时候也喂小黑吃</span></span><br><span class="line">dog.eatBone.call(cat, <span class="string">&#x27;喵喵喵&#x27;</span>, <span class="string">&#x27;call&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;=================== apply =========================&#x27;</span>);</span><br><span class="line">cat.eatFish.apply(dog, [<span class="string">&#x27;汪汪汪&#x27;</span>, <span class="string">&#x27;apply&#x27;</span>])</span><br><span class="line">dog.eatBone.apply(cat, [<span class="string">&#x27;喵喵喵&#x27;</span>, <span class="string">&#x27;apply&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;=================== bind =========================&#x27;</span>);</span><br><span class="line"><span class="comment">// 有一天他们觉得每次吃的时候再喂太麻烦了。干脆直接教对方怎么吃</span></span><br><span class="line"><span class="keyword">const</span> test1 = cat.eatFish.bind(dog, <span class="string">&#x27;汪汪汪&#x27;</span>, <span class="string">&#x27;bind&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> test2 = dog.eatBone.bind(cat, <span class="string">&#x27;喵喵喵&#x27;</span>, <span class="string">&#x27;bind&#x27;</span>)</span><br><span class="line">test1()</span><br><span class="line">test2()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><p>call跟apply的用法几乎一样，唯一的不同就是传递的参数不同，call只能一个参数一个参数的传入。</p>
</li>
<li><p>apply则只支持传入一个数组，哪怕是一个参数也要是数组形式。最终调用函数时候这个数组会拆成一个个参数分别传入。</p>
</li>
<li><p>至于bind方法，他是直接改变这个函数的this指向并且返回一个新的函数，之后再次调用这个函数的时候this都是指向bind绑定的第一个参数。bind传餐方式跟call方法一致。</p>
</li>
</ul>
<p>由于apply函数传参的特殊性，我们又衍生出了一个黑魔法。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 如果一个数组我们已知里面全都是数字，想要知道最大的那个数，由于Array没有max方法，Math对象上有</span></span><br><span class="line"><span class="comment">// 我们可以根据apply传递参数的特性将这个数组当成参数传入</span></span><br><span class="line"><span class="comment">// 最终Math.max函数调用的时候会将apply的数组里面的参数一个一个传入，恰好符合Math.max的参数传递方式</span></span><br><span class="line"><span class="comment">// 这样变相的实现了数组的max方法。min方法也同理</span></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line"><span class="keyword">const</span> max = <span class="built_in">Math</span>.max.apply(<span class="literal">null</span>, arr)</span><br><span class="line"><span class="built_in">console</span>.log(max)    <span class="comment">// 6</span></span><br></pre></td></tr></table></figure>

<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>箭头函数没有this，会忽律第一个参数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> cat = &#123;</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&quot;小黑&quot;</span>,</span><br><span class="line">        <span class="attr">eatFish</span>: <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;this 指向=》&quot;</span>, <span class="built_in">this</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;...args=&gt;&quot;</span>, args);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.name + <span class="string">&quot;吃鱼&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> dog = &#123;</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&quot;大毛&quot;</span>,</span><br><span class="line">        <span class="function"><span class="title">eatBone</span>(<span class="params">...args</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&quot;this 指向=》&quot;</span>, <span class="built_in">this</span>);</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&quot;...args=&gt;&quot;</span>, args);</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="built_in">this</span>.name + <span class="string">&quot;吃骨头&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cat.eatFish.call(dog, <span class="string">&quot;1&quot;</span>, <span class="string">&quot;2&quot;</span>)</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>call 和 apply 的主要作用，是改变对象的执行上下文，并且是立即执行的。它们在参数上的写法略有区别。</p>
<p>bind 也能改变对象的执行上下文，它与 call 和 apply 不同的是，返回值是一个函数，并且需要稍后再调用一下，才会执行。</p>
]]></content>
      <categories>
        <category>js基础</category>
      </categories>
  </entry>
  <entry>
    <title>js实现call, apply, bind方法</title>
    <url>/2021/08/19/js%E5%AE%9E%E7%8E%B0call,%20apply,%20bind%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>#实现call方法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;叫爸爸&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> son = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;叫儿子&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="built_in">this</span>.name) </span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Function</span>.prototype.call_ = <span class="function"><span class="keyword">function</span> (<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//判断是否为null或者undefined,同时考虑传递参数不是对象情况</span></span><br><span class="line">    obj = obj ? <span class="built_in">Object</span>(obj) : <span class="built_in">window</span>;</span><br><span class="line">    <span class="keyword">var</span> args = [];</span><br><span class="line">    <span class="comment">// 注意i从1开始</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>, len = <span class="built_in">arguments</span>.length; i &lt; len; i++) &#123;</span><br><span class="line">        args.push(<span class="built_in">arguments</span>[i])</span><br><span class="line">    &#125;;</span><br><span class="line">    obj.fn = <span class="built_in">this</span>; <span class="comment">// 此时this就是函数fn</span></span><br><span class="line">    obj.fn(...args)</span><br><span class="line">    <span class="keyword">delete</span> obj.fn; <span class="comment">//删除fn</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>#实现apply方法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;叫爸爸&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> son = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;叫儿子&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="built_in">this</span>.name) </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Function</span>.prototype.apply_ = <span class="function"><span class="keyword">function</span> (<span class="params">obj, arr</span>) </span>&#123;</span><br><span class="line">    obj = obj ? <span class="built_in">Object</span>(obj): <span class="built_in">window</span></span><br><span class="line">    obj.fn = <span class="built_in">this</span></span><br><span class="line">    <span class="keyword">if</span> (!arr) &#123;</span><br><span class="line">        obj.fn();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> args = [];</span><br><span class="line">        <span class="comment">// 注意i从1开始</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>, len = <span class="built_in">arguments</span>.length; i &lt; len; i++) &#123;</span><br><span class="line">            args.push(<span class="built_in">arguments</span>[i])</span><br><span class="line">        &#125;;</span><br><span class="line">        obj.fn(...args)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span> obj.fn</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>#实现bind方法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;叫爸爸&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> son = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;叫儿子&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="built_in">this</span>.name) </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Function</span>.prototype.bind_ = <span class="function"><span class="keyword">function</span> (<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//判断是否为null或者undefined,同时考虑传递参数不是对象情况</span></span><br><span class="line">    obj = obj ? <span class="built_in">Object</span>(obj) : <span class="built_in">window</span>;</span><br><span class="line">    <span class="keyword">var</span> args = [];</span><br><span class="line">    <span class="comment">// 注意i从1开始</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>, len = <span class="built_in">arguments</span>.length; i &lt; len; i++) &#123;</span><br><span class="line">        args.push(<span class="built_in">arguments</span>[i])</span><br><span class="line">    &#125;;</span><br><span class="line">    obj.fn = <span class="built_in">this</span>; <span class="comment">// 此时this就是函数fn</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        obj.fn(...args)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>js基础</category>
      </categories>
  </entry>
  <entry>
    <title>js精度问题</title>
    <url>/2021/10/20/js%E7%B2%BE%E5%BA%A6%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>js中的数字按照IEEE 754的标准，使用64位双精度浮点型来表示。</p>
<p>其中符号位S，指数位E，尾数位M分别占了1，11，52位，并在ES5规范中指出了指数位E的取值范围是[-1074, 971].</p>
<h2 id="精度问题汇总"><a href="#精度问题汇总" class="headerlink" title="精度问题汇总"></a>精度问题汇总</h2><p>想用有限的位来表示无穷的数字，显然是不可能的，因此会出现一些列精度问题</p>
<p>· 浮点数精度问题，比如，0.1+0.2 !== 0.3<br>· 大数精度问题，比如9999 9999 9999 9999 == 1000 0000 0000 0000 1<br>· toFixed 四舍五入结果不准确，比如1.335.toFixed(2) == 1.33</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="number">1.335</span>).toPrecision(<span class="number">20</span>); <span class="comment">// &quot;1.3349999999999999645&quot;</span></span><br></pre></td></tr></table></figure>

<p>而关于大数精度问题，我们可以先看下面这个代码片段：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 能精确表示的整数范围上限,S为1个0，E为11个0，S为52个1</span></span><br><span class="line"><span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">53</span>) - <span class="number">1</span> === <span class="built_in">Number</span>.MAX_SAFE_INTEGER    <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 能精确表示的整数范围下限,S为1个1，E为11个0，S为52个1</span></span><br><span class="line">-(<span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">53</span>) - <span class="number">1</span>) === <span class="built_in">Number</span>.MIN_SAFE_INTEGER    <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 能表示的最大数字，S为1个0，E为971，S为52个1</span></span><br><span class="line">(<span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">53</span>) - <span class="number">1</span>) * <span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">971</span>) === <span class="built_in">Number</span>.MAX_VALUE    <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 能表示的最接近于0的正数，S为1个0，E为-1074，S为0</span></span><br><span class="line"><span class="built_in">Math</span>.pow(<span class="number">2</span>, -<span class="number">1074</span>) === <span class="built_in">Number</span>.MIN_VALUE <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>通过以上可以明白，[MIN_SAFE_INTEGER, MAX_SAFE_INTEGER] 的整数都可以精确表示，但是超出这个范围的整数就不一定能精确表示。这样就会产生所谓的大数精度丢失问题。</p>
<h2 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h2><p>首先考虑的是如何解决浮点数运算的精度问题，有 3 种思路：</p>
<p>· 考虑到每次浮点数运算的偏差非常小(其实不然)，可以对结果进行指定精度的四舍五入，比如可以parseFloat(result.toFixed(12));<br>· 将浮点数转为整数运算，再对结果做除法。比如0.1 + 0.2，可以转化为(1*2)/3。<br>· 把浮点数转化为字符串，模拟实际运算的过程。</p>
<p>先来看第一种方案，在大多数情况下，它可以得到正确结果，但是对一些极端情况，toFixed 到 12 是不够的，比如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">210000</span> * <span class="number">10000</span>  * <span class="number">1000</span> * <span class="number">8.2</span>    <span class="comment">// 17219999999999.998</span></span><br><span class="line"><span class="built_in">parseFloat</span>(<span class="number">17219999999999.998</span>.toFixed(<span class="number">12</span>));    <span class="comment">// 17219999999999.998，而正确结果为 17220000000000</span></span><br></pre></td></tr></table></figure>
<p>上面的情况，如果想让结果正确，需要 toFixed(2)，这显然是不可接受的。</p>
<p>再看第二种方案，比如 number-precision 这个库就是使用的这种方案，但是这也是有问题的，比如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这两个浮点数，转化为整数之后，相乘的结果已经超过了 MAX_SAFE_INTEGER</span></span><br><span class="line"><span class="number">123456.789</span> * <span class="number">123456.789</span>     <span class="comment">// 转化为 (123456789 * 123456789)/1000000，结果是 15241578750.19052</span></span><br></pre></td></tr></table></figure>

<p>所以，最终考虑使用第三种方案，目前已经有了很多较为成熟的库，比如 bignumber.js，decimal.js，以及big.js等。我们可以根据自己的需求来选择对应的工具。并且，这些库不仅解决了浮点数的运算精度问题，还支持了大数运算，并且修复了原生toFixed结果不准确的问题。</p>
]]></content>
      <categories>
        <category>js基础</category>
      </categories>
  </entry>
  <entry>
    <title>this指向</title>
    <url>/2021/07/06/this%E6%8C%87%E5%90%91/</url>
    <content><![CDATA[<p>面向对象语言中 this 表示当前对象的一个引用。</p>
<p>但在 JavaScript 中 this 不是固定不变的，它会随着执行环境的改变而改变。</p>
<ul>
<li>在方法中，this 表示该方法所属的对象。</li>
</ul>
<ul>
<li>如果单独使用，this 表示全局对象。</li>
</ul>
<ul>
<li>在函数中，this 表示全局对象。</li>
</ul>
<ul>
<li>在函数中，在严格模式下，this 是未定义的(undefined)。</li>
</ul>
<ul>
<li>在事件中，this 表示接收事件的元素。</li>
</ul>
<ul>
<li>类似 call() 和 apply() 方法可以将 this 引用到任何对象。</li>
</ul>
<h2 id="方法中的this"><a href="#方法中的this" class="headerlink" title="方法中的this"></a>方法中的this</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  <span class="attr">firstName</span>: <span class="string">&quot;John&quot;</span>,</span><br><span class="line">  <span class="attr">lastName</span> : <span class="string">&quot;Doe&quot;</span>,</span><br><span class="line">  <span class="attr">fullName</span> : <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.firstName + <span class="string">&quot; &quot;</span> + <span class="built_in">this</span>.lastName;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">person.fullName() <span class="comment">// John Doe</span></span><br></pre></td></tr></table></figure>
<p>在对象方法中， this 指向调用它所在方法的对象。</p>
<p>在上面一个实例中，this 表示 person 对象。</p>
<p>fullName 方法所属的对象就是 person。</p>
<h2 id="单独使用-this"><a href="#单独使用-this" class="headerlink" title="单独使用 this"></a>单独使用 this</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person = <span class="built_in">this</span> <span class="comment">// [object Window]</span></span><br></pre></td></tr></table></figure>
<p>单独使用 this，则它指向全局(Global)对象。</p>
<p>在浏览器中，window 就是该全局对象为 [object Window]:</p>
<p>ps: 严格模式下，如果单独使用，this 也是指向全局(Global)对象。</p>
<h2 id="函数中使用-this（默认）"><a href="#函数中使用-this（默认）" class="headerlink" title="函数中使用 this（默认）"></a>函数中使用 this（默认）</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myFunction</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>; <span class="comment">// [object Window]</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在函数中，函数的所属者默认绑定到 this 上。</p>
<p>在浏览器中，window 就是该全局对象为 [object Window]:</p>
<p>ps: 严格模式下，函数是没有绑定到this下，this是undefined</p>
<h2 id="事件中的-this"><a href="#事件中的-this" class="headerlink" title="事件中的 this"></a>事件中的 this</h2><p>在 HTML 事件句柄中，this 指向了接收事件的 HTML 元素：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;button onclick=<span class="string">&quot;this =&gt; buttonHtml对象&quot;</span>&gt;</span><br><span class="line">点我</span><br><span class="line">&lt;/button&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="对象方法中绑定"><a href="#对象方法中绑定" class="headerlink" title="对象方法中绑定"></a>对象方法中绑定</h2><p>下面实例中，this 是 person 对象，person 对象是函数的所有者：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  <span class="attr">firstName</span>  : <span class="string">&quot;John&quot;</span>,</span><br><span class="line">  <span class="attr">lastName</span>   : <span class="string">&quot;Doe&quot;</span>,</span><br><span class="line">  <span class="attr">id</span>         : <span class="number">5566</span>,</span><br><span class="line">  <span class="attr">myFunction</span> : <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">person.myFunction() <span class="comment">// [object Object]</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="显式函数绑定"><a href="#显式函数绑定" class="headerlink" title="显式函数绑定"></a>显式函数绑定</h2><p>在 JavaScript 中函数也是对象，对象则有方法，apply 和 call 就是函数对象的方法。</p>
<p>这两个方法异常强大，他们允许切换函数执行的上下文环境（context），即 this 绑定的对象。<br>在下面实例中，当我们使用 person2 作为参数来调用 person1.fullName 方法时, this 将指向 person2, 即便它是 person1 的方法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person1 = &#123;</span><br><span class="line">  <span class="attr">fullName</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.firstName + <span class="string">&quot; &quot;</span> + <span class="built_in">this</span>.lastName;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person2 = &#123;</span><br><span class="line">  <span class="attr">firstName</span>:<span class="string">&quot;John&quot;</span>,</span><br><span class="line">  <span class="attr">lastName</span>: <span class="string">&quot;Doe&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line">person1.fullName.call(person2);  <span class="comment">// 返回 &quot;John Doe&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="隐式绑定"><a href="#隐式绑定" class="headerlink" title="隐式绑定"></a>隐式绑定</h2><p>什么是隐式绑定呢，如果函数调用时，前面存在调用它的对象，那么this就会隐式绑定到这个对象上。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;听风是风&#x27;</span>,</span><br><span class="line">    <span class="attr">func</span>: fn</span><br><span class="line">&#125;;</span><br><span class="line">obj.func() <span class="comment">//听风是风</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如果函数调用前存在多个对象，this指向距离调用自己最近的对象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;行星飞行&#x27;</span>,</span><br><span class="line">    <span class="attr">func</span>: fn,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> obj1 = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;听风是风&#x27;</span>,</span><br><span class="line">    <span class="attr">o</span>: obj</span><br><span class="line">&#125;;</span><br><span class="line">obj1.o.func() <span class="comment">//行星飞行</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>那如果我们将obj对象的name属性注释掉，现在输出什么呢？</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    <span class="attr">func</span>: fn,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> obj1 = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;听风是风&#x27;</span>,</span><br><span class="line">    <span class="attr">o</span>: obj</span><br><span class="line">&#125;;</span><br><span class="line">obj1.o.func() <span class="comment">// undefined</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>大家千万不要将作用域链和原型链弄混淆了，obj对象虽然obj1的属性，但它两原型链并不相同，并不是父子关系，由于obj未提供name属性，所以是undefined。</p>
<p>既然说到原型链，那我们再来点花哨的，我们再改写例子，看看下面输出多少：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fn</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">Fn.prototype.name = <span class="string">&#x27;时间跳跃&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = <span class="keyword">new</span> Fn();</span><br><span class="line">obj.func = fn;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj1 = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;听风是风&#x27;</span>,</span><br><span class="line">    <span class="attr">o</span>: obj</span><br><span class="line">&#125;;</span><br><span class="line">obj1.o.func() <span class="comment">//时间跳跃</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里输出时间跳跃，虽然obj对象并没有name属性，但顺着原型链，找到了产生自己的构造函数Fn，由于Fn原型链存在name属性，所以输出时间跳跃了。</p>
<h2 id="隐式丢失"><a href="#隐式丢失" class="headerlink" title="隐式丢失"></a>隐式丢失</h2><p>在特定情况下会存在隐式绑定丢失的问题，最常见的就是作为参数传递以及变量赋值，先看参数传递：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;行星飞行&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;听风是风&#x27;</span>,</span><br><span class="line">    <span class="attr">fn</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params">param</span>) </span>&#123;</span><br><span class="line">    param();</span><br><span class="line">&#125;;</span><br><span class="line">fn1(obj.fn);<span class="comment">//行星飞行</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这个例子中我们将 obj.fn 也就是一个函数传递进 fn1 中执行，这里只是单纯传递了一个函数而已，this并没有跟函数绑在一起，所以this丢失这里指向了window。</p>
<p>第二个引起丢失的问题是变量赋值，其实本质上与传参相同，看这个例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;行星飞行&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;听风是风&#x27;</span>,</span><br><span class="line">    <span class="attr">fn</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> fn1 = obj.fn;</span><br><span class="line">fn1(); <span class="comment">//行星飞行</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>注意，隐式绑定丢失并不是都会指向全局对象，比如下面的例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;行星飞行&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;听风是风&#x27;</span>,</span><br><span class="line">    <span class="attr">fn</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> obj1 = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;时间跳跃&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">obj1.fn = obj.fn;</span><br><span class="line">obj1.fn(); <span class="comment">//时间跳跃</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>虽然丢失了 obj 的隐式绑定，但是在赋值的过程中，又建立了新的隐式绑定，这里this就指向了对象 obj1。</p>
<h2 id="new绑定"><a href="#new绑定" class="headerlink" title="new绑定"></a>new绑定</h2><p>准确来说，js中的构造函数只是使用new 调用的普通函数，它并不是一个类，最终返回的对象也不是一个实例，只是为了便于理解习惯这么说罢了。</p>
<p>那么new一个函数究竟发生了什么呢，大致分为三步：</p>
<ul>
<li>以构造器的prototype属性为原型，创建新对象；</li>
<li>将this(可以理解为上句创建的新对象)和调用参数传给构造器，执行；</li>
<li>如果构造器没有手动返回对象，则返回第一步创建的对象</li>
</ul>
<p>这个过程我们称之为构造调用，我们来看个例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = <span class="string">&#x27;听风是风&#x27;</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> echo = <span class="keyword">new</span> Fn();</span><br><span class="line">echo.name<span class="comment">//听风是风</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在上方代码中，构造调用创建了一个新对象echo，而在函数体内，this将指向新对象echo上（可以抽象理解为新对象就是this）。</p>
<h2 id="this绑定优先级"><a href="#this绑定优先级" class="headerlink" title="this绑定优先级"></a>this绑定优先级</h2><p>显式绑定 &gt; 隐式绑定 &gt; 默认绑定</p>
<p>new绑定 &gt; 隐式绑定 &gt; 默认绑定</p>
<p>为什么显式绑定不和new绑定比较呢？因为不存在这种绑定同时生效的情景，如果同时写这两种代码会直接抛错，所以大家只用记住上面的规律即可。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = <span class="string">&#x27;听风是风&#x27;</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    <span class="attr">name</span>:<span class="string">&#x27;行星飞行&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> echo = <span class="keyword">new</span> Fn().call(obj);<span class="comment">//报错 call is not a function</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>那么我们结合几个例子来验证下上面的规律，首先是显式大于隐式：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//显式&gt;隐式</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    <span class="attr">name</span>:<span class="string">&#x27;行星飞行&#x27;</span>,</span><br><span class="line">    <span class="attr">fn</span>:<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">obj1 = &#123;</span><br><span class="line">    <span class="attr">name</span>:<span class="string">&#x27;时间跳跃&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line">obj.fn.call(obj1);<span class="comment">// 时间跳跃</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>其次是new绑定大于隐式：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//new&gt;隐式</span></span><br><span class="line">obj = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;时间跳跃&#x27;</span>,</span><br><span class="line">    <span class="attr">fn</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name = <span class="string">&#x27;听风是风&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> echo = <span class="keyword">new</span> obj.fn();</span><br><span class="line">echo.name;<span class="comment">//听风是风</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="箭头函数的this"><a href="#箭头函数的this" class="headerlink" title="箭头函数的this"></a>箭头函数的this</h2><p>ES6的箭头函数是另类的存在，为什么要单独说呢，这是因为箭头函数中的this不适用上面介绍的四种绑定规则。</p>
<p>准确来说，箭头函数中没有this，箭头函数的this指向取决于外层作用域中的this，外层作用域或函数的this指向谁，箭头函数中的this便指向谁。有点吃软饭的嫌疑，一点都不硬朗，我们来看个例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> obj1 = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;听风是风&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> obj2 = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;时间跳跃&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> bar = fn.call(obj1); <span class="comment">// fn this指向obj1</span></span><br><span class="line">bar.call(obj2); <span class="comment">//听风是风</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>为啥我们第一次绑定this并返回箭头函数后，再次改变this指向没生效呢？</p>
<p>前面说了，箭头函数的this取决于外层作用域的this，fn函数执行时this指向了obj1，所以箭头函数的this也指向obj1。除此之外，箭头函数this还有一个特性，那就是一旦箭头函数的this绑定成功，也无法被再次修改，有点硬绑定的意思。</p>
<p>当然，箭头函数的this也不是真的无法修改，我们知道箭头函数的this就像作用域继承一样从上层作用域找，因此我们可以修改外层函数this指向达到间接修改箭头函数this的目的。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> obj1 = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;听风是风&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> obj2 = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;时间跳跃&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line">fn.call(obj1)(); <span class="comment">// fn this指向obj1,箭头函数this也指向obj1</span></span><br><span class="line">fn.call(obj2)(); <span class="comment">//fn this 指向obj2,箭头函数this也指向obj2</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>js基础</category>
      </categories>
  </entry>
  <entry>
    <title>作用域</title>
    <url>/2018/07/06/%E4%BD%9C%E7%94%A8%E5%9F%9F/</url>
    <content><![CDATA[<h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><h3 id="什么是作用域？"><a href="#什么是作用域？" class="headerlink" title="什么是作用域？"></a>什么是作用域？</h3><p>作用域为可访问变量，对象，函数的集合。</p>
<p>作用域就是变量与函数的可访问范围，即作用域控制着变量与函数的可见性和生命周期。</p>
<p>在js中，变量的作用域分为全局作用域和局部作用域两种。<br>一个变量是全局作用域还是局部作用域，主要看变量声明的位置。</p>
<h4 id="全局作用域："><a href="#全局作用域：" class="headerlink" title="全局作用域："></a>全局作用域：</h4><ol>
<li>最外层函数和在最外层函数外面定义的变量</li>
<li>没有通过关键字”var”声明的变量</li>
<li>浏览器中，window对象的属性</li>
</ol>
<h4 id="局部作用域"><a href="#局部作用域" class="headerlink" title="局部作用域"></a>局部作用域</h4><ol>
<li>在函数内部就是局部作用域，这个代码的名字只在函数的内部起作用</li>
<li>调用函数时创建函数作用域，函数执行完毕之后，函数作用域销毁；</li>
<li>每调用一次函数就会创建一个新的函数作用域，它们之间是相互独立的。</li>
</ol>
<h3 id="块级作用域"><a href="#块级作用域" class="headerlink" title="块级作用域"></a>块级作用域</h3><p>在ES6中新增加了一个作用域就是会计作用域，通过let和const声明。那块级作用域什么情况下被创建内？答案如下</p>
<p>在一个函数内部</p>
<p>在一个代码块内部（{}包裹的代码块）</p>
<p>let声明的愈发与var的语法一致，基本上可以用let代替var,但会讲变量的作用域限制在当前代码块中。</p>
<p>块级作用域的特点：</p>
<p>声明变量不会提升到代码块顶部</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Scope</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(scope) <span class="comment">// Uncaught ReferenceError: value is not defined</span></span><br><span class="line"><span class="keyword">let</span> scope = <span class="string">&quot;块级&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(scope) <span class="comment">// 块级</span></span><br><span class="line">&#125;</span><br><span class="line">Scope()</span><br></pre></td></tr></table></figure>

<p>禁止重复声明</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Scope</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">let</span> scope = <span class="string">&#x27;a&#x27;</span></span><br><span class="line"> <span class="comment">//let scope = &#x27;b&#x27; // Uncaught SyntaxError: Identifier &#x27;scope&#x27; has already been declared</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>小技巧：在循环中可以用let const声明变量</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i&lt; <span class="number">100</span>; i++)&#123;&#125;</span><br><span class="line"><span class="built_in">console</span>.log(i) <span class="comment">// Uncaught ReferenceError: i is not defined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i&lt; <span class="number">100</span>; i++)&#123;&#125;</span><br><span class="line"><span class="built_in">console</span>.log(i) <span class="comment">// 100</span></span><br></pre></td></tr></table></figure>


<h3 id="作用域的目的"><a href="#作用域的目的" class="headerlink" title="作用域的目的"></a>作用域的目的</h3><p>是为了提高程序的可靠性，更重要的是减少命名冲突</p>
<h3 id="变量的作用域"><a href="#变量的作用域" class="headerlink" title="变量的作用域"></a>变量的作用域</h3><p>在js中，根据作用域的不同，变量可以分为两种：<strong>全局变量</strong>和<strong>局部变量</strong></p>
<h4 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h4><ul>
<li>在全局作用域下声明的变量叫做全局变量</li>
<li>全局变量在全局任何位置都可以使用，全局作用域中无法访问到局部作用域中的变量<h4 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h4></li>
<li>在局部作用域下声明的变量叫做局部变量</li>
<li>局部变量只能在函数内部使用，在局部作用域中可以访问到全局变量</li>
</ul>
<h2 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h2><p>在js代码运行中，所有用到的变量都需要去当前上下文环境中查找，当找不到的时候，就会继续查找上层的环境变量。<br>这样一级一级向上查找的过程，就组合成了一个作用域链。</p>
<p>所以说，<strong>作用域链</strong>与一个<strong>执行上下文</strong>相关，是内部上下文所有变量对象（包含父变量对象）的列表，用于变量查询。</p>
]]></content>
      <categories>
        <category>js基础</category>
      </categories>
  </entry>
  <entry>
    <title>冒泡排序</title>
    <url>/2021/08/25/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h2 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h2><ol>
<li><p>比较相邻的元素。如果第一个比第二个大，就交换他们两个。</p>
</li>
<li><p>对每一对相邻元素做同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。</p>
</li>
<li><p>针对所有的元素重复以上的步骤，除了最后一个。</p>
</li>
<li><p>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比比较</p>
</li>
</ol>
<h2 id="动图演示"><a href="#动图演示" class="headerlink" title="动图演示"></a>动图演示</h2><p><img src="/.io//1.jpeg" alt="原理图"></p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">40</span>, <span class="number">60</span>, <span class="number">60</span>, <span class="number">0</span>, <span class="number">30</span>]</span><br><span class="line"><span class="comment">// 编写方法，实现冒泡</span></span><br><span class="line"><span class="comment">//外层循环，控制趟数，每一次找到一个最大值</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">    <span class="comment">// 内层循环,控制比较的次数，并且判断两个数的大小</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; arr.length - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">        <span class="comment">// 白话解释：如果前面的数大，放到后面(当然是从小到大的冒泡排序)</span></span><br><span class="line">        <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">var</span> temp = arr[j];</span><br><span class="line">            arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">            arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(arr);</span><br></pre></td></tr></table></figure>

<h2 id="性能分析："><a href="#性能分析：" class="headerlink" title="性能分析："></a>性能分析：</h2><p>时间复杂度: O(N^2)<br>空间复杂度: O(1)<br>稳定性：稳定</p>
]]></content>
      <categories>
        <category>js基础</category>
      </categories>
  </entry>
  <entry>
    <title>创建对象方式</title>
    <url>/2018/07/06/%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<p>在 JavaScript 中创建对象的可行方法有哪些？</p>
<h2 id="1、对象的构造函数"><a href="#1、对象的构造函数" class="headerlink" title="1、对象的构造函数"></a>1、对象的构造函数</h2><p>创建空对象的最简单方法是使用object构造函数，目前不推荐这种方法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = <span class="keyword">new</span> object() <span class="comment">// 对象构造函数</span></span><br></pre></td></tr></table></figure>
<h2 id="2、对象的创建方法："><a href="#2、对象的创建方法：" class="headerlink" title="2、对象的创建方法："></a>2、对象的创建方法：</h2><p>Object的create方法通过将原型对象作为参数传递来创建一个新对象</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = <span class="built_in">Object</span>.create(<span class="literal">null</span>)</span><br></pre></td></tr></table></figure>
<h2 id="3、对象字面量语法"><a href="#3、对象字面量语法" class="headerlink" title="3、对象字面量语法"></a>3、对象字面量语法</h2><p>当传递null作为参数时，对象字面量语法等效于create方法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4、函数构造器"><a href="#4、函数构造器" class="headerlink" title="4、函数构造器"></a>4、函数构造器</h2><p>创建任何函数并应用new运算符来创建对象实例</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> obj = &#123;&#125;</span><br><span class="line">    obj.name = name</span><br><span class="line">    <span class="keyword">return</span> obj</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> obj1 = <span class="keyword">new</span> Person(<span class="string">&quot;哈哈&quot;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="5、带有原型的函数构造函数"><a href="#5、带有原型的函数构造函数" class="headerlink" title="5、带有原型的函数构造函数"></a>5、带有原型的函数构造函数</h2><p>这类似于函数构造函数，但它使用原型作为其属性和方法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">Person.prototype.name = <span class="string">&quot;哈哈&quot;</span></span><br><span class="line"><span class="keyword">var</span> obj = New Person()</span><br></pre></td></tr></table></figure>

<h2 id="6、es6类语法"><a href="#6、es6类语法" class="headerlink" title="6、es6类语法"></a>6、es6类语法</h2><p>es6引入类特性来创建对象</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="title">construtor</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> object = <span class="keyword">new</span> Person(<span class="string">&quot;哈哈&quot;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="7、单例模式"><a href="#7、单例模式" class="headerlink" title="7、单例模式"></a>7、单例模式</h2><p>Singleton是一个只能实例化一次的对象。对其构造函数的重复调用返回相同的实例，这样可以确保它们不会意外创建多个实例</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = <span class="keyword">new</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = <span class="string">&quot;哈哈&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>js基础</category>
      </categories>
  </entry>
  <entry>
    <title>原型及原型链</title>
    <url>/2018/07/06/%E5%8E%9F%E5%9E%8B%E5%8F%8A%E5%8E%9F%E5%9E%8B%E9%93%BE/</url>
    <content><![CDATA[<h2 id="prototype"><a href="#prototype" class="headerlink" title="prototype"></a>prototype</h2><p>每一个js对象(null除外)在创建的时候就会与之关联另一个对象【Prototype】，这个对象就是我们所说的原型。每个对象都会从原型“继承”属性。</p>
<p>举个例子</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line"><span class="attr">name</span>: <span class="string">&quot;zhangsan&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> newObj = <span class="built_in">Object</span>.create(obj)</span><br><span class="line"></span><br><span class="line">newObj.name <span class="comment">// zhangsan</span></span><br></pre></td></tr></table></figure>


<p>上述例子中，newObj对象的【Prototype】属性引用了obj对象，也就是说newObj对象的【Prototype】指向了obj对象，并继承了obj的属性。</p>
<p>几乎所有的对象在创建时【Prototype】属性都会被赋予非空的值，由【Prototype】串联起来的对象的关系链条我们就称为【Prototype】链也就是原型链，一般情况下【Prototype】链的最顶层是Object.prototype</p>
<p>每个函数都有一个 prototype 属性。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.name = <span class="string">&quot;zhangsan&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person()</span><br><span class="line"></span><br><span class="line">person.name <span class="comment">// zhangsan</span></span><br></pre></td></tr></table></figure>

<p><img src="/.io//1.png"></p>
<h2 id="proto"><a href="#proto" class="headerlink" title="proto"></a>proto</h2><p>每一个js对象（除null）都具有一个属性叫proto，这个属性会指向改对象的原型。</p>
<p>对象可以通过__proto__访问内部的【Prototype】属性，即我们可以通过__proto__访问对象的原型。</p>
<p>ps: __proto__是一种非标准的方法，实际开发中我们应该使用Object.getPrototypeOf()来获取对象的原型</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person();</span><br><span class="line"></span><br><span class="line">person.__proto__ === Person.prototype <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p><img src="/.io//2.png"></p>
<h2 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a>constructor</h2><p>每个原型都有一个constructor属性指向关联的构造函数，实例原型指向构造函数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">person.__proto__ == Person.prototype <span class="comment">// true</span></span><br><span class="line">Person === Person.prototype.constructor <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.getPrototypeOf(person) === Person.prototype <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>补充说明：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person();</span><br><span class="line">person.constructor === Person<span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>当获取 person.constructor 时，其实 person 中并没有 constructor 属性,当不能读取到constructor 属性时，会从 person 的原型也就是 Person.prototype 中读取，正好原型中有该属性，所以：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">person.constructor === Person.prototype.constructor</span><br></pre></td></tr></table></figure>
<p><img src="/.io//3.png"></p>
<h2 id="实例与原型"><a href="#实例与原型" class="headerlink" title="实例与原型"></a>实例与原型</h2><p>当读取实例的属性时，如果找不到，就会查找与对象关联的原型中的属性，如果还查不到，就去找原型的原型，一直找到最顶层为止。<br><img src="/.io//4.png"></p>
<h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h2><p>简单的回顾一下构造函数、原型和实例的关系：每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，而实例都包含一个指向原型对象的内部指针。那么假如我们让原型对象等于另一个类型的实例，结果会怎样？显然，此时的原型对象将包含一个指向另一个原型的指针，相应地，另一个原型中也包含着一个指向另一个构造函数的指针。假如另一个原型又是另一个类型的实例，那么上述关系依然成立。如此层层递进，就构成了实例与原型的链条。这就是所谓的原型链的基本概念。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.prototype.__proto__ === <span class="literal">null</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p><img src="/.io//5.png"></p>
]]></content>
      <categories>
        <category>js基础</category>
      </categories>
  </entry>
  <entry>
    <title>希尔排序</title>
    <url>/2021/08/25/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<p>希尔排序是希尔（Donald Shell）于1959年提出的一种排序算法。希尔排序也是一种插入排序，它是简单插入排序经过改进之后的一个更高效的版本，也称为缩小增量排序，同时该算法是冲破O(n2）的第一批算法之一。本文会以图解的方式详细介绍希尔排序的基本思想及其代码实现。</p>
<h2 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h2><p>希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止。</p>
<p>简单插入排序很循规蹈矩，不管数组分布是怎么样的，依然一步一步的对元素进行比较，移动，插入，比如[5,4,3,2,1,0]这种倒序序列，数组末端的0要回到首位置很是费劲，比较和移动元素均需n-1次。而希尔排序在数组中采用跳跃式分组的策略，通过某个增量将数组元素划分为若干组，然后分组进行插入排序，随后逐步缩小增量，继续按组进行插入排序操作，直至增量为1。希尔排序通过这种策略使得整个数组在初始阶段达到从宏观上看基本有序，小的基本在前，大的基本在后。然后缩小增量，到增量为1时，其实多数情况下只需微调即可，不会涉及过多的数据移动。</p>
<p>我们来看下希尔排序的基本步骤，在此我们选择增量gap=length/2，缩小增量继续以gap = gap/2的方式，这种增量选择我们可以用一个序列来表示，{n/2,(n/2)/2…1}，称为增量序列。希尔排序的增量序列的选择与证明是个数学难题，我们选择的这个增量序列是比较常用的，也是希尔建议的增量，称为希尔增量，但其实这个增量序列不是最优的。此处我们做示例使用希尔增量。</p>
<h2 id="动图演示"><a href="#动图演示" class="headerlink" title="动图演示"></a>动图演示</h2><p><img src="/.io//1.png" alt="原理图"></p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">40</span>, <span class="number">60</span>, <span class="number">60</span>, <span class="number">0</span>, <span class="number">30</span>]</span><br><span class="line"><span class="keyword">let</span> interval = <span class="built_in">parseInt</span>(arr.length / <span class="number">2</span>);</span><br><span class="line"><span class="keyword">while</span> (interval &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i ++) &#123;</span><br><span class="line">        <span class="keyword">let</span> n = i;</span><br><span class="line">        <span class="keyword">while</span> (arr[n] &lt; arr[n - interval] &amp;&amp; n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">let</span> temp = arr[n]</span><br><span class="line">            arr[n] = arr[n- interval]</span><br><span class="line">            arr[n - interval] = temp</span><br><span class="line">            n --</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    interval = <span class="built_in">parseInt</span>(interval / <span class="number">2</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(arr)</span><br></pre></td></tr></table></figure>

<h2 id="性能分析："><a href="#性能分析：" class="headerlink" title="性能分析："></a>性能分析：</h2><p>希尔排序中对于增量序列的选择十分重要，直接影响到希尔排序的性能。我们上面选择的增量序列{n/2,(n/2)/2…1}(希尔增量)，其最坏时间复杂度依然为O(n2)，一些经过优化的增量序列如Hibbard经过复杂证明可使得最坏时间复杂度为O(n3/2)</p>
]]></content>
      <categories>
        <category>js基础</category>
      </categories>
  </entry>
  <entry>
    <title>执行上下文</title>
    <url>/2021/07/06/%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87/</url>
    <content><![CDATA[<h2 id="理解执行上下文"><a href="#理解执行上下文" class="headerlink" title="理解执行上下文"></a>理解执行上下文</h2><blockquote>
<p>执行上下文：函数执行前进行的准备工作，也就是执行上下文环境，是当前代码执行的一个环境与作用域。</p>
</blockquote>
<p>运行js代码时，当代码执行进入一个环境时，就会为该环境创建一个执行上下文，它<br>会在你运行代码前做一些准备工作，如确定作用域，创建局部变量对象等。</p>
<h2 id="js中执行环境"><a href="#js中执行环境" class="headerlink" title="js中执行环境"></a>js中执行环境</h2><ul>
<li>全局环境</li>
<li>函数环境</li>
<li>eval函数环境（不推荐使用）</li>
</ul>
<h2 id="执行上下文的类型"><a href="#执行上下文的类型" class="headerlink" title="执行上下文的类型"></a>执行上下文的类型</h2><ul>
<li>全局执行上下文</li>
<li>函数执行上下文</li>
<li>eval函数执行上下文</li>
</ul>
<p>js运行时先进入全局环境，对应会生成全局上下文。程序代码中基本都会存在函数，调用<br>函数，就会进入函数执行环境，对应的就是生成函数执行上下文。</p>
<h2 id="js管理多个执行上下文"><a href="#js管理多个执行上下文" class="headerlink" title="js管理多个执行上下文"></a>js管理多个执行上下文</h2><p>函数变成中，代码中会声明多个函数，对应的执行上下文也会存在多个。在js中，通过栈的存取方式来管理执行上下文，我们可以称<br>其为执行栈，或者函数调用栈。</p>
<p><img src="/.io//1.png" alt="栈数据结构"></p>
<h2 id="执行栈（函数调用栈）"><a href="#执行栈（函数调用栈）" class="headerlink" title="执行栈（函数调用栈）"></a>执行栈（函数调用栈）</h2><p>程序进入一个执行环境时，它的执行上下文就会被创建，并被堆入执行栈中（入栈）；程序执行完成时，她的执行上下文就会被销毁，并从栈顶被推出（出栈），控制权交由下一个执行上下文。</p>
<p>因为JS执行中，最先进入全局环境，所以处于”栈底的永远时全局环境的执行上下文”。而处于”栈顶的是当前执行函数的执行上下文”，当函数调用完成后，它就会从栈顶被推出（理想情况下，闭包会阻止该操作）。</p>
<p><strong>全局环境只有一个，对应的全局执行上下文也只有一个，只有当页面被关闭之后它才会从执行栈中被推出，否则一直存在于栈底。</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params"></span>) </span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">bar</span> (<span class="params"></span>) </span>&#123;        </span><br><span class="line">      <span class="keyword">return</span> <span class="string">&#x27;I am bar&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bar();</span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br></pre></td></tr></table></figure>
<p><img src="/.io//2.png" alt="出栈入栈图解"></p>
<h2 id="执行上下文的声明周期"><a href="#执行上下文的声明周期" class="headerlink" title="执行上下文的声明周期"></a>执行上下文的声明周期</h2><p>执行上下文的声明周期有两个阶段：</p>
<ol>
<li><p>创建阶段（进入执行上下文）</p>
<p> 函数被调用时，进入函数环境，为期创建一个执行上下文，此时进入创建阶段。</p>
</li>
<li><p>执行阶段（代码执行）</p>
<p> 执行函数中代码时，此时执行上下文进入执行阶段。</p>
</li>
</ol>
<h2 id="创建阶段的操作"><a href="#创建阶段的操作" class="headerlink" title="创建阶段的操作"></a>创建阶段的操作</h2><p>1.创建变量对象</p>
<ul>
<li>函数环境会初始化创建Arguments对象（并赋值）</li>
<li>函数声明（并赋值）</li>
<li>变量声明，函数表达式声明（未赋值）</li>
</ul>
<ol start="2">
<li>确定this指向（this由调用者确定）</li>
<li>确定作用域（词法环境决定，哪里声明定义，就在哪里确定）</li>
</ol>
<h2 id="执行阶段的操作"><a href="#执行阶段的操作" class="headerlink" title="执行阶段的操作"></a>执行阶段的操作</h2><ol>
<li>变量对象赋值</li>
</ol>
<ul>
<li>变量赋值</li>
<li>函数表达式赋值</li>
</ul>
<ol start="2">
<li>调用函数</li>
<li>顺序执行其他代码</li>
</ol>
<h2 id="变量对象和活动对象的区别："><a href="#变量对象和活动对象的区别：" class="headerlink" title="变量对象和活动对象的区别："></a>变量对象和活动对象的区别：</h2><p>当进入到一个执行上下文后，这个变量对象才会被激活，所以叫活动对象(AO)，这时候活动对象上的各种属性才能被访问。</p>
<p><strong>“创建阶段对函数声明做赋值，变量及函数表达式仅做声明，真正的赋值操作要等到执行上下文代码执行阶段。”</strong></p>
<p>例1：变量提升</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a);         <span class="comment">// 输出undefined</span></span><br><span class="line">    <span class="keyword">var</span> a = <span class="string">&#x27;I am here&#x27;</span>;    <span class="comment">// 赋值</span></span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br><span class="line"><span class="comment">// 实际执行过程</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a;                <span class="comment">// 变量声明，var初始化undefined</span></span><br><span class="line">    <span class="built_in">console</span>.log(a); </span><br><span class="line">    a = <span class="string">&#x27;I am here&#x27;</span>;     <span class="comment">// 变量重新赋值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例2：函数声明优先级</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(bar);</span><br><span class="line">    <span class="keyword">var</span> bar = <span class="number">20</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> bar = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">30</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">foo();  <span class="comment">// 输出bar()整个函数声明</span></span><br></pre></td></tr></table></figure>

<h2 id="函数声明，变量声明，函数表达式的优先级"><a href="#函数声明，变量声明，函数表达式的优先级" class="headerlink" title="函数声明，变量声明，函数表达式的优先级"></a>函数声明，变量声明，函数表达式的优先级</h2><ol>
<li>函数声明，如果有同名属性，会替换掉</li>
<li>变量，函数表达式</li>
<li>函数声明优先 &gt; 变量，函数表达式</li>
</ol>
<h2 id="执行上下文的数量限制（堆栈溢出）"><a href="#执行上下文的数量限制（堆栈溢出）" class="headerlink" title="执行上下文的数量限制（堆栈溢出）"></a>执行上下文的数量限制（堆栈溢出）</h2><p>执行上下文可存在多个，虽然没有明确的数量限制，但如果超出栈分配的空间，会造成堆栈溢出。常见于递归调用，没有终止条件造成死循环的场景。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 递归调用自身</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    foo();</span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br><span class="line"><span class="comment">// 报错： Uncaught RangeError: Maximum call stack size exceeded</span></span><br></pre></td></tr></table></figure>

<h2 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h2><p>当程序调用一个函数时，会发生什么？</p>
<p>以下几个步骤：</p>
<ol>
<li>js创建一个新的执行上下文，我们叫做函数执行上下文。</li>
<li>这个函数执行上下文将有它自己的一组变量，这些变量将时这个执行上下文的本地变量。</li>
<li>新的执行上下文被推到执行堆栈中。可以将执行堆栈看作是一种保存程序在其执行中的位置的容器。</li>
</ol>
<p>当函数遇到一个return或者一个结束括号 “}” 。</p>
<p>当函数结束时，会执行一下操作：</p>
<ol>
<li>这个本地执行上下文从执行堆栈中弹出。</li>
<li>函数将返回值返回调用上下文。调用上下文时调用这个本地的执行上下文，它可以时全局执行上下文，也可以是灵位一个本地执行上下文。这取决与调用执行上下文来处理此时的返回值，返回的值可以是一个对象、一个数组、一个函数、一个布尔值等等，如果函数没有return语句，则返回undefined.</li>
<li></li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li>JavaScript是单线程</li>
<li>栈顶的执行上下文处于执行中，其它需要排队</li>
<li>全局上下文只有一个处于栈底，页面关闭时出栈</li>
<li>函数执行上下文可存在多个，但应避免递归时堆栈溢出</li>
<li>函数调用时就会创建新的上下文，即使调用自身，也会创建不同的执行上下文</li>
</ol>
]]></content>
      <categories>
        <category>js基础</category>
      </categories>
  </entry>
  <entry>
    <title>数据类型</title>
    <url>/2021/08/19/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<h1 id="js中基本数据类型"><a href="#js中基本数据类型" class="headerlink" title="js中基本数据类型"></a>js中基本数据类型</h1><h2 id="原始数据类型"><a href="#原始数据类型" class="headerlink" title="原始数据类型"></a>原始数据类型</h2><ul>
<li>number</li>
<li>string</li>
<li>boolean</li>
<li>null</li>
<li>undefined</li>
<li>symbol(es6)</li>
<li>bigint(es10)</li>
</ul>
<h2 id="引用数据类型"><a href="#引用数据类型" class="headerlink" title="引用数据类型"></a>引用数据类型</h2><ul>
<li>object (包括function/array/object)</li>
</ul>
]]></content>
      <categories>
        <category>js基础</category>
      </categories>
  </entry>
  <entry>
    <title>插入排序</title>
    <url>/2021/08/25/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h2 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h2><p>1.从数组的第二个数据开始往前比较，即一开始用第二个数和他前面的一个比较，如果 符合条件（比前面的大或者小，自定义），则让他们交换位置。</p>
<p>2.然后再用第三个数和第二个比较，符合则交换，但是此处还得继续往前比较，比如有 5个数8，15，20，45, 17,17比45小，需要交换，但是17也比20小，也要交换，当不需 要和15交换以后，说明也不需要和15前面的数据比较了，肯定不需要交换，因为前 面的数据都是有序的。</p>
<p>3.重复步骤二，一直到数据全都排完。</p>
<h2 id="动图演示"><a href="#动图演示" class="headerlink" title="动图演示"></a>动图演示</h2><p><img src="/.io//1.gif" alt="原理图"></p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">40</span>, <span class="number">60</span>, <span class="number">60</span>, <span class="number">0</span>, <span class="number">30</span>]</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> n = i;</span><br><span class="line">    <span class="keyword">while</span> (arr[n] &gt; arr[n+<span class="number">1</span>] &amp;&amp; n &gt;=<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> temp = arr[n];</span><br><span class="line">        arr[n] = arr[n + <span class="number">1</span>];</span><br><span class="line">        arr[n + <span class="number">1</span>] = temp;</span><br><span class="line">        n--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(arr);</span><br></pre></td></tr></table></figure>

<h2 id="性能分析："><a href="#性能分析：" class="headerlink" title="性能分析："></a>性能分析：</h2><p>1.属于稳定的排序，适合于数据量小，部分数据有序的情况排序。</p>
<p>2.如果目标是把n个元素的序列升序排列，那么采用插入排序存在最好情况和最坏情况。最好情况就是，序列已经是升序排列了，在这种情况下，需要进行的比较操作需（n-1）次即可。最坏情况就是，序列是降序排列，那么此时需要进行的比较共有n(n-1)/2次。插入排序的赋值操作是比较操作的次数加上 (n-1）次。平均来说插入排序算法的时间复杂度为O(n^2）。因而，插入排序不适合对于数据量比较大的排序应用。但是，如果需要排序的数据量很小，例如，量级小于千，那么插入排序还是一个不错的选择</p>
<p>3.插入排序的平均时间复杂度也是 O(n^2)，空间复杂度为常数阶 O(1)</p>
]]></content>
      <categories>
        <category>js基础</category>
      </categories>
  </entry>
  <entry>
    <title>数组操作</title>
    <url>/2021/08/19/%E6%95%B0%E7%BB%84%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h1 id="最常见的几种数组操作方法归纳总结"><a href="#最常见的几种数组操作方法归纳总结" class="headerlink" title="最常见的几种数组操作方法归纳总结"></a>最常见的几种数组操作方法归纳总结</h1><table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>concat()</td>
<td>连接两个或多个数组，并返回已连接数组的副本</td>
</tr>
<tr>
<td>copyWithin()</td>
<td>将数组中的数组元素复制到指定位置或从指定位置复制</td>
</tr>
<tr>
<td>entries()</td>
<td>返回键/值对数组迭代对象</td>
</tr>
<tr>
<td>every()</td>
<td>检查数组中的每个元素是否通过测试</td>
</tr>
<tr>
<td>fill()</td>
<td>用静态值填充数组中的元素</td>
</tr>
<tr>
<td>filter()</td>
<td>使用数组中通过测试的每个元素创建新数组</td>
</tr>
<tr>
<td>find()</td>
<td>返回数组中第一个通过测试的元素的值</td>
</tr>
<tr>
<td>findIndex()</td>
<td>返回数组中通过测试的第一个元素的索引。</td>
</tr>
<tr>
<td>forEach()</td>
<td>为每个数组元素调用函数。</td>
</tr>
<tr>
<td>from()</td>
<td>从对象创建数组</td>
</tr>
<tr>
<td>includes()</td>
<td>检查数组是否包含指定的元素。</td>
</tr>
<tr>
<td>indexOf()</td>
<td>在数组中搜索元素并返回其位置。</td>
</tr>
<tr>
<td>isArray()</td>
<td>检查对象是否为数组。</td>
</tr>
<tr>
<td>join()</td>
<td>将数组的所有元素连接成一个字符串。</td>
</tr>
<tr>
<td>keys()</td>
<td>返回 Array Iteration 对象，包含原始数组的键.</td>
</tr>
<tr>
<td>lastIndexOf()</td>
<td>在数组中搜索元素，从末尾开始，并返回其位置。</td>
</tr>
<tr>
<td>map()</td>
<td>使用为每个数组元素调用函数的结果创建新数组。</td>
</tr>
<tr>
<td>pop()</td>
<td>删除数组的最后一个元素，并返回该元素。</td>
</tr>
<tr>
<td>push()</td>
<td>将新元素添加到数组的末尾，并返回新的长度。</td>
</tr>
<tr>
<td>reduce()</td>
<td>将数组的值减为单个值（从左到右）。</td>
</tr>
<tr>
<td>reduceRight()</td>
<td>将数组的值减为单个值（从右到左）。</td>
</tr>
<tr>
<td>reverse()</td>
<td>反转数组中元素的顺序。</td>
</tr>
<tr>
<td>shift()</td>
<td>删除数组的第一个元素，并返回该元素。</td>
</tr>
<tr>
<td>slice()</td>
<td>选择数组的一部分，并返回新数组。</td>
</tr>
<tr>
<td>some()</td>
<td>检查数组中的任何元素是否通过测试。</td>
</tr>
<tr>
<td>sort()</td>
<td>对数组的元素进行排序。</td>
</tr>
<tr>
<td>splice()</td>
<td>从数组中添加/删除元素。</td>
</tr>
<tr>
<td>toString()</td>
<td>将数组转换为字符串，并返回结果。</td>
</tr>
<tr>
<td>unshift()</td>
<td>将新元素添加到数组的开头，并返回新的长度。</td>
</tr>
<tr>
<td>valueOf()</td>
<td>返回数组的原始值。</td>
</tr>
<tr>
<td>at()</td>
<td>2021.1新提案，解决方括号的限制，可以输入负数。</td>
</tr>
</tbody></table>
<h2 id="1-shift-方法：把数组的第一个元素删除，并返回第一个元素的值"><a href="#1-shift-方法：把数组的第一个元素删除，并返回第一个元素的值" class="headerlink" title="1.shift() 方法：把数组的第一个元素删除，并返回第一个元素的值"></a>1.shift() 方法：把数组的第一个元素删除，并返回第一个元素的值</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">arr.shift() <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<h2 id="2-concat-方法：用于连接两个或多个数组-并返回一个新数组，新数组是将参数添加到原数组中构成的"><a href="#2-concat-方法：用于连接两个或多个数组-并返回一个新数组，新数组是将参数添加到原数组中构成的" class="headerlink" title="2.concat() 方法：用于连接两个或多个数组,并返回一个新数组，新数组是将参数添加到原数组中构成的"></a>2.concat() 方法：用于连接两个或多个数组,并返回一个新数组，新数组是将参数添加到原数组中构成的</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">const</span> arr1 = arr.concat(<span class="number">2</span>, <span class="number">4</span>); <span class="comment">// 1, 3, 2, 4</span></span><br><span class="line"><span class="keyword">const</span> arr2 = [<span class="number">5</span>, <span class="number">6</span>];</span><br><span class="line"><span class="keyword">const</span> arr3 = [<span class="number">7</span>, <span class="number">8</span>];</span><br><span class="line"><span class="keyword">const</span> arr4 = arr2.concat(arr3); <span class="comment">// 5, 6, 7, 8</span></span><br></pre></td></tr></table></figure>

<h2 id="3-join-方法：用于把数组中的所有元素放入一个字符串。元素是通过指定的分隔符进行分隔的。"><a href="#3-join-方法：用于把数组中的所有元素放入一个字符串。元素是通过指定的分隔符进行分隔的。" class="headerlink" title="3. join() 方法：用于把数组中的所有元素放入一个字符串。元素是通过指定的分隔符进行分隔的。"></a>3. join() 方法：用于把数组中的所有元素放入一个字符串。元素是通过指定的分隔符进行分隔的。</h2><p>返回一个字符串。该字符串是通过把 arrayObject 的每个元素转换为字符串，然后把这些字符串连接起来，在两个元素之间插入separator 字符串而生成的。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>];</span><br><span class="line"><span class="keyword">const</span> str = arr.join(<span class="string">&#x27;-&#x27;</span>); <span class="comment">// 1-3-4-5-6</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="4-pop-方法：用于删除并返回数组的最后一个-删除元素-元素-如果数组为空则返回undefined-把数组长度减-1"><a href="#4-pop-方法：用于删除并返回数组的最后一个-删除元素-元素-如果数组为空则返回undefined-把数组长度减-1" class="headerlink" title="4. pop() 方法：用于删除并返回数组的最后一个(删除元素)元素,如果数组为空则返回undefined ,把数组长度减 1"></a>4. pop() 方法：用于删除并返回数组的最后一个(删除元素)元素,如果数组为空则返回undefined ,把数组长度减 1</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line"><span class="keyword">const</span> str = arr.pop(); <span class="comment">// 6</span></span><br><span class="line"><span class="built_in">console</span>.log(arr) <span class="comment">// 1,2,3,4,5</span></span><br></pre></td></tr></table></figure>

<h2 id="5-push-方法：可向数组的末尾添加一个或多个元素，并返回新的长度，（用来改变数组长度）。"><a href="#5-push-方法：可向数组的末尾添加一个或多个元素，并返回新的长度，（用来改变数组长度）。" class="headerlink" title="5.push() 方法：可向数组的末尾添加一个或多个元素，并返回新的长度，（用来改变数组长度）。"></a>5.push() 方法：可向数组的末尾添加一个或多个元素，并返回新的长度，（用来改变数组长度）。</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line"><span class="keyword">const</span> len = arr.push(<span class="number">5</span>)<span class="comment">// 5</span></span><br><span class="line"><span class="built_in">console</span>.log(arr) <span class="comment">// [1,2,3,4,5]</span></span><br></pre></td></tr></table></figure>
<h2 id="6-reverse-：方法用于颠倒数组中元素的顺序。"><a href="#6-reverse-：方法用于颠倒数组中元素的顺序。" class="headerlink" title="6.reverse() ：方法用于颠倒数组中元素的顺序。"></a>6.reverse() ：方法用于颠倒数组中元素的顺序。</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line"><span class="keyword">const</span> len = arr.reverse(); <span class="comment">// [6,5,4,3,2,1]</span></span><br><span class="line"><span class="built_in">console</span>.log(arr) <span class="comment">// [6,5,4,3,2,1]</span></span><br></pre></td></tr></table></figure>
<h2 id="7-slice-方法：可从已有的数组中返回选定的元素。slice-开始截取位置，结束截取位置"><a href="#7-slice-方法：可从已有的数组中返回选定的元素。slice-开始截取位置，结束截取位置" class="headerlink" title="7.slice() 方法：可从已有的数组中返回选定的元素。slice(开始截取位置，结束截取位置)"></a>7.slice() 方法：可从已有的数组中返回选定的元素。slice(开始截取位置，结束截取位置)</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line"><span class="keyword">const</span> a = arr.slice(<span class="number">1</span>,<span class="number">2</span>); <span class="comment">// [2]</span></span><br><span class="line"><span class="built_in">console</span>.log(arr)<span class="comment">// [1,2,3,4,5,6]</span></span><br></pre></td></tr></table></figure>
<h2 id="8-splice-：方法向-从数组中添加-删除项目，然后返回被删除的项目。"><a href="#8-splice-：方法向-从数组中添加-删除项目，然后返回被删除的项目。" class="headerlink" title="8.splice() ：方法向/从数组中添加/删除项目，然后返回被删除的项目。"></a>8.splice() ：方法向/从数组中添加/删除项目，然后返回被删除的项目。</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"><span class="keyword">const</span> a = arr.splice(<span class="number">1</span>,<span class="number">2</span>); <span class="comment">// [2,3]</span></span><br><span class="line"><span class="built_in">console</span>.log(arr) <span class="comment">// [1,4,5]</span></span><br><span class="line"><span class="keyword">const</span> b = arr.splice(<span class="number">1</span>,<span class="number">2</span>,)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arrr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"><span class="keyword">const</span> c = arr.splice(<span class="number">1</span>,<span class="number">0</span>, <span class="string">&#x27;a&#x27;</span>) <span class="comment">// []</span></span><br><span class="line"><span class="built_in">console</span>.log(arrr) <span class="comment">// [1, &#x27;a&#x27;,2,3,4,5]</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="9-unshift：将参数添加到原数组开头，并返回数组的长度"><a href="#9-unshift：将参数添加到原数组开头，并返回数组的长度" class="headerlink" title="9.unshift：将参数添加到原数组开头，并返回数组的长度"></a>9.unshift：将参数添加到原数组开头，并返回数组的长度</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line"><span class="keyword">const</span> len = arr.unshift(<span class="number">0</span>); <span class="comment">// 5</span></span><br><span class="line"><span class="built_in">console</span>.log(arr) <span class="comment">// [0,1,2,3,4]</span></span><br></pre></td></tr></table></figure>
<h2 id="10-sort-orderfunction-：按指定的参数对数组进行排序"><a href="#10-sort-orderfunction-：按指定的参数对数组进行排序" class="headerlink" title="10.sort(orderfunction)：按指定的参数对数组进行排序"></a>10.sort(orderfunction)：按指定的参数对数组进行排序</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line"><span class="keyword">const</span> b = arr.sort(); <span class="comment">// [1,2,3,4]</span></span><br><span class="line"><span class="built_in">console</span>.log(b) <span class="comment">// [1,2,3,4]</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>js基础</category>
      </categories>
  </entry>
  <entry>
    <title>面试题</title>
    <url>/2021/08/19/%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<h1 id="JavaScript-面试题"><a href="#JavaScript-面试题" class="headerlink" title="JavaScript 面试题"></a>JavaScript 面试题</h1><h2 id><a href="#" class="headerlink" title></a><a href="/2018/07/06/%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E6%96%B9%E5%BC%8F/" title="1.在 JavaScript 中创建对象的可行方法有哪些？">1.在 JavaScript 中创建对象的可行方法有哪些？</a></h2><p>1、对象的构造函数-new object()<br>2、对象的创建方法-Object.create(null)<br>3、对象字面量语法-const obj = {}<br>4、函数构造器<br>5、带有原型的函数构造函数<br>6、es6类语法 class<br>7、单例模式</p>
<h2 id="-1"><a href="#-1" class="headerlink" title></a><a href="/2018/07/06/%E5%8E%9F%E5%9E%8B%E5%8F%8A%E5%8E%9F%E5%9E%8B%E9%93%BE/" title="1.什么是原型链？">1.什么是原型链？</a></h2><p>原型链用于基于现有对象构建新类型的对象。它类似于基于类的语言中的继承。</p>
<p>对象实例上的原型可通过Object.getPrototypeOf(object)或proto属性获得，而构造函数上的原型可通过Object.prototype 获得。</p>
<h2 id="-2"><a href="#-2" class="headerlink" title></a><a href="/2021/08/19/call%E3%80%81apply%E5%92%8Cbind%E5%8C%BA%E5%88%AB/" title="3.call、 bind、apply区别？">3.call、 bind、apply区别？</a></h2><h2 id="-3"><a href="#-3" class="headerlink" title></a><a href="/2021/08/19/%E6%95%B0%E7%BB%84%E6%93%8D%E4%BD%9C/" title="4.数组操作？">4.数组操作？</a></h2>]]></content>
  </entry>
  <entry>
    <title>grid布局</title>
    <url>/2021/10/20/grid%E5%B8%83%E5%B1%80/</url>
    <content><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>网格布局是最强大的css布局方案。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">display: grid;</span><br></pre></td></tr></table></figure>
<style>
#container1 {
    display: grid;
    grid-template-columns: 100px 100px 100px;
    grid-template-rows: 100px 100px 100px;
}
.item {
  font-size: 2em;
  text-align: center;
  border: 1px solid #e5e4e9;
}

.item-1 {
  background-color: #ef342a;
}

.item-2 {
  background-color: #f68f26;
}

.item-3 {
  background-color: #4ba946;
}

.item-4 {
  background-color: #0376c2;
}

.item-5 {
  background-color: #c077af;
}

.item-6 {
  background-color: #f8d29d;
}

.item-7 {
  background-color: #b5a87f;
}

.item-8 {
  background-color: #d0e4a9;
}

.item-9 {
  background-color: #4dc7ec;
}
</style>
<div id="container1">
  <div class="item item-1">1</div>
  <div class="item item-2">2</div>
  <div class="item item-3">3</div>
  <div class="item item-4">4</div>
  <div class="item item-5">5</div>
  <div class="item item-6">6</div>
  <div class="item item-7">7</div>
  <div class="item item-8">8</div>
  <div class="item item-9">9</div>
</div>


<h1 id="容器属性："><a href="#容器属性：" class="headerlink" title="容器属性："></a>容器属性：</h1><p>Grid 布局的属性分成两类。一类定义在容器上面，称为容器属性；另一类定义在项目上面，称为项目属性。</p>
<h2 id="display属性"><a href="#display属性" class="headerlink" title="display属性"></a>display属性</h2><p>display: grid指定一个容器采用网格布局。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">div &#123;</span><br><span class="line">  display: grid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div id="container1">
  <div class="item item-1">1</div>
  <div class="item item-2">2</div>
  <div class="item item-3">3</div>
  <div class="item item-4">4</div>
  <div class="item item-5">5</div>
  <div class="item item-6">6</div>
  <div class="item item-7">7</div>
  <div class="item item-8">8</div>
  <div class="item item-9">9</div>
</div>

<p>默认情况下，容器都是块级元素，但也可以设置为行内元素,会出现什么现象？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.item &#123;</span><br><span class="line">  display: inline-grid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过上图，可发现没有变化。这是因为，容器设为网格布局以后，容器子元素（项目）的float、display: inline-block、display: table-cell、vertical-align和column-*等设置都将失效。</p>
<h2 id="grid-template-columns-属性-grid-template-rows属性"><a href="#grid-template-columns-属性-grid-template-rows属性" class="headerlink" title="grid-template-columns 属性 grid-template-rows属性"></a>grid-template-columns 属性 grid-template-rows属性</h2><p>容器指定了网格布局以后，接着就要划分行和列。grid-template-columns属性定义每一列的列宽，grid-template-rows属性定义每一行的行高。</p>
<p>grid-template-columns: none|auto|max-content|min-content|length|initial|inherit;<br>grid-template-rows: none|auto|max-content|min-content|length|initial|inherit;<br>grid-template-columns: 50px 100px auto; 每个值代表每一列的宽度，有多少列，写多少个值<br>grid-template-rows: 50px 100px auto;每个值代表每一行的宽度，有多少行，写多少个值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.container &#123;</span><br><span class="line">  display: grid;</span><br><span class="line">  grid-template-columns: 100px 100px 100px;</span><br><span class="line">  grid-template-rows: 100px 100px 100px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div id="container1">
  <div class="item item-1">1</div>
  <div class="item item-2">2</div>
  <div class="item item-3">3</div>
  <div class="item item-4">4</div>
  <div class="item item-5">5</div>
  <div class="item item-6">6</div>
  <div class="item item-7">7</div>
  <div class="item item-8">8</div>
  <div class="item item-9">9</div>
</div>

<h3 id="repeat-次数，值"><a href="#repeat-次数，值" class="headerlink" title="repeat(次数，值)"></a>repeat(次数，值)</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">.container &#123;</span><br><span class="line">  display: grid;</span><br><span class="line">  grid-template-columns: repeat(3, 33.33%);</span><br><span class="line">  grid-template-rows: repeat(3, 33.33%);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">grid-template-columns: repeat(2, 100px 20px 80px);// 重复后面的数据</span><br></pre></td></tr></table></figure>
<style>
    #container2 {
        display: grid;
        grid-template-columns: repeat(2, 100px 20px 80px);
    }
</style>
<div id="container2">
  <div class="item item-1">1</div>
  <div class="item item-2">2</div>
  <div class="item item-3">3</div>
  <div class="item item-4">4</div>
  <div class="item item-5">5</div>
  <div class="item item-6">6</div>
  <div class="item item-7">7</div>
  <div class="item item-8">8</div>
  <div class="item item-9">9</div>
</div>

<p>第一列和第四列的宽度为100px，第二列和第五列为20px，第三列和第六列为80px。</p>
<h3 id="auto-fill-关键字"><a href="#auto-fill-关键字" class="headerlink" title="auto-fill 关键字"></a>auto-fill 关键字</h3><p>有时，单元格的大小是固定的，但是容器的大小不确定。如果希望每一行（或每一列）容纳尽可能多的单元格，这时可以使用auto-fill关键字表示自动填充。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.container &#123;</span><br><span class="line">  display: grid;</span><br><span class="line">  grid-template-columns: repeat(auto-fill, 100px);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<style>
    #container3 {
        display: grid;
        grid-template-columns: repeat(auto-fill, 100px);
    }
</style>
<div id="container3">
  <div class="item item-1">1</div>
  <div class="item item-2">2</div>
  <div class="item item-3">3</div>
  <div class="item item-4">4</div>
  <div class="item item-5">5</div>
  <div class="item item-6">6</div>
  <div class="item item-7">7</div>
  <div class="item item-8">8</div>
  <div class="item item-9">9</div>
</div>

<h3 id="fr-关键字"><a href="#fr-关键字" class="headerlink" title="fr 关键字"></a>fr 关键字</h3><p>为了方便表示比例关系，网格布局提供了fr关键字（fraction 的缩写，意为”片段”）。如果两列的宽度分别为1fr和2fr，就表示后者是前者的两倍。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.container &#123;</span><br><span class="line">   display: grid;</span><br><span class="line">  grid-template-columns: 1fr 1fr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<style>
    #container4 {
        display: grid;
        grid-template-columns: 1fr 1fr 1fr;
    }
</style>
<div id="container4">
  <div class="item item-1">1</div>
  <div class="item item-2">2</div>
  <div class="item item-3">3</div>
  <div class="item item-4">4</div>
  <div class="item item-5">5</div>
  <div class="item item-6">6</div>
  <div class="item item-7">7</div>
  <div class="item item-8">8</div>
  <div class="item item-9">9</div>
</div>
fr可以与绝对长度的单位结合使用，这时会非常方便。
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.container &#123;</span><br><span class="line">  display: grid;</span><br><span class="line">  grid-template-columns: 150px 1fr 2fr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<style>
    #container5 {
        display: grid;
        grid-template-columns: 150px 1fr 1fr;
    }
</style>
<div id="container5">
  <div class="item item-1">1</div>
  <div class="item item-2">2</div>
  <div class="item item-3">3</div>
  <div class="item item-4">4</div>
  <div class="item item-5">5</div>
  <div class="item item-6">6</div>
  <div class="item item-7">7</div>
  <div class="item item-8">8</div>
  <div class="item item-9">9</div>
</div>

<h3 id="minmax（）"><a href="#minmax（）" class="headerlink" title="minmax（）"></a>minmax（）</h3><p>minmax()函数产生一个长度范围，表示长度就在这个范围之中。它接受两个参数，分别为最小值和最大值。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">grid-template-columns: 1fr 1fr minmax(100px, 1fr);//表示列宽不小于100px，不大于1fr</span><br></pre></td></tr></table></figure>

<style>
    #container6 {
        display: grid;
        grid-template-columns: 1fr 1fr minmax(100px, 2fr);
    }
</style>
<div id="container6">
  <div class="item item-1">1</div>
  <div class="item item-2">2</div>
  <div class="item item-3">3</div>
  <div class="item item-4">4</div>
  <div class="item item-5">5</div>
  <div class="item item-6">6</div>
  <div class="item item-7">7</div>
  <div class="item item-8">8</div>
  <div class="item item-9">9</div>
</div>

<h3 id="auto-关键字"><a href="#auto-关键字" class="headerlink" title="auto 关键字"></a>auto 关键字</h3><p>auto关键字表示由浏览器自己决定长度。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">grid-template-columns: 100px auto 100px;</span><br></pre></td></tr></table></figure>

<style>
    #container7 {
        display: grid;
        grid-template-columns: 100px auto 100px;
    }
</style>
<div id="container7">
  <div class="item item-1">1</div>
  <div class="item item-2">2</div>
  <div class="item item-3">3</div>
  <div class="item item-4">4</div>
  <div class="item item-5">5</div>
  <div class="item item-6">6</div>
  <div class="item item-7">7</div>
  <div class="item item-8">8</div>
  <div class="item item-9">9</div>
</div>

<h3 id="网格线的名称"><a href="#网格线的名称" class="headerlink" title="网格线的名称"></a>网格线的名称</h3><p>grid-template-columns属性和grid-template-rows属性里面，还可以使用方括号，指定每一根网格线的名字，方便以后的引用。网格布局允许同一根线有多个名字.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.container &#123;</span><br><span class="line">  display: grid;</span><br><span class="line">  grid-template-columns: [c1] 100px [c2] 100px [c3] auto [c4];</span><br><span class="line">  grid-template-rows: [r1] 100px [r2] 100px [r3] auto [r4];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="grid-row-gap-grid-column-gap-grid-gap"><a href="#grid-row-gap-grid-column-gap-grid-gap" class="headerlink" title="grid-row-gap grid-column-gap grid-gap"></a>grid-row-gap grid-column-gap grid-gap</h2><p>grid-row-gap属性设置行与行的间隔（行间距），grid-column-gap属性设置列与列的间隔（列间距）。<br>grid-gap属性是grid-column-gap和grid-row-gap的合并简写形式，语法如下。</p>
<p>根据最新标准，上面三个属性名的grid-前缀已经删除，grid-column-gap和grid-row-gap写成column-gap和row-gap，grid-gap写成gap。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">grid-gap: &lt;grid-row-gap&gt; &lt;grid-column-gap&gt;;</span><br><span class="line">.container &#123;</span><br><span class="line">  grid-row-gap: 20px;</span><br><span class="line">  grid-column-gap: 20px;</span><br><span class="line">  // grid-gap: 20px 20px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<style>
    #container8 {
        display: grid;
        grid-template-columns: 100px 100px 100px;
        column-gap: 20px;
        row-gap: 20px;
        /* grid-gap: 20px 20px; // 简写 */
    }
</style>
<div id="container8">
  <div class="item item-1">1</div>
  <div class="item item-2">2</div>
  <div class="item item-3">3</div>
  <div class="item item-4">4</div>
  <div class="item item-5">5</div>
  <div class="item item-6">6</div>
  <div class="item item-7">7</div>
  <div class="item item-8">8</div>
  <div class="item item-9">9</div>
</div>

<h2 id="grid-template-areas"><a href="#grid-template-areas" class="headerlink" title="grid-template-areas"></a>grid-template-areas</h2><p>网格布局允许指定”区域”（area），一个区域由单个或多个单元格组成。grid-template-areas属性用于定义区域。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.container &#123;</span><br><span class="line">  display: grid;</span><br><span class="line">  grid-template-columns: 100px 100px 100px;</span><br><span class="line">  grid-template-rows: 100px 100px 100px;</span><br><span class="line">  grid-template-areas: &#x27;a b c&#x27;</span><br><span class="line">                       &#x27;d e f&#x27;</span><br><span class="line">                       &#x27;g h i&#x27;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果某些区域不需要利用，则使用”点”（.）表示。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.container &#123;</span><br><span class="line">  display: grid;</span><br><span class="line">  grid-template-columns: 100px 100px 100px;</span><br><span class="line">  grid-template-rows: 100px 100px 100px;</span><br><span class="line">  grid-template-areas: &#x27;a . c&#x27;</span><br><span class="line">                       &#x27;d . f&#x27;</span><br><span class="line">                       &#x27;g . i&#x27;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，区域的命名会影响到网格线。每个区域的起始网格线，会自动命名为区域名-start，终止网格线自动命名为区域名-end。</p>
<p>比如，区域名为header，则起始位置的水平网格线和垂直网格线叫做header-start，终止位置的水平网格线和垂直网格线叫做header-end。</p>
<h2 id="grid-auto-flow"><a href="#grid-auto-flow" class="headerlink" title="grid-auto-flow"></a>grid-auto-flow</h2><p>顺序由grid-auto-flow属性决定，默认值是row，即”先行后列”。也可以将它设成column，变成”先列后行”。row dense和column dense。这两个值主要用于，某些项目指定位置以后，剩下的项目怎么自动放置<br>设为row dense，表示”先行后列”，并且尽可能紧密填满，尽量不出现空格。</p>
<p>column:</p>
<style>
    #container9 {
        display: grid;
        grid-template-columns: 100px 100px 100px;
        grid-template-rows: 100px 100px 100px;
        grid-auto-flow: column;
    }
</style>
<div id="container9">
  <div class="item item-1">1</div>
  <div class="item item-2">2</div>
  <div class="item item-3">3</div>
  <div class="item item-4">4</div>
  <div class="item item-5">5</div>
  <div class="item item-6">6</div>
  <div class="item item-7">7</div>
  <div class="item item-8">8</div>
  <div class="item item-9">9</div>
</div>
row(默认):
<style>
    #container10 {
        display: grid;
        grid-template-columns: 100px 100px 100px;
        grid-auto-flow: row;
    }
</style>
<div id="container10">
  <div class="item item-1">1</div>
  <div class="item item-2">2</div>
  <div class="item item-3">3</div>
  <div class="item item-4">4</div>
  <div class="item item-5">5</div>
  <div class="item item-6">6</div>
  <div class="item item-7">7</div>
  <div class="item item-8">8</div>
  <div class="item item-9">9</div>
</div>

<p>row dense 之前:</p>
<style>
    #container11 {
        display: grid;
        grid-template-columns: 100px 100px 100px;
        grid-auto-flow: row;
    }
    #container11 .item-1 {
        grid-column-start: 1;
        grid-column-end: 3;
    }
    #container11 .item-2 {
        grid-column-start: 1;
        grid-column-end: 3;
    }
</style>
<div id="container11">
  <div class="item item-1">1</div>
  <div class="item item-2">2</div>
  <div class="item item-3">3</div>
  <div class="item item-4">4</div>
  <div class="item item-5">5</div>
  <div class="item item-6">6</div>
  <div class="item item-7">7</div>
  <div class="item item-8">8</div>
  <div class="item item-9">9</div>
</div>
row dense
<style>
    #container12 {
        display: grid;
        grid-template-columns: 100px 100px 100px;
        grid-auto-flow: row dense;
    }
    #container12 .item-1 {
        grid-column-start: 1;
        grid-column-end: 3;
    }
    #container12 .item-2 {
        grid-column-start: 1;
        grid-column-end: 3;
    }
</style>
<div id="container12">
  <div class="item item-1">1</div>
  <div class="item item-2">2</div>
  <div class="item item-3">3</div>
  <div class="item item-4">4</div>
  <div class="item item-5">5</div>
  <div class="item item-6">6</div>
  <div class="item item-7">7</div>
  <div class="item item-8">8</div>
  <div class="item item-9">9</div>
</div>

<p>column dense 之前:</p>
<style>
    #container13 {
        display: grid;
        grid-template-columns: 100px 100px 100px;
        grid-template-rows: 100px 100px 100px;
        grid-auto-flow: column;
    }
    #container13 .item-1 {
        grid-row-start: 1;
        grid-row-end: 3;
    }
    #container13 .item-2 {
        grid-row-start: 1;
        grid-row-end: 3;
    }
</style>
<div id="container13">
  <div class="item item-1">1</div>
  <div class="item item-2">2</div>
  <div class="item item-3">3</div>
  <div class="item item-4">4</div>
  <div class="item item-5">5</div>
  <div class="item item-6">6</div>
  <div class="item item-7">7</div>
  <div class="item item-8">8</div>
  <div class="item item-9">9</div>
</div>
column dense
<style>
    #container14 {
        display: grid;
        grid-template-columns: 100px 100px 100px;
        grid-template-rows: 100px 100px 100px;
        grid-auto-flow: column dense;
    }
    #container14 .item-1 {
        grid-row-start: 1;
        grid-row-end: 3;
    }
    #container14 .item-2 {
        grid-row-start: 1;
        grid-row-end: 3;
    }
</style>
<div id="container14">
  <div class="item item-1">1</div>
  <div class="item item-2">2</div>
  <div class="item item-3">3</div>
  <div class="item item-4">4</div>
  <div class="item item-5">5</div>
  <div class="item item-6">6</div>
  <div class="item item-7">7</div>
  <div class="item item-8">8</div>
  <div class="item item-9">9</div>
</div>

<h2 id="justify-items-属性，align-items-属性，place-items-属性"><a href="#justify-items-属性，align-items-属性，place-items-属性" class="headerlink" title="justify-items 属性，align-items 属性，place-items 属性"></a>justify-items 属性，align-items 属性，place-items 属性</h2><p>justify-items属性设置单元格内容的水平位置（左中右），align-items属性设置单元格内容的垂直位置（上中下）。<br>place-items属性是align-items属性和justify-items属性的合并简写形式。<br>· start：对齐单元格的起始边缘。<br>· end：对齐单元格的结束边缘。<br>· center：单元格内部居中。<br>· stretch：拉伸，占满单元格的整个宽度（默认值）。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.container &#123;</span><br><span class="line">  justify-items: start | end | center | stretch;</span><br><span class="line">  align-items: start | end | center | stretch;</span><br><span class="line">&#125;</span><br><span class="line">place-items: &lt;align-items&gt; &lt;justify-items&gt;;</span><br><span class="line">place-items: start end;// 如果省略第二个值，则浏览器认为与第一个值相等。</span><br></pre></td></tr></table></figure>
<p>stretch(默认):</p>
<style>
    #container15 {
        display: grid;
        grid-template-columns: 100px 100px 100px;
        grid-template-rows: 100px 100px 100px;
        justify-items: stretch;
    }
</style>
<div id="container15">
  <div class="item item-1">1</div>
  <div class="item item-2">2</div>
  <div class="item item-3">3</div>
  <div class="item item-4">4</div>
  <div class="item item-5">5</div>
  <div class="item item-6">6</div>
  <div class="item item-7">7</div>
  <div class="item item-8">8</div>
  <div class="item item-9">9</div>
</div>
center: 
<style>
    #container16 {
        display: grid;
        grid-template-columns: 100px 100px 100px;
        grid-template-rows: 100px 100px 100px;
        justify-items: center;
    }
</style>
<div id="container16">
  <div class="item item-1">1</div>
  <div class="item item-2">2</div>
  <div class="item item-3">3</div>
  <div class="item item-4">4</div>
  <div class="item item-5">5</div>
  <div class="item item-6">6</div>
  <div class="item item-7">7</div>
  <div class="item item-8">8</div>
  <div class="item item-9">9</div>
</div>


<h2 id="justify-content-属性，align-content-属性，place-content-属性"><a href="#justify-content-属性，align-content-属性，place-content-属性" class="headerlink" title="justify-content 属性，align-content 属性，place-content 属性"></a>justify-content 属性，align-content 属性，place-content 属性</h2><p>justify-content属性是整个内容区域在容器里面的水平位置（左中右），align-content属性是整个内容区域的垂直位置（上中下）。place-content<br> · start - 对齐容器的起始边框。<br> · end - 对齐容器的结束边框。<br> · center - 容器内部居中。<br> · stretch - 项目大小没有指定时，拉伸占据整个网格容器。<br> · space-around - 每个项目两侧的间隔相等。所以，项目之间的间隔比项目与容器边框的间隔大一倍。<br> · space-between - 项目与项目的间隔相等，项目与容器边框之间没有间隔。<br> · space-evenly - 项目与项目的间隔相等，项目与容器边框之间也是同样长度的间隔。<br> ·</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.container &#123;</span><br><span class="line">  justify-content: start | end | center | stretch | space-around | space-between | space-evenly;</span><br><span class="line">  align-content: start | end | center | stretch | space-around | space-between | space-evenly;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>stretch(默认)：项目大小没有指定时，拉伸占据整个网格容器。</p>
<style>
    #container-box17 {
        width: 100%;
    }
    #container17 {
        display: grid;
        grid-template-columns: auto auto auto;
        grid-template-rows: 100px 100px 100px;
        grid-template-rows: 100px 100px 100px;
        justify-content: stretch;
    }
</style>
<div id="container-box17">
    <div id="container17">
  <div class="item item-1">1</div>
  <div class="item item-2">2</div>
  <div class="item item-3">3</div>
  <div class="item item-4">4</div>
  <div class="item item-5">5</div>
  <div class="item item-6">6</div>
  <div class="item item-7">7</div>
  <div class="item item-8">8</div>
  <div class="item item-9">9</div>
</div>
</div>
center:容器内部居中。
<style>
    #container18 {
        display: grid;
        grid-template-columns: 100px 100px 100px;
        grid-template-rows: 100px 100px 100px;
        justify-content: center;
    }
</style>
<div id="container18">
  <div class="item item-1">1</div>
  <div class="item item-2">2</div>
  <div class="item item-3">3</div>
  <div class="item item-4">4</div>
  <div class="item item-5">5</div>
  <div class="item item-6">6</div>
  <div class="item item-7">7</div>
  <div class="item item-8">8</div>
  <div class="item item-9">9</div>
</div>
start:对齐容器的起始边框。
<style>
    #container19 {
        display: grid;
        grid-template-columns: 100px 100px 100px;
        grid-template-rows: 100px 100px 100px;
        justify-content: start;
    }
</style>
<div id="container19">
  <div class="item item-1">1</div>
  <div class="item item-2">2</div>
  <div class="item item-3">3</div>
  <div class="item item-4">4</div>
  <div class="item item-5">5</div>
  <div class="item item-6">6</div>
  <div class="item item-7">7</div>
  <div class="item item-8">8</div>
  <div class="item item-9">9</div>
</div>
end:对齐容器的结束边框。
<style>
    #container20 {
        display: grid;
        grid-template-columns: 100px 100px 100px;
        grid-template-rows: 100px 100px 100px;
        justify-content: end;
    }
</style>
<div id="container20">
  <div class="item item-1">1</div>
  <div class="item item-2">2</div>
  <div class="item item-3">3</div>
  <div class="item item-4">4</div>
  <div class="item item-5">5</div>
  <div class="item item-6">6</div>
  <div class="item item-7">7</div>
  <div class="item item-8">8</div>
  <div class="item item-9">9</div>
</div>
space-around:每个项目两侧的间隔相等。所以，项目之间的间隔比项目与容器边框的间隔大一倍。
<style>
    #container21 {
        display: grid;
        grid-template-columns: 100px 100px 100px;
        grid-template-rows: 100px 100px 100px;
        justify-content: space-around;
    }
</style>
<div id="container21">
  <div class="item item-1">1</div>
  <div class="item item-2">2</div>
  <div class="item item-3">3</div>
  <div class="item item-4">4</div>
  <div class="item item-5">5</div>
  <div class="item item-6">6</div>
  <div class="item item-7">7</div>
  <div class="item item-8">8</div>
  <div class="item item-9">9</div>
</div>

<p>space-between:项目与项目的间隔相等，项目与容器边框之间没有间隔。</p>
<style>
    #container22 {
        display: grid;
        grid-template-columns: 100px 100px 100px;
        grid-template-rows: 100px 100px 100px;
        justify-content: space-between;
    }
</style>
<div id="container22">
  <div class="item item-1">1</div>
  <div class="item item-2">2</div>
  <div class="item item-3">3</div>
  <div class="item item-4">4</div>
  <div class="item item-5">5</div>
  <div class="item item-6">6</div>
  <div class="item item-7">7</div>
  <div class="item item-8">8</div>
  <div class="item item-9">9</div>
</div>

<p>space-evenly:项目与项目的间隔相等，项目与容器边框之间也是同样长度的间隔。</p>
<style>
    #container23 {
        display: grid;
        grid-template-columns: 100px 100px 100px;
        grid-template-rows: 100px 100px 100px;
        justify-content: space-evenly;
    }
</style>
<div id="container23">
  <div class="item item-1">1</div>
  <div class="item item-2">2</div>
  <div class="item item-3">3</div>
  <div class="item item-4">4</div>
  <div class="item item-5">5</div>
  <div class="item item-6">6</div>
  <div class="item item-7">7</div>
  <div class="item item-8">8</div>
  <div class="item item-9">9</div>
</div>


<h2 id="grid-auto-columns-属性，grid-auto-rows-属性"><a href="#grid-auto-columns-属性，grid-auto-rows-属性" class="headerlink" title="grid-auto-columns 属性，grid-auto-rows 属性"></a>grid-auto-columns 属性，grid-auto-rows 属性</h2><p>有时候，一些项目的指定位置，在现有网格的外部。比如网格只有3列，但是某一个项目指定在第5行。这时，浏览器会自动生成多余的网格，以便放置项目。</p>
<p>grid-auto-columns属性和grid-auto-rows属性用来设置，浏览器自动创建的多余网格的列宽和行高。它们的写法与grid-template-columns和grid-template-rows完全相同。如果不指定这两个属性，浏览器完全根据单元格内容的大小，决定新增网格的列宽和行高。</p>
<h2 id="grid-template-属性，grid-属性"><a href="#grid-template-属性，grid-属性" class="headerlink" title="grid-template 属性，grid 属性"></a>grid-template 属性，grid 属性</h2><p>grid-template属性是grid-template-columns、grid-template-rows和grid-template-areas这三个属性的合并简写形式。</p>
<p>grid属性是grid-template-rows、grid-template-columns、grid-template-areas、 grid-auto-rows、grid-auto-columns、grid-auto-flow这六个属性的合并简写形式。</p>
<h1 id="子元素属性"><a href="#子元素属性" class="headerlink" title="子元素属性"></a>子元素属性</h1><h2 id="grid-column-start-属性，grid-column-end-属性，grid-row-start-属，grid-row-end-属性"><a href="#grid-column-start-属性，grid-column-end-属性，grid-row-start-属，grid-row-end-属性" class="headerlink" title="grid-column-start 属性，grid-column-end 属性，grid-row-start 属，grid-row-end 属性"></a>grid-column-start 属性，grid-column-end 属性，grid-row-start 属，grid-row-end 属性</h2><p>· grid-column-start属性：左边框所在的垂直网格线<br>· grid-column-end属性：右边框所在的垂直网格线<br>· grid-row-start属性：上边框所在的水平网格线<br>· grid-row-end属性：下边框所在的水平网格线</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">.item-1 &#123;</span><br><span class="line">  grid-column-start: 1;</span><br><span class="line">  grid-column-end: 3;</span><br><span class="line">  grid-row-start: 2;</span><br><span class="line">  grid-row-end: 4;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.item-2 &#123;</span><br><span class="line">  grid-column-start: header-start;</span><br><span class="line">  grid-column-end: header-end;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<style>
    #container24 {
        display: grid;
        grid-template-columns: 100px 100px 100px;
        grid-template-rows: 100px 100px 100px;
    }
    #container24 .item-1 {
        grid-column-start: 2;
        grid-column-end: 4;
        
    }
</style>
<div id="container24">
  <div class="item item-1">1</div>
  <div class="item item-2">2</div>
  <div class="item item-3">3</div>
  <div class="item item-4">4</div>
  <div class="item item-5">5</div>
  <div class="item item-6">6</div>
  <div class="item item-7">7</div>
  <div class="item item-8">8</div>
  <div class="item item-9">9</div>
</div>

<p>这四个属性的值还可以使用span关键字，表示”跨越”，即左右边框（上下边框）之间跨越多少个网格。</p>
<style>
    #container25 {
        display: grid;
        grid-template-columns: 100px 100px 100px;
        grid-template-rows: 100px 100px 100px;
    }
    #container25 .item-1 {
        grid-column-start: span 2;
        
    }
    #container25 .item-2 {
        grid-row-end: span 4;
        
    }
</style>
<div id="container25">
  <div class="item item-1">1</div>
  <div class="item item-2">2</div>
  <div class="item item-3">3</div>
  <div class="item item-4">4</div>
  <div class="item item-5">5</div>
  <div class="item item-6">6</div>
  <div class="item item-7">7</div>
  <div class="item item-8">8</div>
  <div class="item item-9">9</div>
</div>
2. grid-column 属性，grid-row 属性

<p>grid-column属性是grid-column-start和grid-column-end的合并简写形式，grid-row属性是grid-row-start属性和grid-row-end的合并简写形式。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.item &#123;</span><br><span class="line">  grid-column: &lt;start-line&gt; / &lt;end-line&gt;;</span><br><span class="line">  grid-row: &lt;start-line&gt; / &lt;end-line&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>grid-area属性<br>grid-area属性指定项目放在哪一个区域。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.item-1 &#123;</span><br><span class="line">  grid-area: e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<style>
 #container26 {
     display: grid;
     grid-template-columns: 100px 100px 100px;
     grid-template-rows: 100px 100px 100px;
     grid-template-areas: 'a b c'
                         'd e f'
                         'g h i'
 }
 #container26 .item-1 {
     grid-area: e;
 }</li>
</ol>
<p></style><p></p>
<div id="container26">
  <div class="item item-1">1</div>
  <div class="item item-2">2</div>
  <div class="item item-3">3</div>
  <div class="item item-4">4</div>
  <div class="item item-5">5</div>
  <div class="item item-6">6</div>
  <div class="item item-7">7</div>
  <div class="item item-8">8</div>
  <div class="item item-9">9</div>
</div>
grid-area属性还可用作grid-row-start、grid-column-start、grid-row-end、grid-column-end的合并简写形式，直接指定项目的位置。

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">.item &#123;</span><br><span class="line">  grid-area: &lt;row-start&gt; / &lt;column-start&gt; / &lt;row-end&gt; / &lt;column-end&gt;;</span><br><span class="line">&#125;</span><br><span class="line">.item-1 &#123;</span><br><span class="line">  grid-area: 1 / 1 / 3 / 3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<style>
    #container27 {
        display: grid;
        grid-template-columns: 100px 100px 100px;
        grid-template-rows: 100px 100px 100px;
    }
    #container27 .item-1 {
        grid-area: 1 / 1 / 3 / 3;
        
    }

</style>
<div id="container27">
  <div class="item item-1">1</div>
  <div class="item item-2">2</div>
  <div class="item item-3">3</div>
  <div class="item item-4">4</div>
  <div class="item item-5">5</div>
  <div class="item item-6">6</div>
  <div class="item item-7">7</div>
  <div class="item item-8">8</div>
  <div class="item item-9">9</div>
</div>


<ol start="4">
<li>justify-self 属性，align-self 属性，place-self 属性</li>
</ol>
<p>justify-self属性设置单元格内容的水平位置（左中右），跟justify-items属性的用法完全一致，但只作用于单个项目。</p>
<p>align-self属性设置单元格内容的垂直位置（上中下），跟align-items属性的用法完全一致，也是只作用于单个项目。</p>
<p>place-self属性是align-self属性和justify-self属性的合并简写形式。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.item &#123;</span><br><span class="line">  justify-self: start | end | center | stretch;</span><br><span class="line">  align-self: start | end | center | stretch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>· start：对齐单元格的起始边缘。<br>· end：对齐单元格的结束边缘。<br>· center：单元格内部居中。<br>· stretch：拉伸，占满单元格的整个宽度（默认值）。</p>
</li></ol>]]></content>
      <categories>
        <category>css</category>
      </categories>
  </entry>
  <entry>
    <title>javascript面试</title>
    <url>/2021/08/19/js%E9%9D%A2%E8%AF%95/</url>
    <content><![CDATA[<h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><h2 id="js中有哪些数据类型，他们的区别是？"><a href="#js中有哪些数据类型，他们的区别是？" class="headerlink" title="js中有哪些数据类型，他们的区别是？"></a>js中有哪些数据类型，他们的区别是？</h2><p>8种原始数据类型：Null, Undefined, Boolean, Number, String,Object,Symbol,BigInt</p>
<p>其中Symbol和BigInt是新增的数据类型：</p>
<ol>
<li>Symbol代表创建后独一无二的数据类型，它主要是为了解决可能出现的全局变量冲突的问题。</li>
<li>BigInt是一种数字类型的数据，它可以表示任意精度格式的整数，使用BigInt可以安全的存储和操作大数据，即使这个书已经超出了Number能够表示的安全整数范围。</li>
</ol>
<p>这些数据可以分为原始数据类型和引用数据类型：</p>
<ol>
<li>栈：原始数据类型（Undefined,Null,Boolean,Number,String）</li>
<li>堆：引用数据类型（对象，数组和函数）</li>
</ol>
<p>两种类型的区别在于存位置的不同：</p>
<ol>
<li>原始数据类型直接存储在栈（stack）中的简单数据段，占据空间小，大小固定，属于被频繁使用数据，所以放入栈种存储；</li>
<li>引用数据类型存储在堆（heap）中的对象，占据空间大，大小不固定。如果存储在栈中，将会影响程序运行的性能；引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索起在栈中的地址，取得地址后从堆中获得实体。</li>
</ol>
<p>堆和栈的概念存在与数据结构和操作系统内存中，在数据结构中：</p>
<ol>
<li>在数据结构中，栈中数据的存取方式为先进后出。</li>
<li>堆是一个优先队列，是按优先级来进行排序的，优先级可以按照大小来规定。</li>
</ol>
<p>在操作系统中，内存被分为栈区和堆区：</p>
<ol>
<li>栈区内存由编译器自动分配释放，存放函数的参数值，局部变量的值等。其操作方式类似与数据结构中的栈。<br>堆区内存一般由开发者分配释放，若开发者不释放，程序结束时可能由垃圾回收机制回收。</li>
</ol>
<h2 id="数据类型检测的方式有哪些？"><a href="#数据类型检测的方式有哪些？" class="headerlink" title="数据类型检测的方式有哪些？"></a>数据类型检测的方式有哪些？</h2><ol>
<li><p>typeof</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">console.log(typeof 2);               // number</span><br><span class="line">console.log(typeof true);            // boolean</span><br><span class="line">console.log(typeof &#x27;str&#x27;);           // string</span><br><span class="line">console.log(typeof []);              // object    </span><br><span class="line">console.log(typeof function()&#123;&#125;);    // function</span><br><span class="line">console.log(typeof &#123;&#125;);              // object</span><br><span class="line">console.log(typeof undefined);       // undefined</span><br><span class="line">console.log(typeof null);            // object</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>其中数组、对象、null都会被判断为object，其他判断都正确</p>
</li>
<li><p>instanceof<br>instanceof 可以正确判断对象的类型，其内部运行机制是判断在其原型链中能否找到该类型的原型。</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">console.log(2 instanceof Number);                    // false</span><br><span class="line">console.log(true instanceof Boolean);                // false </span><br><span class="line">console.log(&#x27;str&#x27; instanceof String);                // false </span><br><span class="line"> </span><br><span class="line">console.log([] instanceof Array);                    // true</span><br><span class="line">console.log(function()&#123;&#125; instanceof Function);       // true</span><br><span class="line">console.log(&#123;&#125; instanceof Object);                   // true</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以看到，instanceof只能正确判断引用数据类型，而不能判断基本数据类型。instanceof运算符可以用来测试一个对象在其原型链中是否存在一个构造函数的prototype属性。</p>
<ol start="3">
<li>constructor</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">console.log((2).constructor === Number); // true</span><br><span class="line">console.log((true).constructor === Boolean); // true</span><br><span class="line">console.log((&#x27;str&#x27;).constructor === String); // true</span><br><span class="line">console.log(([]).constructor === Array); // true</span><br><span class="line">console.log((function() &#123;&#125;).constructor === Function); // true</span><br><span class="line">console.log((&#123;&#125;).constructor === Object); // true</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>constructor有两个作用，一是判断数据的类型，二是对象实例通过constructor对象访问它的构造函数。需要注意，如果创建一个对象来改变它的原型，constructor就不能用来判断数据类型来：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function Fn()&#123;&#125;;</span><br><span class="line"> </span><br><span class="line">Fn.prototype = new Array();</span><br><span class="line"> </span><br><span class="line">var f = new Fn();</span><br><span class="line"> </span><br><span class="line">console.log(f.constructor===Fn);    // false</span><br><span class="line">console.log(f.constructor===Array); // true</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="4">
<li>Object.prototype.toString.call()</li>
</ol>
<p>Object.prototype.toString.call()使用Object对象的原型方法toString来判断数据类型：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var a = Object.prototype.toString;</span><br><span class="line"> </span><br><span class="line">console.log(a.call(2));</span><br><span class="line">console.log(a.call(true));</span><br><span class="line">console.log(a.call(&#x27;str&#x27;));</span><br><span class="line">console.log(a.call([]));</span><br><span class="line">console.log(a.call(function()&#123;&#125;));</span><br><span class="line">console.log(a.call(&#123;&#125;));</span><br><span class="line">console.log(a.call(undefined));</span><br><span class="line">console.log(a.call(null));</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>同样是检测对象obj调用toString方法，obj.toString()的结果和Object.prototype.toString.call(obj)的结果不一样，这是为什么？<br>这是因为toString是Object的原型方法，而Array、function等类型作为Object的实例，都重写了toString方法。不同的对象类型调用toString方法时，根据原型链的知识，调用的是对应的重写之后的toString方法（function类型返回内容为函数体的字符串，Array类型返回元素组成的字符串…），而不会去调用Object上原型toString方法（返回对象的具体类型），所以采用obj.toString()不能得到其对象类型，只能将obj转换为字符串类型；因此，在想要得到对象的具体类型时，应该调用Object原型上的toString方法。</p>
<h2 id="判断数组的方式有哪些"><a href="#判断数组的方式有哪些" class="headerlink" title="判断数组的方式有哪些"></a>判断数组的方式有哪些</h2><ol>
<li>通过Object.prototype.toString.call()做判断</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Object.prototype.toString.call(obj).slice(8,-1) === &#x27;Array&#x27;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>通过原型链做判断</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">obj.__proto__ === Array.prototype;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>通过ES6的Array.isArray()做判断</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Array.isArrray(obj);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="4">
<li>通过instanceof做判断</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">obj instanceof Array</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="5">
<li>通过Array.prototype.isPrototypeOf<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Array.prototype.isPrototypeOf(obj)</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="null和undefined区别"><a href="#null和undefined区别" class="headerlink" title="null和undefined区别"></a>null和undefined区别</h2><p>首先 Undefined 和 Null 都是基本数据类型，这两个基本数据类型分别都只有一个值，就是 undefined 和 null。<br>undefined 代表的含义是未定义，null 代表的含义是空对象。一般变量声明了但还没有定义的时候会返回 undefined，null主要用于赋值给一些可能会返回对象的变量，作为初始化。<br>undefined 在 JavaScript 中不是一个保留字，这意味着可以使用 undefined 来作为一个变量名，但是这样的做法是非常危险的，它会影响对 undefined 值的判断。我们可以通过一些方法获得安全的 undefined 值，比如说 void 0。<br>当对这两种类型使用 typeof 进行判断时，Null 类型化会返回 “object”，这是一个历史遗留的问题。当使用双等号对两种类型的值进行比较时会返回 true，使用三个等号时会返回 false。</p>
<h2 id="typeof-null-的结果是什么，为什么？"><a href="#typeof-null-的结果是什么，为什么？" class="headerlink" title="typeof null 的结果是什么，为什么？"></a>typeof null 的结果是什么，为什么？</h2><p>typeof null 的结果是Object。<br>在 JavaScript 第一个版本中，所有值都存储在 32 位的单元中，每个单元包含一个小的 类型标签(1-3 bits) 以及当前要存储值的真实数据。类型标签存储在每个单元的低位中，共有五种数据类型：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">000: object   - 当前存储的数据指向一个对象。</span><br><span class="line">  1: int      - 当前存储的数据是一个 31 位的有符号整数。</span><br><span class="line">010: double   - 当前存储的数据指向一个双精度的浮点数。</span><br><span class="line">100: string   - 当前存储的数据指向一个字符串。</span><br><span class="line">110: boolean  - 当前存储的数据是布尔值。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果最低位是 1，则类型标签标志位的长度只有一位；如果最低位是 0，则类型标签标志位的长度占三位，为存储其他四种数据类型提供了额外两个 bit 的长度。<br>有两种特殊数据类型：</p>
<p>undefined的值是 (-2)30(一个超出整数范围的数字)；<br>null 的值是机器码 NULL 指针(null 指针的值全是 0)</p>
<p>那也就是说null的类型标签也是000，和Object的类型标签一样，所以会被判定为Object。</p>
<h2 id="intanceof-操作符的实现原理及实现"><a href="#intanceof-操作符的实现原理及实现" class="headerlink" title="intanceof 操作符的实现原理及实现"></a>intanceof 操作符的实现原理及实现</h2><p>instanceof 运算符用于判断构造函数的 prototype 属性是否出现在对象的原型链中的任何位置。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function myInstanceof(left, right) &#123;</span><br><span class="line">  // 获取对象的原型</span><br><span class="line">  let proto = Object.getPrototypeOf(left)</span><br><span class="line">  // 获取构造函数的 prototype 对象</span><br><span class="line">  let prototype = right.prototype; </span><br><span class="line"> </span><br><span class="line">  // 判断构造函数的 prototype 对象是否在对象的原型链上</span><br><span class="line">  while (true) &#123;</span><br><span class="line">    if (!proto) return false;</span><br><span class="line">    if (proto === prototype) return true;</span><br><span class="line">    // 如果没有找到，就继续从其原型上找，Object.getPrototypeOf方法用来获取指定对象的原型</span><br><span class="line">    proto = Object.getPrototypeOf(proto);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="为什么0-1-0-2-0-3，如何让其相等"><a href="#为什么0-1-0-2-0-3，如何让其相等" class="headerlink" title="为什么0.1+0.2 ! == 0.3，如何让其相等"></a>为什么0.1+0.2 ! == 0.3，如何让其相等</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0.1+0.2 = 0.30000000000000004 !== 0.3</span><br></pre></td></tr></table></figure>
<p>这里得到的不是想要的结果，要想等于0.3，就要把它进行转化：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(n1 + n2).toFixed(2) // 注意，toFixed为四舍五入</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol>
<li><p>toFixed(num) 方法</p>
</li>
<li><p>设置一个误差范围，通常称为“机器精度”。对JavaScript来说，这个值通常为2-52，在ES6中，提供了Number.EPSILON属性，而它的值就是2-52，只要判断0.1+0.2-0.3是否小于Number.EPSILON，如果小于，就可以判断为0.1+0.2 ===0.3</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function numberepsilon(arg1,arg2)&#123;                   </span><br><span class="line">  return Math.abs(arg1 - arg2) &lt; Number.EPSILON;        </span><br><span class="line">&#125;        </span><br><span class="line"></span><br><span class="line">console.log(numberepsilon(0.1 + 0.2, 0.3)); // true</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="如何获取安全的-undefined-值？"><a href="#如何获取安全的-undefined-值？" class="headerlink" title="如何获取安全的 undefined 值？"></a>如何获取安全的 undefined 值？</h2><p>因为 undefined 是一个标识符，所以可以被当作变量来使用和赋值，但是这样会影响 undefined 的正常判断。表达式 void ___ 没有返回值，因此返回结果是 undefined。void 并不改变表达式的结果，只是让表达式不返回值。因此可以用 void 0 来获得 undefined。</p>
<h2 id="typeof-NaN-的结果是什么？"><a href="#typeof-NaN-的结果是什么？" class="headerlink" title="typeof NaN 的结果是什么？"></a>typeof NaN 的结果是什么？</h2><p>NaN 指“不是一个数字”（not a number），NaN 是一个“警戒值”（sentinel value，有特殊用途的常规值），用于指出数字类型中的错误情况，即“执行数学运算没有成功，这是失败后返回的结果”。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">typeof NaN; // &quot;number&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>NaN 是一个特殊值，它和自身不相等，是唯一一个非自反（自反，reflexive，即 x === x 不成立）的值。而 NaN !== NaN 为 true。</p>
<h2 id="isNaN-和-Number-isNaN-函数的区别？"><a href="#isNaN-和-Number-isNaN-函数的区别？" class="headerlink" title="isNaN 和 Number.isNaN 函数的区别？"></a>isNaN 和 Number.isNaN 函数的区别？</h2><ol>
<li>函数 isNaN 接收参数后，会尝试将这个参数转换为数值，任何不能被转换为数值的的值都会返回 true，因此非数字值传入也会返回 true ，会影响 NaN 的判断。</li>
<li>函数 Number.isNaN 会首先判断传入参数是否为数字，如果是数字再继续判断是否为 NaN ，不会进行数据类型的转换，这种方法对于 NaN 的判断更为准确。</li>
</ol>
<h2 id="操作符的强制类型转换规则？"><a href="#操作符的强制类型转换规则？" class="headerlink" title="== 操作符的强制类型转换规则？"></a>== 操作符的强制类型转换规则？</h2><p>对于 == 来说，如果对比双方的类型不一样，就会进行类型转换。假如对比 x 和 y 是否相同，就会进行如下判断流程：</p>
<ol>
<li><p>首先会判断两者类型是否<strong>相同，</strong>相同的话就比较两者的大小；</p>
</li>
<li><p>类型不相同的话，就会进行类型转换；</p>
</li>
<li><p>会先判断是否在对比 null 和 undefined，是的话就会返回 true</p>
</li>
<li><p>判断两者类型是否为 string 和 number，是的话就会将字符串转换为 number</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 == &#x27;1&#x27;</span><br><span class="line">      ↓</span><br><span class="line">1 ==  1</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>判断其中一方是否为 boolean，是的话就会把 boolean 转为 number 再进行判断</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#x27;1&#x27; == true</span><br><span class="line">        ↓</span><br><span class="line">&#x27;1&#x27; ==  1</span><br><span class="line">        ↓</span><br><span class="line"> 1  ==  1</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="6">
<li>判断其中一方是否为 object 且另一方为 string、number 或者 symbol，是的话就会把 object 转为原始类型再进行判断</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#x27;1&#x27; == &#123; name: &#x27;js&#x27; &#125;        ↓&#x27;1&#x27; == &#x27;[object Object]&#x27;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="其他值到字符串的转换规则？"><a href="#其他值到字符串的转换规则？" class="headerlink" title="其他值到字符串的转换规则？"></a>其他值到字符串的转换规则？</h2><ol>
<li>Null 和 Undefined 类型 ，null 转换为 “null”，undefined 转换为 “undefined”，</li>
<li>Boolean 类型，true 转换为 “true”，false 转换为 “false”。</li>
<li>Number 类型的值直接转换，不过那些极小和极大的数字会使用指数形式。</li>
<li>Symbol 类型的值直接转换，但是只允许显式强制类型转换，使用隐式强制类型转换会产生错误。</li>
<li>对普通对象来说，除非自行定义 toString() 方法，否则会调用 toString()（Object.prototype.toString()）来返回内部属性 [[Class]] 的值，如”[object Object]”。如果对象有自己的 toString() 方法，字符串化时就会调用该方法并使用其返回值。</li>
</ol>
<h2 id="其他值到数字值的转换规则？"><a href="#其他值到数字值的转换规则？" class="headerlink" title="其他值到数字值的转换规则？"></a>其他值到数字值的转换规则？</h2><ol>
<li>Undefined 类型的值转换为 NaN。</li>
<li>Null 类型的值转换为 0。</li>
<li>Boolean 类型的值，true 转换为 1，false 转换为 0。</li>
<li>String 类型的值转换如同使用 Number() 函数进行转换，如果包含非数字值则转换为 NaN，空字符串为 0。</li>
<li>Symbol 类型的值不能转换为数字，会报错。</li>
<li>对象（包括数组）会首先被转换为相应的基本类型值，如果返回的是非数字的基本类型值，则再遵循以上规则将其强制转换为数字。</li>
</ol>
<p>为了将值转换为相应的基本类型值，抽象操作 ToPrimitive 会首先（通过内部操作 DefaultValue）检查该值是否有valueOf()方法。如果有并且返回基本类型值，就使用该值进行强制类型转换。如果没有就使用 toString() 的返回值（如果存在）来进行强制类型转换。<br>如果 valueOf() 和 toString() 均不返回基本类型值，会产生 TypeError 错误。</p>
<h2 id="其他值到布尔类型的值的转换规则？"><a href="#其他值到布尔类型的值的转换规则？" class="headerlink" title="其他值到布尔类型的值的转换规则？"></a>其他值到布尔类型的值的转换规则？</h2><p>以下这些是假值： • undefined • null • false • +0、-0 和 NaN • “”</p>
<p>假值的布尔强制类型转换结果为 false。从逻辑上说，假值列表以外的都应该是真值。</p>
<h2 id="和-amp-amp-操作符的返回值？"><a href="#和-amp-amp-操作符的返回值？" class="headerlink" title="|| 和 &amp;&amp; 操作符的返回值？"></a>|| 和 &amp;&amp; 操作符的返回值？</h2><p>|| 和 &amp;&amp; 首先会对第一个操作数执行条件判断，如果其不是布尔值就先强制转换为布尔类型，然后再执行条件判断。</p>
<ol>
<li>对于 || 来说，如果条件判断结果为 true 就返回第一个操作数的值，如果为 false 就返回第二个操作数的值。</li>
<li>&amp;&amp; 则相反，如果条件判断结果为 true 就返回第二个操作数的值，如果为 false 就返回第一个操作数的值。</li>
</ol>
<p>|| 和 &amp;&amp; 返回它们其中一个操作数的值，而非条件判断的结果</p>
<h2 id="Object-is-与比较操作符-“-”、“-”-的区别？"><a href="#Object-is-与比较操作符-“-”、“-”-的区别？" class="headerlink" title="Object.is() 与比较操作符 “===”、“==” 的区别？"></a>Object.is() 与比较操作符 “===”、“==” 的区别？</h2><ol>
<li>使用双等号（==）进行相等判断时，如果两边的类型不一致，则会进行强制类型转化后再进行比较。</li>
<li>使用三等号（===）进行相等判断时，如果两边的类型不一致时，不会做强制类型准换，直接返回 false。</li>
<li>使用 Object.is 来进行相等判断时，一般情况下和三等号的判断相同，它处理了一些特殊的情况，比如 -0 和 +0 不再相等，两个 NaN 是相等的。</li>
</ol>
<h2 id="什么是-JavaScript-中的包装类型？"><a href="#什么是-JavaScript-中的包装类型？" class="headerlink" title="什么是 JavaScript 中的包装类型？"></a>什么是 JavaScript 中的包装类型？</h2><p>在 JavaScript 中，基本类型是没有属性和方法的，但是为了便于操作基本类型的值，在调用基本类型的属性或方法时 JavaScript 会在后台隐式地将基本类型的值转换为对象，如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const a = &quot;abc&quot;;</span><br><span class="line">a.length; // 3</span><br><span class="line">a.toUpperCase(); // &quot;ABC&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在访问’abc’.length时，JavaScript 将’abc’在后台转换成String(‘abc’)，然后再访问其length属性。</p>
<p>JavaScript也可以使用Object函数显式地将基本类型转换为包装类型：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var a = &#x27;abc&#x27;</span><br><span class="line">Object(a) // String &#123;&quot;abc&quot;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>也可以使用valueOf方法将包装类型倒转成基本类型：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var a = &#x27;abc&#x27;</span><br><span class="line">var b = Object(a)</span><br><span class="line">var c = b.valueOf() // &#x27;abc&#x27;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>看看如下代码会打印出什么：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var a = new Boolean( false );</span><br><span class="line">if (!a) &#123;</span><br><span class="line">	console.log( &quot;Oops&quot; ); // never runs</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>答案是什么都不会打印，因为虽然包裹的基本类型是false，但是false被包裹成包装类型后就成了对象，所以其非值为false，所以循环体中的内容不会运行。</p>
<h2 id="JavaScript-中如何进行隐式类型转换？"><a href="#JavaScript-中如何进行隐式类型转换？" class="headerlink" title="JavaScript 中如何进行隐式类型转换？"></a>JavaScript 中如何进行隐式类型转换？</h2><p>首先要介绍ToPrimitive方法，这是 JavaScript 中每个值隐含的自带的方法，用来将值 （无论是基本类型值还是对象）转换为基本类型值。如果值为基本类型，则直接返回值本身；如果值为对象，其看起来大概是这样：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line">* @obj 需要转换的对象</span><br><span class="line">* @type 期望的结果类型</span><br><span class="line">*/</span><br><span class="line">ToPrimitive(obj,type)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>type的值为number或者string。<br>（1）当type为number时规则如下：</p>
<ol>
<li>调用obj的valueOf方法，如果为原始值，则返回，否则下一步；</li>
<li>调用obj的toString方法，后续同上；</li>
<li>抛出TypeError 异常。</li>
</ol>
<p>（2）当type为string时规则如下：</p>
<ol>
<li>调用obj的toString方法，如果为原始值，则返回，否则下一步；</li>
<li>调用obj的valueOf方法，后续同上；</li>
<li>抛出TypeError 异常。</li>
</ol>
<p>可以看出两者的主要区别在于调用toString和valueOf的先后顺序。默认情况下：</p>
<ol>
<li>如果对象为 Date 对象，则type默认为string；</li>
<li>其他情况下，type默认为number。</li>
</ol>
<p>总结上面的规则，对于 Date 以外的对象，转换为基本类型的大概规则可以概括为一个函数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var objToNumber = value =&gt; Number(value.valueOf().toString())</span><br><span class="line">objToNumber([]) === 0</span><br><span class="line">objToNumber(&#123;&#125;) === NaN</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>而 JavaScript 中的隐式类型转换主要发生在+、-、*、/以及==、&gt;、&lt;这些运算符之间。而这些运算符只能操作基本类型值，所以在进行这些运算前的第一步就是将两边的值用ToPrimitive转换成基本类型，再进行操作。<br>以下是基本类型的值在不同操作符的情况下隐式转换的规则 （对于对象，其会被ToPrimitive转换成基本类型，所以最终还是要应用基本类型转换规则）：</p>
<ol>
<li>+操作符</li>
</ol>
<p>+操作符的两边有至少一个string类型变量时，两边的变量都会被隐式转换为字符串；其他情况下两边的变量都会被转换为数字。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 + &#x27;23&#x27; // &#x27;123&#x27;</span><br><span class="line"> 1 + false // 1 </span><br><span class="line"> 1 + Symbol() // Uncaught TypeError: Cannot convert a Symbol value to a number</span><br><span class="line"> &#x27;1&#x27; + false // &#x27;1false&#x27;</span><br><span class="line"> false + true // 1</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ol start="2">
<li>-、*、\操作符<br>NaN也是一个数字</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 * &#x27;23&#x27; // 23</span><br><span class="line"> 1 * false // 0</span><br><span class="line"> 1 / &#x27;aa&#x27; // NaN</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ol start="3">
<li>对于==操作符<br>操作符两边的值都尽量转成number：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3 == true // false, 3 转为number为3，true转为number为1</span><br><span class="line">&#x27;0&#x27; == false //true, &#x27;0&#x27;转为number为0，false转为number为0</span><br><span class="line">&#x27;0&#x27; == 0 // &#x27;0&#x27;转为number为0</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="4">
<li>对于&lt;和&gt;比较符<br>如果两边都是字符串，则比较字母表顺序：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#x27;ca&#x27; &lt; &#x27;bd&#x27; // false</span><br><span class="line">&#x27;a&#x27; &lt; &#x27;b&#x27; // true</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
<p>其他情况下，转换为数字再比较：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#x27;12&#x27; &lt; 13 // true</span><br><span class="line">false &gt; -1 // true</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>以上说的是基本类型的隐式转换，而对象会被ToPrimitive转换为基本类型再进行转换：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var a = &#123;&#125;</span><br><span class="line">a &gt; 2 // false</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>其对比过程如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a.valueOf() // &#123;&#125;, 上面提到过，ToPrimitive默认type为number，所以先valueOf，结果还是个对象，下一步</span><br><span class="line">a.toString() // &quot;[object Object]&quot;，现在是一个字符串了</span><br><span class="line">Number(a.toString()) // NaN，根据上面 &lt; 和 &gt; 操作符的规则，要转换成数字</span><br><span class="line">NaN &gt; 2 //false，得出比较结果</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>又比如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var a = &#123;name:&#x27;Jack&#x27;&#125;</span><br><span class="line">var b = &#123;age: 18&#125;</span><br><span class="line">a + b // &quot;[object Object][object Object]&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>运算过程如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a.valueOf() // &#123;&#125;，上面提到过，ToPrimitive默认type为number，所以先valueOf，结果还是个对象，下一步</span><br><span class="line">a.toString() // &quot;[object Object]&quot;</span><br><span class="line">b.valueOf() // 同理</span><br><span class="line">b.toString() // &quot;[object Object]&quot;</span><br><span class="line">a + b // &quot;[object Object][object Object]&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="操作符什么时候用于字符串的拼接？"><a href="#操作符什么时候用于字符串的拼接？" class="headerlink" title="+ 操作符什么时候用于字符串的拼接？"></a>+ 操作符什么时候用于字符串的拼接？</h2><p>根据 ES5 规范，如果某个操作数是字符串或者能够通过以下步骤转换为字符串的话，+ 将进行拼接操作。如果其中一个操作数是对象（包括数组），则首先对其调用 ToPrimitive 抽象操作，该抽象操作再调用 [[DefaultValue]]，以数字作为上下文。如果不能转换为字符串，则会将其转换为数字类型来进行计算。<br>简单来说就是，如果 + 的其中一个操作数是字符串（或者通过以上步骤最终得到字符串），则执行字符串拼接，否则执行数字加法。<br>那么对于除了加法的运算符来说，只要其中一方是数字，那么另一方就会被转为数字。</p>
<h2 id="为什么会有BigInt的提案？"><a href="#为什么会有BigInt的提案？" class="headerlink" title="为什么会有BigInt的提案？"></a>为什么会有BigInt的提案？</h2><p>JavaScript中Number.MAX_SAFE_INTEGER表示最⼤安全数字，计算结果是9007199254740991，即在这个数范围内不会出现精度丢失（⼩数除外）。但是⼀旦超过这个范围，js就会出现计算不准确的情况，这在⼤数计算的时候不得不依靠⼀些第三⽅库进⾏解决，因此官⽅提出了BigInt来解决此问题。</p>
<h2 id="object-assign和扩展运算法是深拷贝还是浅拷贝，两者区别"><a href="#object-assign和扩展运算法是深拷贝还是浅拷贝，两者区别" class="headerlink" title="object.assign和扩展运算法是深拷贝还是浅拷贝，两者区别"></a>object.assign和扩展运算法是深拷贝还是浅拷贝，两者区别</h2><p>扩展运算符：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let outObj = &#123;</span><br><span class="line">  inObj: &#123;a: 1, b: 2&#125;</span><br><span class="line">&#125;</span><br><span class="line">let newObj = &#123;...outObj&#125;</span><br><span class="line">newObj.inObj.a = 2</span><br><span class="line">console.log(outObj) // &#123;inObj: &#123;a: 2, b: 2&#125;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>Object.assign():</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let outObj = &#123;</span><br><span class="line">  inObj: &#123;a: 1, b: 2&#125;</span><br><span class="line">&#125;</span><br><span class="line">let newObj = Object.assign(&#123;&#125;, outObj)</span><br><span class="line">newObj.inObj.a = 2</span><br><span class="line">console.log(outObj) // &#123;inObj: &#123;a: 2, b: 2&#125;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>可以看到，两者都是浅拷贝。</p>
<ol>
<li>Object.assign()方法接收的第一个参数作为目标对象，后面的所有参数作为源对象。然后把所有的源对象合并到目标对象中。它会修改了一个对象，因此会触发 ES6 setter。</li>
<li>扩展操作符（…）使用它时，数组或对象中的每一个值都会被拷贝到一个新的数组或对象中。它不复制继承的属性或类的属性，但是它会复制ES6的 symbols 属性。</li>
</ol>
<h1 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a>ES6</h1><h2 id="let、const、var的区别"><a href="#let、const、var的区别" class="headerlink" title="let、const、var的区别"></a>let、const、var的区别</h2><p>1）块级作用域： 块作用域由 { }包括，let和const具有块级作用域，var不存在块级作用域。块级作用域解决了ES5中的两个问题：</p>
<p>内层变量可能覆盖外层变量<br>用来计数的循环变量泄露为全局变量</p>
<p>（2）变量提升： var存在变量提升，let和const不存在变量提升，即在变量只能在声明之后使用，否在会报错。<br>（3）给全局添加属性： 浏览器的全局对象是window，Node的全局对象是global。var声明的变量为全局变量，并且会将该变量添加为全局对象的属性，但是let和const不会。<br>（4）重复声明： var声明变量时，可以重复声明变量，后声明的同名变量会覆盖之前声明的遍历。const和let不允许重复声明变量。<br>（5）暂时性死区： 在使用let、const命令声明变量之前，该变量都是不可用的。这在语法上，称为暂时性死区。使用var声明的变量不存在暂时性死区。<br>（6）初始值设置： 在变量声明时，var 和 let 可以不用设置初始值。而const声明变量必须设置初始值。<br>（7）指针指向： let和const都是ES6新增的用于创建变量的语法。 let创建的变量是可以更改指针指向（可以重新赋值）。但const声明的变量是不允许改变指针的指向。</p>
<h2 id="const对象的属性可以修改吗"><a href="#const对象的属性可以修改吗" class="headerlink" title="const对象的属性可以修改吗"></a>const对象的属性可以修改吗</h2><p>const保证的并不是变量的值不能改动，而是变量指向的那个内存地址不能改动。对于基本类型的数据（数值、字符串、布尔值），其值就保存在变量指向的那个内存地址，因此等同于常量。<br>但对于引用类型的数据（主要是对象和数组）来说，变量指向数据的内存地址，保存的只是一个指针，const只能保证这个指针是固定不变的，至于它指向的数据结构是不是可变的，就完全不能控制了。</p>
<h2 id="如果new一个箭头函数的会怎么样"><a href="#如果new一个箭头函数的会怎么样" class="headerlink" title="如果new一个箭头函数的会怎么样"></a>如果new一个箭头函数的会怎么样</h2><p>箭头函数是ES6中的提出来的，它没有prototype，也没有自己的this指向，更不可以使用arguments参数，所以不能New一个箭头函数。<br>new操作符的实现步骤如下：</p>
<p>创建一个对象<br>将构造函数的作用域赋给新对象（也就是将对象的__proto__属性指向构造函数的prototype属性）<br>指向构造函数中的代码，构造函数中的this指向该对象（也就是为这个对象添加属性和方法）<br>返回新的对象</p>
<p>所以，上面的第二、三步，箭头函数都是没有办法执行的。</p>
<h2 id="箭头函数与普通函数的区别"><a href="#箭头函数与普通函数的区别" class="headerlink" title="箭头函数与普通函数的区别"></a>箭头函数与普通函数的区别</h2><p>1.箭头函数比普通函数更加简洁</p>
<pre><code>· 如果没有参数，就直接写一个空括号即可
· 如果只有一个参数，可以省去参数的括号
· 如果有多个参数，用逗号分割
· 如果函数体的返回值只有一句，可以省略大括号
· 如果函数体不需要返回值，且只有一句话，可以给这个语句前面加一个void关键字。
</code></pre>
<p>2.箭头函数没有自己的this</p>
<p>箭头函数不会创建自己的this， 所以它没有自己的this，它只会在自己作用域的上一层继承this。所以箭头函数中this的指向在它在定义时已经确定了，之后不会改变。</p>
<ol start="3">
<li>箭头函数继承来的this指向永远不会改变</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var id = &#x27;GLOBAL&#x27;;</span><br><span class="line">var obj = &#123;</span><br><span class="line">  id: &#x27;OBJ&#x27;,</span><br><span class="line">  a: function()&#123;</span><br><span class="line">    console.log(this.id);</span><br><span class="line">  &#125;,</span><br><span class="line">  b: () =&gt; &#123;</span><br><span class="line">    console.log(this.id);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">obj.a();    // &#x27;OBJ&#x27;</span><br><span class="line">obj.b();    // &#x27;GLOBAL&#x27;</span><br><span class="line">new obj.a()  // undefined</span><br><span class="line">new obj.b()  // Uncaught TypeError: obj.b is not a constructor</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>对象obj的方法b是使用箭头函数定义的，这个函数中的this就永远指向它定义时所处的全局执行环境中的this，即便这个函数是作为对象obj的方法调用，this依旧指向Window对象。需要注意，定义对象的大括号{}是无法形成一个单独的执行环境的，它依旧是处于全局执行环境中。</p>
<ol start="4">
<li>call()、apply()、bind()等方法不能改变箭头函数中this的指向</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var id = &#x27;Global&#x27;;</span><br><span class="line">let fun1 = () =&gt; &#123;</span><br><span class="line">    console.log(this.id)</span><br><span class="line">&#125;;</span><br><span class="line">fun1();                     // &#x27;Global&#x27;</span><br><span class="line">fun1.call(&#123;id: &#x27;Obj&#x27;&#125;);     // &#x27;Global&#x27;</span><br><span class="line">fun1.apply(&#123;id: &#x27;Obj&#x27;&#125;);    // &#x27;Global&#x27;</span><br><span class="line">fun1.bind(&#123;id: &#x27;Obj&#x27;&#125;)();   // &#x27;Global&#x27;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="5">
<li>箭头函数不能作为构造函数使用<br>构造函数在new的步骤在上面已经说过了，实际上第二步就是将函数中的this指向该对象。 但是由于箭头函数时没有自己的this的，且this指向外层的执行环境，且不能改变指向，所以不能当做构造函数使用。</li>
<li>箭头函数没有自己的arguments<br>箭头函数没有自己的arguments对象。在箭头函数中访问arguments实际上获得的是它外层函数的arguments值。</li>
<li>箭头函数没有prototype</li>
<li>箭头函数不能用作Generator函数，不能使用yeild关键字</li>
</ol>
<h2 id="箭头函数的this指向哪⾥？"><a href="#箭头函数的this指向哪⾥？" class="headerlink" title="箭头函数的this指向哪⾥？"></a>箭头函数的this指向哪⾥？</h2><p>箭头函数不同于传统JavaScript中的函数，箭头函数并没有属于⾃⼰的this，它所谓的this是捕获其所在上下⽂的 this 值，作为⾃⼰的 this 值，并且由于没有属于⾃⼰的this，所以是不会被new调⽤的，这个所谓的this也不会被改变。<br>可以⽤Babel理解⼀下箭头函数:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// ES6 </span><br><span class="line">const obj = &#123; </span><br><span class="line">  getArrow() &#123; </span><br><span class="line">    return () =&gt; &#123; </span><br><span class="line">      console.log(this === obj); </span><br><span class="line">    &#125;; </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>转化后</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// ES5，由 Babel 转译</span><br><span class="line">var obj = &#123; </span><br><span class="line">   getArrow: function getArrow() &#123; </span><br><span class="line">     var _this = this; </span><br><span class="line">     return function () &#123; </span><br><span class="line">        console.log(_this === obj); </span><br><span class="line">     &#125;; </span><br><span class="line">   &#125; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="扩展运算符的作用及使用场景"><a href="#扩展运算符的作用及使用场景" class="headerlink" title="扩展运算符的作用及使用场景"></a>扩展运算符的作用及使用场景</h2><ol>
<li>对象扩展运算符</li>
</ol>
<p>对象的扩展运算符(…)用于取出参数对象中的所有可遍历属性，拷贝到当前对象之中。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let bar = &#123; a: 1, b: 2 &#125;;</span><br><span class="line">let baz = &#123; ...bar &#125;; // &#123; a: 1, b: 2 &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上述方法实际上等价于:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let bar = &#123; a: 1, b: 2 &#125;;</span><br><span class="line">let baz = Object.assign(&#123;&#125;, bar); // &#123; a: 1, b: 2 &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>Object.assign方法用于对象的合并，将源对象（source）的所有可枚举属性，复制到目标对象（target）。Object.assign方法的第一个参数是目标对象，后面的参数都是源对象。(如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性)。<br>同样，如果用户自定义的属性，放在扩展运算符后面，则扩展运算符内部的同名属性会被覆盖掉。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let bar = &#123;a: 1, b: 2&#125;;</span><br><span class="line">let baz = &#123;...bar, ...&#123;a:2, b: 4&#125;&#125;;  // &#123;a: 2, b: 4&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>利用上述特性就可以很方便的修改对象的部分属性。在redux中的reducer函数规定必须是一个纯函数，reducer中的state对象要求不能直接修改，可以通过扩展运算符把修改路径的对象都复制一遍，然后产生一个新的对象返回。<br>需要注意：扩展运算符对对象实例的拷贝属于浅拷贝。</p>
<ol start="2">
<li>数组扩展运算符</li>
</ol>
<p>数组的扩展运算符可以将一个数组转为用逗号分隔的参数序列，且每次只能展开一层数组。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">console.log(...[1, 2, 3])</span><br><span class="line">// 1 2 3</span><br><span class="line">console.log(...[1, [2, 3, 4], 5])</span><br><span class="line">// 1 [2, 3, 4] 5</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ol>
<li>将数组转换为参数序列</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function add(x, y) &#123;</span><br><span class="line">  return x + y;</span><br><span class="line">&#125;</span><br><span class="line">const numbers = [1, 2];</span><br><span class="line">add(...numbers) // 3</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ol start="2">
<li>复制数组<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const arr1 = [1, 2];</span><br><span class="line">const arr2 = [...arr1];</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li>合并数组<br>如果想在数组内合并数组，可以这样：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const arr1 = [&#x27;two&#x27;, &#x27;three&#x27;];const arr2 = [&#x27;one&#x27;, ...arr1, &#x27;four&#x27;, &#x27;five&#x27;];// [&quot;one&quot;, &quot;two&quot;, &quot;three&quot;, &quot;four&quot;, &quot;five&quot;]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
扩展运算符与解构赋值结合起来，用于生成数组<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const [first, ...rest] = [1, 2, 3, 4, 5];first // 1rest  // [2, 3, 4, 5]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
需要注意：如果将扩展运算符用于数组赋值，只能放在参数的最后一位，否则会报错。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const [...rest, last] = [1, 2, 3, 4, 5];         // 报错const [first, ...rest, last] = [1, 2, 3, 4, 5];  // 报错</span><br><span class="line"></span><br></pre></td></tr></table></figure>
将字符串转为真正的数组<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[...&#x27;hello&#x27;]    // [ &quot;h&quot;, &quot;e&quot;, &quot;l&quot;, &quot;l&quot;, &quot;o&quot; ]</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="Proxy-可以实现什么功能？"><a href="#Proxy-可以实现什么功能？" class="headerlink" title="Proxy 可以实现什么功能？"></a>Proxy 可以实现什么功能？</h2><p>在 Vue3.0 中通过 Proxy 来替换原本的 Object.defineProperty 来实现数据响应式。</p>
<p>Proxy 是 ES6 中新增的功能，它可以用来自定义对象中的操作。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let p = new Proxy(target, handler)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>target 代表需要添加代理的对象，handler 用来自定义对象中的操作，比如可以用来自定义 set 或者 get 函数。</p>
<p>下面来通过 Proxy 来实现一个数据响应式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let onWatch = (obj, setBind, getLogger) =&gt; &#123;</span><br><span class="line">  let handler = &#123;</span><br><span class="line">    get(target, property, receiver) &#123;</span><br><span class="line">      getLogger(target, property)</span><br><span class="line">      return Reflect.get(target, property, receiver)</span><br><span class="line">    &#125;,</span><br><span class="line">    set(target, property, value, receiver) &#123;</span><br><span class="line">      setBind(value, property)</span><br><span class="line">      return Reflect.set(target, property, value)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return new Proxy(obj, handler)</span><br><span class="line">&#125;</span><br><span class="line">let obj = &#123; a: 1 &#125;</span><br><span class="line">let p = onWatch(</span><br><span class="line">  obj,</span><br><span class="line">  (v, property) =&gt; &#123;</span><br><span class="line">    console.log(`监听到属性$&#123;property&#125;改变为$&#123;v&#125;`)</span><br><span class="line">  &#125;,</span><br><span class="line">  (target, property) =&gt; &#123;</span><br><span class="line">    console.log(`&#x27;$&#123;property&#125;&#x27; = $&#123;target[property]&#125;`)</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br><span class="line">p.a = 2 // 监听到属性a改变</span><br><span class="line">p.a // &#x27;a&#x27; = 2</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在上述代码中，通过自定义 set 和 get 函数的方式，在原本的逻辑中插入了我们的函数逻辑，实现了在对对象任何属性进行读写时发出通知。<br>当然这是简单版的响应式实现，如果需要实现一个 Vue 中的响应式，需要在 get 中收集依赖，在 set 派发更新，之所以 Vue3.0 要使用 Proxy 替换原本的 API 原因在于 Proxy 无需一层层递归为每个属性添加代理，一次即可完成以上操作，性能上更好，并且原本的实现有一些数据更新不能监听到，但是 Proxy 可以完美监听到任何方式的数据改变，唯一缺陷就是浏览器的兼容性不好。</p>
]]></content>
      <categories>
        <category>js</category>
      </categories>
  </entry>
  <entry>
    <title>html面试</title>
    <url>/2021/08/19/html%E9%9D%A2%E8%AF%95/</url>
    <content><![CDATA[<h1 id="html基础"><a href="#html基础" class="headerlink" title="html基础"></a>html基础</h1><h2 id="什么是HTML5以及和HTML的区别是什么"><a href="#什么是HTML5以及和HTML的区别是什么" class="headerlink" title="什么是HTML5以及和HTML的区别是什么"></a>什么是HTML5以及和HTML的区别是什么</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>HTML5是HTML的新标准，其主要目标是无需任何额外的插件如Flash、Silverlight等，就可以传输所有内容。它囊括了动画、视频、丰富的图形用户界面等。<br>HTML5是由万维网联盟（W3C）和Web Hypertext Application Technology Working Group 合作创建的HTML新版本。</p>
<h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><p>从文档声明类型上看：</p>
<p>HTML是很长的一段代码，很难记住。如下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;</span><br><span class="line">http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;</span><br><span class="line">&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;</span><br></pre></td></tr></table></figure>
<p>HTML5却只有简简单单的声明，方便记忆。如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br></pre></td></tr></table></figure>
<p>从语义结构上看：</p>
<p>HTML4.0：没有体现结构语义化的标签，通常都是这样来命名的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;header&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<p>这样表示网站的头部。<br>HTML5：在语义上却有很大的优势。提供了一些新的标签，比如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;header&gt;&lt;article&gt;&lt;footer&gt;</span><br></pre></td></tr></table></figure>

<p>拓展： 不输入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE HTML&gt;</span><br></pre></td></tr></table></figure>
<p>，浏览器将无法识别html文件，因此html将无法正常工作。</p>
<h2 id="HTML、XHTML和HTML5区别以及有什么联系"><a href="#HTML、XHTML和HTML5区别以及有什么联系" class="headerlink" title="HTML、XHTML和HTML5区别以及有什么联系"></a>HTML、XHTML和HTML5区别以及有什么联系</h2><p>XHTML与HTML的区别</p>
<ol>
<li>XHTML标签名必须小写；</li>
<li>XHTML元素必须被关闭；</li>
<li>XHTML元素必须被正确的嵌套；</li>
<li>XHTML元素必须要有根元素。</li>
</ol>
<p>XHTML与HTML5的区别</p>
<ol>
<li>HTML5新增了canvas绘画元素；</li>
<li>HTML5新增了用于绘媒介回放的video和audio元素；</li>
<li>更具语义化的标签，便于浏览器识别；</li>
<li>对本地离线存储有更好的支持；</li>
<li>MATHML，SVG等，可以更好的render；</li>
<li>添加了新的表单控件：calendar、date、time、email等。</li>
</ol>
<p>HTML、XHTML、HTML5之间联系</p>
<ol>
<li>XHTML是HTML规范版本；</li>
<li>HTML5是HTML、XHTML以及HTML DOM的新标准。</li>
</ol>
<h2 id="HTML5-为什么只需要写-lt-doctype-html-gt"><a href="#HTML5-为什么只需要写-lt-doctype-html-gt" class="headerlink" title="HTML5 为什么只需要写 &lt;!doctype html&gt;"></a>HTML5 为什么只需要写 &lt;!doctype html&gt;</h2><p>这是因为HTML5不基于SGML，因此不需要对DTD进行引用，但是需要DOCTYPE来规范浏览器的行为（让浏览器按照他们应该的方式来运行）而HTML4.01基于SGML，所以需要对DTD进行引用，才能告知浏览器文档所使用的文档类型。</p>
<h2 id="行内元素有哪些？块级元素有哪些？-空-void-元素有那些？"><a href="#行内元素有哪些？块级元素有哪些？-空-void-元素有那些？" class="headerlink" title="行内元素有哪些？块级元素有哪些？ 空(void)元素有那些？"></a>行内元素有哪些？块级元素有哪些？ 空(void)元素有那些？</h2><ol>
<li>行内元素： a, b, span, img, input, select, strong;</li>
<li>块级元素： div, ul, li, dl, dt, dd, h1-5, p等；</li>
<li>空元素： br, hr, img, link, meta;</li>
</ol>
<h2 id="Html5-有哪些新特性、移除了哪些元素"><a href="#Html5-有哪些新特性、移除了哪些元素" class="headerlink" title="Html5 有哪些新特性、移除了哪些元素"></a>Html5 有哪些新特性、移除了哪些元素</h2><p>（1）新增元素</p>
<p>绘画 canvas<br>用于媒介回放的 video 和 audio 元素<br>本地离线存储 localStorage 长期存储数据，浏览器关闭后数据不丢失<br>sessionStorage 的数据在浏览器关闭后会自动删除<br>语义化更好的内容元素，比如 article 、footer、header、nav、section<br>表单控件 ， calendar 、 date 、 time 、 email 、 url 、 search<br>新的技术 webworker 、 websocket 、 Geolocation</p>
<p>（2）移除的元素</p>
<p>纯表现的元素： basefont 、 big 、 center 、 font 、 s 、 strike 、 tt 、 u<br>对可用性产生负面影响的元素： frame 、 frameset 、 noframes</p>
<p>（3）支持 HTML5 新标签</p>
<p>IE8/IE7/IE6 支持通过 document.createElement 方法产生的标签。<br>可以利用这一特性让这些浏览器支持 HTML5 新标签。<br>浏览器支持新标签后，还需要添加标签默认的样式。</p>
<h2 id="HTML5有哪些更新"><a href="#HTML5有哪些更新" class="headerlink" title="HTML5有哪些更新"></a>HTML5有哪些更新</h2><ol>
<li>语义化标签</li>
</ol>
<p>· header：定义文档的页眉（头部）；<br>· nav：定义导航链接的部分；<br>· footer：定义文档或节的页脚（底部）；<br>· article：定义文章内容；<br>· section：定义文档中的节（section、区段）；<br>· aside：定义其所处内容之外的内容（侧边）；</p>
<ol start="2">
<li>媒体标签<br>（1） audio：音频<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;audio src=&#x27;&#x27; controls autoplay loop=&#x27;true&#x27;&gt;&lt;/audio&gt;</span><br></pre></td></tr></table></figure>
属性：</li>
</ol>
<p>· controls 控制面板<br>· autoplay 自动播放<br>· loop=‘true’ 循环播放</p>
<p>（2）video视频</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;video src=&#x27;&#x27; poster=&#x27;imgs/aa.jpg&#x27; controls&gt;&lt;/video&gt;</span><br></pre></td></tr></table></figure>
<p>属性：<br>· poster：指定视频还没有完全下载完毕，或者用户还没有点击播放前显示的封面。默认显示当前视频文件的第一针画面，当然通过poster也可以自己指定。<br>· controls 控制面板<br>· width<br>· height</p>
<p>（3）source标签<br>因为浏览器对视频格式支持程度不一样，为了能够兼容不同的浏览器，可以通过source来指定视频源。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;video&gt;</span><br><span class="line"> 	&lt;source src=&#x27;aa.flv&#x27; type=&#x27;video/flv&#x27;&gt;&lt;/source&gt;</span><br><span class="line"> 	&lt;source src=&#x27;aa.mp4&#x27; type=&#x27;video/mp4&#x27;&gt;&lt;/source&gt;</span><br><span class="line">&lt;/video&gt;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>表单<br>表单类型：</li>
</ol>
<p>· email ：能够验证当前输入的邮箱地址是否合法<br>· url ： 验证URL<br>· number ： 只能输入数字，其他输入不了，而且自带上下增大减小箭头，max属性可以设置为最大值，min可以设置为最小值，value为默认值。<br>· search ： 输入框后面会给提供一个小叉，可以删除输入的内容，更加人性化。<br>· range ： 可以提供给一个范围，其中可以设置max和min以及value，其中value属性可以设置为默认值<br>· color ： 提供了一个颜色拾取器<br>· time ： 时分秒<br>· data ： 日期选择年月日<br>· datatime ： 时间和日期(目前只有Safari支持)<br>· datatime-local ：日期时间控件<br>· week ：周控件<br>· month：月控件</p>
<p>表单属性：</p>
<p>· placeholder ：提示信息<br>· autofocus ：自动获取焦点<br>· autocomplete=“on” 或者 autocomplete=“off” 使用这个属性需要有两个前提：</p>
<pre><code>· 表单必须提交过
· 必须有name属性。
</code></pre>
<p>· required：要求输入框不能为空，必须有值才能够提交。<br>· pattern=” “ 里面写入想要的正则模式，例如手机号patte=”^(+86)?\d{10}$”<br>· multiple：可以选择多个文件或者多个邮箱<br>· form=” form表单的ID”</p>
<p>表单事件：</p>
<p>· oninput 每当input里的输入框内容发生变化都会触发此事件。<br>· oninvalid 当验证不通过时触发此事件。</p>
<ol start="4">
<li>进度条、度量器</li>
</ol>
<p>· progress标签：用来表示任务的进度（IE、Safari不支持），max用来表示任务的进度，value表示已完成多少<br>· meter属性：用来显示剩余容量或剩余库存（IE、Safari不支持）</p>
<pre><code>· high/low：规定被视作高/低的范围
· max/min：规定最大/小值
· value：规定当前度量值
</code></pre>
<p>设置规则：min &lt; low &lt; high &lt; max<br>5.DOM查询操作</p>
<p>· document.querySelector()<br>· document.querySelectorAll()</p>
<p>它们选择的对象可以是标签，可以是类(需要加点)，可以是ID(需要加#)<br>6. Web存储<br>HTML5 提供了两种在客户端存储数据的新方法：</p>
<p>· localStorage - 没有时间限制的数据存储<br>· sessionStorage - 针对一个 session 的数据存储</p>
<ol start="7">
<li>其他</li>
</ol>
<p>拖放：拖放是一种常见的特性，即抓取对象以后拖到另一个位置。设置元素可拖放：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;img draggable=&quot;true&quot; /&gt;</span><br></pre></td></tr></table></figure>

<p>画布（canvas ）： canvas 元素使用 JavaScript 在网页上绘制图像。画布是一个矩形区域，可以控制其每一像素。canvas 拥有多种绘制路径、矩形、圆形、字符以及添加图像的方法。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;canvas id=&quot;myCanvas&quot; width=&quot;200&quot; height=&quot;100&quot;&gt;&lt;/canvas&gt;</span><br></pre></td></tr></table></figure>

<p>SVG：SVG 指可伸缩矢量图形，用于定义用于网络的基于矢量的图形，使用 XML 格式定义图形，图像在放大或改变尺寸的情况下其图形质量不会有损失，它是万维网联盟的标准<br>地理定位：Geolocation（地理定位）用于定位用户的位置。‘</p>
<p>总结：<br>（1）新增语义化标签：nav、header、footer、aside、section、article<br>（2）音频、视频标签：audio、video<br>（3）数据存储：localStorage、sessionStorage<br>（4）canvas（画布）、Geolocation（地理定位）、websocket（通信协议）<br>（5）input标签新增属性：placeholder、autocomplete、autofocus、required<br>（6）history API：go、forward、back、pushstate<br>移除的元素有：</p>
<p>纯表现的元素：basefont，big，center，font, s，strike，tt，u;<br>对可用性产生负面影响的元素：frame，frameset，noframes；</p>
<h2 id="src和href的区别"><a href="#src和href的区别" class="headerlink" title="src和href的区别"></a>src和href的区别</h2><p>src和href都是用来引用外部的资源，它们的区别如下：</p>
<ol>
<li>src： 表示对资源的引用，它指向的内容会嵌入到当前标签所在的位置。src会将其指向的资源下载并应⽤到⽂档内，如请求js脚本。当浏览器解析到该元素时，会暂停其他资源的下载和处理，直到将该资源加载、编译、执⾏完毕，所以⼀般js脚本会放在页面底部。</li>
<li>href： 表示超文本引用，它指向一些网络资源，建立和当前元素或本文档的链接关系。当浏览器识别到它他指向的⽂件时，就会并⾏下载资源，不会停⽌对当前⽂档的处理。 常用在a、link等标签上。</li>
</ol>
<h2 id="Webp"><a href="#Webp" class="headerlink" title="Webp"></a>Webp</h2><p>WebP 格式，谷歌（google）开发的一种旨在加快图片加载速度的图片格式。图片压缩体积大约只有 JPEG 的 2/3 ，并能节省大量的服务器带宽资源和数据空间。Facebook 、 Ebay 等知名网站已经开始测试并使用 WebP 格式。<br>在质量相同的情况下， WebP 格式图像的体积要比 JPEG 格式图像小40%</p>
<h2 id="WebP-相对于-PNG、JPG-有什么优势？"><a href="#WebP-相对于-PNG、JPG-有什么优势？" class="headerlink" title="WebP 相对于 PNG、JPG 有什么优势？"></a>WebP 相对于 PNG、JPG 有什么优势？</h2><ol>
<li>PNG 转 WebP 的压缩率要高于 PNG 原图压缩率，同样支持有损与无损压缩</li>
<li>转换后的 WebP 体积大幅减少，图片质量也得到保障（同时肉眼几乎无法看出差异）</li>
<li>转换后的 WebP 支持 Alpha 透明和 24-bit 颜色数，不存在 PNG8 色彩不够丰富和在浏览器中可能会出现毛边的问题</li>
</ol>
<h2 id="HTML全局属性-global-attribute-有"><a href="#HTML全局属性-global-attribute-有" class="headerlink" title="HTML全局属性(global attribute)有"></a>HTML全局属性(global attribute)有</h2><ol>
<li>accesskey    规定激活元素的快捷键。</li>
<li>class    规定元素的一个或多个类名（引用样式表中的类）。</li>
<li>contenteditable    规定元素内容是否可编辑。</li>
<li>contextmenu    规定元素的上下文菜单。上下文菜单在用户点击元素时显示。</li>
<li>data-*    用于存储页面或应用程序的私有定制数据。</li>
<li>dir    规定元素中内容的文本方向。</li>
<li>draggable    规定元素是否可拖动。</li>
<li>dropzone    规定在拖动被拖动数据时是否进行复制、移动或链接。</li>
<li>hidden    规定元素仍未或不再相关。</li>
<li>id    规定元素的唯一 id。</li>
<li>lang    规定元素内容的语言。</li>
<li>spellcheck    规定是否对元素进行拼写和语法检查。</li>
<li>style    规定元素的行内 CSS 样式。</li>
<li>tabindex    规定元素的 tab 键次序。</li>
<li>title    规定有关元素的额外信息。</li>
<li>translate    规定是否应该翻译元素内容。</li>
</ol>
<h2 id="对HTML语义化的理解"><a href="#对HTML语义化的理解" class="headerlink" title="对HTML语义化的理解"></a>对HTML语义化的理解</h2><p>语义化是指根据内容的结构化（内容语义化），选择合适的标签（代码语义化）。通俗来讲就是用正确的标签做正确的事情。<br>语义化的优点如下：</p>
<p>对机器友好，带有语义的文字表现力丰富，更适合搜索引擎的爬虫爬取有效信息，有利于SEO。除此之外，语义类还支持读屏软件，根据文章可以自动生成目录；<br>对开发者友好，使用语义类标签增强了可读性，结构更加清晰，开发者能清晰的看出网页的结构，便于团队的开发与维护。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;header&gt;&lt;/header&gt;  头部</span><br><span class="line"></span><br><span class="line">&lt;nav&gt;&lt;/nav&gt;  导航栏</span><br><span class="line"></span><br><span class="line">&lt;section&gt;&lt;/section&gt;  区块（有语义化的div）</span><br><span class="line"></span><br><span class="line">&lt;main&gt;&lt;/main&gt;  主要区域</span><br><span class="line"></span><br><span class="line">&lt;article&gt;&lt;/article&gt;  主要内容</span><br><span class="line"></span><br><span class="line">&lt;aside&gt;&lt;/aside&gt;  侧边栏</span><br><span class="line"></span><br><span class="line">&lt;footer&gt;&lt;/footer&gt;  底部</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="DOCTYPE-⽂档类型-的作⽤"><a href="#DOCTYPE-⽂档类型-的作⽤" class="headerlink" title="DOCTYPE(⽂档类型) 的作⽤"></a>DOCTYPE(⽂档类型) 的作⽤</h2><p>DOCTYPE是HTML5中一种标准通用标记语言的文档类型声明，它的目的是告诉浏览器（解析器）应该以什么样（html或xhtml）的文档类型定义来解析文档，不同的渲染模式会影响浏览器对 CSS 代码甚⾄ JavaScript 脚本的解析。它必须声明在HTML⽂档的第⼀⾏。<br>浏览器渲染页面的两种模式（可通过document.compatMode获取，比如，语雀官网的文档类型是CSS1Compat）：</p>
<ol>
<li>CSS1Compat：标准模式（Strick mode），默认模式，浏览器使用W3C的标准解析渲染页面。在标准模式中，浏览器以其支持的最高标准呈现页面。</li>
<li>BackCompat：怪异模式(混杂模式)(Quick mode)，浏览器使用自己的怪异模式解析渲染页面。在怪异模式中，页面以一种比较宽松的向后兼容的方式显示。</li>
</ol>
<h2 id="viewport的content属性作用"><a href="#viewport的content属性作用" class="headerlink" title="viewport的content属性作用"></a>viewport的content属性作用</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;meta name=&quot;viewport&quot; content=&quot;&quot; /&gt; </span><br><span class="line">	width – viewport的宽度[device-width | pixel_value]width如果直接设置pixel_value数值，大部分的安卓手机不支持，但是ios支持；</span><br><span class="line">	height – viewport 的高度 （范围从 223 到 10,000 ）</span><br><span class="line">	user-scalable [yes | no]是否允许缩放</span><br><span class="line">	initial-scale [数值] 初始化比例（范围从 &gt; 0 到 10）</span><br><span class="line">	minimum-scale [数值] 允许缩放的最小比例</span><br><span class="line">	maximum-scale [数值] 允许缩放的最大比例</span><br><span class="line">	target-densitydpi 值有以下（一般推荐设置中等响度密度或者低像素密度，后者设置具体的值 dpi_value，另外webkit内核已不准备再支持此属性） </span><br><span class="line">	-- dpi_value 一般是70-400//没英寸像素点的个数</span><br><span class="line">	-- device-dpi设备默认像素密度</span><br><span class="line">	-- high-dpi 高像素密度</span><br><span class="line">	-- medium-dpi 中等像素密度</span><br><span class="line">	-- low-dpi 低像素密度</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="常⽤的meta标签有哪些"><a href="#常⽤的meta标签有哪些" class="headerlink" title="常⽤的meta标签有哪些"></a>常⽤的meta标签有哪些</h2><p>meta 标签由 name 和 content 属性定义，用来描述网页文档的属性，比如网页的作者，网页描述，关键词等，除了HTTP标准固定了一些name作为大家使用的共识，开发者还可以自定义name。<br>常用的meta标签：<br>（1）charset，用来描述HTML文档的编码类型：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;meta charset=&quot;UTF-8&quot; &gt;</span><br></pre></td></tr></table></figure>
<p>（2） keywords，页面关键词：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;meta name=&quot;keywords&quot; content=&quot;关键词&quot; /&gt;</span><br></pre></td></tr></table></figure>
<p>（3）description，页面描述：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;meta name=&quot;description&quot; content=&quot;页面描述内容&quot; /&gt;</span><br></pre></td></tr></table></figure>
<p>（4）refresh，页面重定向和刷新：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;meta http-equiv=&quot;refresh&quot; content=&quot;0;url=&quot; /&gt;</span><br></pre></td></tr></table></figure>
<p>（5）viewport，适配移动端，可以控制视口的大小和比例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, maximum-scale=1&quot;&gt;</span><br></pre></td></tr></table></figure>
<p>其中，content 参数有以下几种：</p>
<ol>
<li>width viewport ：宽度(数值/device-width)</li>
<li>height viewport ：高度(数值/device-height)</li>
<li>initial-scale ：初始缩放比例</li>
<li>maximum-scale ：最大缩放比例</li>
<li>minimum-scale ：最小缩放比例</li>
<li>user-scalable ：是否允许用户缩放(yes/no）</li>
</ol>
<p>（6）搜索引擎索引方式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;meta name=&quot;robots&quot; content=&quot;index,follow&quot; /&gt;</span><br></pre></td></tr></table></figure>
<p>其中，content 参数有以下几种：</p>
<ol>
<li>all：文件将被检索，且页面上的链接可以被查询；</li>
<li>none：文件将不被检索，且页面上的链接不可以被查询；</li>
<li>index：文件将被检索；</li>
<li>follow：页面上的链接可以被查询；</li>
<li>noindex：文件将不被检索；</li>
<li>nofollow：页面上的链接不可以被查询。</li>
</ol>
<h2 id="meta-相关"><a href="#meta-相关" class="headerlink" title="meta 相关"></a>meta 相关</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt; &lt;!--H5标准声明，使用 HTML5 doctype，不区分大小写--&gt; </span><br><span class="line">&lt;head lang=”en”&gt; &lt;!--标准的 lang 属性写法--&gt; </span><br><span class="line">&lt;meta charset=’utf-8ʹ&gt; &lt;!--声明文档使用的字符编码--&gt; </span><br><span class="line">&lt;meta http-equiv=”X-UA-Compatible” content=”IE=edge,chrome=1″/&gt; &lt;!--优先使用指定浏 览器使用特定的文档模式--&gt; </span><br><span class="line">&lt;meta name=”description” content=”不超过150个字符”/&gt; &lt;!--页面描述--&gt; </span><br><span class="line">&lt;meta name=”keywords” content=””/&gt; &lt;!-- 页面关键词--&gt; </span><br><span class="line">&lt;meta name=”author” content=”name, email@gmail.com”/&gt; &lt;!--网页作者--&gt; </span><br><span class="line">&lt;meta name=”robots” content=”index,follow”/&gt; &lt;!--搜索引擎抓取--&gt; </span><br><span class="line">&lt;meta name=”viewport” content=”initial-scale=1, maximum-scale=3, minimum-sc </span><br><span class="line">&lt;meta name=”apple-mobile-web-app-title” content=”标题”&gt; &lt;!--iOS 设备 begin--&gt; </span><br><span class="line">&lt;meta name=”apple-mobile-web-app-capable” content=”yes”/&gt; &lt;!--添加到主屏后的标 是否启用 WebApp 全屏模式，删除苹果默认的工具栏和菜单栏--&gt; &lt;meta name=”apple-mobile-web-app-status-bar-style” content=”black”/&gt; </span><br><span class="line">&lt;meta name=”renderer” content=”webkit”&gt; &lt;!-- 启用360浏览器的极速模式(webkit)--&gt; </span><br><span class="line">&lt;meta http-equiv=”X-UA-Compatible” content=”IE=edge”&gt; &lt;!--避免IE使用兼容模式--&gt; </span><br><span class="line">&lt;meta http-equiv=”Cache-Control” content=”no-siteapp” /&gt; &lt;!--不让百度转码--&gt; </span><br><span class="line">&lt;meta name=”HandheldFriendly” content=”true”&gt; &lt;!--针对手持设备优化，主要是针对一些老的 不识别viewport的浏览器--&gt; </span><br><span class="line">&lt;meta name=”MobileOptimized” content=”320″&gt; &lt;!--微软的老式浏览器--&gt; </span><br><span class="line">&lt;meta name=”screen-orientation” content=”portrait”&gt; &lt;!--uc强制竖屏--&gt; </span><br><span class="line">&lt;meta name=”x5-orientation” content=”portrait”&gt; &lt;!--QQ强制竖屏--&gt; </span><br><span class="line">&lt;meta name=”full-screen” content=”yes”&gt; &lt;!--UC强制全屏--&gt; </span><br><span class="line">&lt;meta name=”x5-fullscreen” content=”true”&gt; &lt;!--QQ强制全屏--&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="script标签中defer和async的区别"><a href="#script标签中defer和async的区别" class="headerlink" title="script标签中defer和async的区别"></a>script标签中defer和async的区别</h2><p>如果没有defer或async属性，浏览器会立即加载并执行相应的脚本。它不会等待后续加载的文档元素，读取到就会开始加载和执行，这样就阻塞了后续文档的加载。</p>
<p>defer 和 async属性都是去异步加载外部的JS脚本文件，它们都不会阻塞页面的解析，其区别如下：</p>
<ol>
<li>执行顺序： 多个带async属性的标签，不能保证加载的顺序；多个带defer属性的标签，按照加载顺序执行；</li>
<li>脚本是否并行执行：async属性，表示后续文档的加载和执行与js脚本的加载和执行是并行进行的，即异步执行；defer属性，加载后续文档的过程和js脚本的加载(此时仅加载不执行)是并行进行的(异步)，js脚本需要等到文档所有元素解析完成之后才执行，DOMContentLoaded事件触发执行之前。</li>
<li>async异步，defer是延迟</li>
</ol>
<h2 id="em-与-i-的区别"><a href="#em-与-i-的区别" class="headerlink" title="em 与 i 的区别"></a>em 与 i 的区别</h2><ol>
<li>效果都是斜体</li>
<li>em 是语义化标签，表强调</li>
<li>i 是样式标签， 表斜体</li>
</ol>
<h2 id="HTML-和-DOM-的关系"><a href="#HTML-和-DOM-的关系" class="headerlink" title="HTML 和 DOM 的关系"></a>HTML 和 DOM 的关系</h2><ol>
<li>HTML 只是一个字符串</li>
<li>DOM 由 HTML 解析而来</li>
<li>JS 可以维护 DOM</li>
</ol>
<h2 id="HTML5新增了哪些内容或API，使用过哪些"><a href="#HTML5新增了哪些内容或API，使用过哪些" class="headerlink" title="HTML5新增了哪些内容或API，使用过哪些"></a>HTML5新增了哪些内容或API，使用过哪些</h2><ol>
<li>document.querySelector()和document.querySelectorAll()</li>
</ol>
<p>document.querySelector()：根据css选择器返回第一个匹配的元素，如果没有匹配返回null；</p>
<p>document.querySelectorAll(“selector”)：querySelectorAll和querySelector作用一样的，只是querySelectorAll返回的是元素数组，querySelector返回的是一个元素。如果querySelectorAll没有匹配的内容返回的是一个空数组。</p>
<ol start="2">
<li>document.getElementsByClassName()<br>getElementsByClassName()方法接收一个参数，即一个包含一或多个类名的字符串，返回带有指定类的所有元素的NodeList。传入多个类名时，类名的先后顺序不重要。</li>
</ol>
<ol start="3">
<li><p>classList属性<br>add(value)：将给定的字符串值添加到列表中。如果值已经存在，就不添加了。<br>contains(value)：表示列表中是否存在给定的值，如果存在则返回true，否则返回false。<br>remove(value)：从列表中删除给定的字符串。<br>toggle(value)：如果列表中已经存在给定的值，删除它；如果列表中没有给定的值，添加它</p>
</li>
<li><p>自定义数据属性<br>HTML5 规定可以为元素添加非标准的属性，但要添加前缀data-，目的是为元素提供与渲染无关的信息，或者提供语义信息。这些属性可以任意添加、随便命名，只要以data-开头即可。来看一个例子。</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;myDiv&quot; data-myname=&quot;mike&quot;&gt;&lt;/div&gt;</span><br><span class="line">var div=document.getElementById(&#x27;myDiv&#x27;);</span><br><span class="line">if(div.dataset.myname)&#123;alert(div.dataset.myname);&#125;</span><br></pre></td></tr></table></figure>
<ol start="5">
<li>insertAdjacentHtml(),insertAdjacentText(),insertAdjacentElement()<br>插入标记的最后一个新增方式是insertAdjacentHTML()方法。它接收两个参数：插入位置和要插入的HTML 文本。第一个参数必须是下列值之一：</li>
</ol>
<p>“beforebegin”，在当前元素之前插入一个紧邻的同辈元素；<br>“afterbegin”，在当前元素之下插入一个新的子元素或在第一个子元素之前再插入新的子元素；<br>“beforeend”，在当前元素之下插入一个新的子元素或在最后一个子元素之后再插入新的子元素；<br>“afterend”，在当前元素之后插入一个紧邻的同辈元素。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">element.insertAdjacentHTML(&#x27;beforebegin&#x27;,&#x27;&lt;p&gt;hello world&lt;/p&gt;&#x27;);</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>FullScreen API…</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line"></span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">  &lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">  &lt;style&gt;</span><br><span class="line">    html:-moz-full-screen &#123;</span><br><span class="line">      background: red;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    html:-webkit-full-screen &#123;</span><br><span class="line">      background: red;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    html:fullscreen &#123;</span><br><span class="line">      background: red;</span><br><span class="line">    &#125;</span><br><span class="line">  &lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;ul class=&quot;class1 class2 class3 &quot;&gt;</span><br><span class="line">    &lt;li onclick=&quot;launchFullScreen()&quot;&gt;全屏&lt;/li&gt;</span><br><span class="line">    &lt;input type=&quot;text&quot;&gt;</span><br><span class="line">  &lt;/ul&gt;</span><br><span class="line">  &lt;button onclick=&quot;exitFullscreen()&quot;&gt;click me&lt;/button&gt;</span><br><span class="line">  &lt;script&gt;</span><br><span class="line">    // 找到支持的方法, 使用需要全屏的 element 调用</span><br><span class="line">    function launchFullScreen(element) &#123;</span><br><span class="line"></span><br><span class="line">      var element = element || document.documentElement;</span><br><span class="line">      console.log(element);</span><br><span class="line">      if (element.requestFullscreen) &#123;</span><br><span class="line">        element.requestFullscreen();</span><br><span class="line">      &#125; else if (element.mozRequestFullScreen) &#123;</span><br><span class="line">        element.mozRequestFullScreen();</span><br><span class="line">      &#125; else if (element.webkitRequestFullscreen) &#123;</span><br><span class="line">        element.webkitRequestFullscreen();</span><br><span class="line">      &#125; else if (element.msRequestFullscreen) &#123;</span><br><span class="line">        element.msRequestFullscreen();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //请注意: exitFullscreen 只能通过 document 对象调用 —— 而不是使用普通的 DOM element.</span><br><span class="line">    function exitFullscreen() &#123;</span><br><span class="line">      if (document.exitFullscreen) &#123;</span><br><span class="line">        document.exitFullscreen();</span><br><span class="line">      &#125; else if (document.mozExitFullScreen) &#123;</span><br><span class="line">        document.mozExitFullScreen();</span><br><span class="line">      &#125; else if (document.webkitExitFullscreen) &#123;</span><br><span class="line">        document.webkitExitFullscreen();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    element.webkitRequestFullScreen(Element.ALLOW_KEYBOARD_INPUT);//全屏状态允许键盘输入</span><br><span class="line"></span><br><span class="line">    /*有的时候为了用户友好体验，在进入全屏或者退出全屏的时候，需要给用户提示，</span><br><span class="line">    这个时候我们可以使用FullScreen的screenchange事件进行监控。事件监听没作用？？？？？*/</span><br><span class="line">    document.addEventListener(&quot;fullscreenchange&quot;, function () &#123;</span><br><span class="line">      fullscreenState.innerHTML = (document.fullscreen) ? &quot;&quot; : &quot;not &quot;;</span><br><span class="line">    &#125;, false);</span><br><span class="line"></span><br><span class="line">    document.addEventListener(&quot;mozfullscreenchange&quot;, function () &#123;</span><br><span class="line">      fullscreenState.innerHTML = (document.mozFullScreen) ? &quot;&quot; : &quot;not &quot;;</span><br><span class="line">    &#125;, false);</span><br><span class="line"></span><br><span class="line">    document.addEventListener(&quot;webkitfullscreenchange&quot;, function () &#123;</span><br><span class="line">      fullscreenState.innerHTML = (document.webkitIsFullScreen) ? &quot;&quot; : &quot;not &quot;;</span><br><span class="line">    &#125;, false);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<ol start="7">
<li>页面可见性（Page Visibility）…<br>所谓页面可见性就是当前页面是处于显示状态还是隐藏状态，页面可见性对于网站的统计非常有用。有的时候我们会统计用户停留在每个页面的时间，这个时间就是：用户打开网页到网页关闭或者最小化之间的时间。</li>
</ol>
<p>有的时候在视频播放的时候，当用户离开视频播放页面自动暂停视频播放，我们有时候也对那些定期刷新内容的页面进行控制，当该页面不可见则不刷新，可见则刷新。这些都是页面可见性的具体应用。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">  &lt;title&gt;Title&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;ul class=&quot;class1 class2 class3 &quot;&gt;</span><br><span class="line">  &lt;li&gt;1&lt;/li&gt;</span><br><span class="line">  &lt;li&gt;2&lt;/li&gt;</span><br><span class="line">  &lt;li&gt;3&lt;/li&gt;</span><br><span class="line">  &lt;li&gt;4&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  (function () &#123;</span><br><span class="line">    var hidden = &quot;hidden&quot;;</span><br><span class="line">    // Standards:</span><br><span class="line">    if (hidden in document)</span><br><span class="line">      document.addEventListener(&quot;visibilitychange&quot;, onchange);</span><br><span class="line">    else if ((hidden = &quot;mozHidden&quot;) in document)</span><br><span class="line">      document.addEventListener(&quot;mozvisibilitychange&quot;, onchange);</span><br><span class="line">    else if ((hidden = &quot;webkitHidden&quot;) in document)</span><br><span class="line">      document.addEventListener(&quot;webkitvisibilitychange&quot;, onchange);</span><br><span class="line">    else if ((hidden = &quot;msHidden&quot;) in document)</span><br><span class="line">      document.addEventListener(&quot;msvisibilitychange&quot;, onchange);</span><br><span class="line">    // IE 9 and lower:</span><br><span class="line">    else if (&quot;onfocusin&quot; in document)</span><br><span class="line">      document.onfocusin = document.onfocusout = onchange;</span><br><span class="line">    // All others:</span><br><span class="line">    else</span><br><span class="line">      window.onpageshow = window.onpagehide</span><br><span class="line">        = window.onfocus = window.onblur = onchange;</span><br><span class="line">    function onchange(evt) &#123;</span><br><span class="line">      var v = &quot;visible&quot;, h = &quot;hidden&quot;,</span><br><span class="line">        evtMap = &#123;</span><br><span class="line">          focus: v, focusin: v, pageshow: v, blur: h, focusout: h, pagehide: h</span><br><span class="line">        &#125;;</span><br><span class="line">      evt = evt || window.event;</span><br><span class="line">      if (evt.type in evtMap)</span><br><span class="line">        document.body.className = evtMap[evt.type];</span><br><span class="line">      else</span><br><span class="line">        document.body.className = this[hidden] ? &quot;hidden&quot; : &quot;visible&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    // set the initial state (but only if browser supports the Page Visibility API)</span><br><span class="line">    if (document[hidden] !== undefined)</span><br><span class="line">      onchange(&#123;type: document[hidden] ? &quot;blur&quot; : &quot;focus&quot;&#125;);</span><br><span class="line">  &#125;)();</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<ol start="8">
<li>预加载（prefetch）<br>网站优化一直是项目开发中的重点之中，常用的优化方式主要有：图片懒加载、图片sprite、css合并、js合并、数据本地存储、数据网络缓存等。这些都是项目中经常使用的，HTML5考虑到了这一点，提出了链接预加载的方法，其实，这个方案是FireFox提出的，所以它对链接预加载绝对的支持。什么是链接预加载那？我们看一下mdn的描述：<br>预加载是一种浏览器机制，使用浏览器空闲时间来预先下载/加载用户接下来很可能会浏览的页面/资源。页面提供给浏览器需要预加载的集合。 浏览器载入当前页面完成后，将会在后台下载需要预加载的页面并添加到缓存中。当用户访问某个预加载的链接时，如果从缓存命中, 页面就得以快速呈现。<br>说的直接一些就是让浏览器在后台提前下载一些文件</li>
</ol>
<p>关于链接预加载，有如下注意事项：<br>预加载可以跨域进行，当然，请求时cookie等信息也会被发送。<br>预加载可能破坏网站统计数据，而用户并没有实际访问。<br>浏览器兼容性不是很好</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;link rel=&#x27;prefetch&#x27; href=&#x27;page1.html&#x27;&gt;</span><br><span class="line">&lt;link rel=&#x27;dns-prefetch&#x27; href=&#x27;flower.png&#x27;&gt;</span><br></pre></td></tr></table></figure>

<ol start="9">
<li>图形元素（The Figure Element）<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;figure&gt;</span><br><span class="line">     &lt;img src=&quot;path/to/image&quot; alt=&quot;About image&quot; /&gt;</span><br><span class="line">     &lt;figcaption&gt;</span><br><span class="line">        &lt;p&gt;This is an image of something interesting. &lt;/p&gt;</span><br><span class="line">     &lt;/figcaption&gt;</span><br><span class="line"> &lt;/figure&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li>内容可编辑（contenteditable）<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;ul contenteditable=true&gt;</span><br><span class="line">    &lt;li&gt;i am editable&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;i am editable too&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;i am editable too too&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure></li>
<li>本地存储（Local Storage）</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">//localStorage方法</span><br><span class="line">if (localStorage.pagecount)</span><br><span class="line">    &#123;</span><br><span class="line">    localStorage.pagecount=Number(localStorage.pagecount) +1;</span><br><span class="line">    &#125;</span><br><span class="line">else</span><br><span class="line">    &#123;</span><br><span class="line">    localStorage.pagecount=1;</span><br><span class="line">    &#125;</span><br><span class="line">document.write(&quot;Visits: &quot; + localStorage.pagecount + &quot; time(s).&quot;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//sessionStorage方法</span><br><span class="line">if (sessionStorage.pagecount)</span><br><span class="line">  &#123;</span><br><span class="line">  sessionStorage.pagecount=Number(sessionStorage.pagecount) +1;</span><br><span class="line">  &#125;</span><br><span class="line">else</span><br><span class="line">  &#123;</span><br><span class="line">  sessionStorage.pagecount=1;</span><br><span class="line">  &#125;</span><br><span class="line">document.write(&quot;Visits &quot;+sessionStorage.pagecount+&quot; time(s) this session.&quot;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<ol start="12">
<li>自定义数据属性<br>HTML5 规定可以为元素添加非标准的属性，但要添加前缀data-，目的是为元素提供与渲染无关的信息，或者提供语义信息。这些属性可以任意添加、随便命名，只要以data-开头即可。</li>
</ol>
<h2 id="img的srcset属性的作⽤？"><a href="#img的srcset属性的作⽤？" class="headerlink" title="img的srcset属性的作⽤？"></a>img的srcset属性的作⽤？</h2><p>响应式页面中经常用到根据屏幕密度设置不同的图片。这时就用到了 img 标签的srcset属性。srcset属性用于设置不同屏幕密度下，img 会自动加载不同的图片。用法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;img src=&quot;image-128.png&quot; srcset=&quot;image-256.png 2x&quot; /&gt;</span><br></pre></td></tr></table></figure>
<p>使用上面的代码，就能实现在屏幕密度为1x的情况下加载image-128.png, 屏幕密度为2x时加载image-256.png。<br>按照上面的实现，不同的屏幕密度都要设置图片地址，目前的屏幕密度有1x,2x,3x,4x四种，如果每一个图片都设置4张图片，加载就会很慢。所以就有了新的srcset标准。代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;img src=&quot;image-128.png&quot;</span><br><span class="line">     srcset=&quot;image-128.png 128w, image-256.png 256w, image-512.png 512w&quot;</span><br><span class="line">     sizes=&quot;(max-width: 360px) 340px, 128px&quot; /&gt;</span><br></pre></td></tr></table></figure>
<p>其中srcset指定图片的地址和对应的图片质量。sizes用来设置图片的尺寸零界点。对于 srcset 中的 w 单位，可以理解成图片质量。如果可视区域小于这个质量的值，就可以使用。浏览器会自动选择一个最小的可用图片。<br>sizes语法如下：<br>sizes=”[media query] [length], [media query] [length] … “</p>
<p>sizes就是指默认显示128px, 如果视区宽度大于360px, 则显示340px。</p>
<h2 id="说一下-web-worker"><a href="#说一下-web-worker" class="headerlink" title="说一下 web worker"></a>说一下 web worker</h2><p>在 HTML 页面中，如果在执行脚本时，页面的状态是不可相应的，直到脚本执行完成后，页面才变成可相应。web worker 是运行在后台的 js，独立于其他脚本，不会影响页面的性能。 并且通过 postMessage 将结果回传到主线程。这样在进行复杂操作的时候，就不会阻塞主线程了。</p>
<p>web worker特点：<br>（1）同源限制</p>
<p>分配给 Worker 线程运行的脚本文件，必须与主线程的脚本文件同源。</p>
<p>（2）DOM 限制</p>
<p>Worker 线程所在的全局对象，与主线程不一样，无法读取主线程所在网页的 DOM 对象，也无法使用document、window、parent这些对象。但是，Worker 线程可以navigator对象和location对象。</p>
<p>（3）通信联系</p>
<p>Worker 线程和主线程不在同一个上下文环境，它们不能直接通信，必须通过消息完成。</p>
<p>（4）脚本限制</p>
<p>Worker 线程不能执行alert()方法和confirm()方法，但可以使用 XMLHttpRequest 对象发出 AJAX 请求。</p>
<p>（5）文件限制</p>
<p>Worker 线程无法读取本地文件，即不能打开本机的文件系统（file://），它所加载的脚本，必须来自网络。</p>
<p>如何创建 web worker：</p>
<ol>
<li>检测浏览器对于 web worker 的支持性</li>
<li>创建 web worker 文件（js，回传函数等）</li>
<li>创建 web worker 对象</li>
</ol>
<h2 id="HTML5的离线储存怎么使用，它的工作原理是什么"><a href="#HTML5的离线储存怎么使用，它的工作原理是什么" class="headerlink" title="HTML5的离线储存怎么使用，它的工作原理是什么"></a>HTML5的离线储存怎么使用，它的工作原理是什么</h2><p>离线存储指的是：在用户没有与因特网连接时，可以正常访问站点或应用，在用户与因特网连接时，更新用户机器上的缓存文件。<br><strong>原理：</strong>HTML5的离线存储是基于一个新建的 .appcache 文件的缓存机制(不是存储技术)，通过这个文件上的解析清单离线存储资源，这些资源就会像cookie一样被存储了下来。之后当网络在处于离线状态下时，浏览器会通过被离线存储的数据进行页面展示<br>使用方法：<br>（1）创建一个和 html 同名的 manifest 文件，然后在页面头部加入 manifest 属性：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;html lang=&quot;en&quot; manifest=&quot;index.manifest&quot;&gt;</span><br></pre></td></tr></table></figure>
<p>（2）在 cache.manifest 文件中编写需要离线存储的资源：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CACHE MANIFEST</span><br><span class="line">    #v0.11</span><br><span class="line">    CACHE:</span><br><span class="line">    js/app.js</span><br><span class="line">    css/style.css</span><br><span class="line">    NETWORK:</span><br><span class="line">    resourse/logo.png</span><br><span class="line">    FALLBACK:</span><br><span class="line">    / /offline.html</span><br></pre></td></tr></table></figure>

<ol>
<li>CACHE: 表示需要离线存储的资源列表，由于包含 manifest 文件的页面将被自动离线存储，所以不需要把页面自身也列出来。</li>
<li>NETWORK: 表示在它下面列出来的资源只有在在线的情况下才能访问，他们不会被离线存储，所以在离线情况下无法使用这些资源。不过，如果在 CACHE 和 NETWORK 中有一个相同的资源，那么这个资源还是会被离线存储，也就是说 CACHE 的优先级更高。<br>FALLBACK: 表示如果访问第一个资源失败，那么就使用第二个资源来替换他，比如上面这个文件表示的就是如果访问根目录下任何一个资源失败了，那么就去访问 offline.html 。</li>
</ol>
<p>（3）在离线状态时，操作 window.applicationCache 进行离线缓存的操作。<br>如何更新缓存：<br>（1）更新 manifest 文件<br>（2）通过 javascript 操作<br>（3）清除浏览器缓存<br>注意事项：<br>（1）浏览器对缓存数据的容量限制可能不太一样（某些浏览器设置的限制是每个站点 5MB）。<br>（2）如果 manifest 文件，或者内部列举的某一个文件不能正常下载，整个更新过程都将失败，浏览器继续全部使用老的缓存。<br>（3）引用 manifest 的 html 必须与 manifest 文件同源，在同一个域下。<br>（4）FALLBACK 中的资源必须和 manifest 文件同源。<br>（5）当一个资源被缓存后，该浏览器直接请求这个绝对路径也会访问缓存中的资源。<br>（6）站点中的其他页面即使没有设置 manifest 属性，请求的资源如果在缓存中也从缓存中访问。<br>（7）当 manifest 文件发生改变时，资源请求本身也会触发更新。</p>
<h2 id="浏览器是如何对-HTML5-的离线储存资源进行管理和加载？"><a href="#浏览器是如何对-HTML5-的离线储存资源进行管理和加载？" class="headerlink" title="浏览器是如何对 HTML5 的离线储存资源进行管理和加载？"></a>浏览器是如何对 HTML5 的离线储存资源进行管理和加载？</h2><ol>
<li>在线的情况下，浏览器发现 html 头部有 manifest 属性，它会请求 manifest 文件，如果是第一次访问页面 ，那么浏览器就会根据 manifest 文件的内容下载相应的资源并且进行离线存储。如果已经访问过页面并且资源已经进行离线存储了，那么浏览器就会使用离线的资源加载页面，然后浏览器会对比新的 manifest 文件与旧的 manifest 文件，如果文件没有发生改变，就不做任何操作，如果文件改变了，就会重新下载文件中的资源并进行离线存储。</li>
<li>离线的情况下，浏览器会直接使用离线存储的资源。</li>
</ol>
<h2 id="title与h1的区别、b与strong的区别、i与em的区别？"><a href="#title与h1的区别、b与strong的区别、i与em的区别？" class="headerlink" title="title与h1的区别、b与strong的区别、i与em的区别？"></a>title与h1的区别、b与strong的区别、i与em的区别？</h2><ol>
<li>strong标签有语义，是起到加重语气的效果，而b标签是没有的，b标签只是一个简单加粗标签。b标签之间的字符都设为粗体，strong标签加强字符的语气都是通过粗体来实现的，而搜索引擎更侧重strong标签。</li>
<li>title属性没有明确意义只表示是个标题，H1则表示层次明确的标题，对页面信息的抓取有很大的影响</li>
<li>i内容展示为斜体，em表示强调的文本</li>
</ol>
<h2 id="iframe-有那些优点和缺点？"><a href="#iframe-有那些优点和缺点？" class="headerlink" title="iframe 有那些优点和缺点？"></a>iframe 有那些优点和缺点？</h2><p>iframe 元素会创建包含另外一个文档的内联框架（即行内框架）。<br>优点：</p>
<ol>
<li>用来加载速度较慢的内容（如广告）</li>
<li>可以使脚本可以并行下载</li>
<li>可以实现跨子域通信</li>
</ol>
<p>缺点：</p>
<ol>
<li>iframe 会阻塞主页面的 onload 事件</li>
<li>无法被一些搜索引擎索识别</li>
<li>会产生很多页面，不容易管理</li>
</ol>
<h2 id="页面可见性（Page-Visibility）API-可以有哪些用途"><a href="#页面可见性（Page-Visibility）API-可以有哪些用途" class="headerlink" title="页面可见性（Page Visibility）API 可以有哪些用途"></a>页面可见性（Page Visibility）API 可以有哪些用途</h2><p>在页面被切换到其他后台进程的时候，自动暂停音乐或视频的播放。</p>
<h2 id="script标签为什么要放在body标签的底部，【defer-async】"><a href="#script标签为什么要放在body标签的底部，【defer-async】" class="headerlink" title="script标签为什么要放在body标签的底部，【defer async】"></a>script标签为什么要放在body标签的底部，【defer async】</h2><p>因为浏览器在渲染html的时候，从上到下依次执行，遇到js文件就会停止当前页面的渲染，转而去下载js文件，如果将script标签放在头部，如果文件又很大的情况下，首屏时间就会延长，影响用户体验。<br>解决方法：</p>
<p>将script标签放到body的底部<br>通过defer\async属性将js文件转为异步下载</p>
<p>defer\async的区别<br>首先都是让js文件能够异步下载，不阻塞页面的渲染<br>区别就是defer必须等待整个文档渲染完成后才执行<br>而async在下载完成后，会暂停html的解析，转去执行js</p>
<p>也就是说 下载的处理二者是相同的，主要是执行的时间不同，async执行的时候还是要阻塞html的解析，defer就是安排到最后才执行。 另外如果两个属性同时设置，以async为准。</p>
<h2 id="HTML5的form如何关闭自动完成功能"><a href="#HTML5的form如何关闭自动完成功能" class="headerlink" title="HTML5的form如何关闭自动完成功能"></a>HTML5的form如何关闭自动完成功能</h2><p>给不想要提示的input是设置autocomplete=off即可。</p>
<h2 id="处理兼容问题有两种方式"><a href="#处理兼容问题有两种方式" class="headerlink" title="处理兼容问题有两种方式"></a>处理兼容问题有两种方式</h2><p>IE6/IE7/IE8支持通过document方法产生的标签，利用这一特性让这些浏览器支持HTML5新标签；<br>使用是html5shim框架 另外，DOCTYPE声明的方式是区分HTML和HTML5标志的一个重要因素，此外，还可以根据新增的结构，功能元素来加以区分。</p>
<h2 id="说说-title-和-alt-属性"><a href="#说说-title-和-alt-属性" class="headerlink" title="说说 title 和 alt 属性"></a>说说 title 和 alt 属性</h2><ol>
<li>两个属性都是当鼠标滑动到元素上的时候显示。</li>
<li>alt 是 img 的特有属性，是图片内容的等价描述，图片无法正常显示时候的替代文字。</li>
<li>title 属性可以用在除了base，basefont，head，html，meta，param，script和title 之外的所有标签，是对dom元素的一种类似注释说明。</li>
</ol>
<h2 id="div-css的布局较table布局有什么优点"><a href="#div-css的布局较table布局有什么优点" class="headerlink" title="div+css的布局较table布局有什么优点"></a>div+css的布局较table布局有什么优点</h2><ol>
<li>改版的时候更方便，只需要修改 css 文件。</li>
<li>页面加载速度更快、结构化清晰、页面显示简洁。</li>
<li>表现与结构相分离。</li>
<li>易于优化 seo ，搜索引擎更友好，排名更容易靠前。</li>
</ol>
<h2 id="label-的作用是什么？如何使用？"><a href="#label-的作用是什么？如何使用？" class="headerlink" title="label 的作用是什么？如何使用？"></a>label 的作用是什么？如何使用？</h2><p>label标签来定义表单控件的关系：当用户选择label标签时，浏览器会自动将焦点转到和label标签相关的表单控件上。</p>
<p>使用方法1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;label for=&quot;mobile&quot;&gt;Number:&lt;/label&gt;</span><br><span class="line">&lt;input type=&quot;text&quot; id=&quot;mobile&quot;/&gt;</span><br></pre></td></tr></table></figure>

<p>使用方法2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&lt;label&gt;Date:&lt;input type=&quot;text&quot;/&gt;&lt;/label&gt;</span><br></pre></td></tr></table></figure>

<h2 id="Canvas和SVG的区别"><a href="#Canvas和SVG的区别" class="headerlink" title="Canvas和SVG的区别"></a>Canvas和SVG的区别</h2><p>（1）SVG：<br>SVG可缩放矢量图形（Scalable Vector Graphics）是基于可扩展标记语言XML描述的2D图形的语言，SVG基于XML就意味着SVG DOM中的每个元素都是可用的，可以为某个元素附加Javascript事件处理器。在 SVG 中，每个被绘制的图形均被视为对象。如果 SVG 对象的属性发生变化，那么浏览器能够自动重现图形。<br>其特点如下：</p>
<ol>
<li>不依赖分辨率</li>
<li>支持事件处理器</li>
<li>最适合带有大型渲染区域的应用程序（比如谷歌地图）</li>
<li>复杂度高会减慢渲染速度（任何过度使用 DOM 的应用都不快）</li>
<li>不适合游戏应用</li>
</ol>
<p>（2）Canvas：<br>Canvas是画布，通过Javascript来绘制2D图形，是逐像素进行渲染的。其位置发生改变，就会重新进行绘制。<br>其特点如下：</p>
<ol>
<li>依赖分辨率</li>
<li>不支持事件处理器</li>
<li>弱的文本渲染能力</li>
<li>能够以 .png 或 .jpg 格式保存结果图像</li>
<li>最适合图像密集型的游戏，其中的许多对象会被频繁重绘</li>
</ol>
<p>注：矢量图，也称为面向对象的图像或绘图图像，在数学上定义为一系列由线连接的点。矢量文件中的图形元素称为对象。每个对象都是一个自成一体的实体，它具有颜色、形状、轮廓、大小和屏幕位置等属性。</p>
<h2 id="head-标签有什么作用，其中什么标签必不可少？"><a href="#head-标签有什么作用，其中什么标签必不可少？" class="headerlink" title="head 标签有什么作用，其中什么标签必不可少？"></a>head 标签有什么作用，其中什么标签必不可少？</h2><p> 标签用于定义文档的头部，它是所有头部元素的容器。 中的元素可以引用脚本、指示浏览器在哪里找到样式表、提供元信息等。<br>文档的头部描述了文档的各种属性和信息，包括文档的标题、在 Web 中的位置以及和其他文档的关系等。绝大多数文档头部包含的数据都不会真正作为内容显示给读者。<br>下面这些标签可用在 head 部分：base, link, meta, script, style, title。<br>其中 title 定义文档的标题，它是 head 部分中唯一必需的元素。</p>
<h2 id="文档声明（Doctype）和-lt-Doctype-html-gt-有何作用-严格模式与混杂模式如何区分？它们有何意义"><a href="#文档声明（Doctype）和-lt-Doctype-html-gt-有何作用-严格模式与混杂模式如何区分？它们有何意义" class="headerlink" title="文档声明（Doctype）和&lt;!Doctype html&gt;有何作用? 严格模式与混杂模式如何区分？它们有何意义?"></a>文档声明（Doctype）和&lt;!Doctype html&gt;有何作用? 严格模式与混杂模式如何区分？它们有何意义?</h2><p>文档声明的作用： 文档声明是为了告诉浏览器，当前HTML文档使用什么版本的HTML来写的，这样浏览器才能按照声明的版本来正确的解析。<br>作用：&lt;!Doctype html&gt; 的作用就是让浏览器进入标准模式，使用最新的 HTML5 标准来解析渲染页面；如果不写，浏览器就会进入混杂模式，我们需要避免此类情况发生。<br>严格模式与混杂模式的区分：</p>
<ol>
<li>严格模式： 又称为标准模式，指浏览器按照W3C标准解析代码；</li>
<li>混杂模式： 又称怪异模式、兼容模式，是指浏览器用自己的方式解析代码。混杂模式通常模拟老式浏览器的行为，以防止老站点无法工作；</li>
</ol>
<p>区分：网页中的DTD，直接影响到使用的是严格模式还是浏览模式，可以说DTD的使用与这两种方式的区别息息相关。</p>
<ol>
<li>如果文档包含严格的DOCTYPE ，那么它一般以严格模式呈现（严格 DTD ——严格模式）；<br>包含过渡 DTD 和 URI 的 DOCTYPE ，也以严格模式呈现，但有过渡 DTD 而没有 URI （统一资源标识符，就是声明最后的地址）会导致页面以混杂模式呈现（有 URI 的过渡 DTD ——严格模式；没有 URI 的过渡 DTD ——混杂模式）；</li>
<li>DOCTYPE 不存在或形式不正确会导致文档以混杂模式呈现（DTD不存在或者格式不正确——混杂模式）；</li>
<li>HTML5 没有 DTD ，因此也就没有严格模式与混杂模式的区别，HTML5 有相对宽松的 法，实现时，已经尽可能大的实现了向后兼容(HTML5 没有严格和混杂之分)。</li>
</ol>
<p>总之，严格模式让各个浏览器统一执行一套规范兼容模式保证了旧网站的正常运行。</p>
<h2 id="几种Doctype文档类型"><a href="#几种Doctype文档类型" class="headerlink" title="几种Doctype文档类型"></a>几种Doctype文档类型</h2><p>标签可声明三种 DTD 类型，分别表示严格版本、过渡版本以及基于框架的 HTML 文档。</p>
<ol>
<li>HTML 4.01 规定了三种文档类型：分别是Strict、Transitional 以及 Frameset；</li>
<li>XHTML 1.0 规定了三种 XML 文档类型：分别是Strict、Transitional 以及 Frameset；</li>
<li>Standards （标准）模式（也就是严格呈现模式）用于呈现遵循最新标准的网页；</li>
<li>Quirks（包容）模式（也就是松散呈现模式或者兼容模式）用于呈现为传统浏览器而设计的网页。</li>
</ol>
<h2 id="Quirks模式是什么？它和Standards模式有什么区别？"><a href="#Quirks模式是什么？它和Standards模式有什么区别？" class="headerlink" title="Quirks模式是什么？它和Standards模式有什么区别？"></a>Quirks模式是什么？它和Standards模式有什么区别？</h2><p>Quirks模式<br>Quirks模式，又称怪癖模式、诡异模式、怪异模式。<br>Quirks和Standards模式的区别<br>当我们在写程序时，遇到新旧功能不兼容的时候，如何做才能保证原来的接口不变，又可以提供强大的功能？<br>一般情况下可以通过增加参数和分支来解决。也就是当某个参数为true时，使用新功能，为false时使用旧功能，这样就能不破坏原有的程序，又能提供新功能。<br>IE6也是类似这样做的，它将DTD当成了这个“参数”，因为以前的页面大家都不会去写DTD，第一IE6就假定，如果写了DTD就意味这个页面将采用对CSS支持更好的布局，而如果没有就采用兼容之前的布局方式，这就是Quirks模式（怪癖，诡异，怪异模式）。<br>其与Standards的区别总体会有布局、样式解析、和脚本执行三个方面的区别：</p>
<ol>
<li>盒模型：在W3C标准中，如果设置一个元素的宽度和高度，指的是元素内容的宽度和高度，而在Quirks 模式下，IE的宽度和高度还包含了padding和border；</li>
<li>设置行内元素的高宽：在Standards模式下，给等行内元素设置wdith和height都不会生效，而在2.quirks模式下，则会生效；</li>
<li>设置百分比的高度：在standards模式下，一个元素的高度是由其包含的内容来决定的，如果父元素没有设置百分比的高度，子元素设置一个百分比的高度是无效的用；</li>
<li>设置水平居中：使用margin:0 auto在standards模式下可以使元素水平居中，但在quirks模式下却会失效。</li>
</ol>
<h2 id="什么是前端的结构，样式和行为相分离？以及分离的好处是什么？"><a href="#什么是前端的结构，样式和行为相分离？以及分离的好处是什么？" class="headerlink" title="什么是前端的结构，样式和行为相分离？以及分离的好处是什么？"></a>什么是前端的结构，样式和行为相分离？以及分离的好处是什么？</h2><p>结构，样式和行为分离<br>小编的理解是： 若是将前端比作一个人来举例子，结构（HTML）就相当于是人体的“骨架”，样式就相当于人体的“装饰”，例如衣服，首饰等；行为就相当于人做出的一系列“动作”。<br>在结构，样式和行为分离，就是将三者分离开，各自负责各自的内容，各部分可以通过引用进行使用。<br>在分离的基础上，我们需要做到代码的：精简， 重用， 有序。<br>分离的好处</p>
<ol>
<li>代码分离，利于团队的开发和后期的维护；</li>
<li>减少维护成本，提高可读性和更好的兼容性；</li>
</ol>
<h2 id="如何对网站的文件和资源进行优化"><a href="#如何对网站的文件和资源进行优化" class="headerlink" title="如何对网站的文件和资源进行优化"></a>如何对网站的文件和资源进行优化</h2><ol>
<li>文件合并（目的是减少http请求）；</li>
<li>文件压缩 （目的是直接减少文件下载的体积）；</li>
<li>使用缓存；</li>
<li>使用cdn托管资源；</li>
<li>gizp压缩需要的js和css文件；</li>
<li>反向链接，网站外链接优化；</li>
<li>meta标签优化（title, description, keywords）,heading标签的优化,alt优化；</li>
</ol>
<h2 id="Html5中datalist是什么"><a href="#Html5中datalist是什么" class="headerlink" title="Html5中datalist是什么"></a>Html5中datalist是什么</h2><p>datalist标签，用来定义选项列表，与input元素配合使用该元素，来定义input可能的值。</p>
<p>datalist及其选项不会被显示出来，他仅仅是合法的输入列表值。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;input id=&quot;fruits&quot; list=&quot;fruit&quot; /&gt;</span><br><span class="line">&lt;datalist id=&quot;fruit&quot;&gt;</span><br><span class="line">    &lt;option value=&quot;apple&quot;&gt;</span><br><span class="line">    &lt;option value=&quot;orange&quot;&gt;</span><br><span class="line">    &lt;option value=&quot;banana&quot;&gt;</span><br><span class="line">&lt;/datalist&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="LocalStorage本地存储在HTML5中有什么用途"><a href="#LocalStorage本地存储在HTML5中有什么用途" class="headerlink" title="LocalStorage本地存储在HTML5中有什么用途"></a>LocalStorage本地存储在HTML5中有什么用途</h2><p>localStorage本地存储相当于一个轻量级的数据库，可以在本地永久的储存数据（除非人为删除）。此外，还可以在断网情况下读取本地缓存的cookies。</p>
<ol>
<li>使用localStorage保存数据： localStorage.setItem(key, value);</li>
<li>使用localStorage获取保存的数据: localStorage.getItem(key);</li>
<li>清除localStorage保存的数据： localStorage.removeItem(key);</li>
<li>清除全部localStorage对象保存的数据: localStorage.clear( );</li>
</ol>
<h2 id="新的HTML5文档类型和字符集是什么"><a href="#新的HTML5文档类型和字符集是什么" class="headerlink" title="新的HTML5文档类型和字符集是什么"></a>新的HTML5文档类型和字符集是什么</h2><p>HTML5文档类型：&lt;!doctype html&gt;<br>字符集：HTML5使用的编码&lt;meta charset=”UTF-8”&gt;</p>
<h2 id="为什么HTML5里面我们不需要DTD"><a href="#为什么HTML5里面我们不需要DTD" class="headerlink" title="为什么HTML5里面我们不需要DTD"></a>为什么HTML5里面我们不需要DTD</h2><p>HTML5没有使用SGML或者XHTML，HTML5是一个全新的东西，因此不需要参考DTD，对于HTML5，仅需放置下面的文档类型代码告诉浏览器识别这是HTML5文档就行。</p>
<h2 id="自身对网页标准和标准制定机构重要性有何理解"><a href="#自身对网页标准和标准制定机构重要性有何理解" class="headerlink" title="自身对网页标准和标准制定机构重要性有何理解"></a>自身对网页标准和标准制定机构重要性有何理解</h2><p>网页标准和标准制定机构是让web更加规范，更加标准，健康的发展所必不可少的东西。</p>
<p>于开发者而言： 开发者可以遵循统一的开发标准，大大降低了开发难度，开发成本，从而也提高了代码的可阅读性以及易于后期维护；<br>于SEO而言： 对SEO更加友好，提升了搜索效率。</p>
<p>使用网页标准和标准制定机构，对于提高网站的易用性起着非常大的作用。</p>
<h2 id="对于web标准以及w3c有何理解与认识"><a href="#对于web标准以及w3c有何理解与认识" class="headerlink" title="对于web标准以及w3c有何理解与认识"></a>对于web标准以及w3c有何理解与认识</h2><p>于WEB而言：web标准简单来说可以分为结构、表现和行为。web标准一般是将该三部分独立分开，使其更具有模块化。但一般产生行为时，就会有结构或者表现的变化，也使这三者的界限并不那么清晰；<br>于W3C而言： W3C对web标准提出了规范化的要求，也就是在实际编程中的一些代码规范，如下：<br>结构上的要求：</p>
<ol>
<li>标签必须闭合、标签小写、不乱嵌套，可以提高搜索机器人对网页内容的搜索几率；</li>
</ol>
<p>对于css和js来说：</p>
<ol>
<li>建议使用外链css和js脚本，从而达到结构与行为、结构与表现的分离，提高页面的渲染速度，能更快地显示页面的内容；</li>
<li>样式与标签的分离，更合理的语义化标签，使内容能被更多的用户所访问、内容能被更广泛的设备所访问、更少的代码和组件， 从而降低维护成本、改版更方便；</li>
<li>不需要变动页面内容，便可提供打印版本而不需要复制内容，提高网站易用性；</li>
</ol>
<p>总之，遵循w3c制定的web标准，能够使用户浏览者更方便的阅读，使网页开发者之间更好的交流。</p>
<h2 id="Html5应用程序缓存和HTML浏览器缓存有什么区别"><a href="#Html5应用程序缓存和HTML浏览器缓存有什么区别" class="headerlink" title="Html5应用程序缓存和HTML浏览器缓存有什么区别"></a>Html5应用程序缓存和HTML浏览器缓存有什么区别</h2><p>新的HTML5规范的应用缓存最关键的就是支持离线应用，允许浏览器在链接客户端时预取一些或全部网站资产，如HTML文件，图像，CSS以及JS等，预取文件加速了站点的性能。换句话说，应用程序缓存可以预取完全未被访问的页面，从而在常规的浏览器缓存中不可用。与传统的浏览器缓存比较，该特性并不强制要求用户访问网站。</p>
<h2 id="HTML元素如何体现其嵌套关系"><a href="#HTML元素如何体现其嵌套关系" class="headerlink" title="HTML元素如何体现其嵌套关系"></a>HTML元素如何体现其嵌套关系</h2><ol>
<li>块级元素可以包含行内元素；</li>
<li>块级元素不一定能包含块级元素；</li>
<li>行内元素一般不能包含块级元素（a元素例外）</li>
</ol>
<h2 id="property和attribute的区别是什么"><a href="#property和attribute的区别是什么" class="headerlink" title="property和attribute的区别是什么"></a>property和attribute的区别是什么</h2><p>property是DOM中的属性，是JavaScript里的对象;<br>attribute是HTML标签上的特性，它的值只能够是字符串;</p>
<p>简单的理解就是：Attribute就是DOM节点自带的属性，例如html中常用的id、class、title、align等；而Property是这个DOM元素作为对象，其附加的内容，例如childNodes、firstChild等。</p>
<h2 id="form-作用"><a href="#form-作用" class="headerlink" title="form 作用"></a>form 作用</h2><ol>
<li>直接提交表单</li>
<li>使用 submit / reset 按钮</li>
<li>便于浏览器保存表单</li>
<li>第三方库可以整体取值</li>
<li>第三方库可以进行表单验证</li>
</ol>
<h2 id="请描述一下-cookies，sessionStorage-和-localStorage-的区别？"><a href="#请描述一下-cookies，sessionStorage-和-localStorage-的区别？" class="headerlink" title="请描述一下 cookies，sessionStorage 和 localStorage 的区别？"></a>请描述一下 cookies，sessionStorage 和 localStorage 的区别？</h2><ol>
<li>cookie 是网站为了标示用户身份而储存在用户本地终端（Client Side）上的数据（通常经过加密）</li>
<li>cookie 数据始终在同源的 http 请求中携带（即使不需要），记会在浏览器和服务器间来回传递。</li>
<li>sessionStorage 和 localStorage 不会自动把数据发给服务器，仅在本地保存。</li>
<li>存储大小：<br>· cookie 数据大小不能超过 4k。<br>·sessionStorage 和 localStorage 虽然也有存储大小的限制，但比 cookie 大得多，可以达到 5M 或更大。</li>
<li>有效期（生命周期）：<br>· localStorage: 存储持久数据，浏览器关闭后数据不丢失除非主动删除数据；<br>· sessionStorage: 数据在当前浏览器窗口关闭后自动删除。<br>· cookie: 设置的 cookie 过期时间之前一直有效，即使窗口或浏览器关闭</li>
<li>共享<br>· sessionStorage 不能共享，localStorage 在同源文档之间共享，cookie 在同源且符合 path 规则的文档之间共享</li>
</ol>
<h2 id="浏览器乱码的原因是什么？如何解决？"><a href="#浏览器乱码的原因是什么？如何解决？" class="headerlink" title="浏览器乱码的原因是什么？如何解决？"></a>浏览器乱码的原因是什么？如何解决？</h2><p>产生乱码的原因：</p>
<ol>
<li>网页源代码是gbk的编码，而内容中的中文字是utf-8编码的，这样浏览器打开即会出现html乱码，反之也会出现乱码；</li>
<li>html网页编码是gbk，而程序从数据库中调出呈现是utf-8编码的内容也会造成编码乱码；</li>
<li>浏览器不能自动检测网页编码，造成网页乱码。</li>
</ol>
<p>解决办法：</p>
<ol>
<li>使用软件编辑HTML网页内容；</li>
<li>如果网页设置编码是gbk，而数据库储存数据编码格式是UTF-8，此时需要程序查询数据库数据显示数据前进程序转码；</li>
<li>如果浏览器浏览时候出现网页乱码，在浏览器中找到转换编码的菜单进行转换。</li>
</ol>
<h2 id="渐进增强和优雅降级之间的区别"><a href="#渐进增强和优雅降级之间的区别" class="headerlink" title="渐进增强和优雅降级之间的区别"></a>渐进增强和优雅降级之间的区别</h2><p>（1）渐进增强（progressive enhancement）：主要是针对低版本的浏览器进行页面重构，保证基本的功能情况下，再针对高级浏览器进行效果、交互等方面的改进和追加功能，以达到更好的用户体验。<br>（2）优雅降级 graceful degradation： 一开始就构建完整的功能，然后再针对低版本的浏览器进行兼容。<br>两者区别：</p>
<ol>
<li>优雅降级是从复杂的现状开始的，并试图减少用户体验的供给；而渐进增强是从一个非常基础的，能够起作用的版本开始的，并在此基础上不断扩充，以适应未来环境的需要；</li>
<li>降级（功能衰竭）意味着往回看，而渐进增强则意味着往前看，同时保证其根基处于安全地带。</li>
</ol>
<p>“优雅降级”观点认为应该针对那些最高级、最完善的浏览器来设计网站。而将那些被认为“过时”或有功能缺失的浏览器下的测试工作安排在开发周期的最后阶段，并把测试对象限定为主流浏览器（如 IE、Mozilla 等）的前一个版本。 在这种设计范例下，旧版的浏览器被认为仅能提供“简陋却无妨 (poor, but passable)” 的浏览体验。可以做一些小的调整来适应某个特定的浏览器。但由于它们并非我们所关注的焦点，因此除了修复较大的错误之外，其它的差异将被直接忽略。<br>“渐进增强”观点则认为应关注于内容本身。内容是建立网站的诱因，有的网站展示它，有的则收集它，有的寻求，有的操作，还有的网站甚至会包含以上的种种，但相同点是它们全都涉及到内容。这使得“渐进增强”成为一种更为合理的设计范例。这也是它立即被 Yahoo 所采纳并用以构建其“分级式浏览器支持 (Graded Browser Support)”策略的原因所在。</p>
<h2 id="说一下-HTML5-drag-API"><a href="#说一下-HTML5-drag-API" class="headerlink" title="说一下 HTML5 drag API"></a>说一下 HTML5 drag API</h2><ol>
<li>dragstart：事件主体是被拖放元素，在开始拖放被拖放元素时触发。</li>
<li>darg：事件主体是被拖放元素，在正在拖放被拖放元素时触发。</li>
<li>dragenter：事件主体是目标元素，在被拖放元素进入某元素时触发。</li>
<li>dragover：事件主体是目标元素，在被拖放在某元素内移动时触发。</li>
<li>dragleave：事件主体是目标元素，在被拖放元素移出目标元素是触发。</li>
<li>drop：事件主体是目标元素，在目标元素完全接受被拖放元素时触发。</li>
<li>dragend：事件主体是被拖放元素，在整个拖放操作结束时触发。</li>
</ol>
<h2 id="table的作用以及其优缺点"><a href="#table的作用以及其优缺点" class="headerlink" title="table的作用以及其优缺点"></a>table的作用以及其优缺点</h2><p>作用</p>
<p>可用于布局（已过时）；<br>用于显示批量数据；</p>
<p>优点<br>在某些场合，使用Table是100%的适合、恰当和正确。比如，用table做表格是完全正确的<br>缺点</p>
<ol>
<li>Table要比其它html标记占更多的字节，会导致延迟下载时间，占用服务器更多的流量资源；</li>
<li>Table会阻挡浏览器渲染引擎的渲染顺序，这会导致延迟页面的生成速度，让用户等待更久的时间；</li>
<li>灵活性差，比如要通多td才能设置tr的border属性；</li>
<li>代码臃肿，当在table中套用table的时候，阅读代码会显得异常混乱；</li>
<li>混乱的colspan与rowspan，用来布局时，频繁使用他们会造成整个文档顺序混乱；</li>
<li>深层的嵌套，导致搜索引擎读取困难，同时还很大程度上增加了代码冗余；<br>不够语义。</li>
</ol>
<h2 id="HTML-中的-input-标签有哪些-type"><a href="#HTML-中的-input-标签有哪些-type" class="headerlink" title="HTML 中的 input 标签有哪些 type"></a>HTML 中的 input 标签有哪些 type</h2><h3 id="button"><a href="#button" class="headerlink" title="button"></a>button</h3><p>没有默认行为的按钮，上面显示 value 属性的值，默认为空。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;input type=&quot;button&quot; name=&quot;button&quot; /&gt;</span><br></pre></td></tr></table></figure>
<h3 id="checkbox"><a href="#checkbox" class="headerlink" title="checkbox"></a>checkbox</h3><p>复选框，可设为选中或未选中。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;input type=&quot;checkbox&quot; name=&quot;checkbox&quot; /&gt;</span><br></pre></td></tr></table></figure>
<h3 id="color"><a href="#color" class="headerlink" title="color"></a>color</h3><p>用于指定颜色的控件；在支持的浏览器中，激活时会打开取色器。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;input type=&quot;color&quot; name=&quot;color&quot; /&gt;</span><br></pre></td></tr></table></figure>
<h3 id="date"><a href="#date" class="headerlink" title="date"></a>date</h3><p>输入日期的控件（年、月、日，不包括时间）。在支持的浏览器激活时打开日期选择器或年月日的数字滚轮。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;input type=&quot;date&quot; name=&quot;date&quot; /&gt;</span><br></pre></td></tr></table></figure>
<h3 id="datetime-local"><a href="#datetime-local" class="headerlink" title="datetime-local"></a>datetime-local</h3><p>输入日期和时间的控件，不包括时区。在支持的浏览器激活时打开日期选择器或年月日的数字滚轮。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;input type=&quot;datetime-local&quot; name=&quot;datetime-local&quot; /&gt;</span><br></pre></td></tr></table></figure>
<h3 id="email"><a href="#email" class="headerlink" title="email"></a>email</h3><p>编辑邮箱地址的区域。类似  text  输入，但在支持的浏览器和带有动态键盘的设备上会有确认参数和相应的键盘。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;input type=&quot;email&quot; name=&quot;email&quot; /&gt;</span><br></pre></td></tr></table></figure>
<h3 id="file"><a href="#file" class="headerlink" title="file"></a>file</h3><p>让用户选择文件的控件。使用 accept 属性规定控件能选择的文件类型。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;input type=&quot;file&quot; accept=&quot;image/*, text/*&quot; name=&quot;file&quot; /&gt;</span><br></pre></td></tr></table></figure>
<h3 id="hidden"><a href="#hidden" class="headerlink" title="hidden"></a>hidden</h3><p>不显示的控件，其值仍会提交到服务器。举个例子，右边就是一个隐形的控件。</p>
<h3 id="image"><a href="#image" class="headerlink" title="image"></a>image</h3><p>带图像的  submit 按钮。显示的图像由 src  属性规定。如果 src 缺失，alt 属性就会显示。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;input type=&quot;image&quot; name=&quot;image&quot; src=&quot;&quot; alt=&quot;image input&quot; /&gt;</span><br></pre></td></tr></table></figure>
<h3 id="month"><a href="#month" class="headerlink" title="month"></a>month</h3><p>输入年和月的控件，没有时区。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;input type=&quot;month&quot; name=&quot;month&quot; /&gt;</span><br></pre></td></tr></table></figure>
<h3 id="number"><a href="#number" class="headerlink" title="number"></a>number</h3><p>用于输入数字的控件。如果支持的话，会显示滚动按钮并提供缺省验证（即只能输入数字）。拥有动态键盘的设备上会显示数字键盘。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;input type=&quot;number&quot; name=&quot;number&quot; /&gt;</span><br></pre></td></tr></table></figure>
<h3 id="password"><a href="#password" class="headerlink" title="password"></a>password</h3><p>单行的文本区域，其值会被遮盖。如果站点不安全，会警告用户。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;input type=&quot;password&quot; name=&quot;password&quot; /&gt;</span><br></pre></td></tr></table></figure>
<h3 id="radio"><a href="#radio" class="headerlink" title="radio"></a>radio</h3><p>单选按钮，允许在多个拥有相同 name 值的选项中选中其中一个。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;input type=&quot;radio&quot; name=&quot;radio&quot; /&gt;</span><br></pre></td></tr></table></figure>
<h3 id="range"><a href="#range" class="headerlink" title="range"></a>range</h3><p>此控件用于输入不需要精确的数字。控件是一个范围组件，默认值为正中间的值。同时使用 htmlattrdefmin    和 htmlattrdefmax 来规定值的范围。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;input type=&quot;range&quot; name=&quot;range&quot; min=&quot;0&quot; max=&quot;25&quot; /&gt;</span><br></pre></td></tr></table></figure>
<h3 id="reset"><a href="#reset" class="headerlink" title="reset"></a>reset</h3><p>此按钮将表单的所有内容重置为默认值。不推荐。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;input type=&quot;reset&quot; name=&quot;reset&quot; /&gt;</span><br></pre></td></tr></table></figure>
<h3 id="search"><a href="#search" class="headerlink" title="search"></a>search</h3><p>用于搜索字符串的单行文字区域。输入文本中的换行会被自动去除。在支持的浏览器中可能有一个删除按钮，用于清除整个区域。拥有动态键盘的设备上的回车图标会变成搜索图标。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;input type=&quot;search&quot; name=&quot;search&quot; /&gt;</span><br></pre></td></tr></table></figure>
<h3 id="submit"><a href="#submit" class="headerlink" title="submit"></a>submit</h3><p>用于提交表单的按钮。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;input type=&quot;submit&quot; name=&quot;submit&quot; /&gt;</span><br></pre></td></tr></table></figure>
<h3 id="tel"><a href="#tel" class="headerlink" title="tel"></a>tel</h3><p>用于输入电话号码的控件。拥有动态键盘的设备上会显示电话数字键盘。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;input type=&quot;tel&quot; name=&quot;tel&quot; /&gt;</span><br></pre></td></tr></table></figure>
<h3 id="text"><a href="#text" class="headerlink" title="text"></a>text</h3><p>默认值。单行的文本区域，输入中的换行会被自动去除。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;input type=&quot;text&quot; name=&quot;text&quot; /&gt;</span><br></pre></td></tr></table></figure>
<h3 id="time"><a href="#time" class="headerlink" title="time"></a>time</h3><p>用于输入时间的控件，不包括时区。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;input type=&quot;time&quot; name=&quot;time&quot; /&gt;</span><br></pre></td></tr></table></figure>
<h3 id="url"><a href="#url" class="headerlink" title="url"></a>url</h3><p>用于输入 URL 的控件。类似 text  输入，但有验证参数，在支持动态键盘的设备上有相应的键盘。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;input type=&quot;url&quot; name=&quot;url&quot; /&gt;</span><br></pre></td></tr></table></figure>
<h3 id="week"><a href="#week" class="headerlink" title="week"></a>week</h3><p>用于输入以年和周数组成的日期，不带时区。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;input type=&quot;week&quot; name=&quot;week&quot; /&gt;</span><br></pre></td></tr></table></figure>
<h3 id="什么是-Data-URL"><a href="#什么是-Data-URL" class="headerlink" title="什么是 Data URL"></a>什么是 Data URL</h3><p>Data URL 是将图片转换为 base64 直接嵌入到了网页中，使用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;img src=&quot;data:[MIME type];base64&quot;/&gt;</span><br></pre></td></tr></table></figure>
<p>这种方式引用图片，不需要再发请求获取图片。 使用 Data URL 也有一些缺点：</p>
<ol>
<li>base64 编码后的图片会比原来的体积大三分之一左右。</li>
<li>Data URL 形式的图片不会缓存下来，每次访问页面都要被下载一次。可以将 Data URL 写入到 CSS 文件中随着 CSS 被缓存下来。</li>
</ol>
<h2 id="你做的页面在哪些流览器测试过？这些浏览器的内核分别是什么"><a href="#你做的页面在哪些流览器测试过？这些浏览器的内核分别是什么" class="headerlink" title="你做的页面在哪些流览器测试过？这些浏览器的内核分别是什么?"></a>你做的页面在哪些流览器测试过？这些浏览器的内核分别是什么?</h2><ol>
<li>IE: trident内核</li>
<li>Firefox：gecko内核</li>
<li>Safari:webkit内核</li>
<li>Opera:以前是presto内核，Opera现已改用GoogleChrome的Blink内核</li>
<li>Chrome:Blink(基于webkit，Google与Opera Software共同开发)</li>
</ol>
<h2 id="介绍一下你对浏览器内核的理解？"><a href="#介绍一下你对浏览器内核的理解？" class="headerlink" title="介绍一下你对浏览器内核的理解？"></a>介绍一下你对浏览器内核的理解？</h2><p>主要分成两部分：渲染引擎(layout engineer或Rendering Engine)和JS引擎<br>渲染引擎：负责取得网页的内容（HTML、XML、图像等等）、整理讯息（例如加入CSS等），以及计算网页的显示方式，然后会输出至显示器或打印机。浏览器的内核的不同对于网页的语法解释会有不同，所以渲染的效果也不相同。所有网页浏览器</p>
<h2 id="渲染优化"><a href="#渲染优化" class="headerlink" title="渲染优化"></a>渲染优化</h2><ol>
<li>使用CSS3代码代替JS动画（尽可能避免重绘重排以及回流）</li>
<li>页面中空的href和 src会阻塞页面其他资源的加载 (阻塞下载进程)</li>
<li>用innerHTML代替DOM操作，减少DOM操作次数，优化javascript性能</li>
<li>当需要设置的样式很多时设置className而不是直接操作style</li>
<li>少用全局变量、缓存DOM节点查找的结果。减少IO读取操作</li>
<li>图片预加载，将样式表放在顶部，将脚本放在底部 加上时间戳</li>
</ol>
<h2 id="如何进行网站性能优化"><a href="#如何进行网站性能优化" class="headerlink" title="如何进行网站性能优化"></a>如何进行网站性能优化</h2><p>1、减少HTTP请求：合并文件、CSS精灵、inline Image<br>2、将样式表放到页面顶部<br>3、不使用CSS表达式<br>4、使用link不使用@import<br>5、将脚本放到页面底部<br>6、将javascript和css从外部引入<br>7、压缩javascript和css</p>
<h3 id="什么是-HTML-的实体编码-HTML-Entity-Encode"><a href="#什么是-HTML-的实体编码-HTML-Entity-Encode" class="headerlink" title="什么是 HTML 的实体编码 (HTML Entity Encode)"></a>什么是 HTML 的实体编码 (HTML Entity Encode)</h3><p>HTML 实体是一段以连字号（&amp;）开头、以分号（;）结尾的字符串。用以显示不可见字符及保留字符 (如 HTML 标签)</p>
<p>在前端，一般为了避免 XSS 攻击，会将 &lt;&gt; 编码为 &lt; 与 &gt;，这些就是 HTML 实体编码。</p>
<p>在 whatwg (opens new window)中可查看实体编码数据。</p>
<p>在 HTML 转义时，仅仅只需要对六个字符进行编码: &amp;, &lt;, &gt;, “, ‘, ```。可使用 he (opens new window)这个库进行编码及转义</p>
<ol>
<li>不可分的空格:＆nbsp;</li>
<li>&lt;(小于符号):＆lt;</li>
<li>(大于符号):＆gt;</li>
<li>＆(与符号):＆amp;</li>
<li>″(双引号):＆quot;</li>
<li>‘(单引号):’＆apos;</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 实体编码</span><br><span class="line">&gt; he.encode(&#x27;&lt;img src=&quot;&quot;&gt;&lt;/img&gt;&#x27;)</span><br><span class="line">&lt; &quot;&amp;#x3C;img src=&amp;#x22;&amp;#x22;&amp;#x3E;&amp;#x3C;/img&amp;#x3E;&quot;</span><br><span class="line"></span><br><span class="line">// 转义</span><br><span class="line">&gt; he.escape(&#x27;&lt;img src=&quot;&quot;&gt;&lt;/img&gt;&#x27;)</span><br><span class="line">&lt; &quot;&amp;lt;img src=&amp;quot;&amp;quot;&amp;gt;&amp;lt;/img&amp;gt;&quot;</span><br></pre></td></tr></table></figure>
<h2 id="input和textarea的区别"><a href="#input和textarea的区别" class="headerlink" title="input和textarea的区别"></a>input和textarea的区别</h2><p>input是单行文本框，不会换行。<br>通过size属性指定显示字符的长度，注意：当使用css限定了宽高，那么size属性就不再起作用。<br>value属性指定初始值，Maxlength属性指定文本框可以输入的最长长度。<br>可以通过width和height设置宽高，但是也不会增加行数。<br>textarea是多行文本输入框，文本区中可容纳无限数量的文本，无value属性，其中的文本的默认字体是等宽字体（通常是Courier） ，可以通 过 cols 和 rows 属性来规定 textarea 的尺寸，不过更好的办法是使用 CSS 的 height 和 width 属性。</p>
<h2 id="用一个div模拟textarea的实现"><a href="#用一个div模拟textarea的实现" class="headerlink" title="用一个div模拟textarea的实现"></a>用一个div模拟textarea的实现</h2><p>作为多行文本域功能来讲，textarea满足了我们大部分的需求。然而，textarea有一个不足就是不能像普通div标签一样高度可以跟随内容自适应。textarea总是很自信地显摆它的滚动条，高度固执地岿然不动。</p>
<p>要解决这个问题很简单，一个普通的block元素上加个contenteditable=”true”就ok了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div contenteditable=&quot;true&quot;&gt;&lt;/div&gt; </span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">	&lt;style&gt;</span><br><span class="line">		.textarea&#123;</span><br><span class="line">			min-height: 100px;</span><br><span class="line">			border: 1px solid #a0b3d6; </span><br><span class="line">			width: 300px;</span><br><span class="line">			font-size: 14px;</span><br><span class="line">			max-height: 300px;</span><br><span class="line">			overflow-y: auto;</span><br><span class="line">		&#125;</span><br><span class="line">	&lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">	&lt;!--用div模拟textarea--&gt;</span><br><span class="line">	&lt;div class=&quot;textarea&quot; contenteditable=&quot;true&quot;&gt;</span><br><span class="line">		</span><br><span class="line">	&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure>
<p>给div设置了一个最小高度，当超过最小高度但不超过最大高度时，div的高度根据文本自适应，当超过最大高度时，出现滚动条。</p>
<h2 id="textarea-如何禁止拉伸"><a href="#textarea-如何禁止拉伸" class="headerlink" title="textarea 如何禁止拉伸"></a>textarea 如何禁止拉伸</h2><p>使用 CSS 样式可以避免拉伸</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">textarea &#123;</span><br><span class="line">  resize: none;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="移动设备忽略将页面中的数字识别为电话号码的方法"><a href="#移动设备忽略将页面中的数字识别为电话号码的方法" class="headerlink" title="移动设备忽略将页面中的数字识别为电话号码的方法"></a>移动设备忽略将页面中的数字识别为电话号码的方法</h2><p>在做移动端l的web开发的时候； IOS 上的Safari总会把长串数字识别为电话号码，文字变成蓝色，点击还会弹出菜单添加到通讯录。<br>解决方法：<br>只要加上 ：<br> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;meta name = &quot;format-detection&quot; content = &quot;telephone=no&quot;&gt;  </span><br></pre></td></tr></table></figure><br>meta标签中format-detection翻译成中文的意思是“格式检测”，是用来检测html里的文本格式的，还包括：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;meta name=&quot;format-detection&quot; content=&quot;telephone=no&quot;&gt;  //禁止把数字转化为拨号链接</span><br><span class="line">&lt;meta name=&quot;format-detection&quot; content=&quot;email=no&quot;&gt;  //禁止邮箱,禁止发送邮件</span><br><span class="line">&lt;meta name=&quot;format-detection&quot; content=&quot;adress=no&quot;&gt;  //禁止地址跳转至地图</span><br><span class="line">&lt;meta name=&quot;format-detection&quot; content=&quot;telephone=no,email=no,adress=no&quot;&gt;  //合并写法</span><br></pre></td></tr></table></figure>
<h2 id="在-Canvas-中如何处理跨域的图片"><a href="#在-Canvas-中如何处理跨域的图片" class="headerlink" title="在 Canvas 中如何处理跨域的图片"></a>在 Canvas 中如何处理跨域的图片</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">img.setAttribute(&quot;crossOrigin&quot;, &quot;anonymous&quot;);</span><br></pre></td></tr></table></figure>

<h2 id="什么是-URL-编码-URL-Encode"><a href="#什么是-URL-编码-URL-Encode" class="headerlink" title="什么是 URL 编码 (URL Encode)"></a>什么是 URL 编码 (URL Encode)</h2><ol>
<li><p>encodeURI 用来编码URI，其不会编码保留字符：;,/?😡&amp;=+$</p>
</li>
<li><p>encodeURIComponent 用来编码 URI参数，除了字符：A-Z a-z 0-9 - _ . ! ~ * ‘ ( )，都将会转义</p>
</li>
</ol>
<h2 id="head-元素"><a href="#head-元素" class="headerlink" title="head 元素"></a>head 元素</h2><p>head 子元素大概分为三类，分别是：</p>
<ol>
<li>描述网页基本信息的</li>
<li>指向渲染网页需要其他文件链接的</li>
<li>各大厂商根据自己需要定制的</li>
</ol>
<h2 id="网页基本信息"><a href="#网页基本信息" class="headerlink" title="网页基本信息"></a>网页基本信息</h2><p>一个网页，首先得有个标题，就跟人有名字一样。除此之外，还可以根据实际需要补充一些基本信息。</p>
<ol>
<li>文档标题（浏览器标签中显示的文本）：深入了解 head 元素</li>
<li>编码格式： 如果你的页面出现乱码，那一般就是编码格式不对</li>
<li>视窗设置：</li>
<li>搜索引擎优化相关内容： </li>
<li>IE 浏览器版本渲染设置</li>
</ol>
<h2 id="厂商定制"><a href="#厂商定制" class="headerlink" title="厂商定制"></a>厂商定制</h2><p>同样分享页面到 QQ 的聊天窗口，有些页面直接就是一个链接，但是有些页面有标题，图片，还有文字介绍。为什么区别这么明显呢？其实就是看有没有设置下面这三个内容</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;meta itemprop=&quot;name&quot; content=&quot;这是分享的标题&quot; /&gt;</span><br><span class="line">&lt;meta</span><br><span class="line">  itemprop=&quot;image&quot;</span><br><span class="line">  content=&quot;http://imgcache.qq.com/qqshow/ac/v4/global/logo.png&quot;</span><br><span class="line">/&gt;</span><br><span class="line">&lt;meta name=&quot;description&quot; itemprop=&quot;description&quot; content=&quot;这是要分享的内容&quot; /&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="300-毫秒点击延迟问题"><a href="#300-毫秒点击延迟问题" class="headerlink" title="300 毫秒点击延迟问题"></a>300 毫秒点击延迟问题</h2><ol>
<li>原因<br>移动端浏览器会有一些默认的行为，比如双击缩放、双击滚动，尤其是双击缩放，这也是300 毫秒延迟的主要原因。</li>
<li>解决反感<br>方案一：禁用缩放(不推荐)<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;meta name=&quot;viewport&quot; content=&quot;user-scalable=no&quot;&gt;</span><br><span class="line">&lt;meta name=&quot;viewport&quot; content=&quot;initial-scale=1,maximum-scale=1&quot;&gt;</span><br></pre></td></tr></table></figure>
方案二：更改默认的视口宽度(不推荐)<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width&quot;&gt;</span><br></pre></td></tr></table></figure>
方案三：CSS touch-action(不推荐)<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">touch-action: none</span><br></pre></td></tr></table></figure>
方案四：FastClick（推荐）<br>FastClick的实现原理是在检测到touchend事件的时候，会通过DOM自定义事件立即出发模拟一个click事件，并把浏览器在300ms之后的click事件阻止掉。<br>在移动端开发中，某些机型上使用 click 事件会延迟 300ms 才执行，这样影响了用户体验。 解决方法： 引入fastclick.js。<h1 id="html深入"><a href="#html深入" class="headerlink" title="html深入"></a>html深入</h1><h2 id="网站开发中，如何实现图片的懒加载"><a href="#网站开发中，如何实现图片的懒加载" class="headerlink" title="网站开发中，如何实现图片的懒加载"></a>网站开发中，如何实现图片的懒加载</h2></li>
</ol>
<p>懒加载，顾名思义，在当前网页，滑动页面到能看到图片的时候再加载图片</p>
<p>故问题拆分成两个：</p>
<ol>
<li>如何判断图片出现在了当前视口 （即如何判断我们能够看到图片）</li>
<li>如何控制图片的加载</li>
</ol>
<h3 id="方案一-位置计算-滚动事件-Scroll-DataSet-API"><a href="#方案一-位置计算-滚动事件-Scroll-DataSet-API" class="headerlink" title="方案一: 位置计算 + 滚动事件 (Scroll) + DataSet API"></a>方案一: 位置计算 + 滚动事件 (Scroll) + DataSet API</h3><h4 id="如何判断图片出现在了当前视口"><a href="#如何判断图片出现在了当前视口" class="headerlink" title="如何判断图片出现在了当前视口"></a>如何判断图片出现在了当前视口</h4><p>clientTop，offsetTop，clientHeight 以及 scrollTop 各种关于图片的高度作比对</p>
<p>这些高度都代表了什么意思？</p>
<p>这我以前有可能是知道的，那时候我比较单纯，喜欢死磕。我现在想通了，背不过的东西就不要背了</p>
<p>所以它有一个问题：复杂琐碎不好理解！</p>
<p>仅仅知道它静态的高度还不够，我们还需要知道动态的</p>
<p>如何动态？监听 window.scroll 事件</p>
<h4 id="如何控制图片的加载"><a href="#如何控制图片的加载" class="headerlink" title="如何控制图片的加载"></a>如何控制图片的加载</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;img data-src=&quot;shanyue.jpg&quot; /&gt;</span><br></pre></td></tr></table></figure>
<p>首先设置一个临时 Data 属性 data-src，控制加载时使用 src 代替 data-src，可利用 DataSet API 实现</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">img.src = img.datset.src</span><br></pre></td></tr></table></figure>

<h3 id="方案二-getBoundingClientRect-API-Scroll-with-Throttle-DataSet-API"><a href="#方案二-getBoundingClientRect-API-Scroll-with-Throttle-DataSet-API" class="headerlink" title="方案二: getBoundingClientRect API + Scroll with Throttle + DataSet API"></a>方案二: getBoundingClientRect API + Scroll with Throttle + DataSet API</h3><p>改进一下</p>
<p>#如何判断图片出现在了当前视口<br>引入一个新的 API， Element.getBoundingClientRect() 方法返回元素的大小及其相对于视口的位置。</p>
<p>那如何</p>
<p>判断图片出现在了当前视口呢，根据示例图示意，代码如下，这个就比较好理解了，就可以很容易地背会(就可以愉快地去面试了)。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// clientHeight 代表当前视口的高度</span><br><span class="line">img.getBoundingClientRect().top &lt; document.documentElement.clientHeight;</span><br></pre></td></tr></table></figure>

<p>监听 window.scroll 事件也优化一下</p>
<p>加个节流器，提高性能。工作中一般使用 lodash.throttle 就可以了，万能的 lodash 啊！</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">_.throttle(func, [(wait = 0)], [(options = &#123;&#125;)]);</span><br></pre></td></tr></table></figure>

<h3 id="方案三-IntersectionObserver-API-DataSet-API"><a href="#方案三-IntersectionObserver-API-DataSet-API" class="headerlink" title="方案三: IntersectionObserver API + DataSet API"></a>方案三: IntersectionObserver API + DataSet API</h3><p>再改进一下</p>
<h4 id="如何判断图片出现在了当前视口-1"><a href="#如何判断图片出现在了当前视口-1" class="headerlink" title="如何判断图片出现在了当前视口"></a>如何判断图片出现在了当前视口</h4><p>方案二使用的方法是: window.scroll 监听 Element.getBoundingClientRect() 并使用 _.throttle 节流</p>
<p>一系列组合动作太复杂了，于是浏览器出了一个三合一事件: IntersectionObserver API，一个能够监听元素是否到了当前视口的事件，一步到位！</p>
<p>事件回调的参数是 IntersectionObserverEntry (opens new window)的集合，代表关于是否在可见视口的一系列值</p>
<p>其中，entry.isIntersecting 代表目标元素可见</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const observer = new IntersectionObserver(changes =&gt; &#123;</span><br><span class="line">  // changes: 目标元素集合</span><br><span class="line">  changes.forEach(change =&gt; &#123;</span><br><span class="line">    // intersectionRatio</span><br><span class="line">    if (change.isIntersecting) &#123;</span><br><span class="line">      const img = change.target;</span><br><span class="line">      img.src = img.dataset.src;</span><br><span class="line">      observer.unobserve(img);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>observer.observe(img);<br>当然，IntersectionObserver 除了给图片做懒加载外，还可以对单页应用资源做预加载。</p>
<p>如在 next.js v9 中，会对视口内的资源做预加载，可以参考 next 9 production optimizations(opens new window)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;Link href=&quot;/about&quot;&gt;</span><br><span class="line">  &lt;a&gt;关于山月&lt;/a&gt;</span><br><span class="line">&lt;/Link&gt;</span><br></pre></td></tr></table></figure>

<h3 id="方案四-LazyLoading-属性"><a href="#方案四-LazyLoading-属性" class="headerlink" title="方案四: LazyLoading 属性"></a>方案四: LazyLoading 属性</h3><p>浏览器觉得懒加载这事可以交给自己做，你们开发者加个属性就好了。实在是…！</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;img src=&quot;shanyue.jpg&quot; loading=&quot;lazy&quot; /&gt;</span><br></pre></td></tr></table></figure>
<p>不过目前浏览器兼容性不太好</p>
<h2 id="浏览器中如何实现剪切板复制内容的功能"><a href="#浏览器中如何实现剪切板复制内容的功能" class="headerlink" title="浏览器中如何实现剪切板复制内容的功能"></a>浏览器中如何实现剪切板复制内容的功能</h2><p>它一般可以使用第三方库 clipboard-copy (opens new window)来实现，源码很简单，可以读一读</p>
<p>目前最为推荐的方式是使用 Clipboard API 进行实现</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">navigator.clipboard.writeText(text);</span><br></pre></td></tr></table></figure>
<p>而对于一些不支持 Clipboard API 的浏览器，使用以下 API 进行复制</p>
<p>选中: Selection API<br>复制: document.execCommand (已被废弃)</p>
<h3 id="选中-Selection-API-Range-API"><a href="#选中-Selection-API-Range-API" class="headerlink" title="选中: Selection API/Range API"></a>选中: Selection API/Range API</h3><p>选中主要利用了 Selection API (opens new window)与 Range API</p>
<p>选中的代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const selection = window.getSelection();</span><br><span class="line">const range = document.createRange();</span><br><span class="line"></span><br><span class="line">// RangeAPI: 制造区域</span><br><span class="line">range.selectNodeContents(element);</span><br><span class="line"></span><br><span class="line">// Selection: 选中区域</span><br><span class="line">selection.addRange(range);</span><br><span class="line"></span><br><span class="line">selectedText = selection.toString();</span><br></pre></td></tr></table></figure>
<p>取消选中的代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">window.getSelection().removeAllRanges();</span><br></pre></td></tr></table></figure>

<h2 id="在浏览器中如何监听剪切板中内容"><a href="#在浏览器中如何监听剪切板中内容" class="headerlink" title="在浏览器中如何监听剪切板中内容"></a>在浏览器中如何监听剪切板中内容</h2><p>通过 Clipboard API 可以获取剪切板中内容，但需要获取到 clipboard-read 的权限，以下是关于读取剪贴板内容的代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 是否能够有读取剪贴板的权限</span><br><span class="line">// result.state == &quot;granted&quot; || result.state == &quot;prompt&quot;</span><br><span class="line">const result = await navigator.permissions.query(&#123; name: &quot;clipboard-read&quot; &#125;);</span><br><span class="line"></span><br><span class="line">// 获取剪贴板内容</span><br><span class="line">const text = await navigator.clipboard.readText();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>它有现成的第三方库可以使用: select.js(opens new window)</p>
<h4 id="复制-execCommand"><a href="#复制-execCommand" class="headerlink" title="复制: execCommand"></a>复制: execCommand</h4><p>复制就比较简单了，execCommand</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">document.execCommand(&quot;copy&quot;);</span><br></pre></td></tr></table></figure>

<h2 id="localhost-3000-与-localhost-5000-的-cookie-信息是否共享"><a href="#localhost-3000-与-localhost-5000-的-cookie-信息是否共享" class="headerlink" title="localhost:3000 与 localhost:5000 的 cookie 信息是否共享"></a>localhost:3000 与 localhost:5000 的 cookie 信息是否共享</h2><p>根据同源策略，cookie 是区分端口的，但是浏览器实现来说，“cookie 区分域，而不区分端口，也就是说，同一个 ip 下的多个端口下的 cookie 是共享的！<br>不考虑 domian 设置 path 默认为/的话</p>
<p><a href="https://xxxx.com/">https://xxxx.com</a> 和<a href="http://xxxx.com/">http://xxxx.com</a> 协议不同其他相同的 cookie 也是共享的</p>
<p>默认 domain 为 localhost path 为/ 存储的 cookie 没有端口信息 共享</p>
<h2 id="什么是-CSRF-攻击"><a href="#什么是-CSRF-攻击" class="headerlink" title="什么是 CSRF 攻击"></a>什么是 CSRF 攻击</h2><p>跨站请求伪造（英语：Cross-site request forgery），也被称为 one-click attack 或者 session riding，通常缩写为 CSRF 或者 XSRF， 是一种挟制用户在当前已登录的 Web 应用程序上执行非本意的操作的攻击方法。跟跨网站脚本（XSS）相比，XSS 利用的是用户对指定网站的信任，CSRF 利用的是网站对用户网页浏览器的信任。</p>
<p>CSRF (Cross-site request forgery)，跨站请求伪造，又称为 one-click attack，顾名思义，通过恶意引导用户一次点击劫持 cookie 进行攻击。</p>
<p>使用 JSON API。当进行 CSRF 攻击时，请求体通过 &lt;form&gt; 构建，请求头为 application/www-form-urlencoded。它难以发送 JSON 数据被服务器所理解。<br>CSRF Token。生成一个随机的 token，切勿放在 cookie 中，每次请求手动携带该 token 进行校验。<br>SameSite Cookie。设置为 Lax 或者 Strict，禁止发送第三方 Cookie。</p>
<h2 id="如何把-json-数据转化为-demo-json-并下载文件"><a href="#如何把-json-数据转化为-demo-json-并下载文件" class="headerlink" title="如何把 json 数据转化为 demo.json 并下载文件"></a>如何把 json 数据转化为 demo.json 并下载文件</h2><p>json 视为字符串，可以利用 DataURL 进行下载</p>
<p>Text -&gt; DataURL</p>
<p>除了使用 DataURL，还可以转化为 Object URL 进行下载</p>
<p>Text -&gt; Blob -&gt; Object URL</p>
<p>可以把以下代码直接粘贴到控制台下载文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">function download(url, name) &#123;</span><br><span class="line">  const a = document.createElement(&quot;a&quot;);</span><br><span class="line">  a.download = name;</span><br><span class="line">  a.rel = &quot;noopener&quot;;</span><br><span class="line">  a.href = url;</span><br><span class="line">  // 触发模拟点击</span><br><span class="line">  a.dispatchEvent(new MouseEvent(&quot;click&quot;));</span><br><span class="line">  // 或者 a.click()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const json = &#123;</span><br><span class="line">  a: 3,</span><br><span class="line">  b: 4,</span><br><span class="line">  c: 5</span><br><span class="line">&#125;;</span><br><span class="line">const str = JSON.stringify(json, null, 2);</span><br><span class="line"></span><br><span class="line">// 方案一：Text -&gt; DataURL</span><br><span class="line">const dataUrl = `data:,$&#123;str&#125;`;</span><br><span class="line">download(dataUrl, &quot;demo.json&quot;);</span><br><span class="line"></span><br><span class="line">// 方案二：Text -&gt; Blob -&gt; ObjectURL</span><br><span class="line">const url = URL.createObjectURL(new Blob(str.split(&quot;&quot;)));</span><br><span class="line">download(url, &quot;demo1.json&quot;);</span><br></pre></td></tr></table></figure>
<p>#总结<br>模拟下载，可以通过新建一个 &lt;a href=”url” download&gt;&lt;a&gt; 标签并设置 url 及 download 属性来下载<br>可以通过把 json 转化为 dataurl 来构造 URL<br>可以通过把 json 转换为 Blob 再转化为 ObjectURL 来构造 URL</p>
<h2 id="简单介绍-requestIdleCallback-及使用场景"><a href="#简单介绍-requestIdleCallback-及使用场景" class="headerlink" title="简单介绍 requestIdleCallback 及使用场景"></a>简单介绍 requestIdleCallback 及使用场景</h2><p>requestIdleCallback 维护一个队列，将在浏览器空闲时间内执行。它属于 Background Tasks API (opens new window)，你可以使用 setTimeout 来模拟实现</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">window.requestIdleCallback =</span><br><span class="line">  window.requestIdleCallback ||</span><br><span class="line">  function(handler) &#123;</span><br><span class="line">    let startTime = Date.now();</span><br><span class="line"></span><br><span class="line">    return setTimeout(function() &#123;</span><br><span class="line">      handler(&#123;</span><br><span class="line">        didTimeout: false,</span><br><span class="line">        timeRemaining: function() &#123;</span><br><span class="line">          return Math.max(0, 50.0 - (Date.now() - startTime));</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;, 1);</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const rIC = window[&quot;requestIdleCallback&quot;] || (f =&gt; setTimeout(f, 1));</span><br></pre></td></tr></table></figure>
<p>在 rIC 中执行任务时需要注意以下几点：</p>
<p>执行重计算而非紧急任务<br>空闲回调执行时间应该小于 50ms，最好更少<br>空闲回调中不要操作 DOM，因为它本来就是利用的重排重绘后的间隙空闲时间，重新操作 DOM 又会造成重排重绘<br>React 的时间分片便是基于类似 rIC 而实现，然而因为 rIC 的兼容性及 50ms 流畅问题，React 自制了一个实现: scheduler(opens new window)</p>
<p>use-swr (opens new window)中进行资源的 revalidate 时，也是通过 rIC 来提高性能</p>
<h2 id="如何计算白屏时间和首屏时间"><a href="#如何计算白屏时间和首屏时间" class="headerlink" title="如何计算白屏时间和首屏时间"></a>如何计算白屏时间和首屏时间</h2><p>白屏时间:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">window.performance.timing.domLoading - window.performance.timing.navigationStart</span><br></pre></td></tr></table></figure>

<p>首屏时间:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">window.performance.timing.domInteractive - window.performace.timing.navigationStart</span><br></pre></td></tr></table></figure>
<h2 id="从浏览器地址栏输入url到显示页面的步骤"><a href="#从浏览器地址栏输入url到显示页面的步骤" class="headerlink" title="从浏览器地址栏输入url到显示页面的步骤"></a>从浏览器地址栏输入url到显示页面的步骤</h2><p>浏览器根据请求的URL交给DNS域名解析，找到真实IP，向服务器发起请求；<br>服务器交给后台处理完成后返回数据，浏览器接收文件（HTML、JS、CSS、图象等）；<br>浏览器对加载到的资源（HTML、JS、CSS等）进行语法解析，建立相应的内部数据结构（如HTML的DOM）；<br>载入解析到的资源文件，渲染页面，完成。</p>
<ol>
<li>为什么url要解析（也就是编码)<br>因为网络标准规定了URL只能使用英文字母、阿拉伯数字和某些标点符号（-_.~ ! * ‘ ( ) ; : @ &amp; = + $ , / ? # [ ]，比较常见的就是不包括百分号和双引号），如果URL中有汉字，就必须编码后使用（一般由应用程序决定），如果不转义会出现歧义，比如http:<a href="http://www.baidu.com/?key=value,%E5%81%87%E5%A6%82%E6%88%91%E7%9A%84key%E6%9C%AC%E8%BA%AB%E5%B0%B1%E5%8C%85%E6%8B%AC%E7%AD%89%E4%BA%8E=%E7%AC%A6%E5%8F%B7%EF%BC%8C%E6%AF%94%E5%A6%82ke=y=value%EF%BC%8C%E5%B0%B1%E4%BC%9A%E5%87%BA%E7%8E%B0%E6%AD%A7%E4%B9%89%EF%BC%8C%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93=%E5%88%B0%E5%BA%95%E6%98%AF%E8%BF%9E%E6%8E%A5key%E5%92%8Cvalue%E7%9A%84%E7%AC%A6%E5%8F%B7%EF%BC%8C%E8%BF%98%E6%98%AF%E8%AF%B4%E6%9C%AC%E8%BA%ABkey%E9%87%8C%E9%9D%A2%E5%B0%B1%E6%9C%89=">www.baidu.com?key=value,假如我的key本身就包括等于=符号，比如ke=y=value，就会出现歧义，你不知道=到底是连接key和value的符号，还是说本身key里面就有=</a></li>
<li>url编码的规则是什么？<br> （1）情况1:网址路径中包含汉字，网址路径的编码，用的是utf-8编码<br> （2）情况2:查询字符串包含汉字，查询字符串的编码，用的是操作系统的默认编码。<br> （3）情况3:Get/Post方法生成的URL包含汉字，GET和POST方法的编码，用的是网页的编码。<br> （4）情况4:Ajax调用的URL包含汉字，，IE总是采用GB2312编码（操作系统的默认编码），而Firefox总是采用utf-8编码，也就是说不通浏览器有不同的编码规则</li>
</ol>
<h2 id="什么是关键渲染路径"><a href="#什么是关键渲染路径" class="headerlink" title="什么是关键渲染路径"></a>什么是关键渲染路径</h2><p>从收到 HTML、CSS 和 JavaScript 字节到对其进行必需的处理，从而将它们转变成渲染的像素这一过程中有一些中间步骤，优化性能其实就是了解这些步骤中发生了什么， 即关键渲染路径</p>
<ol>
<li>创建DOM树(Constructing the DOM Tree)</li>
<li>创建CSSOM树(Constructing the CSSOM Tree)</li>
<li>执行脚本(Running JavaScript)</li>
<li>生成渲染树(Creating the Render Tree)</li>
<li>生成布局(Generating the Layout)</li>
<li>绘制(Painting)</li>
</ol>
<h2 id="什么是重排重绘，如何减少重拍重绘"><a href="#什么是重排重绘，如何减少重拍重绘" class="headerlink" title="什么是重排重绘，如何减少重拍重绘"></a>什么是重排重绘，如何减少重拍重绘</h2><p>重排和重绘是关键渲染路径中的两步，可以参考另一个问题: 什么是关键渲染路径(opens new window)</p>
<p>重排(Reflow)：元素的位置发生变动时发生重排，也叫回流。此时在关键渲染路径中的 Layout 阶段，计算每一个元素在设备视口内的确切位置和大小。当一个元素位置发生变化时，其父元素及其后边的元素位置都可能发生变化，代价极高</p>
<p>重绘(Repaint): 元素的样式发生变动，但是位置没有改变。此时在关键渲染路径中的 Paint 阶段，将渲染树中的每个节点转换成屏幕上的实际像素，这一步通常称为绘制或栅格化</p>
<p>另外，重排必定会造成重绘。以下是避免过多重拍重绘的方法</p>
<ol>
<li>使用 DocumentFragment 进行 DOM 操作，不过现在原生操作很少也基本上用不到</li>
<li>CSS 样式尽量批量修改</li>
<li>避免使用 table 布局</li>
<li>为元素提前设置好高宽，不因多次渲染改变位置</li>
</ol>
<h2 id="如何取消请求的发送"><a href="#如何取消请求的发送" class="headerlink" title="如何取消请求的发送"></a>如何取消请求的发送</h2><p>根据发送网络请求的 API 不同，取消方法不同</p>
<p>xhr<br>fetch<br>axios<br>如果使用XMLHttpRequest发送请求可以使用XMLHttpRequest.abort()</p>
<p>如果使用fetch发送请求可以使用AbortController</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const controller = new AbortController();</span><br><span class="line">const signal = controller.signal;</span><br><span class="line">fetch(&#x27;https://somewhere&#x27;, &#123; signal &#125;)</span><br><span class="line">controller.abort()</span><br></pre></td></tr></table></figure>
<p>如果使用axios，取消原理同 fetch</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var CancelToken = axios.CancelToken;</span><br><span class="line">var source = CancelToken.source();</span><br><span class="line"></span><br><span class="line">axios.get(&#x27;/https://somewhere&#x27;, &#123;</span><br><span class="line">  cancelToken: source.token</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">source.cancel()</span><br></pre></td></tr></table></figure>

<p>XHR 使用 xhr.abort()</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const xhr = new XMLHttpRequest(),</span><br><span class="line">  method = &quot;GET&quot;,</span><br><span class="line">  url = &quot;https://developer.mozilla.org/&quot;;</span><br><span class="line">xhr.open(method, url, true);</span><br><span class="line"></span><br><span class="line">xhr.send();</span><br><span class="line"></span><br><span class="line">// 取消发送请求</span><br><span class="line">xhr.abort();</span><br></pre></td></tr></table></figure>

<p>而其中的原理可分为两部分</p>
<p>浏览器端: 基于 XHR，xhr.abort()，见源码axios/lib/adapters/xhr.js(opens new window)<br>Node 端: 基于 http/https/follow-redirects，使用 request.abort()，见源码axios/lib/adapters/http.js</p>
<h2 id="如何实现浏览器内多个标签页之间的通信？"><a href="#如何实现浏览器内多个标签页之间的通信？" class="headerlink" title="如何实现浏览器内多个标签页之间的通信？"></a>如何实现浏览器内多个标签页之间的通信？</h2><h3 id="第一种——调用localStorage"><a href="#第一种——调用localStorage" class="headerlink" title="第一种——调用localStorage"></a>第一种——调用localStorage</h3><p>在一个标签页里面使用 localStorage.setItem(key,value)添加（修改、删除）内容；<br>在另一个标签页里面监听 storage 事件。<br>即可得到 localstorge 存储的值，实现不同标签页之间的通信。</p>
<p>标签页1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;input id=&quot;name&quot;&gt;  </span><br><span class="line">&lt;input type=&quot;button&quot; id=&quot;btn&quot; value=&quot;提交&quot;&gt;  </span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;  </span><br><span class="line">    $(function()&#123;    </span><br><span class="line">        $(&quot;#btn&quot;).click(function()&#123;    </span><br><span class="line">            var name=$(&quot;#name&quot;).val();    </span><br><span class="line">            localStorage.setItem(&quot;name&quot;, name);   </span><br><span class="line">        &#125;);    </span><br><span class="line">    &#125;);    </span><br><span class="line">&lt;/script&gt;  </span><br></pre></td></tr></table></figure>

<p>标签页2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">    $(function()&#123;</span><br><span class="line">        window.addEventListener(&quot;storage&quot;, function(event)&#123;</span><br><span class="line">            console.log(event.key + &quot;=&quot; + event.newValue);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h3 id="第二种——调用cookie-setInterval"><a href="#第二种——调用cookie-setInterval" class="headerlink" title="第二种——调用cookie+setInterval()"></a>第二种——调用cookie+setInterval()</h3><p>将要传递的信息存储在cookie中，每隔一定时间读取cookie信息，即可随时获取要传递的信息。</p>
<p>页面1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;input id=&quot;name&quot;&gt;</span><br><span class="line">&lt;input type=&quot;button&quot; id=&quot;btn&quot; value=&quot;提交&quot;&gt;</span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">    $(function()&#123;</span><br><span class="line">        $(&quot;#btn&quot;).click(function()&#123;</span><br><span class="line">            var name=$(&quot;#name&quot;).val();</span><br><span class="line">            document.cookie=&quot;name=&quot;+name;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>页面2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">    $(function()&#123;</span><br><span class="line">        function getCookie(key) &#123;</span><br><span class="line">            return JSON.parse(&quot;&#123;\&quot;&quot; + document.cookie.replace(/;\s+/gim,&quot;\&quot;,\&quot;&quot;).replace(/=/gim, &quot;\&quot;:\&quot;&quot;) + &quot;\&quot;&#125;&quot;)[key];</span><br><span class="line">        &#125;</span><br><span class="line">        setInterval(function()&#123;</span><br><span class="line">            console.log(&quot;name=&quot; + getCookie(&quot;name&quot;));</span><br><span class="line">        &#125;, 10000);</span><br><span class="line">    &#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h3 id="第三种-websocket通讯"><a href="#第三种-websocket通讯" class="headerlink" title="第三种 websocket通讯"></a>第三种 websocket通讯</h3><h3 id="第四种-html5浏览器的新特性SharedWorker"><a href="#第四种-html5浏览器的新特性SharedWorker" class="headerlink" title="第四种 html5浏览器的新特性SharedWorker"></a>第四种 html5浏览器的新特性SharedWorker</h3><p>普通的webworker直接使用new Worker()即可创建，这种webworker是当前页面专有的。然后还有种共享worker(SharedWorker)，这种是可以多个标签页、iframe共同使用的。</p>
<p>SharedWorker可以被多个window共同使用，但必须保证这些标签页都是同源的(相同的协议，主机和端口号)</p>
<p>首先新建一个js文件worker.js，具体代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// sharedWorker所要用到的js文件，不必打包到项目中，直接放到服务器即可let data = &#x27;&#x27;onconnect = function (e) &#123;  let port = e.ports[0]  port.onmessage = function (e) &#123;    if (e.data === &#x27;get&#x27;) &#123;      port.postMessage(data)    &#125; else &#123;      data = e.data    &#125;  &#125;&#125;</span><br></pre></td></tr></table></figure>

<p>webworker端(暂且这样称呼)的代码就如上，只需注册一个onmessage监听信息的事件，客户端(即使用sharedWorker的标签页)发送message时就会触发。</p>
<p>注意webworker无法在本地使用，出于浏览器本身的安全机制，所以我这次的示例也是放在服务器上的，worker.js和index.html在同一目录。</p>
<p>因为客户端和webworker端的通信不像websocket那样是全双工的，所以客户端发送数据和接收数据要分成两步来处理。示例中会有两个按钮，分别对应的向sharedWorker发送数据的请求以及获取数据的请求，但他们本质上都是相同的事件–发送消息。</p>
<p>webworker端会进行判断，传递的数据为’get’时，就把变量data的值回传给客户端，其他情况，则把客户端传递过来的数据存储到data变量中。下面是客户端的代码：</p>
<p>// 这段代码是必须的，打开页面后注册SharedWorker，显示指定worker.port.start()方法建立与worker间的连接</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (typeof Worker === &quot;undefined&quot;) &#123;</span><br><span class="line"></span><br><span class="line">      alert(&#x27;当前浏览器不支持webworker&#x27;)</span><br><span class="line"></span><br><span class="line">    &#125; else &#123;</span><br><span class="line"></span><br><span class="line">      let worker = new SharedWorker(&#x27;worker.js&#x27;)</span><br><span class="line"></span><br><span class="line">      worker.port.addEventListener(&#x27;message&#x27;, (e) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">        console.log(&#x27;来自worker的数据：&#x27;, e.data)</span><br><span class="line"></span><br><span class="line">      &#125;, false)</span><br><span class="line"></span><br><span class="line">      worker.port.start()</span><br><span class="line"></span><br><span class="line">      window.worker = worker</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>// 获取和发送消息都是调用postMessage方法，我这里约定的是传递’get’表示获取数据。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">window.worker.port.postMessage(&#x27;get&#x27;)</span><br><span class="line"></span><br><span class="line">window.worker.port.postMessage(&#x27;发送信息给worker&#x27;)</span><br></pre></td></tr></table></figure>

<p>页面A发送数据给worker，然后打开页面B，调用window.worker.port.postMessage(‘get’)，即可收到页面A发送给worker的数据。</p>
<h2 id="webSocket如何兼容低浏览器"><a href="#webSocket如何兼容低浏览器" class="headerlink" title="webSocket如何兼容低浏览器"></a>webSocket如何兼容低浏览器</h2><ol>
<li><p>使用轮询或长连接的方式实现伪websocket的通信</p>
</li>
<li><p>使用flash或其他方法实现一个websocket客户端 Adobe Flash Socket；</p>
</li>
<li><p>ActiveX HTMLFile (IE) ；</p>
</li>
<li><p>基于 multipart 编码发送 XHR；</p>
</li>
</ol>
<h2 id="canvas-和-svg-的区别"><a href="#canvas-和-svg-的区别" class="headerlink" title="canvas 和 svg 的区别"></a>canvas 和 svg 的区别</h2><p>canvas 是 html5 提供的新元素，而 svg 存在的历史要比 canvas 久远，已经有十几年了。svg 并不是 html5 专有的标签，最初 svg 是用 xml 技术（超文本扩展语言，可以自定义标签或属性）描述二维图形的语言。在 H5 中看似 canvas 与 svg 很像，但是，他们有巨大的差别。<br>首先，从它们的功能上来讲，canvas 可以看做是一个画布。，其绘制出来的图形为标量图，因此，可以在 canvas 中引入 jpg 或 png 这类格式的图片，在实际开发中，大型的网络游戏都是用 canvas 画布做出来的，并且 canvas 的技术现在已经相当的成熟。另外，我们喜欢用 canvas 来做一些统计用的图表，如柱状图曲线图或饼状图等。 而 svg，所绘制的图形为矢量图，所以其用法上受到了限制。因为只能绘制矢量图，所以 svg 中不能引入普通的图片，因为矢量图的不会失真的效果，在项目中我们会用来做小图标。但是由于其本质为矢量图，可以被无限放大而不会失真，这很适合被用来做地图，而百度地图就是用 svg 技术做出来的。<br>另外从技术发面来讲 canvas 里面绘制的图形不能被引擎抓取，如我们要让 canvas 里面的一个图片跟随鼠标事件: canvas.onmouseover=function(){}。 而 svg 里面的图形可以被引擎抓取，支持事件的绑定。另外 canvas 中我们绘制图形通常是通过 javascript 来实现，svg 更多的是通过标签来来实现，如在 svg 中绘制正矩形形就要用，这里我们不能用属性 style=”width:XXX;height:XXX;”来定义。</p>
]]></content>
      <categories>
        <category>html</category>
      </categories>
  </entry>
  <entry>
    <title>css面试</title>
    <url>/2021/08/19/css%E9%9D%A2%E8%AF%95/</url>
    <content><![CDATA[<h2 id="介绍一下标准的CSS的盒子模型？与低版本IE的盒子模型有什么不同？"><a href="#介绍一下标准的CSS的盒子模型？与低版本IE的盒子模型有什么不同？" class="headerlink" title="介绍一下标准的CSS的盒子模型？与低版本IE的盒子模型有什么不同？"></a>介绍一下标准的CSS的盒子模型？与低版本IE的盒子模型有什么不同？</h2><p>标准盒子模型：宽度=内容宽度（content）+ border + padding + margin</p>
<p>低版本IE盒子模型：宽度=内容宽度（content + border + padding）+ margin</p>
<h2 id="box-sizing属性？"><a href="#box-sizing属性？" class="headerlink" title="box-sizing属性？"></a>box-sizing属性？</h2><p>用来控制元素的盒子模型的解析模式，默认为content-box</p>
<p>content-box：w3c标准盒子模型，设置元素的width/height属性指的是content部分的宽高</p>
<p>border-box：IE传统盒子模型。设置元素的height/width属性指的是border+padding+content<br>部分的宽/高</p>
<h2 id="css选择器有哪些？哪些属性可以继承？"><a href="#css选择器有哪些？哪些属性可以继承？" class="headerlink" title="css选择器有哪些？哪些属性可以继承？"></a>css选择器有哪些？哪些属性可以继承？</h2><p>css选择符：ID选择器（#id）、类选择器（.class）、标签选择器（div,h1）、相邻选择器（h1+p）、<br>子选择器（ul&gt;li）、后代选择器（li a）、通配符选择器(*)、属性选择器（a[rel=”external”]）、伪类选择器(a:hover,li:nth-child)</p>
<p>可继承的属性：font-size,font-family,color</p>
<p>不可继承的样式：border，padding，margin</p>
<p>优先级（就近原则）：！important&gt;id&gt;class&gt;tag, !important比内联优先级高</p>
<h2 id="CSS中可继承与不可继承属性有哪些"><a href="#CSS中可继承与不可继承属性有哪些" class="headerlink" title="CSS中可继承与不可继承属性有哪些"></a>CSS中可继承与不可继承属性有哪些</h2><p>一、无继承性的属性</p>
<ol>
<li>display：规定元素应该生成的框的类型</li>
<li>文本属性：<br>· vertical-align：垂直文本对齐<br>· text-decoration：规定添加到文本的装饰<br>· text-shadow：文本阴影效果<br>· white-space：空白符的处理<br>· unicode-bidi：设置文本的方向</li>
<li>盒子模型的属性：width、height、margin、border、padding</li>
<li>背景属性：background、background-color、background-image</li>
<li>background-repeat、background-position、background-attachment<br>定位属性：float、clear、position、top、right、bottom、left、min-width、min-height、max-width、max-height、overflow、clip、z-index</li>
<li>生成内容属性：content、counter-reset、counter-increment</li>
<li>轮廓样式属性：outline-style、outline-width、outline-color、outline</li>
<li>页面样式属性：size、page-break-before、page-break-after</li>
<li>声音样式属性：pause-before、pause-after、pause、cue-before、cue-after、cue、play-during</li>
</ol>
<p>二、有继承性的属性<br>1.字体系列属性<br>font-family：字体系列<br>font-weight：字体的粗细<br>font-size：字体的大小<br>font-style：字体的风格<br>2. 文本系列属性<br>text-indent：文本缩进<br>text-align：文本水平对齐<br>line-height：行高<br>word-spacing：单词之间的间距<br>letter-spacing：中文或者字母之间的间距<br>text-transform：控制文本大小写（就是uppercase、lowercase、capitalize这三个）<br>color：文本颜色<br>3. 元素可见性<br>visibility：控制元素显示隐藏<br>列表布局属性<br>list-style：列表风格，包括list-style-type、list-style-image等<br>光标属性<br>cursor：光标显示为何种形态</p>
<h2 id="css优先级算法如何计算"><a href="#css优先级算法如何计算" class="headerlink" title="css优先级算法如何计算"></a>css优先级算法如何计算</h2><p>判断优先级时，首先我们会判断一条属性声明是否有权重，也就是是否在声明后面加上了!important。一条声明如果加上了权重，<br>那么它的优先级就是最高的，前提是它之后不再出现相同权重的声明。如果权重相同，我们则需要去比较匹配规则的特殊性。</p>
<p>一条匹配规则一般由多个选择器组成，一条规则的特殊性由组成它的选择器的特殊性累加而成。选择器的特殊性可以分为四个等级，<br>第一个等级是行内样式，为1000，第二个等级是id选择器，为0100，第三个等级是类选择器、伪类选择器和属性选择器，为0010，<br>第四个等级是元素选择器和伪元素选择器，为0001。规则中每出现一个选择器，就将它的特殊性进行叠加，这个叠加只限于对应的等<br>级的叠加，不会产生进位。选择器特殊性值的比较是从左向右排序的，也就是说以1开头的特殊性值比所有以0开头的特殊性值要大。<br>比如说特殊性值为1000的的规则优先级就要比特殊性值为0999的规则高。如果两个规则的特殊性值相等的时候，那么就会根据它们引<br>入的顺序，后出现的规则的优先级最高。</p>
<h2 id="css3新增的伪类有哪些？"><a href="#css3新增的伪类有哪些？" class="headerlink" title="css3新增的伪类有哪些？"></a>css3新增的伪类有哪些？</h2><p>p:first-of-type 选择属于其父元素的首个元素</p>
<p>p:last-of-type 选择属于其父元素的最后元素</p>
<p>p:only-of-type 选择属于其父元素唯一的元素</p>
<p>p:only-child 选择属于其父元素唯一的元素</p>
<p>p:ntn-child(2) 选择属于其父元素的第二个子元素</p>
<p>:enabled,:disabled 表单控件的禁用状态</p>
<p>:checked 单选框或复选框被选中</p>
<h2 id="如何居中div？如何居中一个浮动元素？如何让绝对定位的div居中？"><a href="#如何居中div？如何居中一个浮动元素？如何让绝对定位的div居中？" class="headerlink" title="如何居中div？如何居中一个浮动元素？如何让绝对定位的div居中？"></a>如何居中div？如何居中一个浮动元素？如何让绝对定位的div居中？</h2><p>div:</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">border</span>: <span class="number">1px</span> solid red;</span><br><span class="line"><span class="attribute">margin</span>:<span class="number">0</span> auto;</span><br><span class="line"><span class="attribute">height</span>:<span class="number">50px</span>;</span><br><span class="line"><span class="attribute">width</span>: <span class="number">50px</span>;</span><br></pre></td></tr></table></figure>

<p>浮动元素的上下左右居中：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">border</span>: <span class="number">1px</span> solid red;</span><br><span class="line"><span class="attribute">float</span>: left;</span><br><span class="line"><span class="attribute">position</span>: absolute;</span><br><span class="line"><span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line"><span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line"><span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line"><span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line"><span class="attribute">margin</span>: -<span class="number">50px</span> <span class="number">0</span> <span class="number">0</span> -<span class="number">100px</span>;</span><br></pre></td></tr></table></figure>

<p>绝对定位的左右居中：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">border</span>: <span class="number">1px</span> solid black;</span><br><span class="line"><span class="attribute">position</span>: absolute;</span><br><span class="line"><span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line"><span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line"><span class="attribute">margin</span>: <span class="number">0</span> auto;</span><br><span class="line"><span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line"><span class="attribute">right</span>: <span class="number">0</span>; </span><br></pre></td></tr></table></figure>

<p>flex居中：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">display</span>: flex;</span><br><span class="line"><span class="attribute">align-items</span>: center;</span><br><span class="line"><span class="attribute">justify-content</span>: center;</span><br></pre></td></tr></table></figure>

<h2 id="display有哪些值？说明他们的作用？"><a href="#display有哪些值？说明他们的作用？" class="headerlink" title="display有哪些值？说明他们的作用？"></a>display有哪些值？说明他们的作用？</h2><p>inline(默认)-内联<br>none-隐藏<br>block-块显示<br>table-表格显示<br>list-item -项目列表<br>inline-block（内联块显示）</p>
<h2 id="position的值？"><a href="#position的值？" class="headerlink" title="position的值？"></a>position的值？</h2><p>static（默认）按照正常文档流进行排列</p>
<p>relative（相对定位）：不脱离文档流，参考自身静态位置通过 top,bottom,left,right定位</p>
<p>absolute（绝对定位）：参考距其最近的一个不为 static的福元素通过top,bottom,left,right定位</p>
<p>fixed（固定定位）：所固定的参照对象是可视窗口</p>
<h2 id="css3新特性？"><a href="#css3新特性？" class="headerlink" title="css3新特性？"></a>css3新特性？</h2><ol>
<li>RGBA和透明度</li>
<li>background-image、background-origin background-size background-repeat</li>
<li>word-wrap(对长的不可分割单词换行) work- wrap:break-word</li>
<li>文字阴影  text-shadom:5px 5px 5px #000(水平阴影，垂直阴影，模糊距离，颜色)</li>
<li>font-face属性：定义自己的字体</li>
<li>圆角 border-radius</li>
<li>边框图片 border-image:url() 30 30 round</li>
<li>盒阴影：box-shadom:10px 10px 5px #000(水平阴影，垂直阴影，模糊距离，颜色)</li>
<li>媒体查询@media</li>
</ol>
<h2 id="请解释一下css3的flexbox（弹性盒布局模型），以及适用场景"><a href="#请解释一下css3的flexbox（弹性盒布局模型），以及适用场景" class="headerlink" title="请解释一下css3的flexbox（弹性盒布局模型），以及适用场景"></a>请解释一下css3的flexbox（弹性盒布局模型），以及适用场景</h2><p>该布局模型的目的是提供一种更加高效的方式来对容器中的条目进行布局、对齐和分配空间。在传统的布局方式中，block 布局是把块在垂直方向从上到下依次排列的；而 inline 布局则是在水平方向来排列。弹性盒布局并没有这样内在的方向限制，可以由开发人员自由操作。试用场景：弹性布局适合于移动前端开发，在Android和ios上也完美支持。</p>
<h2 id="用纯CSS创建一个三角形的原理是什么？"><a href="#用纯CSS创建一个三角形的原理是什么？" class="headerlink" title="用纯CSS创建一个三角形的原理是什么？"></a>用纯CSS创建一个三角形的原理是什么？</h2><p>采用的是均分原理,把矩形分为4等份,这4等份其实都是边框</p>
<p>首先，需要把元素的宽度、高度设为0。然后设置边框样式。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line"><span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line"><span class="attribute">border-top</span>: <span class="number">40px</span> solid transparent;</span><br><span class="line"><span class="attribute">border-left</span>: <span class="number">40px</span> solid transparent;</span><br><span class="line"><span class="attribute">border-right</span>: <span class="number">40px</span> solid transparent;</span><br><span class="line"><span class="attribute">border-bottom</span>: <span class="number">40px</span> solid <span class="number">#ff0000</span>;</span><br></pre></td></tr></table></figure>

<h2 id="一个满屏品字布局如何设计？"><a href="#一个满屏品字布局如何设计？" class="headerlink" title="一个满屏品字布局如何设计？"></a>一个满屏品字布局如何设计？</h2><p>第一种真正的品字：</p>
<ol>
<li>三块高宽是确定的；</li>
<li>上面那块用margin: 0 auto;居中；</li>
<li>下面两块用float或者inline-block不换行；</li>
<li>用margin调整位置使他们居中。</li>
</ol>
<p>第二种全屏的品字布局:上面的div设置成100%，下面的div分别宽50%，然后使用float或者inline使其不换行。</p>
<h2 id="常见的兼容性问题？"><a href="#常见的兼容性问题？" class="headerlink" title="常见的兼容性问题？"></a>常见的兼容性问题？</h2><ol>
<li>不同浏览器的标签默认的margin和padding不一样。*{margin:0;padding:0}</li>
<li>IE6双边距bug:块属性标签float后，又有横行的margin情况下，在IE6显示的margin比较大。解决方案： display：inline；将其转化为行内属性。</li>
<li>渐进识别的方式，从总体中逐渐排出局部。首先，巧妙的使用“9”这一标记，将IE浏览器从所有情况中分离出来。接着，再次使用“+”将IE8和IE7、IE6分离开来，这样IE8已经独立识别。<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attribute">background-color</span>:<span class="number">#f1ee18</span>;<span class="comment">/*所有识别*/</span></span><br><span class="line">    <span class="selector-class">.background-color</span>:<span class="number">#00deff</span>\<span class="number">9</span>; <span class="comment">/*IE6、7、8识别*/</span></span><br><span class="line">    +<span class="attribute">background-color</span>:<span class="number">#a200ff</span>;<span class="comment">/*IE6、7识别*/</span></span><br><span class="line">    _background-<span class="attribute">color</span>:<span class="number">#1e0bd1</span>;<span class="comment">/*IE6识别*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>设置较小高度标签（一般小于10px），在IE6，IE7中高度超出自己设置高度。hack：给超出高度的标签设置overflow：hidden；或者设置行高line- height小于你设置的高度。</li>
<li>IE下，可以使用获取常规属性的方法来获取自定义属性,也可以使用getAttribute()获取自定义属性；Firefox下，只能使用getAttribute()获取自定义属性。解决方法:统一通过getAttribute()获取自定义属性。</li>
<li>Chrome 中文界面下默认会将小于 12px 的文本强制按照 12px 显示,可通过加入 CSS 属性 -webkit-text-size-adjust: none; 解决。</li>
<li>超链接访问过后hover样式就不出现了，被点击访问过的超链接样式不再具有hover和active了。解决方法是改变CSS属性的排列顺序:L-V-H-A ( love hate ): a:link {} a:visited {} a:hover {} a:active {}</li>
</ol>
<h2 id="为什么要初始化CSS样式"><a href="#为什么要初始化CSS样式" class="headerlink" title="为什么要初始化CSS样式"></a>为什么要初始化CSS样式</h2><p>因为浏览器的兼容问题，不同浏览器对有些标签的默认值是不同的，如果没对CSS初始化往往会出现浏览器之间的页面显示差异。</p>
<h2 id="absolute的containing-block计算方式跟正常流有什么不同"><a href="#absolute的containing-block计算方式跟正常流有什么不同" class="headerlink" title="absolute的containing block计算方式跟正常流有什么不同"></a>absolute的containing block计算方式跟正常流有什么不同</h2><p>（1）内联元素也可以作为“包含块”所在的元素；</p>
<p>（2）“包含块”所在的元素不是父块级元素，而是最近的position不为static的祖先元素或根元素；</p>
<p>（3）边界是padding box而不是content box。</p>
<h2 id="CSS里的visibility属性有个collapse属性值？在不同浏览器下有什么区别？"><a href="#CSS里的visibility属性有个collapse属性值？在不同浏览器下有什么区别？" class="headerlink" title="CSS里的visibility属性有个collapse属性值？在不同浏览器下有什么区别？"></a>CSS里的visibility属性有个collapse属性值？在不同浏览器下有什么区别？</h2><p>当一个元素的visibility属性被设置成collapse值后，对于一般的元素，它的表现跟hidden是一样的。但例外的是，如果这个元素是table相关的元素，例如table行，table group，table列，table column group，它的表现却跟display:none一样，也就是说，它们占用的空间也会释放。</p>
<ol>
<li>chrome中，使用collapse值和使用hidden没有区别。</li>
<li>firefox，opera和IE，使用collapse值和使用display：none没有什么区别。</li>
</ol>
<h2 id="display-none与visibility：hidden的区别？"><a href="#display-none与visibility：hidden的区别？" class="headerlink" title="display:none与visibility：hidden的区别？"></a>display:none与visibility：hidden的区别？</h2><p>这两个属性都是让元素隐藏，不可见。两者区别如下：<br>（1）在渲染树中</p>
<p>· display:none会让元素完全从渲染树中消失，渲染时不会占据任何空间；<br>· visibility:hidden不会让元素从渲染树中消失，渲染的元素还会占据相应的空间，只是内容不可见。</p>
<p>（2）是否是继承属性</p>
<p>· display:none是非继承属性，子孙节点会随着父节点从渲染树消失，通过修改子孙节点的属性也无法显示；<br>· visibility:hidden是继承属性，子孙节点消失是由于继承了hidden，通过设置visibility:visible可以让子孙节点显示；</p>
<p>（3）修改常规文档流中元素的 display 通常会造成文档的重排，但是修改visibility属性只会造成本元素的重绘；<br>（4）如果使用读屏器，设置为display:none的内容不会被读取，设置为visibility:hidden的内容会被读取。</p>
<h2 id="position跟display、overflow、float这些特性相互叠加后会怎么样？"><a href="#position跟display、overflow、float这些特性相互叠加后会怎么样？" class="headerlink" title="position跟display、overflow、float这些特性相互叠加后会怎么样？"></a>position跟display、overflow、float这些特性相互叠加后会怎么样？</h2><p>display属性规定元素应该生成的框的类型；position属性规定元素的定位类型；float属性是一种布局方式，定义元素在哪个方向浮动。</p>
<p>类似于优先级机制：position：absolute/fixed优先级最高，有他们在时，float不起作用，display值需要调整。float 或者absolute定位的元素，只能是块元素或表格。</p>
<h2 id="对BFC规范-块级格式化上下文：block-formatting-context-的理解？"><a href="#对BFC规范-块级格式化上下文：block-formatting-context-的理解？" class="headerlink" title="对BFC规范(块级格式化上下文：block formatting context)的理解？"></a>对BFC规范(块级格式化上下文：block formatting context)的理解？</h2><p>BFC规定了内部的Block Box如何布局。定位方案：</p>
<ol>
<li>内部的Box会在垂直方向上一个接一个放置。</li>
<li>Box垂直方向的距离由margin决定，属于同一个BFC的两个相邻Box的margin会发生重叠。</li>
<li>每个元素的margin box 的左边，与包含块border box的左边相接触。</li>
<li>BFC的区域不会与float box重叠。</li>
<li>BFC是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。</li>
<li>计算BFC的高度时，浮动元素也会参与计算。</li>
</ol>
<p>满足下列条件之一就可触发BFC:</p>
<ol>
<li>根元素，即html</li>
<li>float的值不为none（默认）</li>
<li>overflow的值不为visible（默认）</li>
<li>display的值为inline-block、table-cell、table-caption</li>
<li>position的值为absolute或fixed</li>
</ol>
<h2 id="为什么会出现浮动和什么时候需要清除浮动？清除浮动的方式？你认为最好的是哪一种？为什么？"><a href="#为什么会出现浮动和什么时候需要清除浮动？清除浮动的方式？你认为最好的是哪一种？为什么？" class="headerlink" title="为什么会出现浮动和什么时候需要清除浮动？清除浮动的方式？你认为最好的是哪一种？为什么？"></a>为什么会出现浮动和什么时候需要清除浮动？清除浮动的方式？你认为最好的是哪一种？为什么？</h2><p>浮动元素碰到包含它的边框或者浮动元素的边框停留。在CSS规范中，浮动定位不属于正常的页面流，而是独立定位的，所以文档流的块框表现得就像浮动框不存在一样。浮动元素会漂浮在文档流的块框上。<br>关于css的定位机制：普通流，浮动，绝对定位（position：fixed是position：absolute的一个子类）。浮动的框可以左右移动，直到它的外边缘遇到包含框或者另一个浮动框的边缘，所以才说浮动定位不属于正常的页面流。文档中的普通流就会表现得和浮动框不存在一样，当浮动框高度超出包含框的时候，就会出现包含框不会自动伸缩高度类笔盒浮动元素。所以，只含有浮动元素的父容器在显示时不需要考虑子元素的位置，就造成显示父容器像空容器一样。</p>
<p>浮动元素会漂浮在文档流的块框上。浮动带来的问题：</p>
<ol>
<li>父元素的高度无法被撑开，影响与父元素同级的元素</li>
<li>与浮动元素同级的非浮动元素（内联元素）会跟随其后</li>
<li>若非第一个元素浮动，则该元素之前的元素也需要浮动，否则会影响页面显示的结构。</li>
</ol>
<p>清除浮动的方式：</p>
<ol>
<li>父级div定义height</li>
<li>最后一个浮动元素后加空div标签 并添加样式clear:both。</li>
<li>包含浮动元素的父标签添加样式overflow为hidden或auto。</li>
<li>父级div定义zoom</li>
</ol>
<p>1<strong>、父级div定义height</strong><br>原理：父级div手动定义height，就解决了父级div无法自动获取到高度的问题<br>优点：简单，代码少，容易掌握<br>缺点：只适合高度固定的布局，要给出精确的高度，如果高度和父级div不一样时，会产生问题<br>建议：不推荐使用，只建议高度固定的布局时使用</p>
<p>2<strong>、结尾处加空 div 标签 clear:both</strong><br>原理：添加一个空div，利用css提高的clear:both清除浮动，让父级div能自动获取到高度<br>优点：简单，代码少，浏览器支持好，不容易出现怪问题<br>缺点：不少初学者不理解原理；如果页面浮动布局多，就要增加很多空div，让人感觉很不爽<br>建议：不推荐使用，但此方法是以前主要使用的一种清除浮动方法</p>
<p>3<strong>、父级 div 定义 overflow:hidden</strong><br>原理：必须定义width或zoom:1，同时不能定义height，使用overflow:hidden时，浏览器会自动检查浮动区域的高度<br>优点：简单，代码少，浏览器支持好<br>缺点：不能和position配合使用，因为超出的尺寸的会被隐藏<br>建议：只推荐没有使用position或对overflow:hidden理解比较深的朋友使用</p>
<p>4<strong>、父级div定义伪类 :after 和 zoom</strong><br>原理：IE8以上和非IE浏览器才支持:after，原理和方法2有点类似，zoom(IE转有属性)可解决ie6,ie7浮动问题<br>优点：浏览器支持好，不容易出现怪问题（目前：大型网站都有使用，如：腾迅，网易，新浪等等）<br>缺点：代码多，不少初学者不理解原理，要两句代码结合使用，才能让主流浏览器都支持<br>建议：推荐使用，建议定义公共类，以减少CSS代码<br>(1) 在子元素后添加一个空div div{clear:both;}<br>(2) 在父元素中{overflow:hidden|auto;zoom:1}<br>(3) :after伪选择符，在父容器的尾部自动创建一个子元素</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.clearfix:after &#123;</span><br><span class="line">    content: &quot;\0020&quot;;display: block;height: 0;clear: both;</span><br><span class="line">&#125;</span><br><span class="line">.clearfix &#123;</span><br><span class="line">    zoom: 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>“clearfix”是父容器的class名称，”content:”020”;”是在父容器的结尾处放一个空白符，<br>“height: 0;”是让这个这个空白字符不显示出来，”display: block; clear: both;”是确保这个空白字符是非浮动的独立区块。:after选择符IE 6不支持,添加一条IE 6的独有命令”zoom:1;”就行了.</p>
<h2 id="上下margin重合的问题"><a href="#上下margin重合的问题" class="headerlink" title="上下margin重合的问题"></a>上下margin重合的问题</h2><p>在重合元素外包裹一层容器，并触发该容器生成一个BFC。</p>
<p>例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div class=&quot;aside&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;div class=&quot;text&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;main&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;!--下面是css代码--&gt;</span><br><span class="line"> .aside &#123;</span><br><span class="line">            margin-bottom: 100px;  </span><br><span class="line">            width: 100px;</span><br><span class="line">            height: 150px;</span><br><span class="line">            background: #f66;</span><br><span class="line">        &#125;</span><br><span class="line">        .main &#123;</span><br><span class="line">            margin-top: 100px;</span><br><span class="line">            height: 200px;</span><br><span class="line">            background: #fcc;</span><br><span class="line">        &#125;</span><br><span class="line">         .text&#123;</span><br><span class="line">            /*盒子main的外面包一个div，通过改变此div的属性使两个盒子分属于两个不同的BFC，以此来阻止margin重叠*/</span><br><span class="line">            overflow: hidden;  //此时已经触发了BFC属性。</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<h2 id="设置元素浮动后，该元素的display值是多少？"><a href="#设置元素浮动后，该元素的display值是多少？" class="headerlink" title="设置元素浮动后，该元素的display值是多少？"></a>设置元素浮动后，该元素的display值是多少？</h2><p>自动变成display:block</p>
<h2 id="移动端的布局用过媒体查询吗？"><a href="#移动端的布局用过媒体查询吗？" class="headerlink" title="移动端的布局用过媒体查询吗？"></a>移动端的布局用过媒体查询吗？</h2><p>媒体查询由⼀个可选的媒体类型和零个或多个使⽤媒体功能的限制了样式表范围的表达式组成，例如宽度、⾼度和颜⾊。媒体查询，添加⾃CSS3，允许内容的呈现针对⼀个特定范围的输出设备⽽进⾏裁剪，⽽不必改变内容本身，适合web⽹⻚应对不同型号的设备⽽做出对应的响应适配。<br>媒体查询包含⼀个可选的媒体类型和满⾜CSS3规范的条件下，包含零个或多个表达式，这些表达式描述了媒体特征，最终会被解析为true或false。如果媒体查询中指定的媒体类型匹配展示⽂档所使⽤的设备类型，并且所有的表达式的值都是true，那么该媒体查询的结果为true。那么媒体查询内的样式将会⽣效。</p>
<p>通过媒体查询可以为不同大小和尺寸的媒体定义不同的css，适应相应的设备的显示。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. &lt;head&gt;里边&lt;link rel=”stylesheet” type=”text/css” href=”xxx.css” media=”only screen and (max-device-width:480px)”&gt;</span><br><span class="line"></span><br><span class="line">2. CSS : @media only screen and (max-device-width:480px) &#123;/css样式/&#125;</span><br></pre></td></tr></table></figure>

<h2 id="使用-CSS-预处理器吗？"><a href="#使用-CSS-预处理器吗？" class="headerlink" title="使用 CSS 预处理器吗？"></a>使用 CSS 预处理器吗？</h2><p>Less sass</p>
<h2 id="CSS优化、提高性能的方法有哪些？"><a href="#CSS优化、提高性能的方法有哪些？" class="headerlink" title="CSS优化、提高性能的方法有哪些？"></a>CSS优化、提高性能的方法有哪些？</h2><p>加载性能：</p>
<p>（1）css压缩：将写好的css进行打包压缩，可以减少很多的体积。<br>（2）css单一样式：当需要下边距和左边距的时候，很多时候选择:margin:top 0 bottom 0;但margin-bottom:bot<br>tom;margin-left:left;执行的效率更高。<br>（3）减少使用@import,而建议使用link，因为后者在页面加载时一起加载，前者是等待页面加载完成之后再进行加载。</p>
<p>选择器性能：</p>
<p>（1）关键选择器（key selector）。选择器的最后面的部分为关键选择器（即用来匹配目标元素的部分）。CSS选择符是从右到<br>左进行匹配的。当使用后代选择器的时候，浏览器会遍历所有子元素来确定是否是指定的元素等等；</p>
<p>（2）如果规则拥有ID选择器作为其关键选择器，则不要为规则增加标签。过滤掉无关的规则（这样样式系统就不会浪费时间去匹<br>配它们了）。</p>
<p>（3）避免使用通配规则，如*{}计算次数惊人！只对需要用到的元素进行选择。</p>
<p>（4）尽量少的去对标签进行选择，而是用class。</p>
<p>（5）尽量少的去使用后代选择器，降低选择器的权重值。后代选择器的开销是最高的，尽量将选择器的深度降到最低，最高不要超过<br>三层，更多的使用类来关联每一个标签元素。</p>
<p>（6）了解哪些属性是可以通过继承而来的，然后避免对这些属性重复指定规则。</p>
<p>渲染性能：</p>
<p>（1）慎重使用高性能属性：浮动、定位。</p>
<p>（2）尽量减少页面重排、重绘。</p>
<p>（3）去除空规则：｛｝。空规则的产生原因一般来说是为了预留样式。去除这些空规则无疑能减少css文档体积。</p>
<p>（4）属性值为0时，不加单位。</p>
<p>（5）属性值为浮动小数0.**，可以省略小数点之前的0。</p>
<p>（6）标准化各种浏览器前缀：带浏览器前缀的在前。标准属性在后。</p>
<p>（7）不使用@import前缀，它会影响css的加载速度。</p>
<p>（8）选择器优化嵌套，尽量避免层级过深。</p>
<p>（9）css雪碧图，同一页面相近部分的小图标，方便使用，减少页面的请求次数，但是同时图片本身会变大，使用时，优劣考虑清<br>楚，再使用。</p>
<p>（10）正确使用display的属性，由于display的作用，某些样式组合会无效，徒增样式体积的同时也影响解析性能。</p>
<p>（11）不滥用web字体。对于中文网站来说WebFonts可能很陌生，国外却很流行。web fonts通常体积庞大，而且一些浏<br>览器在下载web fonts时会阻塞页面渲染损伤性能。</p>
<p>可维护性、健壮性：</p>
<p>（1）将具有相同属性的样式抽离出来，整合并通过class在页面中进行使用，提高css的可维护性。<br>（2）样式与内容分离：将css代码定义到外部css中。</p>
<h2 id="浏览器是怎样解析CSS选择器的？"><a href="#浏览器是怎样解析CSS选择器的？" class="headerlink" title="浏览器是怎样解析CSS选择器的？"></a>浏览器是怎样解析CSS选择器的？</h2><p>样式系统从关键选择器开始匹配，然后左移查找规则选择器的祖先元素。只要选择器的子树一直在工作，样式系统就会持续左移，直<br>到和规则匹配，或者是因为不匹配而放弃该规则。</p>
<p>CSS选择器的解析是从右向左解析的。若从左向右的匹配，发现不符合规则，需要进行回溯，会损失很多性能。若从右向左匹配，先找到所有的最右节点，对于每一个节点，向上寻找其父节点直到找到根元素或满足条件的匹配规则，则结束这个分支的遍历。两种匹配规则的性能差别很大，是因为从右向左的匹配在第一步就筛选掉了大量的不符合条件的最右节点（叶子节点），而从左向右的匹配规则的性能都浪费在了失败的查找上面。</p>
<p>而在 CSS 解析完毕后，需要将解析的结果与 DOM Tree 的内容一起进行分析建立一棵 Render Tree，最终用来进行绘图。在建立 Render Tree 时（WebKit 中的「Attachment」过程），浏览器就要为每个 DOM Tree 中的元素根据 CSS 的解析结果（Style Rules）来确定生成怎样的 Render Tree。</p>
<h2 id="在网页中的应该使用奇数还是偶数的字体？为什么呢？"><a href="#在网页中的应该使用奇数还是偶数的字体？为什么呢？" class="headerlink" title="在网页中的应该使用奇数还是偶数的字体？为什么呢？"></a>在网页中的应该使用奇数还是偶数的字体？为什么呢？</h2><p>（1）偶数字号相对更容易和web设计的其他部分构成比例关系。比如：当我用了14px的正文字号，我可能会在一些地方用14<br>×0.5=7px的margin，在另一些地方用14×1.5=21px的标题字号。<br>（2）浏览器缘故，低版本的浏览器ie6会把奇数字体强制转化为偶数，即13px渲染为14px。<br>（3）系统差别，早期的Windows里，中易宋体点阵只有12和14、15、16px，唯独缺少13px。</p>
<h2 id="margin和padding分别适合什么场景使用？"><a href="#margin和padding分别适合什么场景使用？" class="headerlink" title="margin和padding分别适合什么场景使用？"></a>margin和padding分别适合什么场景使用？</h2><p>margin是用来隔开元素与元素的间距；padding是用来隔开元素与内容的间隔。<br>margin用于布局分开元素使元素与元素互不相干。<br>padding用于元素与内容之间的间隔，让内容（文字）与（包裹）元素之间有一段距离。</p>
<p>何时使用margin：</p>
<ol>
<li>需要在border外侧添加空白</li>
<li>空白处不需要背景色</li>
<li>上下相连的两个盒子之间的空白，需要相互抵消时。</li>
</ol>
<p>何时使用padding：</p>
<ol>
<li>需要在border内侧添加空白</li>
<li>空白处需要背景颜色</li>
<li>上下相连的两个盒子的空白，希望为两者之和。</li>
</ol>
<p>兼容性的问题：在IE5 IE6中，为float的盒子指定margin时，左侧的margin可能会变成两倍的宽度。通过改变padding或者指定盒子的display：inline解决。</p>
<h2 id="元素竖向的百分比设定是相对于容器的高度吗？"><a href="#元素竖向的百分比设定是相对于容器的高度吗？" class="headerlink" title="元素竖向的百分比设定是相对于容器的高度吗？"></a>元素竖向的百分比设定是相对于容器的高度吗？</h2><p>当按百分比设定一个元素的宽度时，它是相对于父容器的宽度计算的，但是，对于一些表示竖向距离的属性，例如 padding-top , padding-bottom , margin-top , margin-bottom 等，当按百分比设定它们时，依据的也是父容器的宽度，而不是高度。</p>
<h2 id="全屏滚动的原理是什么？用到了CSS的哪些属性？"><a href="#全屏滚动的原理是什么？用到了CSS的哪些属性？" class="headerlink" title="全屏滚动的原理是什么？用到了CSS的哪些属性？"></a>全屏滚动的原理是什么？用到了CSS的哪些属性？</h2><p>原理：有点类似于轮播，整体的元素一直排列下去，假设有5个需要展示的全屏页面，那么高度是500%，只是展示100%，剩下的可以通过transform进行y轴定位，也可以通过margin-top实现</p>
<p>overflow：hidden；transition：all 1000ms ease；</p>
<h2 id="什么是响应式设计？响应式设计的基本原理是什么？如何兼容低版本的IE？"><a href="#什么是响应式设计？响应式设计的基本原理是什么？如何兼容低版本的IE？" class="headerlink" title="什么是响应式设计？响应式设计的基本原理是什么？如何兼容低版本的IE？"></a>什么是响应式设计？响应式设计的基本原理是什么？如何兼容低版本的IE？</h2><p>响应式网站设计(Responsive Web design)是一个网站能够兼容多个终端，而不是为每一个终端做一个特定的版本。基本原理是通过媒体查询检测不同的设备屏幕尺寸做处理。页面头部必须有meta声明的viewport。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;meta name=&quot;’viewport’&quot; content=&quot;”width=device-width,&quot; initial-scale=&quot;1.&quot; maximum-scale=&quot;1,user-scalable=no”&quot;/&gt;</span><br></pre></td></tr></table></figure>

<h2 id="视差滚动效果？"><a href="#视差滚动效果？" class="headerlink" title="视差滚动效果？"></a>视差滚动效果？</h2><p>视差滚动（Parallax Scrolling）通过在网页向下滚动的时候，控制背景的移动速度比前景的移动速度慢来创建出令人惊叹的3D效果。</p>
<ol>
<li>CSS3实现优点：开发时间短、性能和开发效率比较好，缺点是不能兼容到低版本的浏览器</li>
<li>jQuery实现通过控制不同层滚动速度，计算每一层的时间，控制滚动效果。优点：能兼容到各个版本的，效果可控性好缺点：开发起来对制作者要求高</li>
<li>插件实现方式例如：parallax-scrolling，兼容性十分好</li>
</ol>
<h2 id="before-和-after中双冒号和单冒号有什么区别？解释一下这2个伪元素的作用"><a href="#before-和-after中双冒号和单冒号有什么区别？解释一下这2个伪元素的作用" class="headerlink" title="::before 和 :after中双冒号和单冒号有什么区别？解释一下这2个伪元素的作用"></a>::before 和 :after中双冒号和单冒号有什么区别？解释一下这2个伪元素的作用</h2><ol>
<li>单冒号(:)用于CSS3伪类，双冒号(::)用于CSS3伪元素。</li>
<li>::before就是以一个子元素的存在，定义在元素主体内容之前的一个伪元素。并不存在于dom之中，只存在在页面之中。</li>
</ol>
<p>:before 和 :after 这两个伪元素，是在CSS2.1里新出现的。起初，伪元素的前缀使用的是单冒号语法，但随着Web的进化，在CSS3的规范里，伪元素的语法被修改成使用双冒号，成为::before ::after</p>
<h2 id="你对line-height是如何理解的？"><a href="#你对line-height是如何理解的？" class="headerlink" title="你对line-height是如何理解的？"></a>你对line-height是如何理解的？</h2><p>行高是指一行文字的高度，具体说是两行文字间基线的距离。CSS中起高度作用的是height和line-height，没有定义height属性，最终其表现作用一定是line-height。单行文本垂直居中：把line-height值设置为height一样大小的值可以实现单行文字的垂直居中，其实也可以把height删除。多行文本垂直居中：需要设置display属性为inline-block。</p>
<h2 id="怎么让Chrome支持小于12px-的文字？"><a href="#怎么让Chrome支持小于12px-的文字？" class="headerlink" title="怎么让Chrome支持小于12px 的文字？"></a>怎么让Chrome支持小于12px 的文字？</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">p&#123;font-size:10px;-webkit-transform:scale(0.8);&#125; //0.8是缩放比例</span><br><span class="line">html,body&#123;-webkit-text-size-adjust:none;&#125;</span><br><span class="line">.divcss5&#123;-webkit-text-size-adjust:none;&#125;</span><br></pre></td></tr></table></figure>

<h2 id="让页面里的字体变清晰，变细用CSS怎么做？"><a href="#让页面里的字体变清晰，变细用CSS怎么做？" class="headerlink" title="让页面里的字体变清晰，变细用CSS怎么做？"></a>让页面里的字体变清晰，变细用CSS怎么做？</h2><p>-webkit-font-smoothing在window系统下没有起作用，但是在IOS设备上起作用-webkit-font-smoothing：antialiased是最佳的，灰度平滑。</p>
<h2 id="position-跟-display、overflow、float-这些特性相互叠加后会怎么样？"><a href="#position-跟-display、overflow、float-这些特性相互叠加后会怎么样？" class="headerlink" title="position 跟 display、overflow、float 这些特性相互叠加后会怎么样？"></a>position 跟 display、overflow、float 这些特性相互叠加后会怎么样？</h2><p>display 属性规定元素应该生成的框的类型；position属性规定元素的定位类型；float属性是一种布局方式，定义元素在哪个方向浮动。<br>类似于优先级机制：position：absolute/fixed优先级最高，有他们在时，float不起作用，display值需要调整。float 或者absolute定位的元素，只能是块元素或表格。</p>
<h2 id="position-fixed-在android下无效怎么处理？"><a href="#position-fixed-在android下无效怎么处理？" class="headerlink" title="position:fixed;在android下无效怎么处理？"></a>position:fixed;在android下无效怎么处理？</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, user-scalable=no&quot;/&gt;</span><br></pre></td></tr></table></figure>

<h2 id="如果需要手动写动画，你认为最小时间间隔是多久，为什么？"><a href="#如果需要手动写动画，你认为最小时间间隔是多久，为什么？" class="headerlink" title="如果需要手动写动画，你认为最小时间间隔是多久，为什么？"></a>如果需要手动写动画，你认为最小时间间隔是多久，为什么？</h2><p>多数显示器默认频率是60Hz，即1秒刷新60次，所以理论上最小间隔为1/60＊1000ms ＝ 16.7ms。</p>
<h2 id="li与li之间有看不见的空白间隔是什么原因引起的？有什么解决办法？"><a href="#li与li之间有看不见的空白间隔是什么原因引起的？有什么解决办法？" class="headerlink" title="li与li之间有看不见的空白间隔是什么原因引起的？有什么解决办法？"></a>li与li之间有看不见的空白间隔是什么原因引起的？有什么解决办法？</h2><p>浏览器会把inline元素间的空白字符（空格、换行、Tab等）渲染成一个空格。而为了美观。我们通常是一个li放在一行，<br>这导致li换行后产生换行字符，它变成一个空格，占用了一个字符的宽度。</p>
<p>解决办法：</p>
<p>（1）为li设置float:left。不足：有些容器是不能设置浮动，如左右切换的焦点图等。</p>
<p>（2）将所有li写在同一行。不足：代码不美观。</p>
<p>（3）将ul内的字符尺寸直接设为0，即font-size:0。不足：ul中的其他字符尺寸也被设为0，需要额外重新设定其他<br>字符尺寸，且在Safari浏览器依然会出现空白间隔。</p>
<p>（4）消除ul的字符间隔letter-spacing:-8px，不足：这也设置了li内的字符间隔，因此需要将li内的字符<br>间隔设为默认letter-spacing:normal。</p>
<h2 id="display-inline-block-什么时候会显示间隙？"><a href="#display-inline-block-什么时候会显示间隙？" class="headerlink" title="display:inline-block 什么时候会显示间隙？"></a>display:inline-block 什么时候会显示间隙？</h2><ol>
<li>有空格时候会有间隙 解决：移除空格</li>
<li>margin正值的时候 解决：margin使用负值</li>
<li>使用font-size时候 解决：font-size:0、letter-spacing、word-spacing</li>
</ol>
<h2 id="有一个高度自适应的div，里面有两个div，一个高度100px，希望另一个填满剩下的高度"><a href="#有一个高度自适应的div，里面有两个div，一个高度100px，希望另一个填满剩下的高度" class="headerlink" title="有一个高度自适应的div，里面有两个div，一个高度100px，希望另一个填满剩下的高度"></a>有一个高度自适应的div，里面有两个div，一个高度100px，希望另一个填满剩下的高度</h2><p>外层div使用position：relative；高度要求自适应的div使用position: absolute; top: 100px; bottom: 0; left: 0</p>
<h2 id="png、jpg、gif-这些图片格式解释一下，分别什么时候用。有没有了解过webp？"><a href="#png、jpg、gif-这些图片格式解释一下，分别什么时候用。有没有了解过webp？" class="headerlink" title="png、jpg、gif 这些图片格式解释一下，分别什么时候用。有没有了解过webp？"></a>png、jpg、gif 这些图片格式解释一下，分别什么时候用。有没有了解过webp？</h2><ol>
<li>png是便携式网络图片（Portable Network Graphics）是一种无损数据压缩位图文件格式.优点是：压缩比高，色彩好。 大多数地方都可以用。</li>
<li>jpg是一种针对相片使用的一种失真压缩方法，是一种破坏性的压缩，在色调及颜色平滑变化做的不错。在www上，被用来储存和传输照片的格式。</li>
<li>gif是一种位图文件格式，以8位色重现真色彩的图像。可以实现动画效果.</li>
<li>webp格式是谷歌在2010年推出的图片格式，压缩率只有jpg的2/3，大小比png小了45%。缺点是压缩的时间更久了，兼容性不好，目前谷歌和opera支持。</li>
</ol>
<h2 id="style标签写在body后与body前有什么区别？"><a href="#style标签写在body后与body前有什么区别？" class="headerlink" title="style标签写在body后与body前有什么区别？"></a>style标签写在body后与body前有什么区别？</h2><p>页面加载自上而下 当然是先加载样式。写在body标签后由于浏览器以逐行方式对HTML文档进行解析，当解析到写在尾部的样式表（外联或写在style标签）会导致浏览器停止之前的渲染，等待加载且解析样式表完成之后重新渲染，在windows的IE下可能会出现FOUC现象（即样式失效导致的页面闪烁问题）</p>
<h2 id="CSS属性overflow属性定义溢出元素内容区的内容会如何处理"><a href="#CSS属性overflow属性定义溢出元素内容区的内容会如何处理" class="headerlink" title="CSS属性overflow属性定义溢出元素内容区的内容会如何处理?"></a>CSS属性overflow属性定义溢出元素内容区的内容会如何处理?</h2><p>参数是scroll时候，必会出现滚动条。<br>参数是auto时候，子元素内容大于父元素时出现滚动条。<br>参数是visible时候，溢出的内容出现在父元素之外。<br>参数是hidden时候，溢出隐藏。</p>
<h2 id="你知道-CSS-中不同属性设置为百分比-x-时对应的计算基准？"><a href="#你知道-CSS-中不同属性设置为百分比-x-时对应的计算基准？" class="headerlink" title="你知道 CSS 中不同属性设置为百分比\x 时对应的计算基准？"></a>你知道 CSS 中不同属性设置为百分比\x 时对应的计算基准？</h2><ol>
<li>基于包含块</li>
</ol>
<p>以下的关于包含块（含块）的概念，不能简单地理解成是父元素。</p>
<p>如果是静态定位和相对定位，包含块一般就是其父元素。但是对于绝对定位的元素，包含块应该是离它最近的 position 不是static的父元素，比如为absolute，relative，或者 fixed 的父元素。而对于固定定位的元素，它的包含块是视口（viewport）。</p>
<ol start="2">
<li><p>基于包含块的宽度（width，min-width，max-width，margin，padding，left，right，text-indent）</p>
</li>
<li><p>百分比是基于包含块的宽度的属性：width，min-width，max-width，margin，padding，left，right，text-indent</p>
</li>
<li><p>基于包含块的高度（height，max-height，min-height，top，bottom）</p>
</li>
</ol>
<p>百分比是基于包含块的高度的属性：height，max-height，min-height，top，bottom</p>
<ol start="5">
<li>基于元素的字体大小（line-height ）</li>
</ol>
<p>line-height 的百分比基于该元素本身的字体大小</p>
<ol start="6">
<li>基于元素的行高（vertical-align）</li>
</ol>
<p>vertical-align 的百分比基于元素的行高 line-height</p>
<p>（vertical-align 主要是设置行内元素的属性，该属性值设置行内元素相对于该元素所在的基线的垂直对齐位置。如果该行内元素是表格的单元格的话，该属性设置的是单元格内的内容的垂直方向的对齐位置）</p>
<ol start="7">
<li>font-size 的百分比<br>字体大小font-size 中的百分比是基于该元素所继承的字体大小的，也就是父元素的字体大小。</li>
</ol>
<p>其他答案：<br>公式：当前元素某CSS属性值 = 基准 * 对应的百分比<br>元素的 position 为 relative 和 absolute 时，top和bottom、left和right基准分别为包含块的 height、width<br>元素的 position 为 fixed 时，top和bottom、left和right基准分别为初始包含块（也就是视口）的 height、width，移动设备较为复杂，基准为 Layout viewport 的 height、width<br>元素的 height 和 width 设置为百分比时，基准分别为包含块的 height 和 width<br>元素的 margin 和 padding 设置为百分比时，基准为包含块的 width（易错）<br>元素的 border-width，不支持百分比<br>元素的 text-indent，基准为包含块的 width</p>
<p>元素的 border-radius，基准为分别为自身的height、width<br>元素的 background-size，基准为分别为自身的height、width<br>元素的 translateX、translateY，基准为分别为自身的height、width<br>元素的 line-height，基准为自身的 font-size</p>
<p>元素的 font-size，基准为父元素字体</p>
<h2 id="一个自适应矩形，水平垂直居中，且宽高比为-2-1"><a href="#一个自适应矩形，水平垂直居中，且宽高比为-2-1" class="headerlink" title="一个自适应矩形，水平垂直居中，且宽高比为 2:1"></a>一个自适应矩形，水平垂直居中，且宽高比为 2:1</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.box &#123;</span><br><span class="line">    position: absolute;</span><br><span class="line">    top: 0;</span><br><span class="line">    right: 0;</span><br><span class="line">    left: 0;</span><br><span class="line">    bottom: 0;</span><br><span class="line">    margin: auto;</span><br><span class="line"></span><br><span class="line">    width: 10%;</span><br><span class="line">    height: 0;</span><br><span class="line">    padding-top: 20%;</span><br><span class="line">    background: tomato;</span><br><span class="line">&#125;</span><br><span class="line">&lt;div class=&quot;box&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<h2 id="css-三栏布局的实现？"><a href="#css-三栏布局的实现？" class="headerlink" title="css 三栏布局的实现？"></a>css 三栏布局的实现？</h2><ol>
<li><p>网格（grid）布局</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.div&#123;</span><br><span class="line">    width: 100%;</span><br><span class="line">    display: grid;</span><br><span class="line">    grid-template-rows: 100px;</span><br><span class="line">    grid-template-columns: 300px auto 300px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>flex布局</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">display: flex;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>3.table布局</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.main&#123;</span><br><span class="line">    width: 100%;</span><br><span class="line">    display: table;</span><br><span class="line">&#125;</span><br><span class="line">.left,.center,.right&#123;</span><br><span class="line">    display: table-cell;</span><br><span class="line">&#125;</span><br><span class="line">.left&#123;</span><br><span class="line">    width: 300px;</span><br><span class="line">    background-color: red;</span><br><span class="line">&#125;</span><br><span class="line">.center&#123;</span><br><span class="line">    background-color: blue;</span><br><span class="line">&#125;</span><br><span class="line">.right&#123;</span><br><span class="line">    width: 300px;</span><br><span class="line">    background-color: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>浮动布局<br>float</li>
<li>position布局</li>
</ol>
<h2 id="css经典布局——头尾固定高度中间高度自适应布局"><a href="#css经典布局——头尾固定高度中间高度自适应布局" class="headerlink" title="css经典布局——头尾固定高度中间高度自适应布局"></a>css经典布局——头尾固定高度中间高度自适应布局</h2><h2 id="常见的元素隐藏方式？"><a href="#常见的元素隐藏方式？" class="headerlink" title="常见的元素隐藏方式？"></a>常见的元素隐藏方式？</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-（1）使用 display:none;隐藏元素，渲染树不会包含该渲染对象，因此该元素不会在页面中占据位置，也不会响应绑定的监听事件。</span><br><span class="line"></span><br><span class="line">-（2）使用 visibility:hidden;隐藏元素。元素在页面中仍占据空间，但是不会响应绑定的监听事件。</span><br><span class="line"></span><br><span class="line">-（3）使用 opacity:0;将元素的透明度设置为 0，以此来实现元素的隐藏。元素在页面中仍然占据空间，并且能够响应元素绑定的监听事件。</span><br><span class="line"></span><br><span class="line">-（4）通过使用绝对定位将元素移除可视区域内，以此来实现元素的隐藏。</span><br><span class="line"></span><br><span class="line">-（5）通过 z-index 负值，来使其他元素遮盖住该元素，以此来实现隐藏。</span><br><span class="line"></span><br><span class="line">-（6）通过 clip/clip-path 元素裁剪的方法来实现元素的隐藏，这种方法下，元素仍在页面中占据位置，但是不会响应绑定的监听事件。</span><br><span class="line"></span><br><span class="line">-（7）通过 transform:scale(0,0)来将元素缩放为 0，以此来实现元素的隐藏。这种方法下，元素仍在页面中占据位置，但是不会响应绑定的监听事件。</span><br></pre></td></tr></table></figure>

<h2 id="如何实现单行／多行文本溢出的省略（…）"><a href="#如何实现单行／多行文本溢出的省略（…）" class="headerlink" title="如何实现单行／多行文本溢出的省略（…）"></a>如何实现单行／多行文本溢出的省略（…）</h2><ol>
<li>单行<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">overflow: hidden;</span><br><span class="line">text-overflow: ellipsis;</span><br><span class="line">white-space: nowrap;</span><br></pre></td></tr></table></figure></li>
<li>多行</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">display:-webkit-box;//对象作为弹性伸缩盒子模型显示 </span><br><span class="line">-webkit-box-orient: vertical;//设置或检索伸缩盒对象的子元素的排列方式 </span><br><span class="line">-webkit-line-clamp: 2;//溢出省略的界限</span><br><span class="line">overflow:hidden;//设置隐藏溢出元素&#x27;</span><br></pre></td></tr></table></figure>

<h2 id="css隐藏元素的背景图到底加不加载"><a href="#css隐藏元素的背景图到底加不加载" class="headerlink" title="css隐藏元素的背景图到底加不加载"></a>css隐藏元素的背景图到底加不加载</h2><p>-（1）元素的背景图片</p>
<p>-元素本身设置 display:none，会请求图片 -父级元素设置 display:none，不会请求图片 -样式没有元素使用，不会请求<br>-:hover 样式下，触发时请求</p>
<p>-（2）img 标签图片任何情况下都会请求图片</p>
<h2 id="white-space-与换行和空格的控制？"><a href="#white-space-与换行和空格的控制？" class="headerlink" title="white-space 与换行和空格的控制？"></a>white-space 与换行和空格的控制？</h2><p>white-space属性声明了如何处理元素内的空白字符，这类空白字符包括Space（空格）键、Enter（回车）键、Tab（制表符）<br>键产生的空白。因此，white-space可以决定图文内容是否在一行显示（回车空格是否生效），是否显示大段连续空白（空格是否<br>生效）等。</p>
<p>其属性值包括下面这些。<br>•normal：合并空白字符和换行符。<br>•pre：空白字符不合并，并且内容只在有换行符的地方换行。<br>•nowrap：该值和normal一样会合并空白字符，但不允许文本环绕。<br>•pre-wrap：空白字符不合并，并且内容只在有换行符的地方换行，同时允许文本环绕。<br>•pre-line：合并空白字符，但只在有换行符的地方换行，允许文本环绕。</p>
<h2 id="word-spacing-单词间距-letter-spacing-字符间距？"><a href="#word-spacing-单词间距-letter-spacing-字符间距？" class="headerlink" title="word-spacing 单词间距 letter-spacing 字符间距？"></a>word-spacing 单词间距 letter-spacing 字符间距？</h2><p>letter-spacing : normal | length<br>word-spacing：normal | length<br>letter-spacing作用于所有字符，但word-spacing仅作用于空格字符。换句话说，word-spacing的作用就是增加空格的间隙宽度。</p>
<p>letter-spacing可以用来控制字符之间的间距，这里说的“字符”包括英文字母、汉字以及空格等。</p>
<p>letter-spacing具有以下一些特性。</p>
<p>（1）继承性。<br>（2）默认值是normal而不是0。虽然说正常情况下，normal的计算值就是0，但两者还是有差别的，在有些场景下，letter-spacing会调整normal的计算值以实现更好的版面布局。<br>（3）支持负值，且值足够大的时候，会让字符形成重叠，甚至反向排列。<br>（4）和text-indent属性一样，无论值多大或多小，第一行一定会保留至少一个字符。<br>（5）支持小数值，即使0.1px也是支持的。<br>（6）暂不支持百分比值。</p>
<h2 id="text-indent-的特殊性"><a href="#text-indent-的特殊性" class="headerlink" title="text-indent 的特殊性"></a>text-indent 的特殊性</h2><p>（1）text-indent仅对第一行内联盒子内容有效。</p>
<p>（2）非替换元素以外的display计算值为inline的内联元素设置text-indent值无效，如果计算值inline-block/inli<br>ne-table则会生效。</p>
<p>（3）input标签按钮text-indent值无效。</p>
<p>（4）button标签按钮text-indent值有效。</p>
<p>（5）text-indent的百分比值是相对于当前元素的“包含块”计算的，而不是当前元素。</p>
<h2 id="font-weight-的特殊性？"><a href="#font-weight-的特殊性？" class="headerlink" title="font-weight 的特殊性？"></a>font-weight 的特殊性？</h2><p>在上面我们已经提到，在很多情况下，字体并不是以九阶数值来划分的，并且其含有的字重数量是不一的，通常情况下为4-6个。</p>
<p>此时，就会出现样式指定的字重数值在字体中找不到直接对应的字重，那浏览器是如何解决的呢？</p>
<p>Bingo！</p>
<p>那就是要靠字体匹配算法来解决。其中关于font-weight部分是这么提及到的：</p>
<p>如果指定的font-weight数值，即所需的字重，能够在字体中找到对应的字重，那么就匹配为该对应的字重。否则，使用下面的规则来查找所需的字重并渲染：</p>
<p>·    如果所需的字重小于400，则首先降序检查小于所需字重的各个字重，如仍然没有，则升序检查大于所需字重的各字重，直到找到匹配的字重。</p>
<p>·    如果所需的字重大于500，则首先升序检查大于所需字重的各字重，之后降序检查小于所需字重的各字重，直到找到匹配的字重。</p>
<p>·    如果所需的字重是400，那么会优先匹配500对应的字重，如仍没有，那么执行第一条所需字重小于400的规则。</p>
<p>·    如果所需的字重是500，则优先匹配400对应的字重，如仍没有，那么执行第二条所需字重大于500的规则。</p>
<h2 id="层叠上下文、层叠水平和层叠顺序"><a href="#层叠上下文、层叠水平和层叠顺序" class="headerlink" title="层叠上下文、层叠水平和层叠顺序"></a>层叠上下文、层叠水平和层叠顺序</h2><ol>
<li>层叠上下文(stacking context)是一种三维概念，如果用户和电脑屏幕之间存在一条看不见的垂直线，假设一个元素含有层叠上下文的话，那么这个元素就会在这个垂直线上比其它元素“高人一等”。</li>
<li>层叠水平(stacking level)决定了同一个层叠上下文中元素在z轴上的显示顺序。所有的元素都有层叠水平，包括层叠上下文元素，普通元素的层叠水平优先由层叠上下文决定。注意不要把层叠水平和z-index属性混为一谈，z-index确实可以影响层叠水平，但是，只限于定位元素以及flex盒子的孩子元素；而层叠水平所有的元素都存在。</li>
<li>层叠顺序(stacking order)表示元素发生层叠时特定的垂直显示顺序。</li>
</ol>
<p>层叠上下文</p>
<p>网页上的元素其实是三维的，类似于高中学的左手坐标系，Z轴就是垂直于屏幕。层叠上下文跟“块状格式化上下文”（BFC）类似，只要元素拥有某些特定的css属性，就会表现出层叠上下文的特点。</p>
<p>层叠准则</p>
<p>(1) 谁大谁上：如生效的z-index属性值，大的就覆盖小的。</p>
<p>(2)后来居上：当元素的层叠顺序一致的时候，比较后面的元素就会覆盖前面的元素。</p>
<p>层叠上下文创建</p>
<p>普通元素可以添加overflow：hidden；使他成为BFC元素。而层叠上下文也可以添加某些css属性变成的。</p>
<ol>
<li>文档根元素（<html>）；</html></li>
<li>position 值为 absolute（绝对定位）或 relative（相对定位）且 z-index 值不为 auto 的元素；</li>
<li>position 值为 fixed（固定定位）或 sticky（粘滞定位）的元素（沾滞定位适配所有移动设备上的浏览器，但老的桌面浏览器不支持）；</li>
<li>flex (flexbox) 容器的子元素，且 z-index 值不为 auto；</li>
<li>grid (grid) 容器的子元素，且 z-index 值不为 auto；</li>
<li>opacity 属性值小于 1 的元素</li>
<li>mix-blend-mode 属性值不为 normal 的元素；</li>
<li>以下任意属性值不为 none 的元素：</li>
<li>transform</li>
<li>filter</li>
<li>perspective</li>
<li>clip-path</li>
<li> mask / mask-image / mask-border</li>
<li>isolation 属性值为 isolate 的元素；</li>
<li>-webkit-overflow-scrolling 属性值为 touch 的元素；</li>
<li>will-change 值设定了任一属性而该属性在 non-initial 值时会创建层叠上下文的元素</li>
<li>contain 属性值为 layout、paint 或包含它们其中之一的合成值（比如 contain: strict、contain: content）的元素。</li>
</ol>
<p>元素的层叠顺序？</p>
<p>层叠顺序</p>
<ol>
<li>background</li>
<li>border</li>
<li>块级</li>
<li>浮动</li>
<li>内联</li>
<li>z-index: 0</li>
<li>z-index: +</li>
</ol>
<p>综述：</p>
<ol>
<li><p>子元素在父元素之上。</p>
</li>
<li><p>Relative、absolute、fixed元素在static元素之上。</p>
</li>
<li><p>同级的元素z-index值高的元素在上。</p>
</li>
<li><p>后定义的元素在先定义的元素之上。</p>
</li>
<li><p>若父元素设定了z-index属性，则子元素受限于父元素的层叠位置；若没有，则子元素被当作与元素同等级的元素。</p>
</li>
</ol>
<p>总结</p>
<ol>
<li>在层叠上下文中，子元素也会发生层叠上下文，但是子元素的z-index的值只在其父元素内起作用。</li>
<li>在同一个层叠上下文中，层叠水平值大的那一个覆盖小的那一个。</li>
<li>当元素的层叠顺序和层叠水平一样时，后出现的元素会覆盖前面的元素。</li>
</ol>
<h2 id="clip-裁剪是什么？"><a href="#clip-裁剪是什么？" class="headerlink" title="clip 裁剪是什么？"></a>clip 裁剪是什么？</h2><p>所谓“可访问性隐藏”，指的是虽然内容肉眼看不见，但是其他辅助设备却能够进行识别和访问的隐藏。</p>
<p>clip剪裁被我称为“最佳可访问性隐藏”的另外一个原因就是，它具有更强的普遍适应性，任何元素、任何场景都可以无障碍使用。</p>
<h2 id="overflow与absolute的关系"><a href="#overflow与absolute的关系" class="headerlink" title="overflow与absolute的关系"></a>overflow与absolute的关系</h2><p>（1）如果overflow不是定位元素，同时绝对定位元素和overflow容器之间也没有定位元素，则overflow无法对absolute<br>元素进行剪裁。</p>
<p>（2）如果overflow的属性值不是hidden而是auto或者scroll，即使绝对定位元素高宽比overflow元素高宽还要大，也<br>都不会出现滚动条。</p>
<p>（3）overflow元素自身transform的时候，Chrome和Opera浏览器下的overflow剪裁是无效的。</p>
<h2 id="无依赖绝对定位的应用"><a href="#无依赖绝对定位的应用" class="headerlink" title="无依赖绝对定位的应用"></a>无依赖绝对定位的应用</h2><p>含义：<br>当绝对定位元素不使用top/right/bottom/left中任何一个属性时，或者上述四个偏移量都使用auto取值时，该绝对定位元素不受其参照物的限制，又可以称为无依赖的绝对定位元素。<br>特点：</p>
<ol>
<li>是一个无宽、高的浮动元素，因此会尽可能向上浮动</li>
<li>位置跟随性，即原来是block水平元素的换行显示行为，在绝对定位以后仍是换行显示，即原来在某个块级元素（普通文档流）之上或者之下，绝对定位以后依然在该元素的上方或者下方；原来是inline或者inline-block水平元素的同行显示行为在绝对定位以后仍是同行显示，也就是如果原来是跟在某个行内元素（普通文档流）后面或者前面，在无依赖绝对定位以后依然在该元素后面或者前面。</li>
<li>对于含有无依赖absolute元素的父级元素DOM结构的布局行为：首先确定当前的普通文档流DOM结构：将普通文档流中的元素按照在DOM结构中的先后顺序进行摆放，确定当前的布局。接着判断无依赖absolute元素，按照DOM结构以此判断，如果多个绝对定位元素相互遮挡，那么按照七层层叠顺序+后来居上+大者居上的准则判断。<br>应用：<br>应用主要是与margin结合、与text-align结合。注意：绝对定位元素无论是否设置偏移量，都可以使用margin。具体包括：</li>
</ol>
<p>图片的图标定位：左上角定位和右上角定位，可延伸到非图片的左上角、右上角定位</p>
<ol>
<li>下拉框：最佳实践</li>
<li>星号和文字的对齐</li>
<li>小图标和文字的对齐：这个图片可以是img，也可以是只含背景图片的空标签</li>
<li>文字溢出的处理</li>
<li>对齐或者居中：与text-align结合</li>
</ol>
<h2 id="overflow-的特殊性？"><a href="#overflow-的特殊性？" class="headerlink" title="overflow 的特殊性？"></a>overflow 的特殊性？</h2><p>（1）一个设置了overflow:hidden声明的元素，假设同时存在border属性和padding属性，则当子元素内容超出容器宽度<br>高度限制的时候，剪裁的边界是border box的内边缘，而非padding box的内边缘。</p>
<p>（2）HTML中有两个标签是默认可以产生滚动条的，一个是根元素html，另一个是文本域textarea。</p>
<p>（3）滚动条会占用容器的可用宽度或高度。</p>
<p>（4）元素设置了overflow:hidden声明，里面内容高度溢出的时候，滚动依然存在，仅仅滚动条不存在！</p>
<h2 id="vertical-align-的特殊性？"><a href="#vertical-align-的特殊性？" class="headerlink" title="vertical-align 的特殊性？"></a>vertical-align 的特殊性？</h2><p>（1）vertical-align的默认值是baseline，即基线对齐，而基线的定义是字母x的下边缘。因此，内联元素默认都是沿着字<br>母x的下边缘对齐的。对于图片等替换元素，往往使用元素本身的下边缘作为基线。：一个inline-block元素，如果里面<br>没有内联元素，或者overflow不是visible，则该元素的基线就是其margin底边缘；否则其基线就是元素里面最后一行<br>内联元素的基线。</p>
<p>（2）vertical-align:top就是垂直上边缘对齐，如果是内联元素，则和这一行位置最高的内联元素的顶部对齐；如果display<br>计算值是table-cell的元素，我们不妨脑补成<td>元素，则和</td><tr>元素上边缘对齐。</tr></p>
<p>（3）vertical-align:middle是中间对齐，对于内联元素，元素的垂直中心点和行框盒子基线往上1/2x-height处对齐。对<br>于table-cell元素，单元格填充盒子相对于外面的表格行居中对齐。</p>
<p>（4）vertical-align支持数值属性，根据数值的不同，相对于基线往上或往下偏移，如果是负值，往下偏移，如果是正值，往上<br>偏移。</p>
<p>（5）vertical-align属性的百分比值则是相对于line-height的计算值计算的。</p>
<p>（6）vertical-align起作用是有前提条件的，这个前提条件就是：只能应用于内联元素以及display值为table-cell的元<br>素。</p>
<p>（7）table-cell元素设置vertical-align垂直对齐的是子元素，但是其作用的并不是子元素，而是table-cell元素自身。</p>
<h2 id="line-height-的特殊性？"><a href="#line-height-的特殊性？" class="headerlink" title="line-height 的特殊性？"></a>line-height 的特殊性？</h2><p>（1）对于非替换元素的纯内联元素，其可视高度完全由line-height决定。对于文本这样的纯内联元素，line-height就是高<br>度计算的基石，用专业说法就是指定了用来计算行框盒子高度的基础高度。</p>
<p>（2）内联元素的高度由固定高度和不固定高度组成，这个不固定的部分就是这里的“行距”。换句话说，line-height之所以起作<br>用，就是通过改变“行距”来实现的。在CSS中，“行距”分散在当前文字的上方和下方，也就是即使是第一行文字，其上方也是<br>有“行距”的，只不过这个“行距”的高度仅仅是完整“行距”高度的一半，因此，也被称为“半行距”。</p>
<p>（3）行距=line-height-font-size。</p>
<p>（4）border以及line-height等传统CSS属性并没有小数像素的概念。如果标注的是文字上边距，则向下取整；如果是文字下<br>边距，则向上取整。</p>
<p>（5）对于纯文本元素，line-height直接决定了最终的高度。但是，如果同时有替换元素，则line-height只能决定最小高度。</p>
<p>（6）对于块级元素，line-height对其本身是没有任何作用的，我们平时改变line-height，块级元素的高度跟着变化实际上是<br>通过改变块级元素里面内联级别元素占据的高度实现的。</p>
<p>（7）line-height的默认值是normal，还支持数值、百分比值以及长度值。为数值类型时，其最终的计算值是和当前font-si<br>ze相乘后的值。为百分比值时，其最终的计算值是和当前font-size相乘后的值。为长度值时原意不变。</p>
<p>（8）如果使用数值作为line-height的属性值，那么所有的子元素继承的都是这个值；但是，如果使用百分比值或者长度值作为<br>属性值，那么所有的子元素继承的是最终的计算值。</p>
<p>（9）无论内联元素line-height如何设置，最终父级元素的高度都是由数值大的那个line-height决定的。</p>
<p>（10）只要有“内联盒子”在，就一定会有“行框盒子”，就是每一行内联元素外面包裹的一层看不见的盒子。然后，重点来了，在每个<br>“行框盒子”前面有一个宽度为0的具有该元素的字体和行高属性的看不见的“幽灵空白节点”。</p>
<h2 id="什么是基线和-x-height？"><a href="#什么是基线和-x-height？" class="headerlink" title="什么是基线和 x-height？"></a>什么是基线和 x-height？</h2><p>字母x的下边缘（线）就是我们的基线。</p>
<p>x-height指的就是小写字母x的高度，术语描述就是基线和等分线（meanline）（也称作中线，midline）之间的距离。在C<br>SS世界中，middle指的是基线往上1/2x-height高度。我们可以近似理解为字母x交叉点那个位置。</p>
<p>ex是CSS中的一个相对单位，指的是小写字母x的高度，没错，就是指x-height。ex的价值就在其副业上不受字体和字号影<br>响的内联元素的垂直居中对齐效果。内联元素默认是基线对齐的，而基线就是x的底部，而1ex就是一个x的高度。</p>
<h2 id="border-的特殊性？"><a href="#border-的特殊性？" class="headerlink" title="border 的特殊性？"></a>border 的特殊性？</h2><p>（1）border-width却不支持百分比。</p>
<p>（2）border-style的默认值是none，有一部分人可能会误以为是solid。这也是单纯设置border-width或border-col<br>or没有边框显示的原因。</p>
<p>（3）border-style:double的表现规则：双线宽度永远相等，中间间隔±1。</p>
<p>（4）border-color默认颜色就是color色值。</p>
<p>（5）默认background背景图片是相对于padding box定位的。</p>
<h2 id="margin-无效的情形"><a href="#margin-无效的情形" class="headerlink" title="margin 无效的情形"></a>margin 无效的情形</h2><p>（1）display计算值inline的非替换元素的垂直margin是无效的。对于内联替换元素，垂直margin有效，并且没有ma<br>rgin合并的问题。</p>
<p>（2）表格中的tr和td元素或者设置display计算值是table-cell或table-row的元素的margin都是无效的。</p>
<p>（3）绝对定位元素非定位方位的margin值“无效”。</p>
<p>（4）定高容器的子元素的margin-bottom或者宽度定死的子元素的margin-right的定位“失效”。</p>
<h2 id="margin-auto-的填充规则？"><a href="#margin-auto-的填充规则？" class="headerlink" title="margin:auto 的填充规则？"></a>margin:auto 的填充规则？</h2><p>margin的’auto’可不是摆设，是具有强烈的计算意味的关键字，用来计算元素对应方向应该获得的剩余间距大小。但是触发mar<br>gin:auto计算有一个前提条件，就是width或height为auto时，元素是具有对应方向的自动填充特性的。</p>
<p>（1）如果一侧定值，一侧auto，则auto为剩余空间大小。<br>（2）如果两侧均是auto，则平分剩余空间。</p>
<h2 id="content-与替换元素的关系？"><a href="#content-与替换元素的关系？" class="headerlink" title="content 与替换元素的关系？"></a>content 与替换元素的关系？</h2><p>content属性生成的对象称为“匿名替换元素”。</p>
<p>（1）我们使用content生成的文本是无法选中、无法复制的，好像设置了user select:none声明一般，但是普通元素的文本<br>却可以被轻松选中。同时，content生成的文本无法被屏幕阅读设备读取，也无法被搜索引擎抓取，因此，千万不要自以为是<br>地把重要的文本信息使用content属性生成，因为这对可访问性和SEO都很不友好。</p>
<p>（2）content生成的内容不能左右:empty伪类。</p>
<p>（3）content动态生成值无法获取。</p>
<h2 id="替换元素的计算规则？"><a href="#替换元素的计算规则？" class="headerlink" title="替换元素的计算规则？"></a>替换元素的计算规则？</h2><p>替换元素的尺寸从内而外分为3类：固有尺寸、HTML尺寸和CSS尺寸。</p>
<p>（1）固有尺寸指的是替换内容原本的尺寸。例如，图片、视频作为一个独立文件存在的时候，都是有着自己的宽度和高度的。</p>
<p>（2）HTML尺寸只能通过HTML原生属性改变，这些HTML原生属性包括img的width和height属性、input的size属性、textarea的cols和rows属性等。</p>
<p>（3）CSS尺寸特指可以通过CSS的width和height或者max-width/min-width和max-height/min-height设置的<br>尺寸，对应盒尺寸中的content box。</p>
<p>这3层结构的计算规则具体如下</p>
<p>（1）如果没有CSS尺寸和HTML尺寸，则使用固有尺寸作为最终的宽高。</p>
<p>（2）如果没有CSS尺寸，则使用HTML尺寸作为最终的宽高。</p>
<p>（3）如果有CSS尺寸，则最终尺寸由CSS属性决定。</p>
<p>（4）如果“固有尺寸”含有固有的宽高比例，同时仅设置了宽度或仅设置了高度，则元素依然按照固有的宽高比例显示。</p>
<p>（5）如果上面的条件都不符合，则最终宽度表现为300像素，高度为150像素。</p>
<p>（6）内联替换元素和块级替换元素使用上面同一套尺寸计算规则。</p>
<h2 id="什么是替换元素？"><a href="#什么是替换元素？" class="headerlink" title="什么是替换元素？"></a>什么是替换元素？</h2><p>通过修改某个属性值呈现的内容就可以被替换的元素就称为“替换元素”。因此，img、object、video、iframe或者表<br>单元素textarea和input和select都是典型的替换元素。</p>
<p>替换元素除了内容可替换这一特性以外，还有以下一些特性。</p>
<p>（1）内容的外观不受页面上的CSS的影响。用专业的话讲就是在样式表现在CSS作用域之外。如何更改替换元素本身的外观需要<br>类似appearance属性，或者浏览器自身暴露的一些样式接口，</p>
<p>（2）有自己的尺寸。在Web中，很多替换元素在没有明确尺寸设定的情况下，其默认的尺寸（不包括边框）是300像素×150像<br>素，如video、iframe或者canvas等，也有少部分替换元素为0像素，如img图片，而表单元素的替换元素<br>的尺寸则和浏览器有关，没有明显的规律。</p>
<p>（3）在很多CSS属性上有自己的一套表现规则。比较具有代表性的就是vertical-align属性，对于替换元素和非替换元素，ve<br>rtical-align属性值的解释是不一样的。比方说vertical-align的默认值的baseline，很简单的属性值，基线之意，<br>被定义为字符x的下边缘，而替换元素的基线却被硬生生定义成了元素的下边缘。</p>
<p>（4）所有的替换元素都是内联水平元素，也就是替换元素和替换元素、替换元素和文字都是可以在一行显示的。但是，替换元素默认<br>的display值却是不一样的，有的是inline，有的是inline-block。</p>
<h2 id="什么是幽灵空白节点？"><a href="#什么是幽灵空白节点？" class="headerlink" title="什么是幽灵空白节点？"></a>什么是幽灵空白节点？</h2><p>“幽灵空白节点”是内联盒模型中非常重要的一个概念，具体指的是：在HTML5文档声明中，内联元素的所有解析和渲染表现就如同<br>每个行框盒子的前面有一个“空白节点”一样。这个“空白节点”永远透明，不占据任何宽度，看不见也无法通过脚本获取，就好像幽灵<br>一样，但又确确实实地存在，表现如同文本节点一样，因此，我称之为“幽灵空白节点”。</p>
<h2 id="内联盒模型基本概念"><a href="#内联盒模型基本概念" class="headerlink" title="内联盒模型基本概念"></a>内联盒模型基本概念</h2><p>（1）内容区域（content area）。内容区域指一种围绕文字看不见的盒子，其大小仅受字符本身特性控制，本质上是一个字符盒子<br>（character box）；但是有些元素，如图片这样的替换元素，其内容显然不是文字，不存在字符盒子之类的，因此，对于这些<br>元素，内容区域可以看成元素自身。</p>
<p>（2）内联盒子（inline box）。“内联盒子”不会让内容成块显示，而是排成一行，这里的“内联盒子”实际指的就是元素的“外在盒<br>子”，用来决定元素是内联还是块级。该盒子又可以细分为“内联盒子”和“匿名内联盒子”两类。</p>
<p>（3）行框盒子（line box），每一行就是一个“行框盒子”（实线框标注），每个“行框盒子”又是由一个一个“内联盒子”组成的。</p>
<p>（4）包含块（containing box），由一行一行的“行框盒子”组成。</p>
<h2 id="min-width-max-width-和-min-height-max-height-属性间的覆盖规则？"><a href="#min-width-max-width-和-min-height-max-height-属性间的覆盖规则？" class="headerlink" title="min-width/max-width 和 min-height/max-height 属性间的覆盖规则？"></a>min-width/max-width 和 min-height/max-height 属性间的覆盖规则？</h2><p>（1）max-width会覆盖width，即使width是行类样式或者设置了!important。</p>
<p>（2）min-width会覆盖max-width，此规则发生在min-width和max-width冲突的时候。</p>
<h2 id="为什么-height-100-会无效？"><a href="#为什么-height-100-会无效？" class="headerlink" title="为什么 height:100%会无效？"></a>为什么 height:100%会无效？</h2><p>对于普通文档流中的元素，百分比高度值要想起作用，其父级必须有一个可以生效的高度值。</p>
<p>原因是如果包含块的高度没有显式指定（即高度由内容决定），并且该元素不是绝对定位，则计算值为auto，因为解释成了auto，<br>所以无法参与计算。</p>
<p>使用绝对定位的元素会有计算值，即使祖先元素的height计算为auto也是如此。</p>
<h2 id="什么是首选最小宽度？"><a href="#什么是首选最小宽度？" class="headerlink" title="什么是首选最小宽度？"></a>什么是首选最小宽度？</h2><p>“首选最小宽度”，指的是元素最适合的最小宽度。</p>
<p>东亚文字（如中文）最小宽度为每个汉字的宽度。</p>
<p>西方文字最小宽度由特定的连续的英文字符单元决定。并不是所有的英文字符都会组成连续单元，一般会终止于空格（普通空格）、短<br>横线、问号以及其他非英文字符等。</p>
<p>如果想让英文字符和中文一样，每一个字符都用最小宽度单元，可以试试使用CSS中的word-break:break-all。</p>
<h2 id="transition-和-animation-的区别"><a href="#transition-和-animation-的区别" class="headerlink" title="transition 和 animation 的区别"></a>transition 和 animation 的区别</h2><p>transition关注的是CSS property的变化，property值和时间的关系是一个三次贝塞尔曲线。</p>
<p>animation作用于元素本身而不是样式属性，可以使用关键帧的概念，应该说可以实现更自由的动画效果。</p>
<h2 id="画一条-0-5px-的线"><a href="#画一条-0-5px-的线" class="headerlink" title="画一条 0.5px 的线"></a>画一条 0.5px 的线</h2><p>采用meta viewport的方式<br>meta name=”viewport” content=”width=device-width,initial-sacle=0.5”<br>采用border-image的方式</p>
<p>采用transform:scale()的方式<br>transform: scaleY(0.5);<br>transform-origin: 50% 100%;</p>
<h2 id="几种常见的CSS布局"><a href="#几种常见的CSS布局" class="headerlink" title="几种常见的CSS布局"></a>几种常见的CSS布局</h2><p>[<a href="https://juejin.cn/post/6844903710070407182#heading-12]">https://juejin.cn/post/6844903710070407182#heading-12]</a></p>
<h2 id="使用-rem-布局的优缺点？"><a href="#使用-rem-布局的优缺点？" class="headerlink" title="使用 rem 布局的优缺点？"></a>使用 rem 布局的优缺点？</h2><p>优点：<br>在屏幕分辨率千差万别的时代，只要将rem与屏幕分辨率关联起来就可以实现页面的整体缩放，使得在设备上的展现都统一起来了。<br>而且现在浏览器基本都已经支持rem了，兼容性也非常的好。</p>
<p>缺点：<br>（1）在奇葩的dpr设备上表现效果不太好，比如一些华为的高端机型用rem布局会出现错乱。<br>（2）使用iframe引用也会出现问题。<br>（3）rem在多屏幕尺寸适配上与当前两大平台的设计哲学不一致。即大屏的出现到底是为了看得又大又清楚，还是为了看的更多的问<br>题。</p>
<h2 id="阐述一下-CSSSprites"><a href="#阐述一下-CSSSprites" class="headerlink" title="阐述一下 CSSSprites"></a>阐述一下 CSSSprites</h2><p>将一个页面涉及到的所有图片都包含到一张大图中去，然后利用CSS的background-image，background-repeat，background<br>-position的组合进行背景定位。利用CSSSprites能很好地减少网页的http请求，从而很好的提高页面的性能；CSSSprites<br>能减少图片的字节。</p>
<p>优点：</p>
<p>减少HTTP请求数，极大地提高页面加载速度<br>增加图片信息重复度，提高压缩比，减少图片大小<br>解决了网页设计师在图片命名上的困扰<br>更换风格方便，只需在一张或几张图片上修改颜色或样式即可实现</p>
<p>缺点：</p>
<p>图片合并麻烦<br>图片合并时需预留好足够空间，宽屏、高分辨率的屏幕下易出现背景断裂<br>开发较麻烦，测量繁琐；<br>维护麻烦，修改一个图片可能需要重新布局整个图片，样式</p>
<h2 id="什么是-CSS-预处理器-后处理器？为什么要使用它们？"><a href="#什么是-CSS-预处理器-后处理器？为什么要使用它们？" class="headerlink" title="什么是 CSS 预处理器/后处理器？为什么要使用它们？"></a>什么是 CSS 预处理器/后处理器？为什么要使用它们？</h2><p>CSS预处理器定义了一种新的语言，其基本思想是，用一种专门的编程语言，为CSS增加了一些编程的特性，将CSS作为目标生成<br>文件，然后开发者就只要使用这种语言进行编码工作。通俗的说，CSS预处理器用一种专门的编程语言，进行Web页面样式设计，然<br>后再编译成正常的CSS文件。</p>
<p>预处理器例如：LESS、Sass、Stylus，用来预编译Sass或less csssprite，增强了css代码的复用性，还有层级、mixin、<br>变量、循环、函数等，具有很方便的UI组件模块化开发能力，极大的提高工作效率。</p>
<p>CSS后处理器是对CSS进行处理，并最终生成CSS的预处理器，它属于广义上的CSS预处理器。我们很久以前就在用CSS后<br>处理器了，最典型的例子是CSS压缩工具（如clean-css），只不过以前没单独拿出来说过。还有最近比较火的Autoprefixer，<br>以CanIUse上的浏览器支持数据为基础，自动处理兼容性问题。</p>
<p>后处理器例如：PostCSS，通常被视为在完成的样式表中根据CSS规范处理CSS，让其更有效；目前最常做的是给CSS属性添加浏<br>览器私有前缀，实现跨浏览器兼容性的问题。</p>
<p>为什么要使用它们？<br>结构清晰，便于扩展。<br>可以方便地屏蔽浏览器私有语法差异。这个不用多说，封装对浏览器语法差异的重复处理，减少无意义的机械劳动。<br>可以轻松实现多重继承。<br>完全兼容 CSS 代码，可以方便地应用到老项目中。LESS 只是在 CSS 语法上做了扩展，所以老的 CSS 代码也可以与 LESS 代码一同编译。</p>
<h2 id="style-标签写在-body-后与-body-前有什么区别？"><a href="#style-标签写在-body-后与-body-前有什么区别？" class="headerlink" title="style 标签写在 body 后与 body 前有什么区别？"></a>style 标签写在 body 后与 body 前有什么区别？</h2><p>页面加载自上而下当然是先加载样式。写在body标签后由于浏览器以逐行方式对HTML文档进行解析，当解析到写在尾部的样式<br>表（外联或写在style标签）会导致浏览器停止之前的渲染，等待加载且解析样式表完成之后重新渲染，在windows的IE下可<br>能会出现FOUC现象（即样式失效导致的页面闪烁问题）</p>
<h2 id="什么是-Cookie-隔离？（或者说：请求资源的时候不要让它带-cookie-怎么做）"><a href="#什么是-Cookie-隔离？（或者说：请求资源的时候不要让它带-cookie-怎么做）" class="headerlink" title="什么是 Cookie 隔离？（或者说：请求资源的时候不要让它带 cookie 怎么做）"></a>什么是 Cookie 隔离？（或者说：请求资源的时候不要让它带 cookie 怎么做）</h2><p>网站向服务器请求的时候，会自动带上cookie这样增加表头信息量，使请求变慢。</p>
<p>如果静态文件都放在主域名下，那静态文件请求的时候都带有的cookie的数据提交给server的，非常浪费流量，所以不如隔离开<br>，静态资源放CDN。</p>
<p>因为cookie有域的限制，因此不能跨域提交请求，故使用非主要域名的时候，请求头中就不会带有cookie数据，这样可以降低请<br>求头的大小，降低请求时间，从而达到降低整体请求延时的目的。</p>
<p>同时这种方式不会将cookie传入WebServer，也减少了WebServer对cookie的处理分析环节，提高了webserver的<br>http请求的解析速度。</p>
<h2 id="浏览器如何判断是否支持-webp-格式图片"><a href="#浏览器如何判断是否支持-webp-格式图片" class="headerlink" title="浏览器如何判断是否支持 webp 格式图片"></a>浏览器如何判断是否支持 webp 格式图片</h2><p>（1）宽高判断法。通过创建image对象，将其src属性设置为webp格式的图片，然后在onload事件中获取图片的宽高，如<br>果能够获取，则说明浏览器支持webp格式图片。如果不能获取或者触发了onerror函数，那么就说明浏览器不支持webp格<br>式的图片。</p>
<p>（2）canvas判断方法。我们可以动态的创建一个canvas对象，通过canvas的toDataURL将设置为webp格式，然后判断<br>返回值中是否含有image/webp字段，如果包含则说明支持WebP，反之则不支持。</p>
<h2 id="png、jpg、gif-这些图片格式解释一下，分别什么时候用。有没有了解过-webp？"><a href="#png、jpg、gif-这些图片格式解释一下，分别什么时候用。有没有了解过-webp？" class="headerlink" title="png、jpg、gif 这些图片格式解释一下，分别什么时候用。有没有了解过 webp？"></a>png、jpg、gif 这些图片格式解释一下，分别什么时候用。有没有了解过 webp？</h2><p>我了解到的一共有七种常见的图片的格式。</p>
<p>（1）第一种是BMP格式，它是无损压缩的，支持索引色和直接色的点阵图。由于它基本上没有进行压缩，因此它的文件体积一般比<br>较大。</p>
<p>（2）第二种是GIF格式，它是无损压缩的使用索引色的点阵图。由于使用了LZW压缩方法，因此文件的体积很小。并且GIF还<br>支持动画和透明度。但因为它使用的是索引色，所以它适用于一些对颜色要求不高且需要文件体积小的场景。</p>
<p>（3）第三种是JPEG格式，它是有损压缩的使用直接色的点阵图。由于使用了直接色，色彩较为丰富，一般适用于来存储照片。但<br>由于使用的是直接色，可能文件的体积相对于GIF格式来说更大。</p>
<p>（4）第四种是PNG-8格式，它是无损压缩的使用索引色的点阵图。它是GIF的一种很好的替代格式，它也支持透明度的调整，并<br>且文件的体积相对于GIF格式更小。一般来说如果不是需要动画的情况，我们都可以使用PNG-8格式代替GIF格式。</p>
<p>（5）第五种是PNG-24格式，它是无损压缩的使用直接色的点阵图。PNG-24的优点是它使用了压缩算法，所以它的体积比BMP<br>格式的文件要小得多，但是相对于其他的几种格式，还是要大一些。</p>
<p>（6）第六种格式是svg格式，它是矢量图，它记录的图片的绘制方式，因此对矢量图进行放大和缩小不会产生锯齿和失真。它一般<br>适合于用来制作一些网站logo或者图标之类的图片。</p>
<p>（7）第七种格式是webp格式，它是支持有损和无损两种压缩方式的使用直接色的点阵图。使用webp格式的最大的优点是，在相<br>同质量的文件下，它拥有更小的文件体积。因此它非常适合于网络图片的传输，因为图片体积的减少，意味着请求时间的减小，<br>这样会提高用户的体验。这是谷歌开发的一种新的图片格式，目前在兼容性上还不是太好。</p>
<h2 id="overflow-scroll-时不能平滑滚动的问题怎么处理？"><a href="#overflow-scroll-时不能平滑滚动的问题怎么处理？" class="headerlink" title="overflow:scroll 时不能平滑滚动的问题怎么处理？"></a>overflow:scroll 时不能平滑滚动的问题怎么处理？</h2><p>以下代码可解决这种卡顿的问题：-webkit-overflow-scrolling:touch;是因为这行代码启用了硬件加速特性，所以滑动很流<br>畅。</p>
<h2 id="如何让去除-inline-block-元素间间距？"><a href="#如何让去除-inline-block-元素间间距？" class="headerlink" title="如何让去除 inline-block 元素间间距？"></a>如何让去除 inline-block 元素间间距？</h2><p>移除空格、使用margin负值、使用font-size:0、letter-spacing、word-spacing</p>
<h2 id="如果需要手动写动画，你认为最小时间间隔是多久，为什么？-1"><a href="#如果需要手动写动画，你认为最小时间间隔是多久，为什么？-1" class="headerlink" title="如果需要手动写动画，你认为最小时间间隔是多久，为什么？"></a>如果需要手动写动画，你认为最小时间间隔是多久，为什么？</h2><p>多数显示器默认频率是60Hz，即1秒刷新60次，所以理论上最小间隔为1/60*1000ms＝16.7ms</p>
<h2 id="position-fixed-在-android-下无效怎么处理？"><a href="#position-fixed-在-android-下无效怎么处理？" class="headerlink" title="position:fixed;在 android 下无效怎么处理？"></a>position:fixed;在 android 下无效怎么处理？</h2><p>因为移动端浏览器默认的viewport叫做layout viewport。在移动端显示时，因为layout viewport的宽度大于移动端屏幕<br>的宽度，所以页面会出现滚动条左右移动，fixed的元素是相对layout viewport来固定位置的，而不是移动端屏幕来固定位置的<br>，所以会出现感觉fixed无效的情况。</p>
<p>如果想实现fixed相对于屏幕的固定效果，我们需要改变的是viewport的大小为ideal viewport，可以如下设置：</p>
<p>metaname=”viewport”content=”width=device-width,initial-scale=1.0,maximum-scale=1.0,minimum-sca<br>le=1.0,user-scalable=no”</p>
<h2 id="layout-viewport、visual-viewport-和-ideal-viewport-的区别？"><a href="#layout-viewport、visual-viewport-和-ideal-viewport-的区别？" class="headerlink" title="layout viewport、visual viewport 和 ideal viewport 的区别？"></a>layout viewport、visual viewport 和 ideal viewport 的区别？</h2><p>移动端一共需要理解三个viewport的概念的理解。</p>
<p>第一个视口是布局视口，在移动端显示网页时，由于移动端的屏幕尺寸比较小，如果网页使用移动端的屏幕尺寸进行布局的话，那么整<br>个页面的布局都会显示错乱。所以移动端浏览器提供了一个layout viewport布局视口的概念，使用这个视口来对页面进行布局展<br>示，一般layout viewport的大小为980px，因此页面布局不会有太大的变化，我们可以通过拖动和缩放来查看到这个页面。</p>
<p>第二个视口指的是视觉视口，visual viewport指的是移动设备上我们可见的区域的视口大小，一般为屏幕的分辨率的大小。visu<br>al viewport和layout viewport的关系，就像是我们通过窗户看外面的风景，视觉视口就是窗户，而外面的风景就是布局视口<br>中的网页内容。</p>
<p>第三个视口是理想视口，由于layout viewport一般比visual viewport要大，所以想要看到整个页面必须通过拖动和缩放才<br>能实现。所以又提出了ideal viewport的概念，ideal viewport下用户不用缩放和滚动条就能够查看到整个页面，并且页面在<br>不同分辨率下显示的内容大小相同。ideal viewport其实就是通过修改layout viewport的大小，让它等于设备的宽度，这个<br>宽度可以理解为是设备独立像素，因此根据ideal viewport设计的页面，在不同分辨率的屏幕下，显示应该相同。</p>
<h2 id="设备像素、css-像素、设备独立像素、dpr、ppi-之间的区别？"><a href="#设备像素、css-像素、设备独立像素、dpr、ppi-之间的区别？" class="headerlink" title="设备像素、css 像素、设备独立像素、dpr、ppi 之间的区别？"></a>设备像素、css 像素、设备独立像素、dpr、ppi 之间的区别？</h2><p>设备像素指的是物理像素，一般手机的分辨率指的就是设备像素，一个设备的设备像素是不可变的。</p>
<p>css像素和设备独立像素是等价的，不管在何种分辨率的设备上，css像素的大小应该是一致的，css像素是一个相对单位，它是相<br>对于设备像素的，一个css像素的大小取决于页面缩放程度和dpr的大小。</p>
<p>dpr指的是设备像素和设备独立像素的比值，一般的pc屏幕，dpr=1。在iphone4时，苹果推出了retina屏幕，它的dpr<br>为2。屏幕的缩放会改变dpr的值。</p>
<p>ppi指的是每英寸的物理像素的密度，ppi越大，屏幕的分辨率越大。</p>
<h2 id="font-style-属性中-italic-和-oblique-的区别？"><a href="#font-style-属性中-italic-和-oblique-的区别？" class="headerlink" title="font-style 属性中 italic 和 oblique 的区别？"></a>font-style 属性中 italic 和 oblique 的区别？</h2><p>italic和oblique这两个关键字都表示“斜体”的意思。</p>
<p>它们的区别在于，italic是使用当前字体的斜体字体，而oblique只是单纯地让文字倾斜。如果当前字体没有对应的斜体字体，<br>则退而求其次，解析为oblique，也就是单纯形状倾斜。</p>
<h2 id="如何修改-chrome-记住密码后自动填充表单的黄色背景？"><a href="#如何修改-chrome-记住密码后自动填充表单的黄色背景？" class="headerlink" title="如何修改 chrome 记住密码后自动填充表单的黄色背景？"></a>如何修改 chrome 记住密码后自动填充表单的黄色背景？</h2><p>chrome表单自动填充后，input文本框的背景会变成黄色的，通过审查元素可以看到这是由于chrome会默认给自动填充的in<br>put表单加上input:-webkit-autofill私有属性，然后对其赋予以下样式：</p>
<p>{<br>background-color:rgb(250,255,189)!important;<br>background-image:none!important;<br>color:rgb(0,0,0)!important;<br>}</p>
<p>对chrome默认定义的background-color，background-image，color使用important是不能提高其优先级的，但是<br>其他属性可使用。</p>
<p>使用足够大的纯色内阴影来覆盖input输入框的黄色背景，处理如下</p>
<p>input:-webkit-autofill,textarea:-webkit-autofill,select:-webkit-autofill{<br>-webkit-box-shadow:000px 1000px white inset;<br>border:1px solid #CCC !important;<br>}</p>
<h2 id="对于-hasLayout-的理解？"><a href="#对于-hasLayout-的理解？" class="headerlink" title="对于 hasLayout 的理解？"></a>对于 hasLayout 的理解？</h2><p>hasLayout是IE特有的一个属性。很多的IE下的css bug都与其息息相关。在IE中，一个元素要么自己对自身的内容进<br>行计算大小和组织，要么依赖于父元素来计算尺寸和组织内容。当一个元素的hasLayout属性值为true时，它负责对自己和可<br>能的子孙元素进行尺寸计算和定位。虽然这意味着这个元素需要花更多的代价来维护自身和里面的内容，而不是依赖于祖先元素来完<br>成这些工作。</p>
<h2 id="absolute-的-containingblock（包含块）计算方式跟正常流有什么不同？"><a href="#absolute-的-containingblock（包含块）计算方式跟正常流有什么不同？" class="headerlink" title="absolute 的 containingblock（包含块）计算方式跟正常流有什么不同？"></a>absolute 的 containingblock（包含块）计算方式跟正常流有什么不同？</h2><p>（1）内联元素也可以作为“包含块”所在的元素；</p>
<p>（2）“包含块”所在的元素不是父块级元素，而是最近的position不为static的祖先元素或根元素；</p>
<p>（3）边界是padding box而不是content box。</p>
<h2 id="为什么不建议使用统配符初始化-css-样式。"><a href="#为什么不建议使用统配符初始化-css-样式。" class="headerlink" title="为什么不建议使用统配符初始化 css 样式。"></a>为什么不建议使用统配符初始化 css 样式。</h2><p>采用*{padding:0;margin:0;}这样的写法好处是写起来很简单，但是是通配符，需要把所有的标签都遍历一遍，当网站较大时，<br>样式比较多，这样写就大大的加强了网站运行的负载，会使网站加载的时候需要很长一段时间，因此一般大型的网站都有分层次的一<br>套初始化样式。</p>
<p>出于性能的考虑，并不是所有标签都会有padding和margin，因此对常见的具有默认padding和margin的元素初始化即<br>可，并不需使用通配符*来初始化。</p>
<h2 id="简单说一下-css3-的-all-属性。"><a href="#简单说一下-css3-的-all-属性。" class="headerlink" title="简单说一下 css3 的 all 属性。"></a>简单说一下 css3 的 all 属性。</h2><p>all属性实际上是所有CSS属性的缩写，表示，所有的CSS属性都怎样怎样，但是，不包括unicode-bidi和direction<br>这两个CSS属性。支持三个CSS通用属性值，initial,inherit,unset。</p>
<p>initial是初始值的意思，也就是该元素元素都除了unicode-bidi和direction以外的CSS属性都使用属性的默认初始<br>值。</p>
<p>inherit是继承的意思，也就是该元素除了unicode-bidi和direction以外的CSS属性都继承父元素的属性值。</p>
<p>unset是取消设置的意思，也就是当前元素浏览器或用户设置的CSS忽略，然后如果是具有继承特性的CSS，如color，则<br>使用继承值；如果是没有继承特性的CSS属性，如background-color，则使用初始值。</p>
<h2 id="抽离样式模块怎么写，说出思路，有无实践经验？"><a href="#抽离样式模块怎么写，说出思路，有无实践经验？" class="headerlink" title="抽离样式模块怎么写，说出思路，有无实践经验？"></a>抽离样式模块怎么写，说出思路，有无实践经验？</h2><p>我的理解是把常用的css样式单独做成css文件……通用的和业务相关的分离出来，通用的做成样式模块儿共享，业务相关的，放<br>进业务相关的库里面做成对应功能的模块儿。</p>
<h2 id="zoom-1-的清除浮动原理"><a href="#zoom-1-的清除浮动原理" class="headerlink" title="zoom:1 的清除浮动原理?"></a>zoom:1 的清除浮动原理?</h2><p>清除浮动，触发hasLayout；<br>zoom属性是IE浏览器的专有属性，它可以设置或检索对象的缩放比例。解决ie下比较奇葩的bug。譬如外边距（margin）<br>的重叠，浮动清除，触发ie的haslayout属性等。</p>
<p>来龙去脉大概如下：<br>当设置了zoom的值之后，所设置的元素就会就会扩大或者缩小，高度宽度就会重新计算了，这里一旦改变zoom值时其实也会发<br>生重新渲染，运用这个原理，也就解决了ie下子元素浮动时候父元素不随着自动扩大的问题。</p>
<p>zoom属性是IE浏览器的专有属性，火狐和老版本的webkit核心的浏览器都不支持这个属性。然而，zoom现在已经被逐步标<br>准化，出现在CSS3.0规范草案中。</p>
<p>目前非ie由于不支持这个属性，它们又是通过什么属性来实现元素的缩放呢？可以通过css3里面的动画属性scale进行缩放。</p>
<h2 id="使用-clear-属性清除浮动的原理？"><a href="#使用-clear-属性清除浮动的原理？" class="headerlink" title="使用 clear 属性清除浮动的原理？"></a>使用 clear 属性清除浮动的原理？</h2><p>使用clear属性清除浮动，其语法如下：</p>
<p>clear:none|left|right|both</p>
<p>如果单看字面意思，clear:left应该是“清除左浮动”，clear:right应该是“清除右浮动”的意思，实际上，这种解释是有问<br>题的，因为浮动一直还在，并没有清除。</p>
<p>官方对clear属性的解释是：“元素盒子的边不能和前面的浮动元素相邻。”，我们对元素设置clear属性是为了避免浮动元素<br>对该元素的影响，而不是清除掉浮动。</p>
<p>还需要注意的一点是clear属性指的是元素盒子的边不能和前面的浮动元素相邻，注意这里“前面的”3个字，也就是clear属<br>性对“后面的”浮动元素是不闻不问的。考虑到float属性要么是left，要么是right，不可能同时存在，同时由于clear<br>属性对“后面的”浮动元素不闻不问，因此，当clear:left有效的时候，clear:right必定无效，也就是此时clear:left<br>等同于设置clear:both；同样地，clear:right如果有效也是等同于设置clear:both。由此可见，clear:left和cle<br>ar:right这两个声明就没有任何使用的价值，至少在CSS世界中是如此，直接使用clear:both吧。</p>
<p>一般使用伪元素的方式清除浮动</p>
<p>.clear::after{<br>content:’’;<br>display:table;//也可以是’block’，或者是’list-item’<br>clear:both;<br>}</p>
<p>clear属性只有块级元素才有效的，而::after等伪元素默认都是内联水平，这就是借助伪元素清除浮动影响时需要设置disp<br>lay属性值的原因。</p>
<h2 id="IFC-是什么？"><a href="#IFC-是什么？" class="headerlink" title="IFC 是什么？"></a>IFC 是什么？</h2><p>IFC指的是行级格式化上下文，它有这样的一些布局规则：</p>
<p>（1）行级上下文内部的盒子会在水平方向，一个接一个地放置。<br>（2）当一行不够的时候会自动切换到下一行。<br>（3）行级上下文的高度由内部最高的内联盒子的高度决定。</p>
<h2 id="margin-重叠问题的理解。"><a href="#margin-重叠问题的理解。" class="headerlink" title="margin 重叠问题的理解。"></a>margin 重叠问题的理解。</h2><p>块级元素的上外边距（margin-top）与下外边距（margin-bottom）有时会合并为单个外边距，这样的现象称为“margin合<br>并”。</p>
<p>产生折叠的必备条件：margin必须是邻接的!</p>
<p>而根据w3c规范，两个margin是邻接的必须满足以下条件：</p>
<p>•必须是处于常规文档流（非float和绝对定位）的块级盒子，并且处于同一个BFC当中。<br>•没有线盒，没有空隙，没有padding和border将他们分隔开<br>•都属于垂直方向上相邻的外边距，可以是下面任意一种情况<br>•元素的margin-top与其第一个常规文档流的子元素的margin-top<br>•元素的margin-bottom与其下一个常规文档流的兄弟元素的margin-top<br>•height为auto的元素的margin-bottom与其最后一个常规文档流的子元素的margin-bottom<br>•高度为0并且最小高度也为0，不包含常规文档流的子元素，并且自身没有建立新的BFC的元素的margin-top<br>和margin-bottom</p>
<p>margin合并的3种场景：</p>
<p>（1）相邻兄弟元素margin合并。</p>
<p>解决办法：<br>•设置块状格式化上下文元素（BFC）</p>
<p>（2）父级和第一个/最后一个子元素的margin合并。</p>
<p>解决办法：</p>
<p>对于margin-top合并，可以进行如下操作（满足一个条件即可）：<br>•父元素设置为块状格式化上下文元素；<br>•父元素设置border-top值；<br>•父元素设置padding-top值；<br>•父元素和第一个子元素之间添加内联元素进行分隔。</p>
<p>对于margin-bottom合并，可以进行如下操作（满足一个条件即可）：<br>•父元素设置为块状格式化上下文元素；<br>•父元素设置border-bottom值；<br>•父元素设置padding-bottom值；<br>•父元素和最后一个子元素之间添加内联元素进行分隔；<br>•父元素设置height、min-height或max-height。</p>
<p>（3）空块级元素的margin合并。</p>
<p>解决办法：<br>•设置垂直方向的border；<br>•设置垂直方向的padding；<br>•里面添加内联元素（直接Space键空格是没用的）；<br>•设置height或者min-height。</p>
<p>margin重叠指的是在垂直方向上，两个相邻元素的margin发生重叠的情况。</p>
<p>一般来说可以分为四种情形：</p>
<p>第一种是相邻兄弟元素的marin-bottom和margin-top的值发生重叠。这种情况下我们可以通过设置其中一个元素为BFC<br>来解决。</p>
<p>第二种是父元素的margin-top和子元素的margin-top发生重叠。它们发生重叠是因为它们是相邻的，所以我们可以通过这<br>一点来解决这个问题。我们可以为父元素设置border-top、padding-top值来分隔它们，当然我们也可以将父元素设置为BFC<br>来解决。</p>
<p>第三种是高度为auto的父元素的margin-bottom和子元素的margin-bottom发生重叠。它们发生重叠一个是因为它们相<br>邻，一个是因为父元素的高度不固定。因此我们可以为父元素设置border-bottom、padding-bottom来分隔它们，也可以为<br>父元素设置一个高度，max-height和min-height也能解决这个问题。当然将父元素设置为BFC是最简单的方法。</p>
<p>第四种情况，是没有内容的元素，自身的margin-top和margin-bottom发生的重叠。我们可以通过为其设置border、pa<br>dding或者高度来解决这个问题。</p>
<h2 id="‘display’、’position’和’float’的相互关系？"><a href="#‘display’、’position’和’float’的相互关系？" class="headerlink" title="‘display’、’position’和’float’的相互关系？"></a>‘display’、’position’和’float’的相互关系？</h2><p>（1）首先我们判断display属性是否为none，如果为none，则position和float属性的值不影响元素最后的表现。</p>
<p>（2）然后判断position的值是否为absolute或者fixed，如果是，则float属性失效，并且display的值应该被<br>设置为table或者block，具体转换需要看初始转换值。</p>
<p>（3）如果position的值不为absolute或者fixed，则判断float属性的值是否为none，如果不是，则display<br>的值则按上面的规则转换。注意，如果position的值为relative并且float属性的值存在，则relative相对<br>于浮动后的最终位置定位。</p>
<p>（4）如果float的值为none，则判断元素是否为根元素，如果是根元素则display属性按照上面的规则转换，如果不是，<br>则保持指定的display属性值不变。</p>
<p>总的来说，可以把它看作是一个类似优先级的机制，”position:absolute”和”position:fixed”优先级最高，有它存在<br>的时候，浮动不起作用，’display’的值也需要调整；其次，元素的’float’特性的值不是”none”的时候或者它是根元素<br>的时候，调整’display’的值；最后，非根元素，并且非浮动元素，并且非绝对定位的元素，’display’特性值同设置值。</p>
<h2 id="简单介绍使用图片-base64-编码的优点和缺点。"><a href="#简单介绍使用图片-base64-编码的优点和缺点。" class="headerlink" title="简单介绍使用图片 base64 编码的优点和缺点。"></a>简单介绍使用图片 base64 编码的优点和缺点。</h2><p>base64编码是一种图片处理格式，通过特定的算法将图片编码成一长串字符串，在页面上显示的时候，可以用该字符串来代替图片的<br>url属性。</p>
<p>使用base64的优点是：</p>
<p>（1）减少一个图片的HTTP请求</p>
<p>使用base64的缺点是：</p>
<p>（1）根据base64的编码原理，编码后的大小会比原文件大小大1/3，如果把大图片编码到html/css中，不仅会造成文件体<br>积的增加，影响文件的加载速度，还会增加浏览器对html或css文件解析渲染的时间。</p>
<p>（2）使用base64无法直接缓存，要缓存只能缓存包含base64的文件，比如HTML或者CSS，这相比域直接缓存图片的效果要<br>差很多。</p>
<p>（3）兼容性的问题，ie8以前的浏览器不支持。</p>
<p>一般一些网站的小图标可以使用base64图片来引入。</p>
<h2 id="绝对定位元素与非绝对定位元素的百分比计算的区别"><a href="#绝对定位元素与非绝对定位元素的百分比计算的区别" class="headerlink" title="绝对定位元素与非绝对定位元素的百分比计算的区别"></a>绝对定位元素与非绝对定位元素的百分比计算的区别</h2><p>绝对定位元素的宽高百分比是相对于临近的position不为static的祖先元素的padding box来计算的。</p>
<p>非绝对定位元素的宽高百分比则是相对于父元素的content box来计算的。</p>
<h2 id="width-auto-和-width-100-的区别"><a href="#width-auto-和-width-100-的区别" class="headerlink" title="width:auto 和 width:100%的区别"></a>width:auto 和 width:100%的区别</h2><p>一般而言</p>
<p>width:100%会使元素box的宽度等于父元素的content box的宽度。</p>
<p>width:auto会使元素撑满整个父元素，margin、border、padding、content区域会自动分配水平空间。</p>
<h2 id="什么是包含块，对于包含块的理解"><a href="#什么是包含块，对于包含块的理解" class="headerlink" title="什么是包含块，对于包含块的理解?"></a>什么是包含块，对于包含块的理解?</h2><p>包含块（containing block）就是元素用来计算和定位的一个框。</p>
<p>（1）根元素（很多场景下可以看成是<html>）被称为“初始包含块”，其尺寸等同于浏览器可视窗口的大小。</html></p>
<p>（2）对于其他元素，如果该元素的position是relative或者static，则“包含块”由其最近的块容器祖先盒的content box<br>边界形成。</p>
<p>（3）如果元素position:fixed，则“包含块”是“初始包含块”。</p>
<p>（4）如果元素position:absolute，则“包含块”由最近的position不为static的祖先元素建立，具体方式如下：</p>
<p>如果该祖先元素是纯inline元素，则规则略复杂：<br>•假设给内联元素的前后各生成一个宽度为0的内联盒子（inline box），则这两个内联盒子的padding box外面的包<br>围盒就是内联元素的“包含块”；<br>•如果该内联元素被跨行分割了，那么“包含块”是未定义的，也就是CSS2.1规范并没有明确定义，浏览器自行发挥<br>否则，“包含块”由该祖先的padding box边界形成。</p>
<p>如果没有符合条件的祖先元素，则“包含块”是“初始包含块”。</p>
<h2 id="经常遇到的浏览器的兼容性有哪些？原因，解决方法是什么，常用-hack-的技巧？"><a href="#经常遇到的浏览器的兼容性有哪些？原因，解决方法是什么，常用-hack-的技巧？" class="headerlink" title="经常遇到的浏览器的兼容性有哪些？原因，解决方法是什么，常用 hack 的技巧？"></a>经常遇到的浏览器的兼容性有哪些？原因，解决方法是什么，常用 hack 的技巧？</h2><p>（1）png24位的图片在iE6浏览器上出现背景<br>解决方案：做成PNG8，也可以引用一段脚本处理。</p>
<p>（2）浏览器默认的margin和padding不同<br>解决方案：加一个全局的*{margin:0;padding:0;}来统一。</p>
<p>（3）IE6双边距bug：在IE6下，如果对元素设置了浮动，同时又设置了margin-left或<br>margin-right，margin值会加倍。</p>
<p>#box{float:left;width:10px;margin:0 0 0 10px;}</p>
<p>这种情况之下IE会产生20px的距离<br>解决方案：在float的标签样式控制中加入_display:inline;将其转化为行内属性。(_这个符号只有ie6会识别)</p>
<p>（4）渐进识别的方式，从总体中逐渐排除局部。<br>首先，巧妙的使用”\9”这一标记，将IE游览器从所有情况中分离出来。<br>接着，再次使用”+”将IE8和IE7、IE6分离开来，这样IE8已经独立识别。<br>.bb{<br>background-color:#f1ee18;/<em>所有识别</em>/<br>.background-color:#00deff\9;/<em>IE6、7、8识别</em>/<br>+background-color:#a200ff;/<em>IE6、7识别</em>/<br>_background-color:#1e0bd1;/<em>IE6识别</em>/<br>}</p>
<p>（5）IE下，可以使用获取常规属性的方法来获取自定义属性，也可以使用getAttribute()获取自定义<br>属性；Firefox下，只能使用getAttribute()获取自定义属性<br>解决方法：统一通过getAttribute()获取自定义属性。</p>
<p>（6）IE下，event对象有x、y属性，但是没有pageX、pageY属性;Firefox下，event对象有<br>pageX、pageY属性，但是没有x、y属性。<br>解决方法：（条件注释）缺点是在IE浏览器下可能会增加额外的HTTP请求数。</p>
<p>（7）Chrome中文界面下默认会将小于12px的文本强制按照12px显示<br>解决方法：</p>
<p>1.可通过加入CSS属性-webkit-text-size-adjust:none;解决。但是，在chrome<br>更新到27版本之后就不可以用了。</p>
<p>2.还可以使用-webkit-transform:scale(0.5);注意-webkit-transform:scale(0.75);<br>收缩的是整个span的大小，这时候，必须要将span转换成块元素，可以使用display：block/inline-block/…；</p>
<p>（8）超链接访问过后hover样式就不出现了，被点击访问过的超链接样式不再具有hover和active了<br>解决方法：改变CSS属性的排列顺序L-V-H-A</p>
<p>（9）怪异模式问题：漏写DTD声明，Firefox仍然会按照标准模式来解析网页，但在IE中会触发怪异模<br>式。为避免怪异模式给我们带来不必要的麻烦，最好养成书写DTD声明的好习惯。</p>
<h2 id="CSS-多列等高如何实现？"><a href="#CSS-多列等高如何实现？" class="headerlink" title="CSS 多列等高如何实现？"></a>CSS 多列等高如何实现？</h2><p>（1）利用padding-bottom|margin-bottom正负值相抵，不会影响页面布局的特点。设置父容器设置超出隐藏（overflow:<br>hidden），这样父容器的高度就还是它里面的列没有设定padding-bottom时的高度，当它里面的任一列高度增加了，则<br>父容器的高度被撑到里面最高那列的高度，其他比这列矮的列会用它们的padding-bottom补偿这部分高度差。</p>
<p>（2）利用table-cell所有单元格高度都相等的特性，来实现多列等高。</p>
<p>（3）利用flex布局中项目align-items属性默认为stretch，如果项目未设置高度或设为auto，将占满整个容器的高度<br>的特性，来实现多列等高。</p>
<h2 id="请解释一下-CSS3-的-Flex-box（弹性盒布局模型），以及适用场景？"><a href="#请解释一下-CSS3-的-Flex-box（弹性盒布局模型），以及适用场景？" class="headerlink" title="请解释一下 CSS3 的 Flex box（弹性盒布局模型），以及适用场景？"></a>请解释一下 CSS3 的 Flex box（弹性盒布局模型），以及适用场景？</h2><p>flex布局是CSS3新增的一种布局方式，我们可以通过将一个元素的display属性值设置为flex从而使它成为一个flex<br>容器，它的所有子元素都会成为它的项目。</p>
<p>一个容器默认有两条轴，一个是水平的主轴，一个是与主轴垂直的交叉轴。我们可以使用flex-direction来指定主轴的方向。<br>我们可以使用justify-content来指定元素在主轴上的排列方式，使用align-items来指定元素在交叉轴上的排列方式。还<br>可以使用flex-wrap来规定当一行排列不下时的换行方式。</p>
<p>对于容器中的项目，我们可以使用order属性来指定项目的排列顺序，还可以使用flex-grow来指定当排列空间有剩余的时候，<br>项目的放大比例。还可以使用flex-shrink来指定当排列空间不足时，项目的缩小比例。</p>
<h2 id="关于伪类-LVHA-的解释"><a href="#关于伪类-LVHA-的解释" class="headerlink" title="关于伪类 LVHA 的解释?"></a>关于伪类 LVHA 的解释?</h2><p>a标签有四种状态：链接访问前、链接访问后、鼠标滑过、激活，分别对应四种伪类:link、:visited、:hover、:active；</p>
<p>当链接未访问过时：</p>
<p>（1）当鼠标滑过a链接时，满足:link和:hover两种状态，要改变a标签的颜色，就必须将:hover伪类在:link伪<br>类后面声明；<br>（2）当鼠标点击激活a链接时，同时满足:link、:hover、:active三种状态，要显示a标签激活时的样式（:active），<br>必须将:active声明放到:link和:hover之后。因此得出LVHA这个顺序。</p>
<p>当链接访问过时，情况基本同上，只不过需要将:link换成:visited。</p>
<p>这个顺序能不能变？可以，但也只有:link和:visited可以交换位置，因为一个链接要么访问过要么没访问过，不可能同时满足，<br>也就不存在覆盖的问题。</p>
<h2 id="css-实现上下固定中间自适应布局？"><a href="#css-实现上下固定中间自适应布局？" class="headerlink" title="css 实现上下固定中间自适应布局？"></a>css 实现上下固定中间自适应布局？</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">利用绝对定位实现body &#123;</span><br><span class="line">  padding: 0;</span><br><span class="line">  margin: 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.header &#123;</span><br><span class="line">  position: absolute;</span><br><span class="line">  top: 0;</span><br><span class="line">  width: 100%;</span><br><span class="line">  height: 100px;</span><br><span class="line">  background: red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.container &#123;</span><br><span class="line">  position: absolute;</span><br><span class="line">  top: 100px;</span><br><span class="line">  bottom: 100px;</span><br><span class="line">  width: 100%;</span><br><span class="line">  background: green;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.footer &#123;</span><br><span class="line">  position: absolute;</span><br><span class="line">  bottom: 0;</span><br><span class="line">  height: 100px;</span><br><span class="line">  width: 100%;</span><br><span class="line">  background: red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">利用flex布局实现html,</span><br><span class="line">body &#123;</span><br><span class="line">  height: 100%;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">body &#123;</span><br><span class="line">  display: flex;</span><br><span class="line">  padding: 0;</span><br><span class="line">  margin: 0;</span><br><span class="line">  flex-direction: column;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.header &#123;</span><br><span class="line">  height: 100px;</span><br><span class="line">  background: red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.container &#123;</span><br><span class="line">  flex-grow: 1;</span><br><span class="line">  background: green;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.footer &#123;</span><br><span class="line">  height: 100px;</span><br><span class="line">  background: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="relative-的特殊性"><a href="#relative-的特殊性" class="headerlink" title="relative 的特殊性"></a>relative 的特殊性</h2><p>（1）相对定位元素的left/top/right/bottom的百分比值是相对于包含块计算的，而不是自身。注意，虽然定位位移是相对自身，但是百分比值的计算值不是。</p>
<p>（2）top和bottom这两个垂直方向的百分比值计算跟height的百分比值是一样的，都是相对高度计算的。同时，如果包含块的高度是auto，那么计算值是0，偏移无效，也就是说，如果父元素没有设定高度或者不是“格式化高度”，那么relative类似top:20%的代码等同于top:0。</p>
<p>（3）当相对定位元素同时应用对立方向定位值的时候，也就是top/bottom和left/right同时使用的时候，只有一个方向的定位属性会起作用。而谁起作用则是与文档流的顺序有关的，默认的文档流是自上而下、从左往右，因此top/bottom同时使用的时候，bottom失效；left/right同时使用的时候，right失效。</p>
<h2 id="CSS-怎么画一个大小为父元素宽度一半的正方形？"><a href="#CSS-怎么画一个大小为父元素宽度一半的正方形？" class="headerlink" title="CSS 怎么画一个大小为父元素宽度一半的正方形？"></a>CSS 怎么画一个大小为父元素宽度一半的正方形？</h2> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> &lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot; /&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;</span><br><span class="line">    &lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">      .outer &#123;</span><br><span class="line">        width: 400px;</span><br><span class="line">        height: 600px;</span><br><span class="line">        background: red;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      .inner &#123;</span><br><span class="line">        width: 50%;</span><br><span class="line">        padding-bottom: 50%;</span><br><span class="line">        background: blue;</span><br><span class="line">      &#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;div class=&quot;outer&quot;&gt;</span><br><span class="line">      &lt;div class=&quot;inner&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="CSS实现自适应正方形、等宽高比矩形"><a href="#CSS实现自适应正方形、等宽高比矩形" class="headerlink" title="CSS实现自适应正方形、等宽高比矩形"></a>CSS实现自适应正方形、等宽高比矩形</h2><ol>
<li><p>双重嵌套，外层 relative，内层 absolute</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> &lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot; /&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;</span><br><span class="line">    &lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">      .outer &#123;</span><br><span class="line">        padding-top: 50%;</span><br><span class="line">        height: 0;</span><br><span class="line">        background: #ccc;</span><br><span class="line">        width: 50%;</span><br><span class="line">        position: relative;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      .inner &#123;</span><br><span class="line">        position: absolute;</span><br><span class="line">        width: 100%;</span><br><span class="line">        height: 100%;</span><br><span class="line">        top: 0;</span><br><span class="line">        left: 0;</span><br><span class="line">        background: blue;</span><br><span class="line">      &#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;div class=&quot;outer&quot;&gt;</span><br><span class="line">      &lt;div class=&quot;inner&quot;&gt;hello&lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>padding 撑高画正方形</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> &lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot; /&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;</span><br><span class="line">    &lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">      .outer &#123;</span><br><span class="line">        width: 400px;</span><br><span class="line">        height: 600px;</span><br><span class="line">        background: blue;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      .inner &#123;</span><br><span class="line">        width: 100%;</span><br><span class="line">        height: 0;</span><br><span class="line">        padding-bottom: 100%;</span><br><span class="line">        background: red;</span><br><span class="line">      &#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;div class=&quot;outer&quot;&gt;</span><br><span class="line">      &lt;div class=&quot;inner&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>相对于视口 VW VH</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> &lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot; /&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;</span><br><span class="line">    &lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">      .inner &#123;</span><br><span class="line">        width: 1vw;</span><br><span class="line">        height: 1vw;</span><br><span class="line">        background: blue;</span><br><span class="line">      &#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;div class=&quot;outer&quot;&gt;</span><br><span class="line">      &lt;div class=&quot;inner&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
<p> 4、伪元素设置 margin-top</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot; /&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;</span><br><span class="line">    &lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">      .inner &#123;</span><br><span class="line">        width: 100px;</span><br><span class="line">        overflow: hidden;</span><br><span class="line">        background: blue;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      .inner::after &#123;</span><br><span class="line">        content: &quot;&quot;;</span><br><span class="line">        margin-top: 100%;</span><br><span class="line">        display: block;</span><br><span class="line">      &#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;div class=&quot;outer&quot;&gt;</span><br><span class="line">      &lt;div class=&quot;inner&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="CSS-动画有哪些？"><a href="#CSS-动画有哪些？" class="headerlink" title="CSS 动画有哪些？"></a>CSS 动画有哪些？</h2><p>animation：用于设置动画属性，他是一个简写的属性，包含6个属性<br>transition：用于设置元素的样式过度，和animation有着类似的效果，但细节上有很大的不同<br>transform：用于元素进行旋转、缩放、移动或倾斜，和设置样式的动画并没有什么关系<br>translate：translate只是transform的一个属性值，即移动，除此之外还有 scale 等</p>
<h2 id="visibility-和-display-的差别（还有opacity"><a href="#visibility-和-display-的差别（还有opacity" class="headerlink" title="visibility 和 display 的差别（还有opacity)"></a>visibility 和 display 的差别（还有opacity)</h2><ol>
<li>visibility 设置 hidden 会隐藏元素，但是其位置还存在与页面文档流中，不会被删除，所以会触发浏览器渲染引擎的重绘</li>
<li>display 设置了 none 属性会隐藏元素，且其位置也不会被保留下来，所以会触发浏览器渲染引擎的回流和重绘。</li>
<li>opacity 会将元素设置为透明，但是其位置也在页面文档流中，不会被删除，所以会触发浏览器渲染引擎的重绘</li>
</ol>
<h2 id="BFC会与float元素相互覆盖吗？为什么？举例说明"><a href="#BFC会与float元素相互覆盖吗？为什么？举例说明" class="headerlink" title="BFC会与float元素相互覆盖吗？为什么？举例说明"></a>BFC会与float元素相互覆盖吗？为什么？举例说明</h2><p>不会，因为 BFC 是页面中一个独立的隔离容器，其内部的元素不会与外部的元素相互影响，比如两个 div，上面的 div 设置了 float，那么如果下面的元素不是 BFC，也没有设置 float，会形成对上面的元素进行包裹内容的情况，如果设置了下面元素为 overflow：hidden；属性那么就能够实现经典的两列布局，左边内容固定宽度，右边因为是 BFC 所以会进行自适应。</p>
<h2 id="两个div上下排列，都设margin，有什么现象？"><a href="#两个div上下排列，都设margin，有什么现象？" class="headerlink" title="两个div上下排列，都设margin，有什么现象？"></a>两个div上下排列，都设margin，有什么现象？</h2><p>1）都正取大<br>2）一正一负相加</p>
<p>问：为什么会有这种现象？你能解释一下吗<br>是由块级格式上下文决定的，BFC，元素在 BFC 中会进行上下排列，然后垂直距离由 margin 决定，并且会发生重叠，具体表现为同正取最大的，同负取绝对值最大的，一正一负，相加<br>BFC 是页面中一个独立的隔离容器，内部的子元素不会影响到外部的元素。</p>
<h2 id="用css2和css3分别写一下垂直居中和水平居中"><a href="#用css2和css3分别写一下垂直居中和水平居中" class="headerlink" title="用css2和css3分别写一下垂直居中和水平居中"></a>用css2和css3分别写一下垂直居中和水平居中</h2><p>CSS2<br>水平居中：</p>
<ol>
<li>div + margin: auto;</li>
<li>span + text-align</li>
</ol>
<p>垂直居中</p>
<ol>
<li>使用 position 然后 left/top 和 margin 的方式垂直居中（已知宽高和未知宽高）</li>
<li>使用 position + margin</li>
<li>使用 display: table-cell;</li>
</ol>
<p>已知宽高，进行水平垂直居中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot; /&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;</span><br><span class="line">    &lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">      .outer &#123;</span><br><span class="line">        position: relative;</span><br><span class="line">        width: 400px;</span><br><span class="line">        height: 600px;</span><br><span class="line">        background: blue;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      .inner &#123;</span><br><span class="line">        position: absolute;</span><br><span class="line">        width: 200px;</span><br><span class="line">        height: 300px;</span><br><span class="line">        background: red;</span><br><span class="line">        left: 50%;</span><br><span class="line">        top: 50%;</span><br><span class="line">        margin: -150px 0 0 -100px;</span><br><span class="line">      &#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;div class=&quot;outer&quot;&gt;</span><br><span class="line">      &lt;div class=&quot;inner&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>宽高未知，比如 内联元素，进行水平垂直居中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot; /&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;</span><br><span class="line">    &lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">      .outer &#123;</span><br><span class="line">        width: 400px;</span><br><span class="line">        height: 600px;</span><br><span class="line">        /* background: blue; */</span><br><span class="line">        border: 1px solid red;</span><br><span class="line">        background-color: transparent;</span><br><span class="line">        position: relative;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      .inner &#123;</span><br><span class="line">        position: absolute;</span><br><span class="line">        background: red;</span><br><span class="line">        left: 50%;</span><br><span class="line">        top: 50%;</span><br><span class="line">        transform: translate(-50%, -50%);</span><br><span class="line">      &#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;div class=&quot;outer&quot;&gt;</span><br><span class="line">      &lt;span class=&quot;inner&quot;&gt;我想居中显示&lt;/span&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>绝对定位的 div 水平垂直居中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot; /&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;</span><br><span class="line">    &lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">      .outer &#123;</span><br><span class="line">        width: 400px;</span><br><span class="line">        height: 600px;</span><br><span class="line">        /* background: blue; */</span><br><span class="line">        border: 1px solid red;</span><br><span class="line">        background-color: transparent;</span><br><span class="line">        position: relative;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      .inner &#123;</span><br><span class="line">        position: absolute;</span><br><span class="line">        background: red;</span><br><span class="line">        left: 0;</span><br><span class="line">        right: 0;</span><br><span class="line">        bottom: 0;</span><br><span class="line">        top: 0;</span><br><span class="line">        width: 200px;</span><br><span class="line">        height: 300px;</span><br><span class="line">        margin: auto;</span><br><span class="line">        border: 1px solid blue;</span><br><span class="line">      &#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;div class=&quot;outer&quot;&gt;</span><br><span class="line">      &lt;div class=&quot;inner&quot;&gt;我想居中显示&lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>图片和其他元素使用 display: table-cell; 进行垂直居中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot; /&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;</span><br><span class="line">    &lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">      .outer &#123;</span><br><span class="line">        width: 400px;</span><br><span class="line">        height: 600px;</span><br><span class="line">        /* background: blue; */</span><br><span class="line">        border: 1px solid red;</span><br><span class="line">        background-color: transparent;</span><br><span class="line">        display: table-cell;</span><br><span class="line">        vertical-align: middle;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      .inner &#123;</span><br><span class="line">        background: red;</span><br><span class="line">        width: 200px;</span><br><span class="line">        height: 300px;</span><br><span class="line">        border: 1px solid blue;</span><br><span class="line">        margin: 0 auto;</span><br><span class="line">      &#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;div class=&quot;outer&quot;&gt;</span><br><span class="line">      &lt;div class=&quot;inner&quot;&gt;我想居中显示&lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>CSS3<br>垂直、水平居中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot; /&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;</span><br><span class="line">    &lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">      .outer &#123;</span><br><span class="line">        width: 400px;</span><br><span class="line">        height: 600px;</span><br><span class="line"></span><br><span class="line">        display: flex;</span><br><span class="line">        </span><br><span class="line">        /* 垂直居中 */</span><br><span class="line">        align-items: center;</span><br><span class="line">        </span><br><span class="line">        /* 水平居中 */</span><br><span class="line">        justify-content: center;</span><br><span class="line">        border: 1px solid red;</span><br><span class="line">        background-color: transparent;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      .inner &#123;</span><br><span class="line">        background: red;</span><br><span class="line">        width: 200px;</span><br><span class="line">        height: 300px;</span><br><span class="line">        border: 1px solid blue;</span><br><span class="line">      &#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;div class=&quot;outer&quot;&gt;</span><br><span class="line">      &lt;div class=&quot;inner&quot;&gt;我想居中显示&lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<h2 id="html-根元素的默认-display-为-block"><a href="#html-根元素的默认-display-为-block" class="headerlink" title="html 根元素的默认 display 为 block"></a>html 根元素的默认 display 为 block</h2><h2 id="‘-’-与-‘-’-选择器有什么不同"><a href="#‘-’-与-‘-’-选择器有什么不同" class="headerlink" title="‘+’ 与 ‘~’ 选择器有什么不同"></a>‘+’ 与 ‘~’ 选择器有什么不同</h2><ol>
<li><ul>
<li>选择器匹配紧邻的兄弟元素</li>
</ul>
</li>
<li>~ 选择器匹配随后的所有兄弟元素</li>
</ol>
<h2 id="css-动画与-js-动画哪个性能更好"><a href="#css-动画与-js-动画哪个性能更好" class="headerlink" title="css 动画与 js 动画哪个性能更好"></a>css 动画与 js 动画哪个性能更好</h2><p>CSS3 的动画：</p>
<ol>
<li>在性能上会稍微好一些，浏览器会对 CSS3 的动画做一些优化（比如专门新建一个图层用来跑动画）</li>
<li>代码相对简单</li>
<li>在动画控制上不够灵活</li>
<li>兼容性不好</li>
<li>部分动画功能无法实现（如滚动动画，视差滚动等）<br>JavaScript 的动画：<br>正好弥补了 css 缺点，控制能力很强，可以单帧的控制、变换，同时写得好完全可以兼容 IE6，并且功能强大。<br>总结： 对于一些复杂控制的动画，使用 javascript 会比较好。而在实现一些小的交互动效的时候，可以多考虑 CSS</li>
</ol>
<h2 id="伪类与伪元素有什么区别"><a href="#伪类与伪元素有什么区别" class="headerlink" title="伪类与伪元素有什么区别"></a>伪类与伪元素有什么区别</h2><ol>
<li>伪类使用单冒号，而伪元素使用双冒号。如 :hover 是伪类，::before 是伪元素</li>
<li>伪元素会在文档流生成一个新的元素，并且可以使用 content 属性设置内容</li>
</ol>
<h2 id="css-如何匹配前-N-个子元素及最后-N-个子元素，偶数，奇数"><a href="#css-如何匹配前-N-个子元素及最后-N-个子元素，偶数，奇数" class="headerlink" title="css 如何匹配前 N 个子元素及最后 N 个子元素，偶数，奇数"></a>css 如何匹配前 N 个子元素及最后 N 个子元素，偶数，奇数</h2><ol>
<li>如何匹配最前三个子元素: :nth-child(-n+3)</li>
<li>如何匹配最后三个子元素: :nth-last-child(-n+3)</li>
<li>如何匹配双行样式: nth-child(2n)/nth-child(even)</li>
<li>如何匹配单行样式: nth-child(2n+1)/nth-child(odd)</li>
</ol>
<h2 id="如何使用-CSS-实现网站的暗黑模式-Dark-Mode"><a href="#如何使用-CSS-实现网站的暗黑模式-Dark-Mode" class="headerlink" title="如何使用 CSS 实现网站的暗黑模式 (Dark Mode)"></a>如何使用 CSS 实现网站的暗黑模式 (Dark Mode)</h2><p>prefers-color-scheme<br>@media (prefers-color-scheme: dark) {<br>  :root {<br>  }<br>}</p>
<h2 id="css-如何实现响应式布局大屏幕三等分、中屏幕二等分、小屏幕一等分"><a href="#css-如何实现响应式布局大屏幕三等分、中屏幕二等分、小屏幕一等分" class="headerlink" title="css 如何实现响应式布局大屏幕三等分、中屏幕二等分、小屏幕一等分"></a>css 如何实现响应式布局大屏幕三等分、中屏幕二等分、小屏幕一等分</h2><p>Grid 布局可以自动判断容器大小，无论大小屏幕自动撑满并均分，请看以下属性</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.container &#123;</span><br><span class="line">  grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>repeat: 用以 N 整分</li>
<li>auto-fill：表示自动填充</li>
<li>minmx: 即书面意思，最小宽度为 300px</li>
</ol>
<h2 id="前端开发中如何进行多主题配置"><a href="#前端开发中如何进行多主题配置" class="headerlink" title="前端开发中如何进行多主题配置"></a>前端开发中如何进行多主题配置</h2><h2 id="如何自定义滚动条的样式"><a href="#如何自定义滚动条的样式" class="headerlink" title="如何自定义滚动条的样式"></a>如何自定义滚动条的样式</h2><p>滚动条相关样式都是伪元素，以 scrollbar 打头，有以下伪元素，从 -webkit 中可见兼容性一般，不过无所谓，现在 Chrome 浏览器占大头</p>
<p>· ::-webkit-scrollbar — 整个滚动条.<br>· ::-webkit-scrollbar-button — 滚动条上的按钮 (上下箭头).<br>· ::-webkit-scrollbar-thumb — 滚动条上的滚动滑块.<br>· ::-webkit-scrollbar-track — 滚动条轨道.<br>· ::-webkit-scrollbar-track-piece — 滚动条没有滑块的轨道部分.<br>· ::-webkit-scrollbar-corner — 当同时有垂直滚动条和水平滚动条时交汇的部分.<br>· ::-webkit-resizer — 某些元素的 corner 部分的部分样式(例:textarea 的可拖动按钮).</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">::-webkit-scrollbar &#123;</span><br><span class="line">  width: 6px;</span><br><span class="line">  height: 6px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">::-webkit-scrollbar-track &#123;</span><br><span class="line">  border-radius: 3px;</span><br><span class="line">  background: rgba(0, 0, 0);</span><br><span class="line">  box-shadow: inset 0 0 5px rgba(0, 0, 0, 0.08);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">::-webkit-scrollbar-thumb &#123;</span><br><span class="line">  border-radius: 3px;</span><br><span class="line">  background: rgba(0, 0, 1);</span><br><span class="line">  box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="网站设置字体时，如何设置优先使用系统默认字体"><a href="#网站设置字体时，如何设置优先使用系统默认字体" class="headerlink" title="网站设置字体时，如何设置优先使用系统默认字体"></a>网站设置字体时，如何设置优先使用系统默认字体</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">font-family: system-ui;</span><br></pre></td></tr></table></figure>

<h2 id="写-CSS-时如何避免命名样式冲突"><a href="#写-CSS-时如何避免命名样式冲突" class="headerlink" title="写 CSS 时如何避免命名样式冲突"></a>写 CSS 时如何避免命名样式冲突</h2><ol>
<li><p>BEM 式: .home-page .home-page-btn</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.home-page &#123;</span><br><span class="line">  .home-page-btn &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>BEM 有一个缺点，就是有些太长，可适当简化，只包裹该页面组件的根类名，但有可能增加样式冲突的风险</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.home-page &#123;</span><br><span class="line">  .btn &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>CSS Scoped<br>scoped css 会对当前组件(scope)下所有元素生成唯一的属性或类名，对所有 CSS 规则将携带唯一属性实现作用域的命名保护</p>
</li>
<li><p>CSS Module<br>module css 会对类名进行 hash 化</p>
</li>
</ol>
<h2 id="CSS-如何设置方格背景"><a href="#CSS-如何设置方格背景" class="headerlink" title="CSS 如何设置方格背景"></a>CSS 如何设置方格背景</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">background: linear-gradient(90deg, rgba(200, 200, 200, 0.1) 3%, transparent 0),</span><br><span class="line">  linear-gradient(rgba(200, 200, 200, 0.1) 3%, transparent 0);</span><br><span class="line">background-size: 20px 20px;</span><br></pre></td></tr></table></figure>

<h2 id="aspect-ratio"><a href="#aspect-ratio" class="headerlink" title="aspect-ratio"></a>aspect-ratio</h2><p>aspect ratio翻译为中文就是宽高比（也称：纵横比）即x:y。</p>
<h2 id="normalize-css-与-reset-css-又何区别"><a href="#normalize-css-与-reset-css-又何区别" class="headerlink" title="normalize.css 与 reset.css 又何区别"></a>normalize.css 与 reset.css 又何区别</h2><p>· normalize.css (opens new window): 会保留有用的样式，比如 h1 的字体大小<br>· reset.css (opens new window): 把所有样式都重置，比如 h1、h2、h3 的字体大小都进行了重置，保持了无样式</p>
<h2 id="Grid-布局的优势在哪里"><a href="#Grid-布局的优势在哪里" class="headerlink" title="Grid 布局的优势在哪里"></a>Grid 布局的优势在哪里</h2><p>Flex 布局是轴线布局，只能指定”项目”针对轴线的位置，可以看作是一维布局。 Grid 布局则是将容器划分成”行”和”列”，产生单元格，然后指定”项目所在”的单元格，可以看作是二维布局。 Grid 布局远比 Flex 布局强大</p>
<h2 id="css-加载会阻塞-DOM-树的解析和渲染吗"><a href="#css-加载会阻塞-DOM-树的解析和渲染吗" class="headerlink" title="css 加载会阻塞 DOM 树的解析和渲染吗"></a>css 加载会阻塞 DOM 树的解析和渲染吗</h2><p>css 加载会直接影响网页的渲染，因为只有 css 加载完毕，构建完 CSSOM 后，渲染树(Render Tree)才会构建，然后渲染成位图</p>
<p>如果 html 中有加载 script 的话，还会间接影响 DOM 树的解析，因为 javascript 的下载、解析和执行和阻塞 DOM 树的解析，而 javascript 中有可能访问 CSSOM，比如 Element.getBoundingClientRect，因此 CSSOM 构建完毕以后才会开始 javascript 的执行，间接阻塞 dom 树的解析</p>
<h2 id="如何理解-CSS-的继承和重用？"><a href="#如何理解-CSS-的继承和重用？" class="headerlink" title="如何理解 CSS 的继承和重用？"></a>如何理解 CSS 的继承和重用？</h2><p>继承：在一个属性应用于一个特定标签之后，该标签的子标签也应该应用该属性。这一行为称为继承。但并不是所有的属性都会被继承。如文字样式一般都继承，盒图的宽高一般不 继承，总之该继承的都会继承，不该继承的都不继承。<br>重用：一个样式文件，可以多个页面使用，这对于一些公共样式的重构是很有用的。</p>
<h2 id="如何水平并且垂直居中一张背景图"><a href="#如何水平并且垂直居中一张背景图" class="headerlink" title="如何水平并且垂直居中一张背景图"></a>如何水平并且垂直居中一张背景图</h2><p>设置 background-position:center;</p>
<h2 id="font-style属性可以让它赋值为“oblique”是什么意思"><a href="#font-style属性可以让它赋值为“oblique”是什么意思" class="headerlink" title="font-style属性可以让它赋值为“oblique”是什么意思"></a>font-style属性可以让它赋值为“oblique”是什么意思</h2><p>让一种字体标识为斜体(oblique)，如果没有这种格式，就使用italic字体</p>
<h2 id="常见的浏览器内核有哪些？"><a href="#常见的浏览器内核有哪些？" class="headerlink" title="常见的浏览器内核有哪些？"></a>常见的浏览器内核有哪些？</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">**Trident内核**：IE,MaxThon,TT,The World,360,搜狗浏览器等。[又称MSHTML]</span><br><span class="line">**Gecko内核**：Netscape6及以上版本，FF,MozillaSuite/SeaMonkey等。</span><br><span class="line">**Presto内核**：Opera7及以上。[Opera内核原为：Presto，现为：Blink;]</span><br><span class="line">**Webkit内核**：Safari,Chrome等。[ Chrome的：Blink（WebKit的分支）]</span><br><span class="line">**EdgeHTML内核**：Microsoft Edge。[此内核其实是从MSHTML fork而来，删掉了几乎所有的</span><br></pre></td></tr></table></figure>

<h2 id="介绍一下你对浏览器内核的理解"><a href="#介绍一下你对浏览器内核的理解" class="headerlink" title="介绍一下你对浏览器内核的理解"></a>介绍一下你对浏览器内核的理解</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">主要分成两部分：渲染引擎（layout engineer或Rendering Engine）和 JS 引擎。</span><br><span class="line">（1）渲染引擎：负责取得网页的内容（HTML、XML、图像等等）、整理讯息（例如加入CSS等），以及计算网页的显示方式，然后会输出至显示器或打印机。浏览器的内核的不同对于网页的语法解释会有不同，所以渲染的效果也不相同。所有网页浏览器、电子邮件客户以及其他它所需要编辑、显示网络的应用程序都需要内核。</span><br><span class="line">（2）JS引擎则：解析和执行JavaScript 来实现网页的动态效果；</span><br><span class="line">最开始渲染引擎和 JS 并没有区分的很明确，后来JS引擎越来越独立，内核就倾向于只渲染引擎。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="CSS引入的方式有哪些？使用Link和-import有什么区别？"><a href="#CSS引入的方式有哪些？使用Link和-import有什么区别？" class="headerlink" title="CSS引入的方式有哪些？使用Link和@import有什么区别？"></a>CSS引入的方式有哪些？使用Link和@import有什么区别？</h2><p>答：内联，内嵌，外链，导入<br>（1）link 属于 XHTML 标签，除了加载 CSS 外，还能用于定义RSS，定义 rel 连接属性等作用，无兼容性，支持使用javascript改变样式；而@import是CSS提供的，只能用于加载CSS，不支持使用 javascript 改变样式；<br>（2）页面被加载的时，link 会被同时加载，而@import 引用的CSS会等到页面加载完再加载；<br>（3）import是CSS2.1 提出的，CSS2.1以下浏览器不支持，只在IE5以上才能被识别，而link是XHTML标签，无兼容问题。</p>
<h2 id="translate-方法能移动一个元素在z轴上的位置？"><a href="#translate-方法能移动一个元素在z轴上的位置？" class="headerlink" title="translate()方法能移动一个元素在z轴上的位置？"></a>translate()方法能移动一个元素在z轴上的位置？</h2><p>不能。它只能移动x,y轴的位置。translate3d可以。</p>
<h2 id="rgba-和-opacity-的透明效果有什么不同？"><a href="#rgba-和-opacity-的透明效果有什么不同？" class="headerlink" title="rgba() 和 opacity 的透明效果有什么不同？"></a>rgba() 和 opacity 的透明效果有什么不同？</h2><p>rgba()和opacity都能实现透明效果，但最大的不同是opacity作用于元素，以及元素内的所有内容的透明度，<br>而rgba()只作用于元素的颜色或其背景色。（设置rgba透明的元素的子元素不会继承透明效果！）</p>
<h2 id="CSS-伪类和伪元素的区别？"><a href="#CSS-伪类和伪元素的区别？" class="headerlink" title="CSS 伪类和伪元素的区别？"></a>CSS 伪类和伪元素的区别？</h2><p>伪类： :focus、:hover、:active<br>伪元素：:before、:after<br>伪类本质上是为了弥补常规CSS选择器的不足，以便获取到更多信息；<br>伪元素本质上是创建了一个有内容的虚拟容器；<br>CSS3中伪类和伪元素的语法不同；<br>可以同时使用多个伪类，而只能同时使用一个伪元素；</p>
<h2 id="transition和animation的区别"><a href="#transition和animation的区别" class="headerlink" title="transition和animation的区别"></a>transition和animation的区别</h2><p>· transition是过度属性，强调过度，它的实现需要触发一个事件（比如鼠标移动上去，焦点，点击等）才执行动画。它类似于flash的补间动画，设置一个开始关键帧，一个结束关键帧。</p>
<p>· animation是动画属性，它的实现不需要触发事件，设定好时间之后可以自己执行，且可以循环一个动画。它也类似于flash的补间动画，但是它可以设置多个关键帧（用@keyframe定义）完成动画。</p>
<h2 id="对requestAnimationframe的理解"><a href="#对requestAnimationframe的理解" class="headerlink" title="对requestAnimationframe的理解"></a>对requestAnimationframe的理解</h2><p>实现动画效果的方法比较多，Javascript 中可以通过定时器 setTimeout 来实现，CSS3 中可以使用 transition 和 animation 来实现，HTML5 中的 canvas 也可以实现。除此之外，HTML5 提供一个专门用于请求动画的API，那就是 requestAnimationFrame，顾名思义就是请求动画帧。</p>
<p>MDN对该方法的描述：<br>window.requestAnimationFrame() 告诉浏览器——你希望执行一个动画，并且要求浏览器在下次重绘之前调用指定的回调函数更新动画。该方法需要传入一个回调函数作为参数，该回调函数会在浏览器下一次重绘之前执行。</p>
<p>优势：</p>
<ol>
<li>CPU节能：使用SetTinterval 实现的动画，当页面被隐藏或最小化时，SetTinterval 仍然在后台执行动画任务，由于此时页面处于不可见或不可用状态，刷新动画是没有意义的，完全是浪费CPU资源。而RequestAnimationFrame则完全不同，当页面处理未激活的状态下，该页面的屏幕刷新任务也会被系统暂停，因此跟着系统走的RequestAnimationFrame也会停止渲染，当页面被激活时，动画就从上次停留的地方继续执行，有效节省了CPU开销。</li>
<li>函数节流：在高频率事件( resize, scroll 等)中，为了防止在一个刷新间隔内发生多次函数执行，RequestAnimationFrame可保证每个刷新间隔内，函数只被执行一次，这样既能保证流畅性，也能更好的节省函数执行的开销，一个刷新间隔内函数执行多次时没有意义的，因为多数显示器每16.7ms刷新一次，多次绘制并不会在屏幕上体现出来。</li>
<li>减少DOM操作：requestAnimationFrame 会把每一帧中的所有DOM操作集中起来，在一次重绘或回流中就完成，并且重绘或回流的时间间隔紧紧跟随浏览器的刷新频率，一般来说，这个频率为每秒60帧。</li>
</ol>
<h2 id="为什么有时候⽤translate来改变位置⽽不是定位"><a href="#为什么有时候⽤translate来改变位置⽽不是定位" class="headerlink" title="为什么有时候⽤translate来改变位置⽽不是定位"></a>为什么有时候⽤translate来改变位置⽽不是定位</h2><p>translate 是 transform 属性的⼀个值。改变transform或opacity不会触发浏览器重新布局（reflow）或重绘（repaint），只会触发复合（compositions）。⽽改变绝对定位会触发重新布局，进⽽触发重绘和复合。transform使浏览器为元素创建⼀个 GPU 图层，但改变绝对定位会使⽤到 CPU。 因此translate()更⾼效，可以缩短平滑动画的绘制时间。 ⽽translate改变位置时，元素依然会占据其原始空间，绝对定位就不会发⽣这种情况。</p>
<h2 id="替换元素的概念及计算规则"><a href="#替换元素的概念及计算规则" class="headerlink" title="替换元素的概念及计算规则"></a>替换元素的概念及计算规则</h2><p>通过修改某个属性值呈现的内容就可以被替换的元素就称为“替换元素”。<br>替换元素除了内容可替换这一特性以外，还有以下特性：</p>
<ol>
<li>内容的外观不受页面上的CSS的影响：用专业的话讲就是在样式表现在CSS作用域之外。如何更改替换元素本身的外观需要类似appearance属性，或者浏览器自身暴露的一些样式接口。</li>
<li>有自己的尺寸：在Web中，很多替换元素在没有明确尺寸设定的情况下，其默认的尺寸（不包括边框）是300像素×150像素，如</li>
<li>在很多CSS属性上有自己的一套表现规则：比较具有代表性的就是vertical-align属性，对于替换元素和非替换元素，vertical-align属性值的解释是不一样的。比方说vertical-align的默认值的baseline，很简单的属性值，基线之意，被定义为字符x的下边缘，而替换元素的基线却被硬生生定义成了元素的下边缘。</li>
<li>所有的替换元素都是内联水平元素：也就是替换元素和替换元素、替换元素和文字都是可以在一行显示的。但是，替换元素默认的display值却是不一样的，有的是inline，有的是inline-block。</li>
</ol>
<p>替换元素的尺寸从内而外分为三类：</p>
<ol>
<li>固有尺寸： 指的是替换内容原本的尺寸。例如，图片、视频作为一个独立文件存在的时候，都是有着自己的宽度和高度的。</li>
<li>HTML尺寸： 只能通过HTML原生属性改变，这些HTML原生属性包括的width和height属性、的size属性。</li>
<li>CSS尺寸： 特指可以通过CSS的width和height或者max-width/min-width和max-height/min-height设置的尺寸，对应盒尺寸中的content box。</li>
</ol>
<p>这三层结构的计算规则具体如下：<br>（1）如果没有CSS尺寸和HTML尺寸，则使用固有尺寸作为最终的宽高。<br>（2）如果没有CSS尺寸，则使用HTML尺寸作为最终的宽高。<br>（3）如果有CSS尺寸，则最终尺寸由CSS属性决定。<br>（4）如果“固有尺寸”含有固有的宽高比例，同时仅设置了宽度或仅设置了高度，则元素依然按照固有的宽高比例显示。<br>（5）如果上面的条件都不符合，则最终宽度表现为300像素，高度为150像素。<br>（6）内联替换元素和块级替换元素使用上面同一套尺寸计算规则。</p>
<h2 id="什么是物理像素，逻辑像素和像素密度，为什么在移动端开发时需要用到-3x-2x这种图片？"><a href="#什么是物理像素，逻辑像素和像素密度，为什么在移动端开发时需要用到-3x-2x这种图片？" class="headerlink" title="什么是物理像素，逻辑像素和像素密度，为什么在移动端开发时需要用到@3x, @2x这种图片？"></a>什么是物理像素，逻辑像素和像素密度，为什么在移动端开发时需要用到@3x, @2x这种图片？</h2><p>以 iPhone XS 为例，当写 CSS 代码时，针对于单位 px，其宽度为 414px &amp; 896px，也就是说当赋予一个 DIV元素宽度为 414px，这个 DIV 就会填满手机的宽度；</p>
<p>而如果有一把尺子来实际测量这部手机的物理像素，实际为 1242*2688 物理像素；经过计算可知，1242/414=3，也就是说，在单边上，一个逻辑像素=3个物理像素，就说这个屏幕的像素密度为 3，也就是常说的 3 倍屏。</p>
<p>对于图片来说，为了保证其不失真，1 个图片像素至少要对应一个物理像素，假如原始图片是 500300 像素，那么在 3 倍屏上就要放一个 1500900 像素的图片才能保证 1 个物理像素至少对应一个图片像素，才能不失真。</p>
<h2 id="对-CSS-工程化的理解"><a href="#对-CSS-工程化的理解" class="headerlink" title="对 CSS 工程化的理解"></a>对 CSS 工程化的理解</h2><p>CSS 工程化是为了解决以下问题：</p>
<ol>
<li>宏观设计：CSS 代码如何组织、如何拆分、模块结构怎样设计？</li>
<li>编码优化：怎样写出更好的 CSS？</li>
<li>构建：如何处理我的 CSS，才能让它的打包结果最优？</li>
<li>可维护性：代码写完了，如何最小化它后续的变更成本？如何确保任何一个同事都能轻松接手？</li>
</ol>
<p>以下三个方向都是时下比较流行的、普适性非常好的 CSS 工程化实践：</p>
<ol>
<li>预处理器：Less、 Sass 等；</li>
<li>重要的工程化插件： PostCss；</li>
<li>Webpack loader 等 。</li>
</ol>
<h2 id="PostCss：PostCss-是如何工作的？我们在什么场景下会使用-PostCss？"><a href="#PostCss：PostCss-是如何工作的？我们在什么场景下会使用-PostCss？" class="headerlink" title="PostCss：PostCss 是如何工作的？我们在什么场景下会使用 PostCss？"></a>PostCss：PostCss 是如何工作的？我们在什么场景下会使用 PostCss？</h2><p>它和预处理器的不同就在于，预处理器处理的是 类CSS，而 PostCss 处理的就是 CSS 本身。Babel 可以将高版本的 JS 代码转换为低版本的 JS 代码。PostCss 做的是类似的事情：它可以编译尚未被浏览器广泛支持的先进的 CSS 语法，还可以自动为一些需要额外兼容的语法增加前缀。更强的是，由于 PostCss 有着强大的插件机制，支持各种各样的扩展，极大地强化了 CSS 的能力。<br>PostCss 在业务中的使用场景非常多：</p>
<ol>
<li>提高 CSS 代码的可读性：PostCss 其实可以做类似预处理器能做的工作；</li>
<li>当我们的 CSS 代码需要适配低版本浏览器时，PostCss 的 Autoprefixer 插件可以帮助我们自动增加浏览器前缀；</li>
<li>允许我们编写面向未来的 CSS：PostCss 能够帮助我们编译 CSS next 代码；</li>
</ol>
<h2 id="Webpack-能处理-CSS-吗？如何实现？-Webpack-能处理-CSS-吗："><a href="#Webpack-能处理-CSS-吗？如何实现？-Webpack-能处理-CSS-吗：" class="headerlink" title="Webpack 能处理 CSS 吗？如何实现？ Webpack 能处理 CSS 吗："></a>Webpack 能处理 CSS 吗？如何实现？ Webpack 能处理 CSS 吗：</h2><p>· Webpack 在裸奔的状态下，是不能处理 CSS 的，Webpack 本身是一个面向 JavaScript 且只能处理 JavaScript 代码的模块化打包工具；<br>· Webpack 在 loader 的辅助下，是可以处理 CSS 的。</p>
<p>如何用 Webpack 实现对 CSS 的处理：</p>
<ol>
<li>Webpack 中操作 CSS 需要使用的两个关键的 loader：css-loader 和 style-loader</li>
<li>注意，答出“用什么”有时候可能还不够，面试官会怀疑你是不是在背答案，所以你还需要了解每个 loader 都做了什么事情：<br>· css-loader：导入 CSS 模块，对 CSS 代码进行编译处理；<br>· style-loader：创建style标签，把 CSS 内容写入标签。<br>在实际使用中，css-loader 的执行顺序一定要安排在 style-loader 的前面。因为只有完成了编译过程，才可以对 css 代码进行插入；若提前插入了未编译的代码，那么 webpack 是无法理解这坨东西的，它会无情报错。</li>
</ol>
<h2 id="z-index属性在什么情况下会失效"><a href="#z-index属性在什么情况下会失效" class="headerlink" title="z-index属性在什么情况下会失效"></a>z-index属性在什么情况下会失效</h2><p>通常 z-index 的使用是在有两个重叠的标签，在一定的情况下控制其中一个在另一个的上方或者下方出现。z-index值越大就越是在上层。z-index元素的position属性需要是relative，absolute或是fixed。<br>z-index属性在下列情况下会失效：</p>
<ol>
<li>父元素position为relative时，子元素的z-index失效。解决：父元素position改为absolute或static；</li>
<li>元素没有设置position属性为非static属性。解决：设置该元素的position属性为relative，absolute或是fixed中的一种；</li>
<li>元素在设置z-index的同时还设置了float浮动。解决：float去除，改为display：inline-block；</li>
</ol>
<h2 id="px、em、rem的区别及使用场景"><a href="#px、em、rem的区别及使用场景" class="headerlink" title="px、em、rem的区别及使用场景"></a>px、em、rem的区别及使用场景</h2><p>区别:</p>
<ol>
<li>px是固定的像素，一旦设置了就无法因为适应页面大小而改变。</li>
<li>em和rem相对于px更具有灵活性，他们是相对长度单位，其长度不是固定的，更适用于响应式布局。</li>
<li>em是相对于其父元素来设置字体大小，这样就会存在一个问题，进行任何元素设置，都有可能需要知道他父元素的大小。而rem是相对于根元素，这样就意味着，只需要在根元素确定一个参考值。<br>使用场景：</li>
<li>对于只需要适配少部分移动设备，且分辨率对页面影响不大的，使用px即可 。</li>
<li>对于需要适配各种移动设备，使用rem，例如需要适配iPhone和iPad等分辨率差别比较挺大的设备。</li>
</ol>
<h2 id="如何根据设计稿进行移动端适配？"><a href="#如何根据设计稿进行移动端适配？" class="headerlink" title="如何根据设计稿进行移动端适配？"></a>如何根据设计稿进行移动端适配？</h2><p>移动端适配主要有两个维度：</p>
<ol>
<li>适配不同像素密度， 针对不同的像素密度，使用 CSS 媒体查询，选择不同精度的图片，以保证图片不会失真；</li>
<li>适配不同屏幕大小， 由于不同的屏幕有着不同的逻辑像素大小，所以如果直接使用 px 作为开发单位，会使得开发的页面在某一款手机上可以准确显示，但是在另一款手机上就会失真。为了适配不同屏幕的大小，应按照比例来还原设计稿的内容。</li>
</ol>
<p>为了能让页面的尺寸自适应，可以使用 rem，em，vw，vh 等相对单位。</p>
<h2 id="absolute与fixed共同点与不同点"><a href="#absolute与fixed共同点与不同点" class="headerlink" title="absolute与fixed共同点与不同点"></a>absolute与fixed共同点与不同点</h2><p>共同点：</p>
<ol>
<li>改变行内元素的呈现方式，将display置为inline-block  </li>
<li>使元素脱离普通文档流，不再占据文档物理空间</li>
<li>覆盖非定位文档元素</li>
</ol>
<p>不同点：</p>
<ol>
<li>abuselute与fixed的根元素不同，abuselute的根元素可以设置，fixed根元素是浏览器。</li>
<li>在有滚动条的页面中，absolute会跟着父元素进行移动，fixed固定在页面的具体位置。</li>
</ol>
<h2 id="对-sticky-定位的理解"><a href="#对-sticky-定位的理解" class="headerlink" title="对 sticky 定位的理解"></a>对 sticky 定位的理解</h2><p>sticky 英文字面意思是粘贴，所以可以把它称之为粘性定位。语法：position: sticky; 基于用户的滚动位置来定位。<br>粘性定位的元素是依赖于用户的滚动，在 position:relative 与 position:fixed 定位之间切换。它的行为就像 position:relative; 而当页面滚动超出目标区域时，它的表现就像 position:fixed;，它会固定在目标位置。元素定位表现为在跨越特定阈值前为相对定位，之后为固定定位。这个特定阈值指的是 top, right, bottom 或 left 之一，换言之，指定 top, right, bottom 或 left 四个阈值其中之一，才可使粘性定位生效。否则其行为与相对定位相同。</p>
<h2 id="实现一个扇形"><a href="#实现一个扇形" class="headerlink" title="实现一个扇形"></a>实现一个扇形</h2><p>用CSS实现扇形的思路和三角形基本一致，就是多了一个圆角的样式，实现一个90°的扇形：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">div&#123;</span><br><span class="line">    border: 100px solid transparent;</span><br><span class="line">    width: 0;</span><br><span class="line">    heigt: 0;</span><br><span class="line">    border-radius: 100px;</span><br><span class="line">    border-top-color: red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="如何解决-1px-问题？"><a href="#如何解决-1px-问题？" class="headerlink" title="如何解决 1px 问题？"></a>如何解决 1px 问题？</h2><p>1px 问题指的是：在一些 Retina屏幕 的机型上，移动端页面的 1px 会变得很粗，呈现出不止 1px 的效果。原因很简单——CSS 中的 1px 并不能和移动设备上的 1px 划等号。它们之间的比例关系有一个专门的属性来描述：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">window.devicePixelRatio = 设备的物理像素 / CSS像素。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>打开 Chrome 浏览器，启动移动端调试模式，在控制台去输出这个 devicePixelRatio 的值。这里选中 iPhone6/7/8 这系列的机型，输出的结果就是2：<br>这就意味着设置的 1px CSS 像素，在这个设备上实际会用 2 个物理像素单元来进行渲染，所以实际看到的一定会比 1px 粗一些。 解决1px 问题的三种思路：</p>
<ol>
<li>思路一：直接写 0.5px<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">border:1px solid #333</span><br><span class="line"></span><br><span class="line">&lt;div id=&quot;container&quot; data-device=&#123;&#123;window.devicePixelRatio&#125;&#125;&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">#container[data-device=&quot;2&quot;] &#123;</span><br><span class="line">  border:0.5px solid #333</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>思路二：伪元素先放大后缩小<br>这个方法的可行性会更高，兼容性也更好。唯一的缺点是代码会变多。<br>思路是先放大、后缩小：在目标元素的后面追加一个 ::after 伪元素，让这个元素布局为 absolute 之后、整个伸展开铺在目标元素上，然后把它的宽和高都设置为目标元素的两倍，border值设为 1px。接着借助 CSS 动画特效中的放缩能力，把整个伪元素缩小为原来的 50%。此时，伪元素的宽高刚好可以和原有的目标元素对齐，而 border 也缩小为了 1px 的二分之一，间接地实现了 0.5px 的效果。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#container[data-device=&quot;2&quot;] &#123;</span><br><span class="line">    position: relative;</span><br><span class="line">&#125;</span><br><span class="line">#container[data-device=&quot;2&quot;]::after&#123;</span><br><span class="line">      position:absolute;</span><br><span class="line">      top: 0;</span><br><span class="line">      left: 0;</span><br><span class="line">      width: 200%;</span><br><span class="line">      height: 200%;</span><br><span class="line">      content:&quot;&quot;;</span><br><span class="line">      transform: scale(0.5);</span><br><span class="line">      transform-origin: left top;</span><br><span class="line">      box-sizing: border-box;</span><br><span class="line">      border: 1px solid #333;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>思路三：viewport 缩放来解决</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;meta name=&quot;viewport&quot; content=&quot;initial-scale=0.5, maximum-scale=0.5, minimum-scale=0.5, user-scalable=no&quot;&gt;</span><br><span class="line"></span><br><span class="line">const scale = 1 / window.devicePixelRatio;</span><br><span class="line">// 这里 metaEl 指的是 meta 标签对应的 Dom</span><br><span class="line">metaEl.setAttribute(&#x27;content&#x27;, `width=device-width,user-scalable=no,initial-scale=$&#123;scale&#125;,maximum-scale=$&#123;scale&#125;,minimum-scale=$&#123;scale&#125;`);</span><br><span class="line"></span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>css</category>
      </categories>
  </entry>
</search>
