<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>js实现call, apply, bind方法</title>
    <url>/2021/08/19/js%E5%AE%9E%E7%8E%B0call,%20apply,%20bind%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>#实现call方法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;叫爸爸&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> son = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;叫儿子&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="built_in">this</span>.name) </span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Function</span>.prototype.call_ = <span class="function"><span class="keyword">function</span> (<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//判断是否为null或者undefined,同时考虑传递参数不是对象情况</span></span><br><span class="line">    obj = obj ? <span class="built_in">Object</span>(obj) : <span class="built_in">window</span>;</span><br><span class="line">    <span class="keyword">var</span> args = [];</span><br><span class="line">    <span class="comment">// 注意i从1开始</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>, len = <span class="built_in">arguments</span>.length; i &lt; len; i++) &#123;</span><br><span class="line">        args.push(<span class="built_in">arguments</span>[i])</span><br><span class="line">    &#125;;</span><br><span class="line">    obj.fn = <span class="built_in">this</span>; <span class="comment">// 此时this就是函数fn</span></span><br><span class="line">    obj.fn(...args)</span><br><span class="line">    <span class="keyword">delete</span> obj.fn; <span class="comment">//删除fn</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>#实现apply方法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;叫爸爸&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> son = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;叫儿子&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="built_in">this</span>.name) </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Function</span>.prototype.apply_ = <span class="function"><span class="keyword">function</span> (<span class="params">obj, arr</span>) </span>&#123;</span><br><span class="line">    obj = obj ? <span class="built_in">Object</span>(obj): <span class="built_in">window</span></span><br><span class="line">    obj.fn = <span class="built_in">this</span></span><br><span class="line">    <span class="keyword">if</span> (!arr) &#123;</span><br><span class="line">        obj.fn();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> args = [];</span><br><span class="line">        <span class="comment">// 注意i从1开始</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>, len = <span class="built_in">arguments</span>.length; i &lt; len; i++) &#123;</span><br><span class="line">            args.push(<span class="built_in">arguments</span>[i])</span><br><span class="line">        &#125;;</span><br><span class="line">        obj.fn(...args)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span> obj.fn</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>#实现bind方法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;叫爸爸&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> son = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;叫儿子&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="built_in">this</span>.name) </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Function</span>.prototype.bind_ = <span class="function"><span class="keyword">function</span> (<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//判断是否为null或者undefined,同时考虑传递参数不是对象情况</span></span><br><span class="line">    obj = obj ? <span class="built_in">Object</span>(obj) : <span class="built_in">window</span>;</span><br><span class="line">    <span class="keyword">var</span> args = [];</span><br><span class="line">    <span class="comment">// 注意i从1开始</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>, len = <span class="built_in">arguments</span>.length; i &lt; len; i++) &#123;</span><br><span class="line">        args.push(<span class="built_in">arguments</span>[i])</span><br><span class="line">    &#125;;</span><br><span class="line">    obj.fn = <span class="built_in">this</span>; <span class="comment">// 此时this就是函数fn</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        obj.fn(...args)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>js基础</category>
      </categories>
  </entry>
  <entry>
    <title>this指向</title>
    <url>/2021/07/06/this%E6%8C%87%E5%90%91/</url>
    <content><![CDATA[<p>面向对象语言中 this 表示当前对象的一个引用。</p>
<p>但在 JavaScript 中 this 不是固定不变的，它会随着执行环境的改变而改变。</p>
<ul>
<li>在方法中，this 表示该方法所属的对象。</li>
</ul>
<ul>
<li>如果单独使用，this 表示全局对象。</li>
</ul>
<ul>
<li>在函数中，this 表示全局对象。</li>
</ul>
<ul>
<li>在函数中，在严格模式下，this 是未定义的(undefined)。</li>
</ul>
<ul>
<li>在事件中，this 表示接收事件的元素。</li>
</ul>
<ul>
<li>类似 call() 和 apply() 方法可以将 this 引用到任何对象。</li>
</ul>
<h2 id="方法中的this"><a href="#方法中的this" class="headerlink" title="方法中的this"></a>方法中的this</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  <span class="attr">firstName</span>: <span class="string">&quot;John&quot;</span>,</span><br><span class="line">  <span class="attr">lastName</span> : <span class="string">&quot;Doe&quot;</span>,</span><br><span class="line">  <span class="attr">fullName</span> : <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.firstName + <span class="string">&quot; &quot;</span> + <span class="built_in">this</span>.lastName;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">person.fullName() <span class="comment">// John Doe</span></span><br></pre></td></tr></table></figure>
<p>在对象方法中， this 指向调用它所在方法的对象。</p>
<p>在上面一个实例中，this 表示 person 对象。</p>
<p>fullName 方法所属的对象就是 person。</p>
<h2 id="单独使用-this"><a href="#单独使用-this" class="headerlink" title="单独使用 this"></a>单独使用 this</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person = <span class="built_in">this</span> <span class="comment">// [object Window]</span></span><br></pre></td></tr></table></figure>
<p>单独使用 this，则它指向全局(Global)对象。</p>
<p>在浏览器中，window 就是该全局对象为 [object Window]:</p>
<p>ps: 严格模式下，如果单独使用，this 也是指向全局(Global)对象。</p>
<h2 id="函数中使用-this（默认）"><a href="#函数中使用-this（默认）" class="headerlink" title="函数中使用 this（默认）"></a>函数中使用 this（默认）</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myFunction</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>; <span class="comment">// [object Window]</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在函数中，函数的所属者默认绑定到 this 上。</p>
<p>在浏览器中，window 就是该全局对象为 [object Window]:</p>
<p>ps: 严格模式下，函数是没有绑定到this下，this是undefined</p>
<h2 id="事件中的-this"><a href="#事件中的-this" class="headerlink" title="事件中的 this"></a>事件中的 this</h2><p>在 HTML 事件句柄中，this 指向了接收事件的 HTML 元素：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;button onclick=<span class="string">&quot;this =&gt; buttonHtml对象&quot;</span>&gt;</span><br><span class="line">点我</span><br><span class="line">&lt;/button&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="对象方法中绑定"><a href="#对象方法中绑定" class="headerlink" title="对象方法中绑定"></a>对象方法中绑定</h2><p>下面实例中，this 是 person 对象，person 对象是函数的所有者：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  <span class="attr">firstName</span>  : <span class="string">&quot;John&quot;</span>,</span><br><span class="line">  <span class="attr">lastName</span>   : <span class="string">&quot;Doe&quot;</span>,</span><br><span class="line">  <span class="attr">id</span>         : <span class="number">5566</span>,</span><br><span class="line">  <span class="attr">myFunction</span> : <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">person.myFunction() <span class="comment">// [object Object]</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="显式函数绑定"><a href="#显式函数绑定" class="headerlink" title="显式函数绑定"></a>显式函数绑定</h2><p>在 JavaScript 中函数也是对象，对象则有方法，apply 和 call 就是函数对象的方法。</p>
<p>这两个方法异常强大，他们允许切换函数执行的上下文环境（context），即 this 绑定的对象。<br>在下面实例中，当我们使用 person2 作为参数来调用 person1.fullName 方法时, this 将指向 person2, 即便它是 person1 的方法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person1 = &#123;</span><br><span class="line">  <span class="attr">fullName</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.firstName + <span class="string">&quot; &quot;</span> + <span class="built_in">this</span>.lastName;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person2 = &#123;</span><br><span class="line">  <span class="attr">firstName</span>:<span class="string">&quot;John&quot;</span>,</span><br><span class="line">  <span class="attr">lastName</span>: <span class="string">&quot;Doe&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line">person1.fullName.call(person2);  <span class="comment">// 返回 &quot;John Doe&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="隐式绑定"><a href="#隐式绑定" class="headerlink" title="隐式绑定"></a>隐式绑定</h2><p>什么是隐式绑定呢，如果函数调用时，前面存在调用它的对象，那么this就会隐式绑定到这个对象上。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;听风是风&#x27;</span>,</span><br><span class="line">    <span class="attr">func</span>: fn</span><br><span class="line">&#125;;</span><br><span class="line">obj.func() <span class="comment">//听风是风</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如果函数调用前存在多个对象，this指向距离调用自己最近的对象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;行星飞行&#x27;</span>,</span><br><span class="line">    <span class="attr">func</span>: fn,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> obj1 = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;听风是风&#x27;</span>,</span><br><span class="line">    <span class="attr">o</span>: obj</span><br><span class="line">&#125;;</span><br><span class="line">obj1.o.func() <span class="comment">//行星飞行</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>那如果我们将obj对象的name属性注释掉，现在输出什么呢？</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    <span class="attr">func</span>: fn,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> obj1 = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;听风是风&#x27;</span>,</span><br><span class="line">    <span class="attr">o</span>: obj</span><br><span class="line">&#125;;</span><br><span class="line">obj1.o.func() <span class="comment">// undefined</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>大家千万不要将作用域链和原型链弄混淆了，obj对象虽然obj1的属性，但它两原型链并不相同，并不是父子关系，由于obj未提供name属性，所以是undefined。</p>
<p>既然说到原型链，那我们再来点花哨的，我们再改写例子，看看下面输出多少：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fn</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">Fn.prototype.name = <span class="string">&#x27;时间跳跃&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = <span class="keyword">new</span> Fn();</span><br><span class="line">obj.func = fn;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj1 = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;听风是风&#x27;</span>,</span><br><span class="line">    <span class="attr">o</span>: obj</span><br><span class="line">&#125;;</span><br><span class="line">obj1.o.func() <span class="comment">//时间跳跃</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里输出时间跳跃，虽然obj对象并没有name属性，但顺着原型链，找到了产生自己的构造函数Fn，由于Fn原型链存在name属性，所以输出时间跳跃了。</p>
<h2 id="隐式丢失"><a href="#隐式丢失" class="headerlink" title="隐式丢失"></a>隐式丢失</h2><p>在特定情况下会存在隐式绑定丢失的问题，最常见的就是作为参数传递以及变量赋值，先看参数传递：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;行星飞行&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;听风是风&#x27;</span>,</span><br><span class="line">    <span class="attr">fn</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params">param</span>) </span>&#123;</span><br><span class="line">    param();</span><br><span class="line">&#125;;</span><br><span class="line">fn1(obj.fn);<span class="comment">//行星飞行</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这个例子中我们将 obj.fn 也就是一个函数传递进 fn1 中执行，这里只是单纯传递了一个函数而已，this并没有跟函数绑在一起，所以this丢失这里指向了window。</p>
<p>第二个引起丢失的问题是变量赋值，其实本质上与传参相同，看这个例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;行星飞行&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;听风是风&#x27;</span>,</span><br><span class="line">    <span class="attr">fn</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> fn1 = obj.fn;</span><br><span class="line">fn1(); <span class="comment">//行星飞行</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>注意，隐式绑定丢失并不是都会指向全局对象，比如下面的例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;行星飞行&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;听风是风&#x27;</span>,</span><br><span class="line">    <span class="attr">fn</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> obj1 = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;时间跳跃&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">obj1.fn = obj.fn;</span><br><span class="line">obj1.fn(); <span class="comment">//时间跳跃</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>虽然丢失了 obj 的隐式绑定，但是在赋值的过程中，又建立了新的隐式绑定，这里this就指向了对象 obj1。</p>
<h2 id="new绑定"><a href="#new绑定" class="headerlink" title="new绑定"></a>new绑定</h2><p>准确来说，js中的构造函数只是使用new 调用的普通函数，它并不是一个类，最终返回的对象也不是一个实例，只是为了便于理解习惯这么说罢了。</p>
<p>那么new一个函数究竟发生了什么呢，大致分为三步：</p>
<ul>
<li>以构造器的prototype属性为原型，创建新对象；</li>
<li>将this(可以理解为上句创建的新对象)和调用参数传给构造器，执行；</li>
<li>如果构造器没有手动返回对象，则返回第一步创建的对象</li>
</ul>
<p>这个过程我们称之为构造调用，我们来看个例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = <span class="string">&#x27;听风是风&#x27;</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> echo = <span class="keyword">new</span> Fn();</span><br><span class="line">echo.name<span class="comment">//听风是风</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在上方代码中，构造调用创建了一个新对象echo，而在函数体内，this将指向新对象echo上（可以抽象理解为新对象就是this）。</p>
<h2 id="this绑定优先级"><a href="#this绑定优先级" class="headerlink" title="this绑定优先级"></a>this绑定优先级</h2><p>显式绑定 &gt; 隐式绑定 &gt; 默认绑定</p>
<p>new绑定 &gt; 隐式绑定 &gt; 默认绑定</p>
<p>为什么显式绑定不和new绑定比较呢？因为不存在这种绑定同时生效的情景，如果同时写这两种代码会直接抛错，所以大家只用记住上面的规律即可。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = <span class="string">&#x27;听风是风&#x27;</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    <span class="attr">name</span>:<span class="string">&#x27;行星飞行&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> echo = <span class="keyword">new</span> Fn().call(obj);<span class="comment">//报错 call is not a function</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>那么我们结合几个例子来验证下上面的规律，首先是显式大于隐式：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//显式&gt;隐式</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    <span class="attr">name</span>:<span class="string">&#x27;行星飞行&#x27;</span>,</span><br><span class="line">    <span class="attr">fn</span>:<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">obj1 = &#123;</span><br><span class="line">    <span class="attr">name</span>:<span class="string">&#x27;时间跳跃&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line">obj.fn.call(obj1);<span class="comment">// 时间跳跃</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>其次是new绑定大于隐式：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//new&gt;隐式</span></span><br><span class="line">obj = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;时间跳跃&#x27;</span>,</span><br><span class="line">    <span class="attr">fn</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name = <span class="string">&#x27;听风是风&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> echo = <span class="keyword">new</span> obj.fn();</span><br><span class="line">echo.name;<span class="comment">//听风是风</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="箭头函数的this"><a href="#箭头函数的this" class="headerlink" title="箭头函数的this"></a>箭头函数的this</h2><p>ES6的箭头函数是另类的存在，为什么要单独说呢，这是因为箭头函数中的this不适用上面介绍的四种绑定规则。</p>
<p>准确来说，箭头函数中没有this，箭头函数的this指向取决于外层作用域中的this，外层作用域或函数的this指向谁，箭头函数中的this便指向谁。有点吃软饭的嫌疑，一点都不硬朗，我们来看个例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> obj1 = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;听风是风&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> obj2 = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;时间跳跃&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> bar = fn.call(obj1); <span class="comment">// fn this指向obj1</span></span><br><span class="line">bar.call(obj2); <span class="comment">//听风是风</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>为啥我们第一次绑定this并返回箭头函数后，再次改变this指向没生效呢？</p>
<p>前面说了，箭头函数的this取决于外层作用域的this，fn函数执行时this指向了obj1，所以箭头函数的this也指向obj1。除此之外，箭头函数this还有一个特性，那就是一旦箭头函数的this绑定成功，也无法被再次修改，有点硬绑定的意思。</p>
<p>当然，箭头函数的this也不是真的无法修改，我们知道箭头函数的this就像作用域继承一样从上层作用域找，因此我们可以修改外层函数this指向达到间接修改箭头函数this的目的。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> obj1 = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;听风是风&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> obj2 = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;时间跳跃&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line">fn.call(obj1)(); <span class="comment">// fn this指向obj1,箭头函数this也指向obj1</span></span><br><span class="line">fn.call(obj2)(); <span class="comment">//fn this 指向obj2,箭头函数this也指向obj2</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>js基础</category>
      </categories>
  </entry>
  <entry>
    <title>作用域</title>
    <url>/2018/07/06/%E4%BD%9C%E7%94%A8%E5%9F%9F/</url>
    <content><![CDATA[<h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><h3 id="什么是作用域？"><a href="#什么是作用域？" class="headerlink" title="什么是作用域？"></a>什么是作用域？</h3><p>作用域为可访问变量，对象，函数的集合。</p>
<p>作用域就是变量与函数的可访问范围，即作用域控制着变量与函数的可见性和生命周期。</p>
<p>在js中，变量的作用域分为全局作用域和局部作用域两种。<br>一个变量是全局作用域还是局部作用域，主要看变量声明的位置。</p>
<h4 id="全局作用域："><a href="#全局作用域：" class="headerlink" title="全局作用域："></a>全局作用域：</h4><ol>
<li>最外层函数和在最外层函数外面定义的变量</li>
<li>没有通过关键字”var”声明的变量</li>
<li>浏览器中，window对象的属性</li>
</ol>
<h4 id="局部作用域"><a href="#局部作用域" class="headerlink" title="局部作用域"></a>局部作用域</h4><ol>
<li>在函数内部就是局部作用域，这个代码的名字只在函数的内部起作用</li>
<li>调用函数时创建函数作用域，函数执行完毕之后，函数作用域销毁；</li>
<li>每调用一次函数就会创建一个新的函数作用域，它们之间是相互独立的。</li>
</ol>
<h3 id="块级作用域"><a href="#块级作用域" class="headerlink" title="块级作用域"></a>块级作用域</h3><p>在ES6中新增加了一个作用域就是会计作用域，通过let和const声明。那块级作用域什么情况下被创建内？答案如下</p>
<p>在一个函数内部</p>
<p>在一个代码块内部（{}包裹的代码块）</p>
<p>let声明的愈发与var的语法一致，基本上可以用let代替var,但会讲变量的作用域限制在当前代码块中。</p>
<p>块级作用域的特点：</p>
<p>声明变量不会提升到代码块顶部</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Scope</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(scope) <span class="comment">// Uncaught ReferenceError: value is not defined</span></span><br><span class="line"><span class="keyword">let</span> scope = <span class="string">&quot;块级&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(scope) <span class="comment">// 块级</span></span><br><span class="line">&#125;</span><br><span class="line">Scope()</span><br></pre></td></tr></table></figure>

<p>禁止重复声明</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Scope</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">let</span> scope = <span class="string">&#x27;a&#x27;</span></span><br><span class="line"> <span class="comment">//let scope = &#x27;b&#x27; // Uncaught SyntaxError: Identifier &#x27;scope&#x27; has already been declared</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>小技巧：在循环中可以用let const声明变量</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i&lt; <span class="number">100</span>; i++)&#123;&#125;</span><br><span class="line"><span class="built_in">console</span>.log(i) <span class="comment">// Uncaught ReferenceError: i is not defined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i&lt; <span class="number">100</span>; i++)&#123;&#125;</span><br><span class="line"><span class="built_in">console</span>.log(i) <span class="comment">// 100</span></span><br></pre></td></tr></table></figure>


<h3 id="作用域的目的"><a href="#作用域的目的" class="headerlink" title="作用域的目的"></a>作用域的目的</h3><p>是为了提高程序的可靠性，更重要的是减少命名冲突</p>
<h3 id="变量的作用域"><a href="#变量的作用域" class="headerlink" title="变量的作用域"></a>变量的作用域</h3><p>在js中，根据作用域的不同，变量可以分为两种：<strong>全局变量</strong>和<strong>局部变量</strong></p>
<h4 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h4><ul>
<li>在全局作用域下声明的变量叫做全局变量</li>
<li>全局变量在全局任何位置都可以使用，全局作用域中无法访问到局部作用域中的变量<h4 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h4></li>
<li>在局部作用域下声明的变量叫做局部变量</li>
<li>局部变量只能在函数内部使用，在局部作用域中可以访问到全局变量</li>
</ul>
<h2 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h2><p>在js代码运行中，所有用到的变量都需要去当前上下文环境中查找，当找不到的时候，就会继续查找上层的环境变量。<br>这样一级一级向上查找的过程，就组合成了一个作用域链。</p>
<p>所以说，<strong>作用域链</strong>与一个<strong>执行上下文</strong>相关，是内部上下文所有变量对象（包含父变量对象）的列表，用于变量查询。</p>
]]></content>
      <categories>
        <category>js基础</category>
      </categories>
  </entry>
  <entry>
    <title>冒泡排序</title>
    <url>/2021/08/25/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h2 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h2><ol>
<li><p>比较相邻的元素。如果第一个比第二个大，就交换他们两个。</p>
</li>
<li><p>对每一对相邻元素做同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。</p>
</li>
<li><p>针对所有的元素重复以上的步骤，除了最后一个。</p>
</li>
<li><p>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比比较</p>
</li>
</ol>
<h2 id="动图演示"><a href="#动图演示" class="headerlink" title="动图演示"></a>动图演示</h2><p><img src="/.io//1.jpeg" alt="原理图"></p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">40</span>, <span class="number">60</span>, <span class="number">60</span>, <span class="number">0</span>, <span class="number">30</span>]</span><br><span class="line"><span class="comment">// 编写方法，实现冒泡</span></span><br><span class="line"><span class="comment">//外层循环，控制趟数，每一次找到一个最大值</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">    <span class="comment">// 内层循环,控制比较的次数，并且判断两个数的大小</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; arr.length - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">        <span class="comment">// 白话解释：如果前面的数大，放到后面(当然是从小到大的冒泡排序)</span></span><br><span class="line">        <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">var</span> temp = arr[j];</span><br><span class="line">            arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">            arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(arr);</span><br></pre></td></tr></table></figure>

<h2 id="性能分析："><a href="#性能分析：" class="headerlink" title="性能分析："></a>性能分析：</h2><p>时间复杂度: O(N^2)<br>空间复杂度: O(1)<br>稳定性：稳定</p>
]]></content>
      <categories>
        <category>js基础</category>
      </categories>
  </entry>
  <entry>
    <title>call、 bind、apply区别</title>
    <url>/2021/08/19/call%E3%80%81apply%E5%92%8Cbind%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h1 id="call、-bind、apply区别"><a href="#call、-bind、apply区别" class="headerlink" title="call、 bind、apply区别"></a>call、 bind、apply区别</h1><p>我们都知道call apply bind都可以改变函数调用的this指向。那么它们三者有什么区别，什么时候该用哪个呢？</p>
<p>我们先来看MDN语法说明</p>
<h2 id="语法说明"><a href="#语法说明" class="headerlink" title="语法说明"></a>语法说明</h2><h3 id="1-call语法"><a href="#1-call语法" class="headerlink" title="1. call语法"></a>1. call语法</h3><ul>
<li>fun.call(thisArg, arg1, arg2, …)</li>
<li>thisArg: 在fun函数运行时指定的this值。需要注意的是，指定的this值并不一定是该函数执行时真正的this值，如果这个函数处于非严格模式下，则指定为null和undefined的this值会自动指向全局对象(浏览器中就是window对象)，同时值为原始值(数字，字符串，布尔值)的this会指向该原始值的自动包装对象。</li>
<li>arg1, arg2, … 指定的参数列表</li>
</ul>
<h3 id="2-apply语法"><a href="#2-apply语法" class="headerlink" title="2. apply语法"></a>2. apply语法</h3><ul>
<li>fun.apply(thisArg, [argsArray])</li>
<li>thisArg 在 fun 函数运行时指定的 this 值。需要注意的是，指定的 this 值并不一定是该函数执行时真正的 this 值，如果这个函数处于非严格模式下，则指定为 null 或 undefined 时会自动指向全局对象（浏览器中就是window对象），同时值为原始值（数字，字符串，布尔值）的 this 会指向该原始值的自动包装对象。</li>
<li>argsArray 一个数组或者类数组对象，其中的数组元素将作为单独的参数传给 fun 函数。如果该参数的值为null 或 undefined，则表示不需要传入任何参数。从ECMAScript 5 开始可以使用类数组对象。</li>
</ul>
<h3 id="3-bind语法"><a href="#3-bind语法" class="headerlink" title="3. bind语法"></a>3. bind语法</h3><ul>
<li>fun.bind(thisArg[, arg1[, arg2[, …]]])</li>
<li>thisArg 当绑定函数被调用时，该参数会作为原函数运行时的 this 指向。当使用new 操作符调用绑定函数时，该参数无效。</li>
<li>arg1, arg2, … 当绑定函数被调用时，这些参数将置于实参之前传递给被绑定的方法。</li>
</ul>
<h2 id="例子说明"><a href="#例子说明" class="headerlink" title="例子说明"></a>例子说明</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 有只猫叫小黑，小黑会吃鱼</span></span><br><span class="line"><span class="keyword">const</span> cat = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;小黑&#x27;</span>,</span><br><span class="line">    <span class="function"><span class="title">eatFish</span>(<span class="params">...args</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;this指向=&gt;&#x27;</span>, <span class="built_in">this</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;...args&#x27;</span>, args);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.name + <span class="string">&#x27;吃鱼&#x27;</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 有只狗叫大毛，大毛会吃骨头</span></span><br><span class="line"><span class="keyword">const</span> dog = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;大毛&#x27;</span>,</span><br><span class="line">    <span class="function"><span class="title">eatBone</span>(<span class="params">...args</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;this指向=&gt;&#x27;</span>, <span class="built_in">this</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;...args&#x27;</span>, args);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.name + <span class="string">&#x27;吃骨头&#x27;</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;=================== call =========================&#x27;</span>);</span><br><span class="line"><span class="comment">// 有一天大毛想吃鱼了，可是它不知道怎么吃。怎么办？小黑说我吃的时候喂你吃</span></span><br><span class="line">cat.eatFish.call(dog, <span class="string">&#x27;汪汪汪&#x27;</span>, <span class="string">&#x27;call&#x27;</span>)</span><br><span class="line"><span class="comment">// 大毛为了表示感谢，决定下次吃骨头的时候也喂小黑吃</span></span><br><span class="line">dog.eatBone.call(cat, <span class="string">&#x27;喵喵喵&#x27;</span>, <span class="string">&#x27;call&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;=================== apply =========================&#x27;</span>);</span><br><span class="line">cat.eatFish.apply(dog, [<span class="string">&#x27;汪汪汪&#x27;</span>, <span class="string">&#x27;apply&#x27;</span>])</span><br><span class="line">dog.eatBone.apply(cat, [<span class="string">&#x27;喵喵喵&#x27;</span>, <span class="string">&#x27;apply&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;=================== bind =========================&#x27;</span>);</span><br><span class="line"><span class="comment">// 有一天他们觉得每次吃的时候再喂太麻烦了。干脆直接教对方怎么吃</span></span><br><span class="line"><span class="keyword">const</span> test1 = cat.eatFish.bind(dog, <span class="string">&#x27;汪汪汪&#x27;</span>, <span class="string">&#x27;bind&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> test2 = dog.eatBone.bind(cat, <span class="string">&#x27;喵喵喵&#x27;</span>, <span class="string">&#x27;bind&#x27;</span>)</span><br><span class="line">test1()</span><br><span class="line">test2()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><p>call跟apply的用法几乎一样，唯一的不同就是传递的参数不同，call只能一个参数一个参数的传入。</p>
</li>
<li><p>apply则只支持传入一个数组，哪怕是一个参数也要是数组形式。最终调用函数时候这个数组会拆成一个个参数分别传入。</p>
</li>
<li><p>至于bind方法，他是直接改变这个函数的this指向并且返回一个新的函数，之后再次调用这个函数的时候this都是指向bind绑定的第一个参数。bind传餐方式跟call方法一致。</p>
</li>
</ul>
<p>由于apply函数传参的特殊性，我们又衍生出了一个黑魔法。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 如果一个数组我们已知里面全都是数字，想要知道最大的那个数，由于Array没有max方法，Math对象上有</span></span><br><span class="line"><span class="comment">// 我们可以根据apply传递参数的特性将这个数组当成参数传入</span></span><br><span class="line"><span class="comment">// 最终Math.max函数调用的时候会将apply的数组里面的参数一个一个传入，恰好符合Math.max的参数传递方式</span></span><br><span class="line"><span class="comment">// 这样变相的实现了数组的max方法。min方法也同理</span></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line"><span class="keyword">const</span> max = <span class="built_in">Math</span>.max.apply(<span class="literal">null</span>, arr)</span><br><span class="line"><span class="built_in">console</span>.log(max)    <span class="comment">// 6</span></span><br></pre></td></tr></table></figure>

<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>箭头函数没有this，会忽律第一个参数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> cat = &#123;</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&quot;小黑&quot;</span>,</span><br><span class="line">        <span class="attr">eatFish</span>: <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;this 指向=》&quot;</span>, <span class="built_in">this</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;...args=&gt;&quot;</span>, args);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.name + <span class="string">&quot;吃鱼&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> dog = &#123;</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&quot;大毛&quot;</span>,</span><br><span class="line">        <span class="function"><span class="title">eatBone</span>(<span class="params">...args</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&quot;this 指向=》&quot;</span>, <span class="built_in">this</span>);</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&quot;...args=&gt;&quot;</span>, args);</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="built_in">this</span>.name + <span class="string">&quot;吃骨头&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cat.eatFish.call(dog, <span class="string">&quot;1&quot;</span>, <span class="string">&quot;2&quot;</span>)</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>call 和 apply 的主要作用，是改变对象的执行上下文，并且是立即执行的。它们在参数上的写法略有区别。</p>
<p>bind 也能改变对象的执行上下文，它与 call 和 apply 不同的是，返回值是一个函数，并且需要稍后再调用一下，才会执行。</p>
]]></content>
      <categories>
        <category>js基础</category>
      </categories>
  </entry>
  <entry>
    <title>创建对象方式</title>
    <url>/2018/07/06/%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<p>在 JavaScript 中创建对象的可行方法有哪些？</p>
<h2 id="1、对象的构造函数"><a href="#1、对象的构造函数" class="headerlink" title="1、对象的构造函数"></a>1、对象的构造函数</h2><p>创建空对象的最简单方法是使用object构造函数，目前不推荐这种方法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = <span class="keyword">new</span> object() <span class="comment">// 对象构造函数</span></span><br></pre></td></tr></table></figure>
<h2 id="2、对象的创建方法："><a href="#2、对象的创建方法：" class="headerlink" title="2、对象的创建方法："></a>2、对象的创建方法：</h2><p>Object的create方法通过将原型对象作为参数传递来创建一个新对象</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = <span class="built_in">Object</span>.create(<span class="literal">null</span>)</span><br></pre></td></tr></table></figure>
<h2 id="3、对象字面量语法"><a href="#3、对象字面量语法" class="headerlink" title="3、对象字面量语法"></a>3、对象字面量语法</h2><p>当传递null作为参数时，对象字面量语法等效于create方法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4、函数构造器"><a href="#4、函数构造器" class="headerlink" title="4、函数构造器"></a>4、函数构造器</h2><p>创建任何函数并应用new运算符来创建对象实例</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> obj = &#123;&#125;</span><br><span class="line">    obj.name = name</span><br><span class="line">    <span class="keyword">return</span> obj</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> obj1 = <span class="keyword">new</span> Person(<span class="string">&quot;哈哈&quot;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="5、带有原型的函数构造函数"><a href="#5、带有原型的函数构造函数" class="headerlink" title="5、带有原型的函数构造函数"></a>5、带有原型的函数构造函数</h2><p>这类似于函数构造函数，但它使用原型作为其属性和方法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">Person.prototype.name = <span class="string">&quot;哈哈&quot;</span></span><br><span class="line"><span class="keyword">var</span> obj = New Person()</span><br></pre></td></tr></table></figure>

<h2 id="6、es6类语法"><a href="#6、es6类语法" class="headerlink" title="6、es6类语法"></a>6、es6类语法</h2><p>es6引入类特性来创建对象</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="title">construtor</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> object = <span class="keyword">new</span> Person(<span class="string">&quot;哈哈&quot;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="7、单例模式"><a href="#7、单例模式" class="headerlink" title="7、单例模式"></a>7、单例模式</h2><p>Singleton是一个只能实例化一次的对象。对其构造函数的重复调用返回相同的实例，这样可以确保它们不会意外创建多个实例</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = <span class="keyword">new</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = <span class="string">&quot;哈哈&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>js基础</category>
      </categories>
  </entry>
  <entry>
    <title>原型及原型链</title>
    <url>/2018/07/06/%E5%8E%9F%E5%9E%8B%E5%8F%8A%E5%8E%9F%E5%9E%8B%E9%93%BE/</url>
    <content><![CDATA[<h2 id="prototype"><a href="#prototype" class="headerlink" title="prototype"></a>prototype</h2><p>每一个js对象(null除外)在创建的时候就会与之关联另一个对象【Prototype】，这个对象就是我们所说的原型。每个对象都会从原型“继承”属性。</p>
<p>举个例子</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line"><span class="attr">name</span>: <span class="string">&quot;zhangsan&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> newObj = <span class="built_in">Object</span>.create(obj)</span><br><span class="line"></span><br><span class="line">newObj.name <span class="comment">// zhangsan</span></span><br></pre></td></tr></table></figure>


<p>上述例子中，newObj对象的【Prototype】属性引用了obj对象，也就是说newObj对象的【Prototype】指向了obj对象，并继承了obj的属性。</p>
<p>几乎所有的对象在创建时【Prototype】属性都会被赋予非空的值，由【Prototype】串联起来的对象的关系链条我们就称为【Prototype】链也就是原型链，一般情况下【Prototype】链的最顶层是Object.prototype</p>
<p>每个函数都有一个 prototype 属性。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.name = <span class="string">&quot;zhangsan&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person()</span><br><span class="line"></span><br><span class="line">person.name <span class="comment">// zhangsan</span></span><br></pre></td></tr></table></figure>

<p><img src="/.io//1.png"></p>
<h2 id="proto"><a href="#proto" class="headerlink" title="proto"></a>proto</h2><p>每一个js对象（除null）都具有一个属性叫proto，这个属性会指向改对象的原型。</p>
<p>对象可以通过__proto__访问内部的【Prototype】属性，即我们可以通过__proto__访问对象的原型。</p>
<p>ps: __proto__是一种非标准的方法，实际开发中我们应该使用Object.getPrototypeOf()来获取对象的原型</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person();</span><br><span class="line"></span><br><span class="line">person.__proto__ === Person.prototype <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p><img src="/.io//2.png"></p>
<h2 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a>constructor</h2><p>每个原型都有一个constructor属性指向关联的构造函数，实例原型指向构造函数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">person.__proto__ == Person.prototype <span class="comment">// true</span></span><br><span class="line">Person === Person.prototype.constructor <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.getPrototypeOf(person) === Person.prototype <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>补充说明：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person();</span><br><span class="line">person.constructor === Person<span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>当获取 person.constructor 时，其实 person 中并没有 constructor 属性,当不能读取到constructor 属性时，会从 person 的原型也就是 Person.prototype 中读取，正好原型中有该属性，所以：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">person.constructor === Person.prototype.constructor</span><br></pre></td></tr></table></figure>
<p><img src="/.io//3.png"></p>
<h2 id="实例与原型"><a href="#实例与原型" class="headerlink" title="实例与原型"></a>实例与原型</h2><p>当读取实例的属性时，如果找不到，就会查找与对象关联的原型中的属性，如果还查不到，就去找原型的原型，一直找到最顶层为止。<br><img src="/.io//4.png"></p>
<h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h2><p>简单的回顾一下构造函数、原型和实例的关系：每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，而实例都包含一个指向原型对象的内部指针。那么假如我们让原型对象等于另一个类型的实例，结果会怎样？显然，此时的原型对象将包含一个指向另一个原型的指针，相应地，另一个原型中也包含着一个指向另一个构造函数的指针。假如另一个原型又是另一个类型的实例，那么上述关系依然成立。如此层层递进，就构成了实例与原型的链条。这就是所谓的原型链的基本概念。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.prototype.__proto__ === <span class="literal">null</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p><img src="/.io//5.png"></p>
]]></content>
      <categories>
        <category>js基础</category>
      </categories>
  </entry>
  <entry>
    <title>希尔排序</title>
    <url>/2021/08/25/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<p>希尔排序是希尔（Donald Shell）于1959年提出的一种排序算法。希尔排序也是一种插入排序，它是简单插入排序经过改进之后的一个更高效的版本，也称为缩小增量排序，同时该算法是冲破O(n2）的第一批算法之一。本文会以图解的方式详细介绍希尔排序的基本思想及其代码实现。</p>
<h2 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h2><p>希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止。</p>
<p>简单插入排序很循规蹈矩，不管数组分布是怎么样的，依然一步一步的对元素进行比较，移动，插入，比如[5,4,3,2,1,0]这种倒序序列，数组末端的0要回到首位置很是费劲，比较和移动元素均需n-1次。而希尔排序在数组中采用跳跃式分组的策略，通过某个增量将数组元素划分为若干组，然后分组进行插入排序，随后逐步缩小增量，继续按组进行插入排序操作，直至增量为1。希尔排序通过这种策略使得整个数组在初始阶段达到从宏观上看基本有序，小的基本在前，大的基本在后。然后缩小增量，到增量为1时，其实多数情况下只需微调即可，不会涉及过多的数据移动。</p>
<p>我们来看下希尔排序的基本步骤，在此我们选择增量gap=length/2，缩小增量继续以gap = gap/2的方式，这种增量选择我们可以用一个序列来表示，{n/2,(n/2)/2…1}，称为增量序列。希尔排序的增量序列的选择与证明是个数学难题，我们选择的这个增量序列是比较常用的，也是希尔建议的增量，称为希尔增量，但其实这个增量序列不是最优的。此处我们做示例使用希尔增量。</p>
<h2 id="动图演示"><a href="#动图演示" class="headerlink" title="动图演示"></a>动图演示</h2><p><img src="/.io//1.png" alt="原理图"></p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">40</span>, <span class="number">60</span>, <span class="number">60</span>, <span class="number">0</span>, <span class="number">30</span>]</span><br><span class="line"><span class="keyword">let</span> interval = <span class="built_in">parseInt</span>(arr.length / <span class="number">2</span>);</span><br><span class="line"><span class="keyword">while</span> (interval &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i ++) &#123;</span><br><span class="line">        <span class="keyword">let</span> n = i;</span><br><span class="line">        <span class="keyword">while</span> (arr[n] &lt; arr[n - interval] &amp;&amp; n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">let</span> temp = arr[n]</span><br><span class="line">            arr[n] = arr[n- interval]</span><br><span class="line">            arr[n - interval] = temp</span><br><span class="line">            n --</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    interval = <span class="built_in">parseInt</span>(interval / <span class="number">2</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(arr)</span><br></pre></td></tr></table></figure>

<h2 id="性能分析："><a href="#性能分析：" class="headerlink" title="性能分析："></a>性能分析：</h2><p>希尔排序中对于增量序列的选择十分重要，直接影响到希尔排序的性能。我们上面选择的增量序列{n/2,(n/2)/2…1}(希尔增量)，其最坏时间复杂度依然为O(n2)，一些经过优化的增量序列如Hibbard经过复杂证明可使得最坏时间复杂度为O(n3/2)</p>
]]></content>
      <categories>
        <category>js基础</category>
      </categories>
  </entry>
  <entry>
    <title>执行上下文</title>
    <url>/2021/07/06/%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87/</url>
    <content><![CDATA[<h2 id="理解执行上下文"><a href="#理解执行上下文" class="headerlink" title="理解执行上下文"></a>理解执行上下文</h2><blockquote>
<p>执行上下文：函数执行前进行的准备工作，也就是执行上下文环境，是当前代码执行的一个环境与作用域。</p>
</blockquote>
<p>运行js代码时，当代码执行进入一个环境时，就会为该环境创建一个执行上下文，它<br>会在你运行代码前做一些准备工作，如确定作用域，创建局部变量对象等。</p>
<h2 id="js中执行环境"><a href="#js中执行环境" class="headerlink" title="js中执行环境"></a>js中执行环境</h2><ul>
<li>全局环境</li>
<li>函数环境</li>
<li>eval函数环境（不推荐使用）</li>
</ul>
<h2 id="执行上下文的类型"><a href="#执行上下文的类型" class="headerlink" title="执行上下文的类型"></a>执行上下文的类型</h2><ul>
<li>全局执行上下文</li>
<li>函数执行上下文</li>
<li>eval函数执行上下文</li>
</ul>
<p>js运行时先进入全局环境，对应会生成全局上下文。程序代码中基本都会存在函数，调用<br>函数，就会进入函数执行环境，对应的就是生成函数执行上下文。</p>
<h2 id="js管理多个执行上下文"><a href="#js管理多个执行上下文" class="headerlink" title="js管理多个执行上下文"></a>js管理多个执行上下文</h2><p>函数变成中，代码中会声明多个函数，对应的执行上下文也会存在多个。在js中，通过栈的存取方式来管理执行上下文，我们可以称<br>其为执行栈，或者函数调用栈。</p>
<p><img src="/.io//1.png" alt="栈数据结构"></p>
<h2 id="执行栈（函数调用栈）"><a href="#执行栈（函数调用栈）" class="headerlink" title="执行栈（函数调用栈）"></a>执行栈（函数调用栈）</h2><p>程序进入一个执行环境时，它的执行上下文就会被创建，并被堆入执行栈中（入栈）；程序执行完成时，她的执行上下文就会被销毁，并从栈顶被推出（出栈），控制权交由下一个执行上下文。</p>
<p>因为JS执行中，最先进入全局环境，所以处于”栈底的永远时全局环境的执行上下文”。而处于”栈顶的是当前执行函数的执行上下文”，当函数调用完成后，它就会从栈顶被推出（理想情况下，闭包会阻止该操作）。</p>
<p><strong>全局环境只有一个，对应的全局执行上下文也只有一个，只有当页面被关闭之后它才会从执行栈中被推出，否则一直存在于栈底。</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params"></span>) </span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">bar</span> (<span class="params"></span>) </span>&#123;        </span><br><span class="line">      <span class="keyword">return</span> <span class="string">&#x27;I am bar&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bar();</span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br></pre></td></tr></table></figure>
<p><img src="/.io//2.png" alt="出栈入栈图解"></p>
<h2 id="执行上下文的声明周期"><a href="#执行上下文的声明周期" class="headerlink" title="执行上下文的声明周期"></a>执行上下文的声明周期</h2><p>执行上下文的声明周期有两个阶段：</p>
<ol>
<li><p>创建阶段（进入执行上下文）</p>
<p> 函数被调用时，进入函数环境，为期创建一个执行上下文，此时进入创建阶段。</p>
</li>
<li><p>执行阶段（代码执行）</p>
<p> 执行函数中代码时，此时执行上下文进入执行阶段。</p>
</li>
</ol>
<h2 id="创建阶段的操作"><a href="#创建阶段的操作" class="headerlink" title="创建阶段的操作"></a>创建阶段的操作</h2><p>1.创建变量对象</p>
<ul>
<li>函数环境会初始化创建Arguments对象（并赋值）</li>
<li>函数声明（并赋值）</li>
<li>变量声明，函数表达式声明（未赋值）</li>
</ul>
<ol start="2">
<li>确定this指向（this由调用者确定）</li>
<li>确定作用域（词法环境决定，哪里声明定义，就在哪里确定）</li>
</ol>
<h2 id="执行阶段的操作"><a href="#执行阶段的操作" class="headerlink" title="执行阶段的操作"></a>执行阶段的操作</h2><ol>
<li>变量对象赋值</li>
</ol>
<ul>
<li>变量赋值</li>
<li>函数表达式赋值</li>
</ul>
<ol start="2">
<li>调用函数</li>
<li>顺序执行其他代码</li>
</ol>
<h2 id="变量对象和活动对象的区别："><a href="#变量对象和活动对象的区别：" class="headerlink" title="变量对象和活动对象的区别："></a>变量对象和活动对象的区别：</h2><p>当进入到一个执行上下文后，这个变量对象才会被激活，所以叫活动对象(AO)，这时候活动对象上的各种属性才能被访问。</p>
<p><strong>“创建阶段对函数声明做赋值，变量及函数表达式仅做声明，真正的赋值操作要等到执行上下文代码执行阶段。”</strong></p>
<p>例1：变量提升</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a);         <span class="comment">// 输出undefined</span></span><br><span class="line">    <span class="keyword">var</span> a = <span class="string">&#x27;I am here&#x27;</span>;    <span class="comment">// 赋值</span></span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br><span class="line"><span class="comment">// 实际执行过程</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a;                <span class="comment">// 变量声明，var初始化undefined</span></span><br><span class="line">    <span class="built_in">console</span>.log(a); </span><br><span class="line">    a = <span class="string">&#x27;I am here&#x27;</span>;     <span class="comment">// 变量重新赋值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例2：函数声明优先级</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(bar);</span><br><span class="line">    <span class="keyword">var</span> bar = <span class="number">20</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> bar = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">30</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">foo();  <span class="comment">// 输出bar()整个函数声明</span></span><br></pre></td></tr></table></figure>

<h2 id="函数声明，变量声明，函数表达式的优先级"><a href="#函数声明，变量声明，函数表达式的优先级" class="headerlink" title="函数声明，变量声明，函数表达式的优先级"></a>函数声明，变量声明，函数表达式的优先级</h2><ol>
<li>函数声明，如果有同名属性，会替换掉</li>
<li>变量，函数表达式</li>
<li>函数声明优先 &gt; 变量，函数表达式</li>
</ol>
<h2 id="执行上下文的数量限制（堆栈溢出）"><a href="#执行上下文的数量限制（堆栈溢出）" class="headerlink" title="执行上下文的数量限制（堆栈溢出）"></a>执行上下文的数量限制（堆栈溢出）</h2><p>执行上下文可存在多个，虽然没有明确的数量限制，但如果超出栈分配的空间，会造成堆栈溢出。常见于递归调用，没有终止条件造成死循环的场景。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 递归调用自身</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    foo();</span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br><span class="line"><span class="comment">// 报错： Uncaught RangeError: Maximum call stack size exceeded</span></span><br></pre></td></tr></table></figure>

<h2 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h2><p>当程序调用一个函数时，会发生什么？</p>
<p>以下几个步骤：</p>
<ol>
<li>js创建一个新的执行上下文，我们叫做函数执行上下文。</li>
<li>这个函数执行上下文将有它自己的一组变量，这些变量将时这个执行上下文的本地变量。</li>
<li>新的执行上下文被推到执行堆栈中。可以将执行堆栈看作是一种保存程序在其执行中的位置的容器。</li>
</ol>
<p>当函数遇到一个return或者一个结束括号 “}” 。</p>
<p>当函数结束时，会执行一下操作：</p>
<ol>
<li>这个本地执行上下文从执行堆栈中弹出。</li>
<li>函数将返回值返回调用上下文。调用上下文时调用这个本地的执行上下文，它可以时全局执行上下文，也可以是灵位一个本地执行上下文。这取决与调用执行上下文来处理此时的返回值，返回的值可以是一个对象、一个数组、一个函数、一个布尔值等等，如果函数没有return语句，则返回undefined.</li>
<li></li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li>JavaScript是单线程</li>
<li>栈顶的执行上下文处于执行中，其它需要排队</li>
<li>全局上下文只有一个处于栈底，页面关闭时出栈</li>
<li>函数执行上下文可存在多个，但应避免递归时堆栈溢出</li>
<li>函数调用时就会创建新的上下文，即使调用自身，也会创建不同的执行上下文</li>
</ol>
]]></content>
      <categories>
        <category>js基础</category>
      </categories>
  </entry>
  <entry>
    <title>插入排序</title>
    <url>/2021/08/25/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h2 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h2><p>1.从数组的第二个数据开始往前比较，即一开始用第二个数和他前面的一个比较，如果 符合条件（比前面的大或者小，自定义），则让他们交换位置。</p>
<p>2.然后再用第三个数和第二个比较，符合则交换，但是此处还得继续往前比较，比如有 5个数8，15，20，45, 17,17比45小，需要交换，但是17也比20小，也要交换，当不需 要和15交换以后，说明也不需要和15前面的数据比较了，肯定不需要交换，因为前 面的数据都是有序的。</p>
<p>3.重复步骤二，一直到数据全都排完。</p>
<h2 id="动图演示"><a href="#动图演示" class="headerlink" title="动图演示"></a>动图演示</h2><p><img src="/.io//1.gif" alt="原理图"></p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">40</span>, <span class="number">60</span>, <span class="number">60</span>, <span class="number">0</span>, <span class="number">30</span>]</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> n = i;</span><br><span class="line">    <span class="keyword">while</span> (arr[n] &gt; arr[n+<span class="number">1</span>] &amp;&amp; n &gt;=<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> temp = arr[n];</span><br><span class="line">        arr[n] = arr[n + <span class="number">1</span>];</span><br><span class="line">        arr[n + <span class="number">1</span>] = temp;</span><br><span class="line">        n--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(arr);</span><br></pre></td></tr></table></figure>

<h2 id="性能分析："><a href="#性能分析：" class="headerlink" title="性能分析："></a>性能分析：</h2><p>1.属于稳定的排序，适合于数据量小，部分数据有序的情况排序。</p>
<p>2.如果目标是把n个元素的序列升序排列，那么采用插入排序存在最好情况和最坏情况。最好情况就是，序列已经是升序排列了，在这种情况下，需要进行的比较操作需（n-1）次即可。最坏情况就是，序列是降序排列，那么此时需要进行的比较共有n(n-1)/2次。插入排序的赋值操作是比较操作的次数加上 (n-1）次。平均来说插入排序算法的时间复杂度为O(n^2）。因而，插入排序不适合对于数据量比较大的排序应用。但是，如果需要排序的数据量很小，例如，量级小于千，那么插入排序还是一个不错的选择</p>
<p>3.插入排序的平均时间复杂度也是 O(n^2)，空间复杂度为常数阶 O(1)</p>
]]></content>
      <categories>
        <category>js基础</category>
      </categories>
  </entry>
  <entry>
    <title>数组操作</title>
    <url>/2021/08/19/%E6%95%B0%E7%BB%84%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h1 id="最常见的几种数组操作方法归纳总结"><a href="#最常见的几种数组操作方法归纳总结" class="headerlink" title="最常见的几种数组操作方法归纳总结"></a>最常见的几种数组操作方法归纳总结</h1><h2 id="1-shift-方法：把数组的第一个元素删除，并返回第一个元素的值"><a href="#1-shift-方法：把数组的第一个元素删除，并返回第一个元素的值" class="headerlink" title="1.shift() 方法：把数组的第一个元素删除，并返回第一个元素的值"></a>1.shift() 方法：把数组的第一个元素删除，并返回第一个元素的值</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">arr.shift() <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<h2 id="2-concat-方法：用于连接两个或多个数组-并返回一个新数组，新数组是将参数添加到原数组中构成的"><a href="#2-concat-方法：用于连接两个或多个数组-并返回一个新数组，新数组是将参数添加到原数组中构成的" class="headerlink" title="2.concat() 方法：用于连接两个或多个数组,并返回一个新数组，新数组是将参数添加到原数组中构成的"></a>2.concat() 方法：用于连接两个或多个数组,并返回一个新数组，新数组是将参数添加到原数组中构成的</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">const</span> arr1 = arr.concat(<span class="number">2</span>, <span class="number">4</span>); <span class="comment">// 1, 3, 2, 4</span></span><br><span class="line"><span class="keyword">const</span> arr2 = [<span class="number">5</span>, <span class="number">6</span>];</span><br><span class="line"><span class="keyword">const</span> arr3 = [<span class="number">7</span>, <span class="number">8</span>];</span><br><span class="line"><span class="keyword">const</span> arr4 = arr2.concat(arr3); <span class="comment">// 5, 6, 7, 8</span></span><br></pre></td></tr></table></figure>

<h2 id="3-join-方法：用于把数组中的所有元素放入一个字符串。元素是通过指定的分隔符进行分隔的。"><a href="#3-join-方法：用于把数组中的所有元素放入一个字符串。元素是通过指定的分隔符进行分隔的。" class="headerlink" title="3. join() 方法：用于把数组中的所有元素放入一个字符串。元素是通过指定的分隔符进行分隔的。"></a>3. join() 方法：用于把数组中的所有元素放入一个字符串。元素是通过指定的分隔符进行分隔的。</h2><p>返回一个字符串。该字符串是通过把 arrayObject 的每个元素转换为字符串，然后把这些字符串连接起来，在两个元素之间插入separator 字符串而生成的。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>];</span><br><span class="line"><span class="keyword">const</span> str = arr.join(<span class="string">&#x27;-&#x27;</span>); <span class="comment">// 1-3-4-5-6</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="4-pop-方法：用于删除并返回数组的最后一个-删除元素-元素-如果数组为空则返回undefined-把数组长度减-1"><a href="#4-pop-方法：用于删除并返回数组的最后一个-删除元素-元素-如果数组为空则返回undefined-把数组长度减-1" class="headerlink" title="4. pop() 方法：用于删除并返回数组的最后一个(删除元素)元素,如果数组为空则返回undefined ,把数组长度减 1"></a>4. pop() 方法：用于删除并返回数组的最后一个(删除元素)元素,如果数组为空则返回undefined ,把数组长度减 1</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line"><span class="keyword">const</span> str = arr.pop(); <span class="comment">// 6</span></span><br><span class="line"><span class="built_in">console</span>.log(arr) <span class="comment">// 1,2,3,4,5</span></span><br></pre></td></tr></table></figure>

<h2 id="5-push-方法：可向数组的末尾添加一个或多个元素，并返回新的长度，（用来改变数组长度）。"><a href="#5-push-方法：可向数组的末尾添加一个或多个元素，并返回新的长度，（用来改变数组长度）。" class="headerlink" title="5.push() 方法：可向数组的末尾添加一个或多个元素，并返回新的长度，（用来改变数组长度）。"></a>5.push() 方法：可向数组的末尾添加一个或多个元素，并返回新的长度，（用来改变数组长度）。</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line"><span class="keyword">const</span> len = arr.push(<span class="number">5</span>)<span class="comment">// 5</span></span><br><span class="line"><span class="built_in">console</span>.log(arr) <span class="comment">// [1,2,3,4,5]</span></span><br></pre></td></tr></table></figure>
<h2 id="6-reverse-：方法用于颠倒数组中元素的顺序。"><a href="#6-reverse-：方法用于颠倒数组中元素的顺序。" class="headerlink" title="6.reverse() ：方法用于颠倒数组中元素的顺序。"></a>6.reverse() ：方法用于颠倒数组中元素的顺序。</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line"><span class="keyword">const</span> len = arr.reverse(); <span class="comment">// [6,5,4,3,2,1]</span></span><br><span class="line"><span class="built_in">console</span>.log(arr) <span class="comment">// [6,5,4,3,2,1]</span></span><br></pre></td></tr></table></figure>
<h2 id="7-slice-方法：可从已有的数组中返回选定的元素。slice-开始截取位置，结束截取位置"><a href="#7-slice-方法：可从已有的数组中返回选定的元素。slice-开始截取位置，结束截取位置" class="headerlink" title="7.slice() 方法：可从已有的数组中返回选定的元素。slice(开始截取位置，结束截取位置)"></a>7.slice() 方法：可从已有的数组中返回选定的元素。slice(开始截取位置，结束截取位置)</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line"><span class="keyword">const</span> a = arr.slice(<span class="number">1</span>,<span class="number">2</span>); <span class="comment">// [2]</span></span><br><span class="line"><span class="built_in">console</span>.log(arr)<span class="comment">// [1,2,3,4,5,6]</span></span><br></pre></td></tr></table></figure>
<h2 id="8-splice-：方法向-从数组中添加-删除项目，然后返回被删除的项目。"><a href="#8-splice-：方法向-从数组中添加-删除项目，然后返回被删除的项目。" class="headerlink" title="8.splice() ：方法向/从数组中添加/删除项目，然后返回被删除的项目。"></a>8.splice() ：方法向/从数组中添加/删除项目，然后返回被删除的项目。</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"><span class="keyword">const</span> a = arr.splice(<span class="number">1</span>,<span class="number">2</span>); <span class="comment">// [2,3]</span></span><br><span class="line"><span class="built_in">console</span>.log(arr) <span class="comment">// [1,4,5]</span></span><br><span class="line"><span class="keyword">const</span> b = arr.splice(<span class="number">1</span>,<span class="number">2</span>,)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arrr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"><span class="keyword">const</span> c = arr.splice(<span class="number">1</span>,<span class="number">0</span>, <span class="string">&#x27;a&#x27;</span>) <span class="comment">// []</span></span><br><span class="line"><span class="built_in">console</span>.log(arrr) <span class="comment">// [1, &#x27;a&#x27;,2,3,4,5]</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="9-unshift：将参数添加到原数组开头，并返回数组的长度"><a href="#9-unshift：将参数添加到原数组开头，并返回数组的长度" class="headerlink" title="9.unshift：将参数添加到原数组开头，并返回数组的长度"></a>9.unshift：将参数添加到原数组开头，并返回数组的长度</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line"><span class="keyword">const</span> len = arr.unshift(<span class="number">0</span>); <span class="comment">// 5</span></span><br><span class="line"><span class="built_in">console</span>.log(arr) <span class="comment">// [0,1,2,3,4]</span></span><br></pre></td></tr></table></figure>
<h2 id="10-sort-orderfunction-：按指定的参数对数组进行排序"><a href="#10-sort-orderfunction-：按指定的参数对数组进行排序" class="headerlink" title="10.sort(orderfunction)：按指定的参数对数组进行排序"></a>10.sort(orderfunction)：按指定的参数对数组进行排序</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line"><span class="keyword">const</span> b = arr.sort(); <span class="comment">// [1,2,3,4]</span></span><br><span class="line"><span class="built_in">console</span>.log(b) <span class="comment">// [1,2,3,4]</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>js基础</category>
      </categories>
  </entry>
  <entry>
    <title>数据类型</title>
    <url>/2021/08/19/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<h1 id="js中基本数据类型"><a href="#js中基本数据类型" class="headerlink" title="js中基本数据类型"></a>js中基本数据类型</h1><h2 id="原始数据类型"><a href="#原始数据类型" class="headerlink" title="原始数据类型"></a>原始数据类型</h2><ul>
<li>number</li>
<li>string</li>
<li>boolean</li>
<li>null</li>
<li>undefined</li>
<li>symbol(es6)</li>
<li>bigint(es10)</li>
</ul>
<h2 id="引用数据类型"><a href="#引用数据类型" class="headerlink" title="引用数据类型"></a>引用数据类型</h2><ul>
<li>object (包括function/array/object)</li>
</ul>
]]></content>
      <categories>
        <category>js基础</category>
      </categories>
  </entry>
  <entry>
    <title>面试题</title>
    <url>/2021/08/19/%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<h1 id="JavaScript-面试题"><a href="#JavaScript-面试题" class="headerlink" title="JavaScript 面试题"></a>JavaScript 面试题</h1><h2 id><a href="#" class="headerlink" title></a><a href="/2018/07/06/%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E6%96%B9%E5%BC%8F/" title="1.在 JavaScript 中创建对象的可行方法有哪些？">1.在 JavaScript 中创建对象的可行方法有哪些？</a></h2><p>1、对象的构造函数-new object()<br>2、对象的创建方法-Object.create(null)<br>3、对象字面量语法-const obj = {}<br>4、函数构造器<br>5、带有原型的函数构造函数<br>6、es6类语法 class<br>7、单例模式</p>
<h2 id="-1"><a href="#-1" class="headerlink" title></a><a href="/2018/07/06/%E5%8E%9F%E5%9E%8B%E5%8F%8A%E5%8E%9F%E5%9E%8B%E9%93%BE/" title="1.什么是原型链？">1.什么是原型链？</a></h2><p>原型链用于基于现有对象构建新类型的对象。它类似于基于类的语言中的继承。</p>
<p>对象实例上的原型可通过Object.getPrototypeOf(object)或proto属性获得，而构造函数上的原型可通过Object.prototype 获得。</p>
<h2 id="-2"><a href="#-2" class="headerlink" title></a><a href="/2021/08/19/call%E3%80%81apply%E5%92%8Cbind%E5%8C%BA%E5%88%AB/" title="3.call、 bind、apply区别？">3.call、 bind、apply区别？</a></h2><h2 id="-3"><a href="#-3" class="headerlink" title></a><a href="/2021/08/19/%E6%95%B0%E7%BB%84%E6%93%8D%E4%BD%9C/" title="4.数组操作？">4.数组操作？</a></h2>]]></content>
  </entry>
</search>
