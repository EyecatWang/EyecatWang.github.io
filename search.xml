<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>call、 bind、apply区别</title>
    <url>/2021/08/19/call%E3%80%81apply%E5%92%8Cbind%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h1 id="call、-bind、apply区别"><a href="#call、-bind、apply区别" class="headerlink" title="call、 bind、apply区别"></a>call、 bind、apply区别</h1><p>我们都知道call apply bind都可以改变函数调用的this指向。那么它们三者有什么区别，什么时候该用哪个呢？</p>
<p>我们先来看MDN语法说明</p>
<h2 id="语法说明"><a href="#语法说明" class="headerlink" title="语法说明"></a>语法说明</h2><h3 id="1-call语法"><a href="#1-call语法" class="headerlink" title="1. call语法"></a>1. call语法</h3><ul>
<li>fun.call(thisArg, arg1, arg2, …)</li>
<li>thisArg: 在fun函数运行时指定的this值。需要注意的是，指定的this值并不一定是该函数执行时真正的this值，如果这个函数处于非严格模式下，则指定为null和undefined的this值会自动指向全局对象(浏览器中就是window对象)，同时值为原始值(数字，字符串，布尔值)的this会指向该原始值的自动包装对象。</li>
<li>arg1, arg2, … 指定的参数列表</li>
</ul>
<h3 id="2-apply语法"><a href="#2-apply语法" class="headerlink" title="2. apply语法"></a>2. apply语法</h3><ul>
<li>fun.apply(thisArg, [argsArray])</li>
<li>thisArg 在 fun 函数运行时指定的 this 值。需要注意的是，指定的 this 值并不一定是该函数执行时真正的 this 值，如果这个函数处于非严格模式下，则指定为 null 或 undefined 时会自动指向全局对象（浏览器中就是window对象），同时值为原始值（数字，字符串，布尔值）的 this 会指向该原始值的自动包装对象。</li>
<li>argsArray 一个数组或者类数组对象，其中的数组元素将作为单独的参数传给 fun 函数。如果该参数的值为null 或 undefined，则表示不需要传入任何参数。从ECMAScript 5 开始可以使用类数组对象。</li>
</ul>
<h3 id="3-bind语法"><a href="#3-bind语法" class="headerlink" title="3. bind语法"></a>3. bind语法</h3><ul>
<li>fun.bind(thisArg[, arg1[, arg2[, …]]])</li>
<li>thisArg 当绑定函数被调用时，该参数会作为原函数运行时的 this 指向。当使用new 操作符调用绑定函数时，该参数无效。</li>
<li>arg1, arg2, … 当绑定函数被调用时，这些参数将置于实参之前传递给被绑定的方法。</li>
</ul>
<h2 id="例子说明"><a href="#例子说明" class="headerlink" title="例子说明"></a>例子说明</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 有只猫叫小黑，小黑会吃鱼</span></span><br><span class="line"><span class="keyword">const</span> cat = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;小黑&#x27;</span>,</span><br><span class="line">    <span class="function"><span class="title">eatFish</span>(<span class="params">...args</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;this指向=&gt;&#x27;</span>, <span class="built_in">this</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;...args&#x27;</span>, args);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.name + <span class="string">&#x27;吃鱼&#x27;</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 有只狗叫大毛，大毛会吃骨头</span></span><br><span class="line"><span class="keyword">const</span> dog = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;大毛&#x27;</span>,</span><br><span class="line">    <span class="function"><span class="title">eatBone</span>(<span class="params">...args</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;this指向=&gt;&#x27;</span>, <span class="built_in">this</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;...args&#x27;</span>, args);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.name + <span class="string">&#x27;吃骨头&#x27;</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;=================== call =========================&#x27;</span>);</span><br><span class="line"><span class="comment">// 有一天大毛想吃鱼了，可是它不知道怎么吃。怎么办？小黑说我吃的时候喂你吃</span></span><br><span class="line">cat.eatFish.call(dog, <span class="string">&#x27;汪汪汪&#x27;</span>, <span class="string">&#x27;call&#x27;</span>)</span><br><span class="line"><span class="comment">// 大毛为了表示感谢，决定下次吃骨头的时候也喂小黑吃</span></span><br><span class="line">dog.eatBone.call(cat, <span class="string">&#x27;喵喵喵&#x27;</span>, <span class="string">&#x27;call&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;=================== apply =========================&#x27;</span>);</span><br><span class="line">cat.eatFish.apply(dog, [<span class="string">&#x27;汪汪汪&#x27;</span>, <span class="string">&#x27;apply&#x27;</span>])</span><br><span class="line">dog.eatBone.apply(cat, [<span class="string">&#x27;喵喵喵&#x27;</span>, <span class="string">&#x27;apply&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;=================== bind =========================&#x27;</span>);</span><br><span class="line"><span class="comment">// 有一天他们觉得每次吃的时候再喂太麻烦了。干脆直接教对方怎么吃</span></span><br><span class="line"><span class="keyword">const</span> test1 = cat.eatFish.bind(dog, <span class="string">&#x27;汪汪汪&#x27;</span>, <span class="string">&#x27;bind&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> test2 = dog.eatBone.bind(cat, <span class="string">&#x27;喵喵喵&#x27;</span>, <span class="string">&#x27;bind&#x27;</span>)</span><br><span class="line">test1()</span><br><span class="line">test2()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><p>call跟apply的用法几乎一样，唯一的不同就是传递的参数不同，call只能一个参数一个参数的传入。</p>
</li>
<li><p>apply则只支持传入一个数组，哪怕是一个参数也要是数组形式。最终调用函数时候这个数组会拆成一个个参数分别传入。</p>
</li>
<li><p>至于bind方法，他是直接改变这个函数的this指向并且返回一个新的函数，之后再次调用这个函数的时候this都是指向bind绑定的第一个参数。bind传餐方式跟call方法一致。</p>
</li>
</ul>
<p>由于apply函数传参的特殊性，我们又衍生出了一个黑魔法。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 如果一个数组我们已知里面全都是数字，想要知道最大的那个数，由于Array没有max方法，Math对象上有</span></span><br><span class="line"><span class="comment">// 我们可以根据apply传递参数的特性将这个数组当成参数传入</span></span><br><span class="line"><span class="comment">// 最终Math.max函数调用的时候会将apply的数组里面的参数一个一个传入，恰好符合Math.max的参数传递方式</span></span><br><span class="line"><span class="comment">// 这样变相的实现了数组的max方法。min方法也同理</span></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line"><span class="keyword">const</span> max = <span class="built_in">Math</span>.max.apply(<span class="literal">null</span>, arr)</span><br><span class="line"><span class="built_in">console</span>.log(max)    <span class="comment">// 6</span></span><br></pre></td></tr></table></figure>

<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>箭头函数没有this，会忽律第一个参数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> cat = &#123;</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&quot;小黑&quot;</span>,</span><br><span class="line">        <span class="attr">eatFish</span>: <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;this 指向=》&quot;</span>, <span class="built_in">this</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;...args=&gt;&quot;</span>, args);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.name + <span class="string">&quot;吃鱼&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> dog = &#123;</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&quot;大毛&quot;</span>,</span><br><span class="line">        <span class="function"><span class="title">eatBone</span>(<span class="params">...args</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&quot;this 指向=》&quot;</span>, <span class="built_in">this</span>);</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&quot;...args=&gt;&quot;</span>, args);</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="built_in">this</span>.name + <span class="string">&quot;吃骨头&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cat.eatFish.call(dog, <span class="string">&quot;1&quot;</span>, <span class="string">&quot;2&quot;</span>)</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>call 和 apply 的主要作用，是改变对象的执行上下文，并且是立即执行的。它们在参数上的写法略有区别。</p>
<p>bind 也能改变对象的执行上下文，它与 call 和 apply 不同的是，返回值是一个函数，并且需要稍后再调用一下，才会执行。</p>
]]></content>
      <categories>
        <category>js基础</category>
      </categories>
  </entry>
  <entry>
    <title>css面试</title>
    <url>/2021/08/19/css%E9%9D%A2%E8%AF%95/</url>
    <content><![CDATA[<p>1、介绍一下标准的CSS的盒子模型？与低版本IE的盒子模型有什么不同？</p>
<p>标准盒子模型：宽度=内容宽度（content）+ border + padding + margin</p>
<p>低版本IE盒子模型：宽度=内容宽度（content + border + padding）+ margin</p>
<p>2、box-sizing属性？</p>
<p>用来控制元素的盒子模型的解析模式，默认为content-box</p>
<p>content-box：w3c标准盒子模型，设置元素的width/height属性指的是content部分的宽高</p>
<p>border-box：IE传统盒子模型。设置元素的height/width属性指的是border+padding+content<br>部分的宽/高</p>
<p>3、css选择器有哪些？哪些属性可以继承？</p>
<p>css选择符：ID选择器（#id）、类选择器（.class）、标签选择器（div,h1）、相邻选择器（h1+p）、<br>子选择器（ul&gt;li）、后代选择器（li a）、通配符选择器(*)、属性选择器（a[rel=”external”]）、伪类选择器(a:hover,li:nth-child)</p>
<p>可继承的属性：font-size,font-family,color</p>
<p>不可继承的样式：border，padding，margin</p>
<p>优先级（就近原则）：！important&gt;id&gt;class&gt;tag, !important比内联优先级高</p>
<p>4、css优先级算法如何计算</p>
<p>元素选择符： 1</p>
<p>class选择符： 10</p>
<p>id选择符：100</p>
<p>元素标签：1000</p>
<p>优先级（就近原则）：！important&gt;id&gt;class｜属性｜伪类》元素选择器, !important比内联优先级高</p>
<p>1、!important声明的样式优先级最高，如果有冲突在进行计算</p>
<p>2、如果优先级相同，则选择最后出现的样式</p>
<p>3、继承得到的样式优先级最低</p>
<p>5、css3新增的伪类有哪些？</p>
<p>p:first-of-type 选择属于其父元素的首个元素</p>
<p>p:last-of-type 选择属于其父元素的最后元素</p>
<p>p:only-of-type 选择属于其父元素唯一的元素</p>
<p>p:only-child 选择属于其父元素唯一的元素</p>
<p>p:ntn-child(2) 选择属于其父元素的第二个子元素</p>
<p>:enabled,:disabled 表单控件的禁用状态</p>
<p>:checked 单选框或复选框被选中</p>
<p>6、如何居中div？如何居中一个浮动元素？如何让绝对定位的div居中？</p>
<p>div:</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">border</span>: <span class="number">1px</span> solid red;</span><br><span class="line"><span class="attribute">margin</span>:<span class="number">0</span> auto;</span><br><span class="line"><span class="attribute">height</span>:<span class="number">50px</span>;</span><br><span class="line"><span class="attribute">width</span>: <span class="number">50px</span>;</span><br></pre></td></tr></table></figure>

<p>浮动元素的上下左右居中：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">border</span>: <span class="number">1px</span> solid red;</span><br><span class="line"><span class="attribute">float</span>: left;</span><br><span class="line"><span class="attribute">position</span>: absolute;</span><br><span class="line"><span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line"><span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line"><span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line"><span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line"><span class="attribute">margin</span>: -<span class="number">50px</span> <span class="number">0</span> <span class="number">0</span> -<span class="number">100px</span>;</span><br></pre></td></tr></table></figure>

<p>绝对定位的左右居中：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">border</span>: <span class="number">1px</span> solid black;</span><br><span class="line"><span class="attribute">position</span>: absolute;</span><br><span class="line"><span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line"><span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line"><span class="attribute">margin</span>: <span class="number">0</span> auto;</span><br><span class="line"><span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line"><span class="attribute">right</span>: <span class="number">0</span>; </span><br></pre></td></tr></table></figure>

<p>flex居中：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">display</span>: flex;</span><br><span class="line"><span class="attribute">align-items</span>: center;</span><br><span class="line"><span class="attribute">justify-content</span>: center;</span><br></pre></td></tr></table></figure>

<p>7、display有哪些值？说明他们的作用？</p>
<p>inline(默认)-内联<br>none-隐藏<br>block-块显示<br>table-表格显示<br>list-item -项目列表<br>inline-block（内联块显示）</p>
<p>8、position的值？</p>
<p>static（默认）按照正常文档流进行排列</p>
<p>relative（相对定位）：不脱离文档流，参考自身静态位置通过 top,bottom,left,right定位</p>
<p>absolute（绝对定位）：参考距其最近的一个不为 static的福元素通过top,bottom,left,right定位</p>
<p>fixed（固定定位）：所固定的参照对象是可视窗口</p>
<p>9、css3新特性？</p>
<ol>
<li>RGBA和透明度</li>
<li>background-image、background-origin background-size background-repeat</li>
<li>word-wrap(对长的不可分割单词换行) work- wrap:break-word</li>
<li>文字阴影  text-shadom:5px 5px 5px #000(水平阴影，垂直阴影，模糊距离，颜色)</li>
<li>font-face属性：定义自己的字体</li>
<li>圆角 border-radius</li>
<li>边框图片 border-image:url() 30 30 round</li>
<li>盒阴影：box-shadom:10px 10px 5px #000(水平阴影，垂直阴影，模糊距离，颜色)</li>
<li>媒体查询@media</li>
</ol>
<p>10、请解释一下css3的flexbox（弹性盒布局模型），以及适用场景</p>
<p>该布局模型的目的是提供一种更加高效的方式来对容器中的条目进行布局、对齐和分配空间。在传统的布局方式中，block 布局是把块在垂直方向从上到下依次排列的；而 inline 布局则是在水平方向来排列。弹性盒布局并没有这样内在的方向限制，可以由开发人员自由操作。试用场景：弹性布局适合于移动前端开发，在Android和ios上也完美支持。</p>
<p>11、用纯CSS创建一个三角形的原理是什么？<br>采用的是均分原理,把矩形分为4等份,这4等份其实都是边框</p>
<p>首先，需要把元素的宽度、高度设为0。然后设置边框样式。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line"><span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line"><span class="attribute">border-top</span>: <span class="number">40px</span> solid transparent;</span><br><span class="line"><span class="attribute">border-left</span>: <span class="number">40px</span> solid transparent;</span><br><span class="line"><span class="attribute">border-right</span>: <span class="number">40px</span> solid transparent;</span><br><span class="line"><span class="attribute">border-bottom</span>: <span class="number">40px</span> solid <span class="number">#ff0000</span>;</span><br></pre></td></tr></table></figure>

<p>12、一个满屏品字布局如何设计？</p>
<p>第一种真正的品字：</p>
<ol>
<li>三块高宽是确定的；</li>
<li>上面那块用margin: 0 auto;居中；</li>
<li>下面两块用float或者inline-block不换行；</li>
<li>用margin调整位置使他们居中。</li>
</ol>
<p>第二种全屏的品字布局:上面的div设置成100%，下面的div分别宽50%，然后使用float或者inline使其不换行。</p>
<p>13、常见的兼容性问题？</p>
<ol>
<li>不同浏览器的标签默认的margin和padding不一样。*{margin:0;padding:0}</li>
<li>IE6双边距bug:块属性标签float后，又有横行的margin情况下，在IE6显示的margin比较大。解决方案： display：inline；将其转化为行内属性。</li>
<li>渐进识别的方式，从总体中逐渐排出局部。首先，巧妙的使用“9”这一标记，将IE浏览器从所有情况中分离出来。接着，再次使用“+”将IE8和IE7、IE6分离开来，这样IE8已经独立识别。<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attribute">background-color</span>:<span class="number">#f1ee18</span>;<span class="comment">/*所有识别*/</span></span><br><span class="line">    <span class="selector-class">.background-color</span>:<span class="number">#00deff</span>\<span class="number">9</span>; <span class="comment">/*IE6、7、8识别*/</span></span><br><span class="line">    +<span class="attribute">background-color</span>:<span class="number">#a200ff</span>;<span class="comment">/*IE6、7识别*/</span></span><br><span class="line">    _background-<span class="attribute">color</span>:<span class="number">#1e0bd1</span>;<span class="comment">/*IE6识别*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>设置较小高度标签（一般小于10px），在IE6，IE7中高度超出自己设置高度。hack：给超出高度的标签设置overflow：hidden；或者设置行高line- height小于你设置的高度。</li>
<li>IE下，可以使用获取常规属性的方法来获取自定义属性,也可以使用getAttribute()获取自定义属性；Firefox下，只能使用getAttribute()获取自定义属性。解决方法:统一通过getAttribute()获取自定义属性。</li>
<li>Chrome 中文界面下默认会将小于 12px 的文本强制按照 12px 显示,可通过加入 CSS 属性 -webkit-text-size-adjust: none; 解决。</li>
<li>超链接访问过后hover样式就不出现了，被点击访问过的超链接样式不再具有hover和active了。解决方法是改变CSS属性的排列顺序:L-V-H-A ( love hate ): a:link {} a:visited {} a:hover {} a:active {}</li>
</ol>
<p>14、为什么要初始化CSS样式</p>
<p>因为浏览器的兼容问题，不同浏览器对有些标签的默认值是不同的，如果没对CSS初始化往往会出现浏览器之间的页面显示差异。</p>
<p>15、 absolute的containing block计算方式跟正常流有什么不同</p>
<p>无论属于哪种，都要先找到其祖先元素中最近的 position 值不为 static 的元素，然后再判断：</p>
<ol>
<li>若此元素为 inline 元素，则 containing block 为能够包含这个元素生成的第一个和最后一个 inline box 的 padding box (除 margin, border 外的区域) 的最小矩形；</li>
<li>否则,则由这个祖先元素的 padding box 构成。</li>
<li>如果都找不到，则为 initial containing block。<br>补充：</li>
<li>static(默认的)/relative：简单说就是它的父元素的内容框（即去掉padding的部分）</li>
<li>absolute: 向上找最近的定位为absolute/relative的元素</li>
<li>fixed: 它的containing block一律为根元素(html/body)</li>
</ol>
<p>16、CSS里的visibility属性有个collapse属性值？在不同浏览器下以后什么区别？</p>
<p>当一个元素的visibility属性被设置成collapse值后，对于一般的元素，它的表现跟hidden是一样的。</p>
<ol>
<li>chrome中，使用collapse值和使用hidden没有区别。</li>
<li>firefox，opera和IE，使用collapse值和使用display：none没有什么区别。</li>
</ol>
<p>17、display:none与visibility：hidden的区别？</p>
<ol>
<li>display：none 不显示对应的元素，在文档布局中不再分配空间（回流+重绘）</li>
<li>visibility：hidden 隐藏对应元素，在文档布局中仍保留原来的空间（重绘）</li>
</ol>
<p>18、position跟display、overflow、float这些特性相互叠加后会怎么样？</p>
<p>display属性规定元素应该生成的框的类型；position属性规定元素的定位类型；float属性是一种布局方式，定义元素在哪个方向浮动。</p>
<p>类似于优先级机制：position：absolute/fixed优先级最高，有他们在时，float不起作用，display值需要调整。float 或者absolute定位的元素，只能是块元素或表格。</p>
<p>19、对BFC规范(块级格式化上下文：block formatting context)的理解？</p>
<p>BFC规定了内部的Block Box如何布局。定位方案：</p>
<ol>
<li>内部的Box会在垂直方向上一个接一个放置。</li>
<li>Box垂直方向的距离由margin决定，属于同一个BFC的两个相邻Box的margin会发生重叠。</li>
<li>每个元素的margin box 的左边，与包含块border box的左边相接触。</li>
<li>BFC的区域不会与float box重叠。</li>
<li>BFC是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。</li>
<li>计算BFC的高度时，浮动元素也会参与计算。</li>
</ol>
<p>满足下列条件之一就可触发BFC:</p>
<ol>
<li>根元素，即html</li>
<li>float的值不为none（默认）</li>
<li>overflow的值不为visible（默认）</li>
<li>display的值为inline-block、table-cell、table-caption</li>
<li>position的值为absolute或fixed</li>
</ol>
<p>20、为什么会出现浮动和什么时候需要清除浮动？清除浮动的方式？</p>
<p>浮动元素碰到包含它的边框或者浮动元素的边框停留。由于浮动元素不在文档流中，所以文档流的块框表现得就像浮动框不存在一样。浮动元素会漂浮在文档流的块框上。浮动带来的问题：</p>
<ol>
<li>父元素的高度无法被撑开，影响与父元素同级的元素</li>
<li>与浮动元素同级的非浮动元素（内联元素）会跟随其后</li>
<li>若非第一个元素浮动，则该元素之前的元素也需要浮动，否则会影响页面显示的结构。</li>
</ol>
<p>清除浮动的方式：</p>
<ol>
<li>父级div定义height</li>
<li>最后一个浮动元素后加空div标签 并添加样式clear:both。</li>
<li>包含浮动元素的父标签添加样式overflow为hidden或auto。</li>
<li>父级div定义zoom</li>
</ol>
<p>21、上下margin重合的问题</p>
<p>在重合元素外包裹一层容器，并触发该容器生成一个BFC。</p>
<p>例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div class=&quot;aside&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;div class=&quot;text&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;main&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;!--下面是css代码--&gt;</span><br><span class="line"> .aside &#123;</span><br><span class="line">            margin-bottom: 100px;  </span><br><span class="line">            width: 100px;</span><br><span class="line">            height: 150px;</span><br><span class="line">            background: #f66;</span><br><span class="line">        &#125;</span><br><span class="line">        .main &#123;</span><br><span class="line">            margin-top: 100px;</span><br><span class="line">            height: 200px;</span><br><span class="line">            background: #fcc;</span><br><span class="line">        &#125;</span><br><span class="line">         .text&#123;</span><br><span class="line">            /*盒子main的外面包一个div，通过改变此div的属性使两个盒子分属于两个不同的BFC，以此来阻止margin重叠*/</span><br><span class="line">            overflow: hidden;  //此时已经触发了BFC属性。</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>22、设置元素浮动后，该元素的display值是多少？</p>
<p>自动变成display:block</p>
<p>23、移动端的布局用过媒体查询吗？</p>
<p>通过媒体查询可以为不同大小和尺寸的媒体定义不同的css，适应相应的设备的显示。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. &lt;head&gt;里边&lt;link rel=”stylesheet” type=”text/css” href=”xxx.css” media=”only screen and (max-device-width:480px)”&gt;</span><br><span class="line"></span><br><span class="line">2. CSS : @media only screen and (max-device-width:480px) &#123;/css样式/&#125;</span><br></pre></td></tr></table></figure>

<p>24、使用 CSS 预处理器吗？</p>
<p>Less sass</p>
<p>25、CSS优化、提高性能的方法有哪些？</p>
<ol>
<li>避免过度约束</li>
<li>避免后代选择符</li>
<li>避免链式选择符</li>
<li>使用紧凑的语法</li>
<li>避免不必要的命名空间</li>
<li>避免不必要的重复</li>
<li>最好使用表示语义的名字。一个好的类名应该是描述他是什么而不是像什么</li>
<li>避免！important，可以选择其他选择器</li>
<li>尽可能的精简规则，你可以合并不同类里的重复规则</li>
</ol>
<p>26、浏览器是怎样解析CSS选择器的？</p>
<p>CSS选择器的解析是从右向左解析的。若从左向右的匹配，发现不符合规则，需要进行回溯，会损失很多性能。若从右向左匹配，先找到所有的最右节点，对于每一个节点，向上寻找其父节点直到找到根元素或满足条件的匹配规则，则结束这个分支的遍历。两种匹配规则的性能差别很大，是因为从右向左的匹配在第一步就筛选掉了大量的不符合条件的最右节点（叶子节点），而从左向右的匹配规则的性能都浪费在了失败的查找上面。</p>
<p>而在 CSS 解析完毕后，需要将解析的结果与 DOM Tree 的内容一起进行分析建立一棵 Render Tree，最终用来进行绘图。在建立 Render Tree 时（WebKit 中的「Attachment」过程），浏览器就要为每个 DOM Tree 中的元素根据 CSS 的解析结果（Style Rules）来确定生成怎样的 Render Tree。</p>
<p>27、在网页中的应该使用奇数还是偶数的字体？为什么呢？</p>
<p>使用偶数字体。偶数字号相对更容易和 web 设计的其他部分构成比例关系。Windows 自带的点阵宋体（中易宋体）从 Vista 开始只提供 12、14、16 px 这三个大小的点阵，而 13、15、17 px时用的是小一号的点。（即每个字占的空间大了 1 px，但点阵没变），于是略显稀疏。</p>
<p>28、margin和padding分别适合什么场景使用？</p>
<p>何时使用margin：</p>
<ol>
<li>需要在border外侧添加空白</li>
<li>空白处不需要背景色</li>
<li>上下相连的两个盒子之间的空白，需要相互抵消时。</li>
</ol>
<p>何时使用padding：</p>
<ol>
<li>需要在border内侧添加空白</li>
<li>空白处需要背景颜色</li>
<li>上下相连的两个盒子的空白，希望为两者之和。</li>
</ol>
<p>兼容性的问题：在IE5 IE6中，为float的盒子指定margin时，左侧的margin可能会变成两倍的宽度。通过改变padding或者指定盒子的display：inline解决。</p>
<p>29、元素竖向的百分比设定是相对于容器的高度吗？</p>
<p>当按百分比设定一个元素的宽度时，它是相对于父容器的宽度计算的，但是，对于一些表示竖向距离的属性，例如 padding-top , padding-bottom , margin-top , margin-bottom 等，当按百分比设定它们时，依据的也是父容器的宽度，而不是高度。</p>
]]></content>
      <categories>
        <category>css</category>
      </categories>
  </entry>
  <entry>
    <title>js实现call, apply, bind方法</title>
    <url>/2021/08/19/js%E5%AE%9E%E7%8E%B0call,%20apply,%20bind%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>#实现call方法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;叫爸爸&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> son = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;叫儿子&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="built_in">this</span>.name) </span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Function</span>.prototype.call_ = <span class="function"><span class="keyword">function</span> (<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//判断是否为null或者undefined,同时考虑传递参数不是对象情况</span></span><br><span class="line">    obj = obj ? <span class="built_in">Object</span>(obj) : <span class="built_in">window</span>;</span><br><span class="line">    <span class="keyword">var</span> args = [];</span><br><span class="line">    <span class="comment">// 注意i从1开始</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>, len = <span class="built_in">arguments</span>.length; i &lt; len; i++) &#123;</span><br><span class="line">        args.push(<span class="built_in">arguments</span>[i])</span><br><span class="line">    &#125;;</span><br><span class="line">    obj.fn = <span class="built_in">this</span>; <span class="comment">// 此时this就是函数fn</span></span><br><span class="line">    obj.fn(...args)</span><br><span class="line">    <span class="keyword">delete</span> obj.fn; <span class="comment">//删除fn</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>#实现apply方法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;叫爸爸&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> son = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;叫儿子&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="built_in">this</span>.name) </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Function</span>.prototype.apply_ = <span class="function"><span class="keyword">function</span> (<span class="params">obj, arr</span>) </span>&#123;</span><br><span class="line">    obj = obj ? <span class="built_in">Object</span>(obj): <span class="built_in">window</span></span><br><span class="line">    obj.fn = <span class="built_in">this</span></span><br><span class="line">    <span class="keyword">if</span> (!arr) &#123;</span><br><span class="line">        obj.fn();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> args = [];</span><br><span class="line">        <span class="comment">// 注意i从1开始</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>, len = <span class="built_in">arguments</span>.length; i &lt; len; i++) &#123;</span><br><span class="line">            args.push(<span class="built_in">arguments</span>[i])</span><br><span class="line">        &#125;;</span><br><span class="line">        obj.fn(...args)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span> obj.fn</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>#实现bind方法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;叫爸爸&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> son = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;叫儿子&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="built_in">this</span>.name) </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Function</span>.prototype.bind_ = <span class="function"><span class="keyword">function</span> (<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//判断是否为null或者undefined,同时考虑传递参数不是对象情况</span></span><br><span class="line">    obj = obj ? <span class="built_in">Object</span>(obj) : <span class="built_in">window</span>;</span><br><span class="line">    <span class="keyword">var</span> args = [];</span><br><span class="line">    <span class="comment">// 注意i从1开始</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>, len = <span class="built_in">arguments</span>.length; i &lt; len; i++) &#123;</span><br><span class="line">        args.push(<span class="built_in">arguments</span>[i])</span><br><span class="line">    &#125;;</span><br><span class="line">    obj.fn = <span class="built_in">this</span>; <span class="comment">// 此时this就是函数fn</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        obj.fn(...args)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>js基础</category>
      </categories>
  </entry>
  <entry>
    <title>js精度问题</title>
    <url>/2021/10/20/js%E7%B2%BE%E5%BA%A6%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>js中的数字按照IEEE 754的标准，使用64位双精度浮点型来表示。</p>
<p>其中符号位S，指数位E，尾数位M分别占了1，11，52位，并在ES5规范中指出了指数位E的取值范围是[-1074, 971].</p>
<h2 id="精度问题汇总"><a href="#精度问题汇总" class="headerlink" title="精度问题汇总"></a>精度问题汇总</h2><p>想用有限的位来表示无穷的数字，显然是不可能的，因此会出现一些列精度问题</p>
<p>· 浮点数精度问题，比如，0.1+0.2 !== 0.3<br>· 大数精度问题，比如9999 9999 9999 9999 == 1000 0000 0000 0000 1<br>· toFixed 四舍五入结果不准确，比如1.335.toFixed(2) == 1.33</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="number">1.335</span>).toPrecision(<span class="number">20</span>); <span class="comment">// &quot;1.3349999999999999645&quot;</span></span><br></pre></td></tr></table></figure>

<p>而关于大数精度问题，我们可以先看下面这个代码片段：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 能精确表示的整数范围上限,S为1个0，E为11个0，S为52个1</span></span><br><span class="line"><span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">53</span>) - <span class="number">1</span> === <span class="built_in">Number</span>.MAX_SAFE_INTEGER    <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 能精确表示的整数范围下限,S为1个1，E为11个0，S为52个1</span></span><br><span class="line">-(<span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">53</span>) - <span class="number">1</span>) === <span class="built_in">Number</span>.MIN_SAFE_INTEGER    <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 能表示的最大数字，S为1个0，E为971，S为52个1</span></span><br><span class="line">(<span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">53</span>) - <span class="number">1</span>) * <span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">971</span>) === <span class="built_in">Number</span>.MAX_VALUE    <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 能表示的最接近于0的正数，S为1个0，E为-1074，S为0</span></span><br><span class="line"><span class="built_in">Math</span>.pow(<span class="number">2</span>, -<span class="number">1074</span>) === <span class="built_in">Number</span>.MIN_VALUE <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>通过以上可以明白，[MIN_SAFE_INTEGER, MAX_SAFE_INTEGER] 的整数都可以精确表示，但是超出这个范围的整数就不一定能精确表示。这样就会产生所谓的大数精度丢失问题。</p>
<h2 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h2><p>首先考虑的是如何解决浮点数运算的精度问题，有 3 种思路：</p>
<p>· 考虑到每次浮点数运算的偏差非常小(其实不然)，可以对结果进行指定精度的四舍五入，比如可以parseFloat(result.toFixed(12));<br>· 将浮点数转为整数运算，再对结果做除法。比如0.1 + 0.2，可以转化为(1*2)/3。<br>· 把浮点数转化为字符串，模拟实际运算的过程。</p>
<p>先来看第一种方案，在大多数情况下，它可以得到正确结果，但是对一些极端情况，toFixed 到 12 是不够的，比如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">210000</span> * <span class="number">10000</span>  * <span class="number">1000</span> * <span class="number">8.2</span>    <span class="comment">// 17219999999999.998</span></span><br><span class="line"><span class="built_in">parseFloat</span>(<span class="number">17219999999999.998</span>.toFixed(<span class="number">12</span>));    <span class="comment">// 17219999999999.998，而正确结果为 17220000000000</span></span><br></pre></td></tr></table></figure>
<p>上面的情况，如果想让结果正确，需要 toFixed(2)，这显然是不可接受的。</p>
<p>再看第二种方案，比如 number-precision 这个库就是使用的这种方案，但是这也是有问题的，比如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这两个浮点数，转化为整数之后，相乘的结果已经超过了 MAX_SAFE_INTEGER</span></span><br><span class="line"><span class="number">123456.789</span> * <span class="number">123456.789</span>     <span class="comment">// 转化为 (123456789 * 123456789)/1000000，结果是 15241578750.19052</span></span><br></pre></td></tr></table></figure>

<p>所以，最终考虑使用第三种方案，目前已经有了很多较为成熟的库，比如 bignumber.js，decimal.js，以及big.js等。我们可以根据自己的需求来选择对应的工具。并且，这些库不仅解决了浮点数的运算精度问题，还支持了大数运算，并且修复了原生toFixed结果不准确的问题。</p>
]]></content>
      <categories>
        <category>js基础</category>
      </categories>
  </entry>
  <entry>
    <title>this指向</title>
    <url>/2021/07/06/this%E6%8C%87%E5%90%91/</url>
    <content><![CDATA[<p>面向对象语言中 this 表示当前对象的一个引用。</p>
<p>但在 JavaScript 中 this 不是固定不变的，它会随着执行环境的改变而改变。</p>
<ul>
<li>在方法中，this 表示该方法所属的对象。</li>
</ul>
<ul>
<li>如果单独使用，this 表示全局对象。</li>
</ul>
<ul>
<li>在函数中，this 表示全局对象。</li>
</ul>
<ul>
<li>在函数中，在严格模式下，this 是未定义的(undefined)。</li>
</ul>
<ul>
<li>在事件中，this 表示接收事件的元素。</li>
</ul>
<ul>
<li>类似 call() 和 apply() 方法可以将 this 引用到任何对象。</li>
</ul>
<h2 id="方法中的this"><a href="#方法中的this" class="headerlink" title="方法中的this"></a>方法中的this</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  <span class="attr">firstName</span>: <span class="string">&quot;John&quot;</span>,</span><br><span class="line">  <span class="attr">lastName</span> : <span class="string">&quot;Doe&quot;</span>,</span><br><span class="line">  <span class="attr">fullName</span> : <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.firstName + <span class="string">&quot; &quot;</span> + <span class="built_in">this</span>.lastName;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">person.fullName() <span class="comment">// John Doe</span></span><br></pre></td></tr></table></figure>
<p>在对象方法中， this 指向调用它所在方法的对象。</p>
<p>在上面一个实例中，this 表示 person 对象。</p>
<p>fullName 方法所属的对象就是 person。</p>
<h2 id="单独使用-this"><a href="#单独使用-this" class="headerlink" title="单独使用 this"></a>单独使用 this</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person = <span class="built_in">this</span> <span class="comment">// [object Window]</span></span><br></pre></td></tr></table></figure>
<p>单独使用 this，则它指向全局(Global)对象。</p>
<p>在浏览器中，window 就是该全局对象为 [object Window]:</p>
<p>ps: 严格模式下，如果单独使用，this 也是指向全局(Global)对象。</p>
<h2 id="函数中使用-this（默认）"><a href="#函数中使用-this（默认）" class="headerlink" title="函数中使用 this（默认）"></a>函数中使用 this（默认）</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myFunction</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>; <span class="comment">// [object Window]</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在函数中，函数的所属者默认绑定到 this 上。</p>
<p>在浏览器中，window 就是该全局对象为 [object Window]:</p>
<p>ps: 严格模式下，函数是没有绑定到this下，this是undefined</p>
<h2 id="事件中的-this"><a href="#事件中的-this" class="headerlink" title="事件中的 this"></a>事件中的 this</h2><p>在 HTML 事件句柄中，this 指向了接收事件的 HTML 元素：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;button onclick=<span class="string">&quot;this =&gt; buttonHtml对象&quot;</span>&gt;</span><br><span class="line">点我</span><br><span class="line">&lt;/button&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="对象方法中绑定"><a href="#对象方法中绑定" class="headerlink" title="对象方法中绑定"></a>对象方法中绑定</h2><p>下面实例中，this 是 person 对象，person 对象是函数的所有者：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  <span class="attr">firstName</span>  : <span class="string">&quot;John&quot;</span>,</span><br><span class="line">  <span class="attr">lastName</span>   : <span class="string">&quot;Doe&quot;</span>,</span><br><span class="line">  <span class="attr">id</span>         : <span class="number">5566</span>,</span><br><span class="line">  <span class="attr">myFunction</span> : <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">person.myFunction() <span class="comment">// [object Object]</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="显式函数绑定"><a href="#显式函数绑定" class="headerlink" title="显式函数绑定"></a>显式函数绑定</h2><p>在 JavaScript 中函数也是对象，对象则有方法，apply 和 call 就是函数对象的方法。</p>
<p>这两个方法异常强大，他们允许切换函数执行的上下文环境（context），即 this 绑定的对象。<br>在下面实例中，当我们使用 person2 作为参数来调用 person1.fullName 方法时, this 将指向 person2, 即便它是 person1 的方法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person1 = &#123;</span><br><span class="line">  <span class="attr">fullName</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.firstName + <span class="string">&quot; &quot;</span> + <span class="built_in">this</span>.lastName;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person2 = &#123;</span><br><span class="line">  <span class="attr">firstName</span>:<span class="string">&quot;John&quot;</span>,</span><br><span class="line">  <span class="attr">lastName</span>: <span class="string">&quot;Doe&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line">person1.fullName.call(person2);  <span class="comment">// 返回 &quot;John Doe&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="隐式绑定"><a href="#隐式绑定" class="headerlink" title="隐式绑定"></a>隐式绑定</h2><p>什么是隐式绑定呢，如果函数调用时，前面存在调用它的对象，那么this就会隐式绑定到这个对象上。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;听风是风&#x27;</span>,</span><br><span class="line">    <span class="attr">func</span>: fn</span><br><span class="line">&#125;;</span><br><span class="line">obj.func() <span class="comment">//听风是风</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如果函数调用前存在多个对象，this指向距离调用自己最近的对象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;行星飞行&#x27;</span>,</span><br><span class="line">    <span class="attr">func</span>: fn,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> obj1 = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;听风是风&#x27;</span>,</span><br><span class="line">    <span class="attr">o</span>: obj</span><br><span class="line">&#125;;</span><br><span class="line">obj1.o.func() <span class="comment">//行星飞行</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>那如果我们将obj对象的name属性注释掉，现在输出什么呢？</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    <span class="attr">func</span>: fn,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> obj1 = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;听风是风&#x27;</span>,</span><br><span class="line">    <span class="attr">o</span>: obj</span><br><span class="line">&#125;;</span><br><span class="line">obj1.o.func() <span class="comment">// undefined</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>大家千万不要将作用域链和原型链弄混淆了，obj对象虽然obj1的属性，但它两原型链并不相同，并不是父子关系，由于obj未提供name属性，所以是undefined。</p>
<p>既然说到原型链，那我们再来点花哨的，我们再改写例子，看看下面输出多少：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fn</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">Fn.prototype.name = <span class="string">&#x27;时间跳跃&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = <span class="keyword">new</span> Fn();</span><br><span class="line">obj.func = fn;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj1 = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;听风是风&#x27;</span>,</span><br><span class="line">    <span class="attr">o</span>: obj</span><br><span class="line">&#125;;</span><br><span class="line">obj1.o.func() <span class="comment">//时间跳跃</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里输出时间跳跃，虽然obj对象并没有name属性，但顺着原型链，找到了产生自己的构造函数Fn，由于Fn原型链存在name属性，所以输出时间跳跃了。</p>
<h2 id="隐式丢失"><a href="#隐式丢失" class="headerlink" title="隐式丢失"></a>隐式丢失</h2><p>在特定情况下会存在隐式绑定丢失的问题，最常见的就是作为参数传递以及变量赋值，先看参数传递：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;行星飞行&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;听风是风&#x27;</span>,</span><br><span class="line">    <span class="attr">fn</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params">param</span>) </span>&#123;</span><br><span class="line">    param();</span><br><span class="line">&#125;;</span><br><span class="line">fn1(obj.fn);<span class="comment">//行星飞行</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这个例子中我们将 obj.fn 也就是一个函数传递进 fn1 中执行，这里只是单纯传递了一个函数而已，this并没有跟函数绑在一起，所以this丢失这里指向了window。</p>
<p>第二个引起丢失的问题是变量赋值，其实本质上与传参相同，看这个例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;行星飞行&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;听风是风&#x27;</span>,</span><br><span class="line">    <span class="attr">fn</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> fn1 = obj.fn;</span><br><span class="line">fn1(); <span class="comment">//行星飞行</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>注意，隐式绑定丢失并不是都会指向全局对象，比如下面的例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;行星飞行&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;听风是风&#x27;</span>,</span><br><span class="line">    <span class="attr">fn</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> obj1 = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;时间跳跃&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">obj1.fn = obj.fn;</span><br><span class="line">obj1.fn(); <span class="comment">//时间跳跃</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>虽然丢失了 obj 的隐式绑定，但是在赋值的过程中，又建立了新的隐式绑定，这里this就指向了对象 obj1。</p>
<h2 id="new绑定"><a href="#new绑定" class="headerlink" title="new绑定"></a>new绑定</h2><p>准确来说，js中的构造函数只是使用new 调用的普通函数，它并不是一个类，最终返回的对象也不是一个实例，只是为了便于理解习惯这么说罢了。</p>
<p>那么new一个函数究竟发生了什么呢，大致分为三步：</p>
<ul>
<li>以构造器的prototype属性为原型，创建新对象；</li>
<li>将this(可以理解为上句创建的新对象)和调用参数传给构造器，执行；</li>
<li>如果构造器没有手动返回对象，则返回第一步创建的对象</li>
</ul>
<p>这个过程我们称之为构造调用，我们来看个例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = <span class="string">&#x27;听风是风&#x27;</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> echo = <span class="keyword">new</span> Fn();</span><br><span class="line">echo.name<span class="comment">//听风是风</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在上方代码中，构造调用创建了一个新对象echo，而在函数体内，this将指向新对象echo上（可以抽象理解为新对象就是this）。</p>
<h2 id="this绑定优先级"><a href="#this绑定优先级" class="headerlink" title="this绑定优先级"></a>this绑定优先级</h2><p>显式绑定 &gt; 隐式绑定 &gt; 默认绑定</p>
<p>new绑定 &gt; 隐式绑定 &gt; 默认绑定</p>
<p>为什么显式绑定不和new绑定比较呢？因为不存在这种绑定同时生效的情景，如果同时写这两种代码会直接抛错，所以大家只用记住上面的规律即可。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = <span class="string">&#x27;听风是风&#x27;</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    <span class="attr">name</span>:<span class="string">&#x27;行星飞行&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> echo = <span class="keyword">new</span> Fn().call(obj);<span class="comment">//报错 call is not a function</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>那么我们结合几个例子来验证下上面的规律，首先是显式大于隐式：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//显式&gt;隐式</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    <span class="attr">name</span>:<span class="string">&#x27;行星飞行&#x27;</span>,</span><br><span class="line">    <span class="attr">fn</span>:<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">obj1 = &#123;</span><br><span class="line">    <span class="attr">name</span>:<span class="string">&#x27;时间跳跃&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line">obj.fn.call(obj1);<span class="comment">// 时间跳跃</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>其次是new绑定大于隐式：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//new&gt;隐式</span></span><br><span class="line">obj = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;时间跳跃&#x27;</span>,</span><br><span class="line">    <span class="attr">fn</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name = <span class="string">&#x27;听风是风&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> echo = <span class="keyword">new</span> obj.fn();</span><br><span class="line">echo.name;<span class="comment">//听风是风</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="箭头函数的this"><a href="#箭头函数的this" class="headerlink" title="箭头函数的this"></a>箭头函数的this</h2><p>ES6的箭头函数是另类的存在，为什么要单独说呢，这是因为箭头函数中的this不适用上面介绍的四种绑定规则。</p>
<p>准确来说，箭头函数中没有this，箭头函数的this指向取决于外层作用域中的this，外层作用域或函数的this指向谁，箭头函数中的this便指向谁。有点吃软饭的嫌疑，一点都不硬朗，我们来看个例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> obj1 = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;听风是风&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> obj2 = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;时间跳跃&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> bar = fn.call(obj1); <span class="comment">// fn this指向obj1</span></span><br><span class="line">bar.call(obj2); <span class="comment">//听风是风</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>为啥我们第一次绑定this并返回箭头函数后，再次改变this指向没生效呢？</p>
<p>前面说了，箭头函数的this取决于外层作用域的this，fn函数执行时this指向了obj1，所以箭头函数的this也指向obj1。除此之外，箭头函数this还有一个特性，那就是一旦箭头函数的this绑定成功，也无法被再次修改，有点硬绑定的意思。</p>
<p>当然，箭头函数的this也不是真的无法修改，我们知道箭头函数的this就像作用域继承一样从上层作用域找，因此我们可以修改外层函数this指向达到间接修改箭头函数this的目的。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> obj1 = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;听风是风&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> obj2 = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;时间跳跃&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line">fn.call(obj1)(); <span class="comment">// fn this指向obj1,箭头函数this也指向obj1</span></span><br><span class="line">fn.call(obj2)(); <span class="comment">//fn this 指向obj2,箭头函数this也指向obj2</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>js基础</category>
      </categories>
  </entry>
  <entry>
    <title>作用域</title>
    <url>/2018/07/06/%E4%BD%9C%E7%94%A8%E5%9F%9F/</url>
    <content><![CDATA[<h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><h3 id="什么是作用域？"><a href="#什么是作用域？" class="headerlink" title="什么是作用域？"></a>什么是作用域？</h3><p>作用域为可访问变量，对象，函数的集合。</p>
<p>作用域就是变量与函数的可访问范围，即作用域控制着变量与函数的可见性和生命周期。</p>
<p>在js中，变量的作用域分为全局作用域和局部作用域两种。<br>一个变量是全局作用域还是局部作用域，主要看变量声明的位置。</p>
<h4 id="全局作用域："><a href="#全局作用域：" class="headerlink" title="全局作用域："></a>全局作用域：</h4><ol>
<li>最外层函数和在最外层函数外面定义的变量</li>
<li>没有通过关键字”var”声明的变量</li>
<li>浏览器中，window对象的属性</li>
</ol>
<h4 id="局部作用域"><a href="#局部作用域" class="headerlink" title="局部作用域"></a>局部作用域</h4><ol>
<li>在函数内部就是局部作用域，这个代码的名字只在函数的内部起作用</li>
<li>调用函数时创建函数作用域，函数执行完毕之后，函数作用域销毁；</li>
<li>每调用一次函数就会创建一个新的函数作用域，它们之间是相互独立的。</li>
</ol>
<h3 id="块级作用域"><a href="#块级作用域" class="headerlink" title="块级作用域"></a>块级作用域</h3><p>在ES6中新增加了一个作用域就是会计作用域，通过let和const声明。那块级作用域什么情况下被创建内？答案如下</p>
<p>在一个函数内部</p>
<p>在一个代码块内部（{}包裹的代码块）</p>
<p>let声明的愈发与var的语法一致，基本上可以用let代替var,但会讲变量的作用域限制在当前代码块中。</p>
<p>块级作用域的特点：</p>
<p>声明变量不会提升到代码块顶部</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Scope</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(scope) <span class="comment">// Uncaught ReferenceError: value is not defined</span></span><br><span class="line"><span class="keyword">let</span> scope = <span class="string">&quot;块级&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(scope) <span class="comment">// 块级</span></span><br><span class="line">&#125;</span><br><span class="line">Scope()</span><br></pre></td></tr></table></figure>

<p>禁止重复声明</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Scope</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">let</span> scope = <span class="string">&#x27;a&#x27;</span></span><br><span class="line"> <span class="comment">//let scope = &#x27;b&#x27; // Uncaught SyntaxError: Identifier &#x27;scope&#x27; has already been declared</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>小技巧：在循环中可以用let const声明变量</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i&lt; <span class="number">100</span>; i++)&#123;&#125;</span><br><span class="line"><span class="built_in">console</span>.log(i) <span class="comment">// Uncaught ReferenceError: i is not defined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i&lt; <span class="number">100</span>; i++)&#123;&#125;</span><br><span class="line"><span class="built_in">console</span>.log(i) <span class="comment">// 100</span></span><br></pre></td></tr></table></figure>


<h3 id="作用域的目的"><a href="#作用域的目的" class="headerlink" title="作用域的目的"></a>作用域的目的</h3><p>是为了提高程序的可靠性，更重要的是减少命名冲突</p>
<h3 id="变量的作用域"><a href="#变量的作用域" class="headerlink" title="变量的作用域"></a>变量的作用域</h3><p>在js中，根据作用域的不同，变量可以分为两种：<strong>全局变量</strong>和<strong>局部变量</strong></p>
<h4 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h4><ul>
<li>在全局作用域下声明的变量叫做全局变量</li>
<li>全局变量在全局任何位置都可以使用，全局作用域中无法访问到局部作用域中的变量<h4 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h4></li>
<li>在局部作用域下声明的变量叫做局部变量</li>
<li>局部变量只能在函数内部使用，在局部作用域中可以访问到全局变量</li>
</ul>
<h2 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h2><p>在js代码运行中，所有用到的变量都需要去当前上下文环境中查找，当找不到的时候，就会继续查找上层的环境变量。<br>这样一级一级向上查找的过程，就组合成了一个作用域链。</p>
<p>所以说，<strong>作用域链</strong>与一个<strong>执行上下文</strong>相关，是内部上下文所有变量对象（包含父变量对象）的列表，用于变量查询。</p>
]]></content>
      <categories>
        <category>js基础</category>
      </categories>
  </entry>
  <entry>
    <title>冒泡排序</title>
    <url>/2021/08/25/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h2 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h2><ol>
<li><p>比较相邻的元素。如果第一个比第二个大，就交换他们两个。</p>
</li>
<li><p>对每一对相邻元素做同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。</p>
</li>
<li><p>针对所有的元素重复以上的步骤，除了最后一个。</p>
</li>
<li><p>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比比较</p>
</li>
</ol>
<h2 id="动图演示"><a href="#动图演示" class="headerlink" title="动图演示"></a>动图演示</h2><p><img src="/.io//1.jpeg" alt="原理图"></p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">40</span>, <span class="number">60</span>, <span class="number">60</span>, <span class="number">0</span>, <span class="number">30</span>]</span><br><span class="line"><span class="comment">// 编写方法，实现冒泡</span></span><br><span class="line"><span class="comment">//外层循环，控制趟数，每一次找到一个最大值</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">    <span class="comment">// 内层循环,控制比较的次数，并且判断两个数的大小</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; arr.length - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">        <span class="comment">// 白话解释：如果前面的数大，放到后面(当然是从小到大的冒泡排序)</span></span><br><span class="line">        <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">var</span> temp = arr[j];</span><br><span class="line">            arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">            arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(arr);</span><br></pre></td></tr></table></figure>

<h2 id="性能分析："><a href="#性能分析：" class="headerlink" title="性能分析："></a>性能分析：</h2><p>时间复杂度: O(N^2)<br>空间复杂度: O(1)<br>稳定性：稳定</p>
]]></content>
      <categories>
        <category>js基础</category>
      </categories>
  </entry>
  <entry>
    <title>创建对象方式</title>
    <url>/2018/07/06/%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<p>在 JavaScript 中创建对象的可行方法有哪些？</p>
<h2 id="1、对象的构造函数"><a href="#1、对象的构造函数" class="headerlink" title="1、对象的构造函数"></a>1、对象的构造函数</h2><p>创建空对象的最简单方法是使用object构造函数，目前不推荐这种方法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = <span class="keyword">new</span> object() <span class="comment">// 对象构造函数</span></span><br></pre></td></tr></table></figure>
<h2 id="2、对象的创建方法："><a href="#2、对象的创建方法：" class="headerlink" title="2、对象的创建方法："></a>2、对象的创建方法：</h2><p>Object的create方法通过将原型对象作为参数传递来创建一个新对象</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = <span class="built_in">Object</span>.create(<span class="literal">null</span>)</span><br></pre></td></tr></table></figure>
<h2 id="3、对象字面量语法"><a href="#3、对象字面量语法" class="headerlink" title="3、对象字面量语法"></a>3、对象字面量语法</h2><p>当传递null作为参数时，对象字面量语法等效于create方法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4、函数构造器"><a href="#4、函数构造器" class="headerlink" title="4、函数构造器"></a>4、函数构造器</h2><p>创建任何函数并应用new运算符来创建对象实例</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> obj = &#123;&#125;</span><br><span class="line">    obj.name = name</span><br><span class="line">    <span class="keyword">return</span> obj</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> obj1 = <span class="keyword">new</span> Person(<span class="string">&quot;哈哈&quot;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="5、带有原型的函数构造函数"><a href="#5、带有原型的函数构造函数" class="headerlink" title="5、带有原型的函数构造函数"></a>5、带有原型的函数构造函数</h2><p>这类似于函数构造函数，但它使用原型作为其属性和方法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">Person.prototype.name = <span class="string">&quot;哈哈&quot;</span></span><br><span class="line"><span class="keyword">var</span> obj = New Person()</span><br></pre></td></tr></table></figure>

<h2 id="6、es6类语法"><a href="#6、es6类语法" class="headerlink" title="6、es6类语法"></a>6、es6类语法</h2><p>es6引入类特性来创建对象</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="title">construtor</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> object = <span class="keyword">new</span> Person(<span class="string">&quot;哈哈&quot;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="7、单例模式"><a href="#7、单例模式" class="headerlink" title="7、单例模式"></a>7、单例模式</h2><p>Singleton是一个只能实例化一次的对象。对其构造函数的重复调用返回相同的实例，这样可以确保它们不会意外创建多个实例</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = <span class="keyword">new</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = <span class="string">&quot;哈哈&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>js基础</category>
      </categories>
  </entry>
  <entry>
    <title>原型及原型链</title>
    <url>/2018/07/06/%E5%8E%9F%E5%9E%8B%E5%8F%8A%E5%8E%9F%E5%9E%8B%E9%93%BE/</url>
    <content><![CDATA[<h2 id="prototype"><a href="#prototype" class="headerlink" title="prototype"></a>prototype</h2><p>每一个js对象(null除外)在创建的时候就会与之关联另一个对象【Prototype】，这个对象就是我们所说的原型。每个对象都会从原型“继承”属性。</p>
<p>举个例子</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line"><span class="attr">name</span>: <span class="string">&quot;zhangsan&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> newObj = <span class="built_in">Object</span>.create(obj)</span><br><span class="line"></span><br><span class="line">newObj.name <span class="comment">// zhangsan</span></span><br></pre></td></tr></table></figure>


<p>上述例子中，newObj对象的【Prototype】属性引用了obj对象，也就是说newObj对象的【Prototype】指向了obj对象，并继承了obj的属性。</p>
<p>几乎所有的对象在创建时【Prototype】属性都会被赋予非空的值，由【Prototype】串联起来的对象的关系链条我们就称为【Prototype】链也就是原型链，一般情况下【Prototype】链的最顶层是Object.prototype</p>
<p>每个函数都有一个 prototype 属性。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.name = <span class="string">&quot;zhangsan&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person()</span><br><span class="line"></span><br><span class="line">person.name <span class="comment">// zhangsan</span></span><br></pre></td></tr></table></figure>

<p><img src="/.io//1.png"></p>
<h2 id="proto"><a href="#proto" class="headerlink" title="proto"></a>proto</h2><p>每一个js对象（除null）都具有一个属性叫proto，这个属性会指向改对象的原型。</p>
<p>对象可以通过__proto__访问内部的【Prototype】属性，即我们可以通过__proto__访问对象的原型。</p>
<p>ps: __proto__是一种非标准的方法，实际开发中我们应该使用Object.getPrototypeOf()来获取对象的原型</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person();</span><br><span class="line"></span><br><span class="line">person.__proto__ === Person.prototype <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p><img src="/.io//2.png"></p>
<h2 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a>constructor</h2><p>每个原型都有一个constructor属性指向关联的构造函数，实例原型指向构造函数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">person.__proto__ == Person.prototype <span class="comment">// true</span></span><br><span class="line">Person === Person.prototype.constructor <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.getPrototypeOf(person) === Person.prototype <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>补充说明：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person();</span><br><span class="line">person.constructor === Person<span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>当获取 person.constructor 时，其实 person 中并没有 constructor 属性,当不能读取到constructor 属性时，会从 person 的原型也就是 Person.prototype 中读取，正好原型中有该属性，所以：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">person.constructor === Person.prototype.constructor</span><br></pre></td></tr></table></figure>
<p><img src="/.io//3.png"></p>
<h2 id="实例与原型"><a href="#实例与原型" class="headerlink" title="实例与原型"></a>实例与原型</h2><p>当读取实例的属性时，如果找不到，就会查找与对象关联的原型中的属性，如果还查不到，就去找原型的原型，一直找到最顶层为止。<br><img src="/.io//4.png"></p>
<h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h2><p>简单的回顾一下构造函数、原型和实例的关系：每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，而实例都包含一个指向原型对象的内部指针。那么假如我们让原型对象等于另一个类型的实例，结果会怎样？显然，此时的原型对象将包含一个指向另一个原型的指针，相应地，另一个原型中也包含着一个指向另一个构造函数的指针。假如另一个原型又是另一个类型的实例，那么上述关系依然成立。如此层层递进，就构成了实例与原型的链条。这就是所谓的原型链的基本概念。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.prototype.__proto__ === <span class="literal">null</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p><img src="/.io//5.png"></p>
]]></content>
      <categories>
        <category>js基础</category>
      </categories>
  </entry>
  <entry>
    <title>希尔排序</title>
    <url>/2021/08/25/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<p>希尔排序是希尔（Donald Shell）于1959年提出的一种排序算法。希尔排序也是一种插入排序，它是简单插入排序经过改进之后的一个更高效的版本，也称为缩小增量排序，同时该算法是冲破O(n2）的第一批算法之一。本文会以图解的方式详细介绍希尔排序的基本思想及其代码实现。</p>
<h2 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h2><p>希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止。</p>
<p>简单插入排序很循规蹈矩，不管数组分布是怎么样的，依然一步一步的对元素进行比较，移动，插入，比如[5,4,3,2,1,0]这种倒序序列，数组末端的0要回到首位置很是费劲，比较和移动元素均需n-1次。而希尔排序在数组中采用跳跃式分组的策略，通过某个增量将数组元素划分为若干组，然后分组进行插入排序，随后逐步缩小增量，继续按组进行插入排序操作，直至增量为1。希尔排序通过这种策略使得整个数组在初始阶段达到从宏观上看基本有序，小的基本在前，大的基本在后。然后缩小增量，到增量为1时，其实多数情况下只需微调即可，不会涉及过多的数据移动。</p>
<p>我们来看下希尔排序的基本步骤，在此我们选择增量gap=length/2，缩小增量继续以gap = gap/2的方式，这种增量选择我们可以用一个序列来表示，{n/2,(n/2)/2…1}，称为增量序列。希尔排序的增量序列的选择与证明是个数学难题，我们选择的这个增量序列是比较常用的，也是希尔建议的增量，称为希尔增量，但其实这个增量序列不是最优的。此处我们做示例使用希尔增量。</p>
<h2 id="动图演示"><a href="#动图演示" class="headerlink" title="动图演示"></a>动图演示</h2><p><img src="/.io//1.png" alt="原理图"></p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">40</span>, <span class="number">60</span>, <span class="number">60</span>, <span class="number">0</span>, <span class="number">30</span>]</span><br><span class="line"><span class="keyword">let</span> interval = <span class="built_in">parseInt</span>(arr.length / <span class="number">2</span>);</span><br><span class="line"><span class="keyword">while</span> (interval &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i ++) &#123;</span><br><span class="line">        <span class="keyword">let</span> n = i;</span><br><span class="line">        <span class="keyword">while</span> (arr[n] &lt; arr[n - interval] &amp;&amp; n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">let</span> temp = arr[n]</span><br><span class="line">            arr[n] = arr[n- interval]</span><br><span class="line">            arr[n - interval] = temp</span><br><span class="line">            n --</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    interval = <span class="built_in">parseInt</span>(interval / <span class="number">2</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(arr)</span><br></pre></td></tr></table></figure>

<h2 id="性能分析："><a href="#性能分析：" class="headerlink" title="性能分析："></a>性能分析：</h2><p>希尔排序中对于增量序列的选择十分重要，直接影响到希尔排序的性能。我们上面选择的增量序列{n/2,(n/2)/2…1}(希尔增量)，其最坏时间复杂度依然为O(n2)，一些经过优化的增量序列如Hibbard经过复杂证明可使得最坏时间复杂度为O(n3/2)</p>
]]></content>
      <categories>
        <category>js基础</category>
      </categories>
  </entry>
  <entry>
    <title>插入排序</title>
    <url>/2021/08/25/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h2 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h2><p>1.从数组的第二个数据开始往前比较，即一开始用第二个数和他前面的一个比较，如果 符合条件（比前面的大或者小，自定义），则让他们交换位置。</p>
<p>2.然后再用第三个数和第二个比较，符合则交换，但是此处还得继续往前比较，比如有 5个数8，15，20，45, 17,17比45小，需要交换，但是17也比20小，也要交换，当不需 要和15交换以后，说明也不需要和15前面的数据比较了，肯定不需要交换，因为前 面的数据都是有序的。</p>
<p>3.重复步骤二，一直到数据全都排完。</p>
<h2 id="动图演示"><a href="#动图演示" class="headerlink" title="动图演示"></a>动图演示</h2><p><img src="/.io//1.gif" alt="原理图"></p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">40</span>, <span class="number">60</span>, <span class="number">60</span>, <span class="number">0</span>, <span class="number">30</span>]</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> n = i;</span><br><span class="line">    <span class="keyword">while</span> (arr[n] &gt; arr[n+<span class="number">1</span>] &amp;&amp; n &gt;=<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> temp = arr[n];</span><br><span class="line">        arr[n] = arr[n + <span class="number">1</span>];</span><br><span class="line">        arr[n + <span class="number">1</span>] = temp;</span><br><span class="line">        n--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(arr);</span><br></pre></td></tr></table></figure>

<h2 id="性能分析："><a href="#性能分析：" class="headerlink" title="性能分析："></a>性能分析：</h2><p>1.属于稳定的排序，适合于数据量小，部分数据有序的情况排序。</p>
<p>2.如果目标是把n个元素的序列升序排列，那么采用插入排序存在最好情况和最坏情况。最好情况就是，序列已经是升序排列了，在这种情况下，需要进行的比较操作需（n-1）次即可。最坏情况就是，序列是降序排列，那么此时需要进行的比较共有n(n-1)/2次。插入排序的赋值操作是比较操作的次数加上 (n-1）次。平均来说插入排序算法的时间复杂度为O(n^2）。因而，插入排序不适合对于数据量比较大的排序应用。但是，如果需要排序的数据量很小，例如，量级小于千，那么插入排序还是一个不错的选择</p>
<p>3.插入排序的平均时间复杂度也是 O(n^2)，空间复杂度为常数阶 O(1)</p>
]]></content>
      <categories>
        <category>js基础</category>
      </categories>
  </entry>
  <entry>
    <title>执行上下文</title>
    <url>/2021/07/06/%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87/</url>
    <content><![CDATA[<h2 id="理解执行上下文"><a href="#理解执行上下文" class="headerlink" title="理解执行上下文"></a>理解执行上下文</h2><blockquote>
<p>执行上下文：函数执行前进行的准备工作，也就是执行上下文环境，是当前代码执行的一个环境与作用域。</p>
</blockquote>
<p>运行js代码时，当代码执行进入一个环境时，就会为该环境创建一个执行上下文，它<br>会在你运行代码前做一些准备工作，如确定作用域，创建局部变量对象等。</p>
<h2 id="js中执行环境"><a href="#js中执行环境" class="headerlink" title="js中执行环境"></a>js中执行环境</h2><ul>
<li>全局环境</li>
<li>函数环境</li>
<li>eval函数环境（不推荐使用）</li>
</ul>
<h2 id="执行上下文的类型"><a href="#执行上下文的类型" class="headerlink" title="执行上下文的类型"></a>执行上下文的类型</h2><ul>
<li>全局执行上下文</li>
<li>函数执行上下文</li>
<li>eval函数执行上下文</li>
</ul>
<p>js运行时先进入全局环境，对应会生成全局上下文。程序代码中基本都会存在函数，调用<br>函数，就会进入函数执行环境，对应的就是生成函数执行上下文。</p>
<h2 id="js管理多个执行上下文"><a href="#js管理多个执行上下文" class="headerlink" title="js管理多个执行上下文"></a>js管理多个执行上下文</h2><p>函数变成中，代码中会声明多个函数，对应的执行上下文也会存在多个。在js中，通过栈的存取方式来管理执行上下文，我们可以称<br>其为执行栈，或者函数调用栈。</p>
<p><img src="/.io//1.png" alt="栈数据结构"></p>
<h2 id="执行栈（函数调用栈）"><a href="#执行栈（函数调用栈）" class="headerlink" title="执行栈（函数调用栈）"></a>执行栈（函数调用栈）</h2><p>程序进入一个执行环境时，它的执行上下文就会被创建，并被堆入执行栈中（入栈）；程序执行完成时，她的执行上下文就会被销毁，并从栈顶被推出（出栈），控制权交由下一个执行上下文。</p>
<p>因为JS执行中，最先进入全局环境，所以处于”栈底的永远时全局环境的执行上下文”。而处于”栈顶的是当前执行函数的执行上下文”，当函数调用完成后，它就会从栈顶被推出（理想情况下，闭包会阻止该操作）。</p>
<p><strong>全局环境只有一个，对应的全局执行上下文也只有一个，只有当页面被关闭之后它才会从执行栈中被推出，否则一直存在于栈底。</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params"></span>) </span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">bar</span> (<span class="params"></span>) </span>&#123;        </span><br><span class="line">      <span class="keyword">return</span> <span class="string">&#x27;I am bar&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bar();</span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br></pre></td></tr></table></figure>
<p><img src="/.io//2.png" alt="出栈入栈图解"></p>
<h2 id="执行上下文的声明周期"><a href="#执行上下文的声明周期" class="headerlink" title="执行上下文的声明周期"></a>执行上下文的声明周期</h2><p>执行上下文的声明周期有两个阶段：</p>
<ol>
<li><p>创建阶段（进入执行上下文）</p>
<p> 函数被调用时，进入函数环境，为期创建一个执行上下文，此时进入创建阶段。</p>
</li>
<li><p>执行阶段（代码执行）</p>
<p> 执行函数中代码时，此时执行上下文进入执行阶段。</p>
</li>
</ol>
<h2 id="创建阶段的操作"><a href="#创建阶段的操作" class="headerlink" title="创建阶段的操作"></a>创建阶段的操作</h2><p>1.创建变量对象</p>
<ul>
<li>函数环境会初始化创建Arguments对象（并赋值）</li>
<li>函数声明（并赋值）</li>
<li>变量声明，函数表达式声明（未赋值）</li>
</ul>
<ol start="2">
<li>确定this指向（this由调用者确定）</li>
<li>确定作用域（词法环境决定，哪里声明定义，就在哪里确定）</li>
</ol>
<h2 id="执行阶段的操作"><a href="#执行阶段的操作" class="headerlink" title="执行阶段的操作"></a>执行阶段的操作</h2><ol>
<li>变量对象赋值</li>
</ol>
<ul>
<li>变量赋值</li>
<li>函数表达式赋值</li>
</ul>
<ol start="2">
<li>调用函数</li>
<li>顺序执行其他代码</li>
</ol>
<h2 id="变量对象和活动对象的区别："><a href="#变量对象和活动对象的区别：" class="headerlink" title="变量对象和活动对象的区别："></a>变量对象和活动对象的区别：</h2><p>当进入到一个执行上下文后，这个变量对象才会被激活，所以叫活动对象(AO)，这时候活动对象上的各种属性才能被访问。</p>
<p><strong>“创建阶段对函数声明做赋值，变量及函数表达式仅做声明，真正的赋值操作要等到执行上下文代码执行阶段。”</strong></p>
<p>例1：变量提升</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a);         <span class="comment">// 输出undefined</span></span><br><span class="line">    <span class="keyword">var</span> a = <span class="string">&#x27;I am here&#x27;</span>;    <span class="comment">// 赋值</span></span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br><span class="line"><span class="comment">// 实际执行过程</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a;                <span class="comment">// 变量声明，var初始化undefined</span></span><br><span class="line">    <span class="built_in">console</span>.log(a); </span><br><span class="line">    a = <span class="string">&#x27;I am here&#x27;</span>;     <span class="comment">// 变量重新赋值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例2：函数声明优先级</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(bar);</span><br><span class="line">    <span class="keyword">var</span> bar = <span class="number">20</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> bar = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">30</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">foo();  <span class="comment">// 输出bar()整个函数声明</span></span><br></pre></td></tr></table></figure>

<h2 id="函数声明，变量声明，函数表达式的优先级"><a href="#函数声明，变量声明，函数表达式的优先级" class="headerlink" title="函数声明，变量声明，函数表达式的优先级"></a>函数声明，变量声明，函数表达式的优先级</h2><ol>
<li>函数声明，如果有同名属性，会替换掉</li>
<li>变量，函数表达式</li>
<li>函数声明优先 &gt; 变量，函数表达式</li>
</ol>
<h2 id="执行上下文的数量限制（堆栈溢出）"><a href="#执行上下文的数量限制（堆栈溢出）" class="headerlink" title="执行上下文的数量限制（堆栈溢出）"></a>执行上下文的数量限制（堆栈溢出）</h2><p>执行上下文可存在多个，虽然没有明确的数量限制，但如果超出栈分配的空间，会造成堆栈溢出。常见于递归调用，没有终止条件造成死循环的场景。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 递归调用自身</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    foo();</span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br><span class="line"><span class="comment">// 报错： Uncaught RangeError: Maximum call stack size exceeded</span></span><br></pre></td></tr></table></figure>

<h2 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h2><p>当程序调用一个函数时，会发生什么？</p>
<p>以下几个步骤：</p>
<ol>
<li>js创建一个新的执行上下文，我们叫做函数执行上下文。</li>
<li>这个函数执行上下文将有它自己的一组变量，这些变量将时这个执行上下文的本地变量。</li>
<li>新的执行上下文被推到执行堆栈中。可以将执行堆栈看作是一种保存程序在其执行中的位置的容器。</li>
</ol>
<p>当函数遇到一个return或者一个结束括号 “}” 。</p>
<p>当函数结束时，会执行一下操作：</p>
<ol>
<li>这个本地执行上下文从执行堆栈中弹出。</li>
<li>函数将返回值返回调用上下文。调用上下文时调用这个本地的执行上下文，它可以时全局执行上下文，也可以是灵位一个本地执行上下文。这取决与调用执行上下文来处理此时的返回值，返回的值可以是一个对象、一个数组、一个函数、一个布尔值等等，如果函数没有return语句，则返回undefined.</li>
<li></li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li>JavaScript是单线程</li>
<li>栈顶的执行上下文处于执行中，其它需要排队</li>
<li>全局上下文只有一个处于栈底，页面关闭时出栈</li>
<li>函数执行上下文可存在多个，但应避免递归时堆栈溢出</li>
<li>函数调用时就会创建新的上下文，即使调用自身，也会创建不同的执行上下文</li>
</ol>
]]></content>
      <categories>
        <category>js基础</category>
      </categories>
  </entry>
  <entry>
    <title>数据类型</title>
    <url>/2021/08/19/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<h1 id="js中基本数据类型"><a href="#js中基本数据类型" class="headerlink" title="js中基本数据类型"></a>js中基本数据类型</h1><h2 id="原始数据类型"><a href="#原始数据类型" class="headerlink" title="原始数据类型"></a>原始数据类型</h2><ul>
<li>number</li>
<li>string</li>
<li>boolean</li>
<li>null</li>
<li>undefined</li>
<li>symbol(es6)</li>
<li>bigint(es10)</li>
</ul>
<h2 id="引用数据类型"><a href="#引用数据类型" class="headerlink" title="引用数据类型"></a>引用数据类型</h2><ul>
<li>object (包括function/array/object)</li>
</ul>
]]></content>
      <categories>
        <category>js基础</category>
      </categories>
  </entry>
  <entry>
    <title>数组操作</title>
    <url>/2021/08/19/%E6%95%B0%E7%BB%84%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h1 id="最常见的几种数组操作方法归纳总结"><a href="#最常见的几种数组操作方法归纳总结" class="headerlink" title="最常见的几种数组操作方法归纳总结"></a>最常见的几种数组操作方法归纳总结</h1><table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>concat()</td>
<td>连接两个或多个数组，并返回已连接数组的副本</td>
</tr>
<tr>
<td>copyWithin()</td>
<td>将数组中的数组元素复制到指定位置或从指定位置复制</td>
</tr>
<tr>
<td>entries()</td>
<td>返回键/值对数组迭代对象</td>
</tr>
<tr>
<td>every()</td>
<td>检查数组中的每个元素是否通过测试</td>
</tr>
<tr>
<td>fill()</td>
<td>用静态值填充数组中的元素</td>
</tr>
<tr>
<td>filter()</td>
<td>使用数组中通过测试的每个元素创建新数组</td>
</tr>
<tr>
<td>find()</td>
<td>返回数组中第一个通过测试的元素的值</td>
</tr>
<tr>
<td>findIndex()</td>
<td>返回数组中通过测试的第一个元素的索引。</td>
</tr>
<tr>
<td>forEach()</td>
<td>为每个数组元素调用函数。</td>
</tr>
<tr>
<td>from()</td>
<td>从对象创建数组</td>
</tr>
<tr>
<td>includes()</td>
<td>检查数组是否包含指定的元素。</td>
</tr>
<tr>
<td>indexOf()</td>
<td>在数组中搜索元素并返回其位置。</td>
</tr>
<tr>
<td>isArray()</td>
<td>检查对象是否为数组。</td>
</tr>
<tr>
<td>join()</td>
<td>将数组的所有元素连接成一个字符串。</td>
</tr>
<tr>
<td>keys()</td>
<td>返回 Array Iteration 对象，包含原始数组的键.</td>
</tr>
<tr>
<td>lastIndexOf()</td>
<td>在数组中搜索元素，从末尾开始，并返回其位置。</td>
</tr>
<tr>
<td>map()</td>
<td>使用为每个数组元素调用函数的结果创建新数组。</td>
</tr>
<tr>
<td>pop()</td>
<td>删除数组的最后一个元素，并返回该元素。</td>
</tr>
<tr>
<td>push()</td>
<td>将新元素添加到数组的末尾，并返回新的长度。</td>
</tr>
<tr>
<td>reduce()</td>
<td>将数组的值减为单个值（从左到右）。</td>
</tr>
<tr>
<td>reduceRight()</td>
<td>将数组的值减为单个值（从右到左）。</td>
</tr>
<tr>
<td>reverse()</td>
<td>反转数组中元素的顺序。</td>
</tr>
<tr>
<td>shift()</td>
<td>删除数组的第一个元素，并返回该元素。</td>
</tr>
<tr>
<td>slice()</td>
<td>选择数组的一部分，并返回新数组。</td>
</tr>
<tr>
<td>some()</td>
<td>检查数组中的任何元素是否通过测试。</td>
</tr>
<tr>
<td>sort()</td>
<td>对数组的元素进行排序。</td>
</tr>
<tr>
<td>splice()</td>
<td>从数组中添加/删除元素。</td>
</tr>
<tr>
<td>toString()</td>
<td>将数组转换为字符串，并返回结果。</td>
</tr>
<tr>
<td>unshift()</td>
<td>将新元素添加到数组的开头，并返回新的长度。</td>
</tr>
<tr>
<td>valueOf()</td>
<td>返回数组的原始值。</td>
</tr>
<tr>
<td>at()</td>
<td>2021.1新提案，解决方括号的限制，可以输入负数。</td>
</tr>
</tbody></table>
<h2 id="1-shift-方法：把数组的第一个元素删除，并返回第一个元素的值"><a href="#1-shift-方法：把数组的第一个元素删除，并返回第一个元素的值" class="headerlink" title="1.shift() 方法：把数组的第一个元素删除，并返回第一个元素的值"></a>1.shift() 方法：把数组的第一个元素删除，并返回第一个元素的值</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">arr.shift() <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<h2 id="2-concat-方法：用于连接两个或多个数组-并返回一个新数组，新数组是将参数添加到原数组中构成的"><a href="#2-concat-方法：用于连接两个或多个数组-并返回一个新数组，新数组是将参数添加到原数组中构成的" class="headerlink" title="2.concat() 方法：用于连接两个或多个数组,并返回一个新数组，新数组是将参数添加到原数组中构成的"></a>2.concat() 方法：用于连接两个或多个数组,并返回一个新数组，新数组是将参数添加到原数组中构成的</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">const</span> arr1 = arr.concat(<span class="number">2</span>, <span class="number">4</span>); <span class="comment">// 1, 3, 2, 4</span></span><br><span class="line"><span class="keyword">const</span> arr2 = [<span class="number">5</span>, <span class="number">6</span>];</span><br><span class="line"><span class="keyword">const</span> arr3 = [<span class="number">7</span>, <span class="number">8</span>];</span><br><span class="line"><span class="keyword">const</span> arr4 = arr2.concat(arr3); <span class="comment">// 5, 6, 7, 8</span></span><br></pre></td></tr></table></figure>

<h2 id="3-join-方法：用于把数组中的所有元素放入一个字符串。元素是通过指定的分隔符进行分隔的。"><a href="#3-join-方法：用于把数组中的所有元素放入一个字符串。元素是通过指定的分隔符进行分隔的。" class="headerlink" title="3. join() 方法：用于把数组中的所有元素放入一个字符串。元素是通过指定的分隔符进行分隔的。"></a>3. join() 方法：用于把数组中的所有元素放入一个字符串。元素是通过指定的分隔符进行分隔的。</h2><p>返回一个字符串。该字符串是通过把 arrayObject 的每个元素转换为字符串，然后把这些字符串连接起来，在两个元素之间插入separator 字符串而生成的。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>];</span><br><span class="line"><span class="keyword">const</span> str = arr.join(<span class="string">&#x27;-&#x27;</span>); <span class="comment">// 1-3-4-5-6</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="4-pop-方法：用于删除并返回数组的最后一个-删除元素-元素-如果数组为空则返回undefined-把数组长度减-1"><a href="#4-pop-方法：用于删除并返回数组的最后一个-删除元素-元素-如果数组为空则返回undefined-把数组长度减-1" class="headerlink" title="4. pop() 方法：用于删除并返回数组的最后一个(删除元素)元素,如果数组为空则返回undefined ,把数组长度减 1"></a>4. pop() 方法：用于删除并返回数组的最后一个(删除元素)元素,如果数组为空则返回undefined ,把数组长度减 1</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line"><span class="keyword">const</span> str = arr.pop(); <span class="comment">// 6</span></span><br><span class="line"><span class="built_in">console</span>.log(arr) <span class="comment">// 1,2,3,4,5</span></span><br></pre></td></tr></table></figure>

<h2 id="5-push-方法：可向数组的末尾添加一个或多个元素，并返回新的长度，（用来改变数组长度）。"><a href="#5-push-方法：可向数组的末尾添加一个或多个元素，并返回新的长度，（用来改变数组长度）。" class="headerlink" title="5.push() 方法：可向数组的末尾添加一个或多个元素，并返回新的长度，（用来改变数组长度）。"></a>5.push() 方法：可向数组的末尾添加一个或多个元素，并返回新的长度，（用来改变数组长度）。</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line"><span class="keyword">const</span> len = arr.push(<span class="number">5</span>)<span class="comment">// 5</span></span><br><span class="line"><span class="built_in">console</span>.log(arr) <span class="comment">// [1,2,3,4,5]</span></span><br></pre></td></tr></table></figure>
<h2 id="6-reverse-：方法用于颠倒数组中元素的顺序。"><a href="#6-reverse-：方法用于颠倒数组中元素的顺序。" class="headerlink" title="6.reverse() ：方法用于颠倒数组中元素的顺序。"></a>6.reverse() ：方法用于颠倒数组中元素的顺序。</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line"><span class="keyword">const</span> len = arr.reverse(); <span class="comment">// [6,5,4,3,2,1]</span></span><br><span class="line"><span class="built_in">console</span>.log(arr) <span class="comment">// [6,5,4,3,2,1]</span></span><br></pre></td></tr></table></figure>
<h2 id="7-slice-方法：可从已有的数组中返回选定的元素。slice-开始截取位置，结束截取位置"><a href="#7-slice-方法：可从已有的数组中返回选定的元素。slice-开始截取位置，结束截取位置" class="headerlink" title="7.slice() 方法：可从已有的数组中返回选定的元素。slice(开始截取位置，结束截取位置)"></a>7.slice() 方法：可从已有的数组中返回选定的元素。slice(开始截取位置，结束截取位置)</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line"><span class="keyword">const</span> a = arr.slice(<span class="number">1</span>,<span class="number">2</span>); <span class="comment">// [2]</span></span><br><span class="line"><span class="built_in">console</span>.log(arr)<span class="comment">// [1,2,3,4,5,6]</span></span><br></pre></td></tr></table></figure>
<h2 id="8-splice-：方法向-从数组中添加-删除项目，然后返回被删除的项目。"><a href="#8-splice-：方法向-从数组中添加-删除项目，然后返回被删除的项目。" class="headerlink" title="8.splice() ：方法向/从数组中添加/删除项目，然后返回被删除的项目。"></a>8.splice() ：方法向/从数组中添加/删除项目，然后返回被删除的项目。</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"><span class="keyword">const</span> a = arr.splice(<span class="number">1</span>,<span class="number">2</span>); <span class="comment">// [2,3]</span></span><br><span class="line"><span class="built_in">console</span>.log(arr) <span class="comment">// [1,4,5]</span></span><br><span class="line"><span class="keyword">const</span> b = arr.splice(<span class="number">1</span>,<span class="number">2</span>,)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arrr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"><span class="keyword">const</span> c = arr.splice(<span class="number">1</span>,<span class="number">0</span>, <span class="string">&#x27;a&#x27;</span>) <span class="comment">// []</span></span><br><span class="line"><span class="built_in">console</span>.log(arrr) <span class="comment">// [1, &#x27;a&#x27;,2,3,4,5]</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="9-unshift：将参数添加到原数组开头，并返回数组的长度"><a href="#9-unshift：将参数添加到原数组开头，并返回数组的长度" class="headerlink" title="9.unshift：将参数添加到原数组开头，并返回数组的长度"></a>9.unshift：将参数添加到原数组开头，并返回数组的长度</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line"><span class="keyword">const</span> len = arr.unshift(<span class="number">0</span>); <span class="comment">// 5</span></span><br><span class="line"><span class="built_in">console</span>.log(arr) <span class="comment">// [0,1,2,3,4]</span></span><br></pre></td></tr></table></figure>
<h2 id="10-sort-orderfunction-：按指定的参数对数组进行排序"><a href="#10-sort-orderfunction-：按指定的参数对数组进行排序" class="headerlink" title="10.sort(orderfunction)：按指定的参数对数组进行排序"></a>10.sort(orderfunction)：按指定的参数对数组进行排序</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line"><span class="keyword">const</span> b = arr.sort(); <span class="comment">// [1,2,3,4]</span></span><br><span class="line"><span class="built_in">console</span>.log(b) <span class="comment">// [1,2,3,4]</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>js基础</category>
      </categories>
  </entry>
  <entry>
    <title>面试题</title>
    <url>/2021/08/19/%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<h1 id="JavaScript-面试题"><a href="#JavaScript-面试题" class="headerlink" title="JavaScript 面试题"></a>JavaScript 面试题</h1><h2 id><a href="#" class="headerlink" title></a><a href="/2018/07/06/%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E6%96%B9%E5%BC%8F/" title="1.在 JavaScript 中创建对象的可行方法有哪些？">1.在 JavaScript 中创建对象的可行方法有哪些？</a></h2><p>1、对象的构造函数-new object()<br>2、对象的创建方法-Object.create(null)<br>3、对象字面量语法-const obj = {}<br>4、函数构造器<br>5、带有原型的函数构造函数<br>6、es6类语法 class<br>7、单例模式</p>
<h2 id="-1"><a href="#-1" class="headerlink" title></a><a href="/2018/07/06/%E5%8E%9F%E5%9E%8B%E5%8F%8A%E5%8E%9F%E5%9E%8B%E9%93%BE/" title="1.什么是原型链？">1.什么是原型链？</a></h2><p>原型链用于基于现有对象构建新类型的对象。它类似于基于类的语言中的继承。</p>
<p>对象实例上的原型可通过Object.getPrototypeOf(object)或proto属性获得，而构造函数上的原型可通过Object.prototype 获得。</p>
<h2 id="-2"><a href="#-2" class="headerlink" title></a><a href="/2021/08/19/call%E3%80%81apply%E5%92%8Cbind%E5%8C%BA%E5%88%AB/" title="3.call、 bind、apply区别？">3.call、 bind、apply区别？</a></h2><h2 id="-3"><a href="#-3" class="headerlink" title></a><a href="/2021/08/19/%E6%95%B0%E7%BB%84%E6%93%8D%E4%BD%9C/" title="4.数组操作？">4.数组操作？</a></h2>]]></content>
  </entry>
</search>
